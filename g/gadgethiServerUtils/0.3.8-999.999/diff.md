# Comparing `tmp/gadgethiServerUtils-0.3.8-py3-none-any.whl.zip` & `tmp/gadgethiServerUtils-999.999-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,31 +1,31 @@
-Zip file size: 43229 bytes, number of entries: 29
--rw-r--r--  2.0 unx     4807 b- defN 21-Jul-29 04:26 gadgethiServerUtils/GadgethiClient.py
--rw-r--r--  2.0 unx    12800 b- defN 21-Jul-02 14:59 gadgethiServerUtils/GadgethiServer.py
--rw-r--r--  2.0 unx        0 b- defN 21-May-29 03:14 gadgethiServerUtils/__init__.py
--rw-r--r--  2.0 unx     3727 b- defN 21-Jul-02 02:53 gadgethiServerUtils/_configs.py
--rw-r--r--  2.0 unx     2785 b- defN 21-Jul-02 02:53 gadgethiServerUtils/_exceptions.py
--rw-r--r--  2.0 unx     3811 b- defN 21-Jul-02 04:03 gadgethiServerUtils/authentication.py
--rw-r--r--  2.0 unx     6062 b- defN 20-Oct-10 11:28 gadgethiServerUtils/cash_flow.py
--rw-r--r--  2.0 unx    13657 b- defN 21-Jul-02 02:53 gadgethiServerUtils/db_basics.py
--rw-r--r--  2.0 unx    22836 b- defN 21-Jul-02 02:54 gadgethiServerUtils/db_operations.py
--rw-r--r--  2.0 unx     6620 b- defN 21-Jul-02 02:53 gadgethiServerUtils/encryption.py
--rw-r--r--  2.0 unx     4635 b- defN 20-Nov-22 03:47 gadgethiServerUtils/exceptions.py
--rw-r--r--  2.0 unx     5459 b- defN 21-Jul-02 02:53 gadgethiServerUtils/file_basics.py
--rw-r--r--  2.0 unx     2041 b- defN 20-Oct-09 13:00 gadgethiServerUtils/global_config.py
--rw-r--r--  2.0 unx     1437 b- defN 21-Jul-02 02:53 gadgethiServerUtils/main.py
--rw-r--r--  2.0 unx    10225 b- defN 21-May-30 02:07 gadgethiServerUtils/pay_integration.py
--rw-r--r--  2.0 unx     3428 b- defN 21-Jul-02 02:53 gadgethiServerUtils/time_basics.py
--rw-r--r--  2.0 unx        0 b- defN 21-Jul-02 02:53 gadgethiServerUtils/scripts/__init__.py
--rw-r--r--  2.0 unx     3852 b- defN 21-Jul-02 02:53 gadgethiServerUtils/scripts/generate_configs.py
--rw-r--r--  2.0 unx        0 b- defN 21-May-29 04:33 gadgethiServerUtils/tests/__init__.py
--rw-r--r--  2.0 unx     6355 b- defN 21-Jul-02 02:53 gadgethiServerUtils/tests/testAuth.py
--rw-r--r--  2.0 unx     6542 b- defN 21-Jul-02 02:53 gadgethiServerUtils/tests/testGserver.py
--rw-r--r--  2.0 unx     3505 b- defN 21-Jul-02 02:53 gadgethiServerUtils/tests/testPrimitives.py
--rw-r--r--  2.0 unx     3120 b- defN 21-Jul-02 02:53 gadgethiServerUtils/tests/testScripts.py
--rw-r--r--  2.0 unx     3366 b- defN 21-Jul-02 02:53 gadgethiServerUtils/tests/testTime.py
--rw-r--r--  2.0 unx     1702 b- defN 21-Jul-29 04:27 gadgethiServerUtils-0.3.8.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 21-Jul-29 04:27 gadgethiServerUtils-0.3.8.dist-info/WHEEL
--rw-r--r--  2.0 unx       77 b- defN 21-Jul-29 04:27 gadgethiServerUtils-0.3.8.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       20 b- defN 21-Jul-29 04:27 gadgethiServerUtils-0.3.8.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     2678 b- defN 21-Jul-29 04:27 gadgethiServerUtils-0.3.8.dist-info/RECORD
-29 files, 135639 bytes uncompressed, 38823 bytes compressed:  71.4%
+Zip file size: 44661 bytes, number of entries: 29
+-rw-r--r--  2.0 unx     4572 b- defN 22-Mar-15 07:23 gadgethiServerUtils/GadgethiAWSHandler.py
+-rw-r--r--  2.0 unx     4904 b- defN 22-Mar-15 07:23 gadgethiServerUtils/GadgethiClient.py
+-rw-r--r--  2.0 unx    12217 b- defN 22-Mar-15 07:23 gadgethiServerUtils/GadgethiServer.py
+-rw-r--r--  2.0 unx      948 b- defN 22-Mar-15 07:23 gadgethiServerUtils/GadgethiZMQ.py
+-rw-r--r--  2.0 unx        0 b- defN 22-Mar-15 07:23 gadgethiServerUtils/__init__.py
+-rw-r--r--  2.0 unx     3728 b- defN 22-Mar-15 07:23 gadgethiServerUtils/_configs.py
+-rw-r--r--  2.0 unx     3606 b- defN 22-Mar-15 07:23 gadgethiServerUtils/_exceptions.py
+-rw-r--r--  2.0 unx     3811 b- defN 22-Mar-15 07:23 gadgethiServerUtils/authentication.py
+-rw-r--r--  2.0 unx    14313 b- defN 22-Mar-15 07:23 gadgethiServerUtils/db_basics.py
+-rw-r--r--  2.0 unx    22078 b- defN 22-Mar-15 07:23 gadgethiServerUtils/db_operations.py
+-rw-r--r--  2.0 unx     6620 b- defN 22-Mar-15 07:23 gadgethiServerUtils/encryption.py
+-rw-r--r--  2.0 unx     8058 b- defN 22-Mar-15 07:23 gadgethiServerUtils/file_basics.py
+-rw-r--r--  2.0 unx     1437 b- defN 22-Mar-15 07:23 gadgethiServerUtils/main.py
+-rw-r--r--  2.0 unx    10806 b- defN 22-Mar-15 07:23 gadgethiServerUtils/pay_integration.py
+-rw-r--r--  2.0 unx     3745 b- defN 22-Mar-15 07:23 gadgethiServerUtils/time_basics.py
+-rw-r--r--  2.0 unx        0 b- defN 22-Mar-15 07:23 gadgethiServerUtils/scripts/__init__.py
+-rw-r--r--  2.0 unx     3852 b- defN 22-Mar-15 07:23 gadgethiServerUtils/scripts/generate_configs.py
+-rw-r--r--  2.0 unx        0 b- defN 22-Mar-15 07:23 gadgethiServerUtils/tests/__init__.py
+-rw-r--r--  2.0 unx    14759 b- defN 22-Mar-15 07:23 gadgethiServerUtils/tests/testAWSHandler.py
+-rw-r--r--  2.0 unx     6355 b- defN 22-Mar-15 07:23 gadgethiServerUtils/tests/testAuth.py
+-rw-r--r--  2.0 unx     6542 b- defN 22-Mar-15 07:23 gadgethiServerUtils/tests/testGserver.py
+-rw-r--r--  2.0 unx     3505 b- defN 22-Mar-15 07:23 gadgethiServerUtils/tests/testPrimitives.py
+-rw-r--r--  2.0 unx     3120 b- defN 22-Mar-15 07:23 gadgethiServerUtils/tests/testScripts.py
+-rw-r--r--  2.0 unx     3414 b- defN 22-Mar-15 07:23 gadgethiServerUtils/tests/testTime.py
+-rw-r--r--  2.0 unx     1673 b- defN 22-Mar-15 07:23 gadgethiServerUtils-999.999.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 22-Mar-15 07:23 gadgethiServerUtils-999.999.dist-info/WHEEL
+-rw-r--r--  2.0 unx       77 b- defN 22-Mar-15 07:23 gadgethiServerUtils-999.999.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx       20 b- defN 22-Mar-15 07:23 gadgethiServerUtils-999.999.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     2705 b- defN 22-Mar-15 07:23 gadgethiServerUtils-999.999.dist-info/RECORD
+29 files, 146957 bytes uncompressed, 40201 bytes compressed:  72.6%
```

## zipnote {}

```diff
@@ -1,46 +1,43 @@
+Filename: gadgethiServerUtils/GadgethiAWSHandler.py
+Comment: 
+
 Filename: gadgethiServerUtils/GadgethiClient.py
 Comment: 
 
 Filename: gadgethiServerUtils/GadgethiServer.py
 Comment: 
 
+Filename: gadgethiServerUtils/GadgethiZMQ.py
+Comment: 
+
 Filename: gadgethiServerUtils/__init__.py
 Comment: 
 
 Filename: gadgethiServerUtils/_configs.py
 Comment: 
 
 Filename: gadgethiServerUtils/_exceptions.py
 Comment: 
 
 Filename: gadgethiServerUtils/authentication.py
 Comment: 
 
-Filename: gadgethiServerUtils/cash_flow.py
-Comment: 
-
 Filename: gadgethiServerUtils/db_basics.py
 Comment: 
 
 Filename: gadgethiServerUtils/db_operations.py
 Comment: 
 
 Filename: gadgethiServerUtils/encryption.py
 Comment: 
 
-Filename: gadgethiServerUtils/exceptions.py
-Comment: 
-
 Filename: gadgethiServerUtils/file_basics.py
 Comment: 
 
-Filename: gadgethiServerUtils/global_config.py
-Comment: 
-
 Filename: gadgethiServerUtils/main.py
 Comment: 
 
 Filename: gadgethiServerUtils/pay_integration.py
 Comment: 
 
 Filename: gadgethiServerUtils/time_basics.py
@@ -51,14 +48,17 @@
 
 Filename: gadgethiServerUtils/scripts/generate_configs.py
 Comment: 
 
 Filename: gadgethiServerUtils/tests/__init__.py
 Comment: 
 
+Filename: gadgethiServerUtils/tests/testAWSHandler.py
+Comment: 
+
 Filename: gadgethiServerUtils/tests/testAuth.py
 Comment: 
 
 Filename: gadgethiServerUtils/tests/testGserver.py
 Comment: 
 
 Filename: gadgethiServerUtils/tests/testPrimitives.py
@@ -66,23 +66,23 @@
 
 Filename: gadgethiServerUtils/tests/testScripts.py
 Comment: 
 
 Filename: gadgethiServerUtils/tests/testTime.py
 Comment: 
 
-Filename: gadgethiServerUtils-0.3.8.dist-info/METADATA
+Filename: gadgethiServerUtils-999.999.dist-info/METADATA
 Comment: 
 
-Filename: gadgethiServerUtils-0.3.8.dist-info/WHEEL
+Filename: gadgethiServerUtils-999.999.dist-info/WHEEL
 Comment: 
 
-Filename: gadgethiServerUtils-0.3.8.dist-info/entry_points.txt
+Filename: gadgethiServerUtils-999.999.dist-info/entry_points.txt
 Comment: 
 
-Filename: gadgethiServerUtils-0.3.8.dist-info/top_level.txt
+Filename: gadgethiServerUtils-999.999.dist-info/top_level.txt
 Comment: 
 
-Filename: gadgethiServerUtils-0.3.8.dist-info/RECORD
+Filename: gadgethiServerUtils-999.999.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## gadgethiServerUtils/GadgethiClient.py

```diff
@@ -1,11 +1,12 @@
 import os
 import requests
 from gadgethiServerUtils.file_basics import *
 from gadgethiServerUtils.authentication import *
+from gadgethiServerUtils._exceptions import *
 from gadgethiServerUtils.time_basics import timeout
 
 """
 Represents the client class to send
 HTTP requests. Including gadgethi
 authentication function. 
 """
@@ -23,15 +24,16 @@
         for key in configs:
             if "_http_url" in key:
                 setattr(self, key, configs[key])
 
     def __getitem__(self, key):
         return getattr(self, key)
     
-    @timeout(5)
+    @gexception
+    @timeout(10)
     def client_get(self, key, input_dict, gauth=False, custom_headers={}):
         """
         This is the main function to send out HTTP GET. 
         @params key: the key of the url stored in the ADT
         @params input_dict: the input dictionary of the data that is 
             going to send
         @params gauth: whether we should enable gadgethi authentication, 
@@ -56,15 +58,16 @@
             headers.update(auth_header)
             r = requests.get(get_query,headers=headers)
         else:
             r = requests.get(get_query,headers=custom_headers)
         response = r.text 
         return response
 
-    @timeout(5)
+    @gexception
+    @timeout(10)
     def client_post(self, key, input_dict,gauth=False,urlencode=False, 
         custom_headers={}):
         """
         This is the main function to send out HTTP POST. 
         @params key: the key of the url stored in the ADT
         @params input_dict: the input dictionary of the data that is 
             going to send
@@ -94,15 +97,16 @@
                 r = requests.post(post_query, data=input_dict,headers=custom_headers)
             else:
                 r = requests.post(post_query, json=input_dict,headers=custom_headers)
             response = r.text
 
         return response
 
-    @timeout(5)
+    @gexception
+    @timeout(10)
     def client_put(self, key, input_dict, custom_headers={}):
         """
         This is the main function to send out HTTP PUT. 
         @params key: the key of the url stored in the ADT
         @params input_dict: the input dictionary of the data that is 
             going to send
         @params gauth: whether we should enable gadgethi authentication,
```

## gadgethiServerUtils/GadgethiServer.py

```diff
@@ -268,29 +268,54 @@
 	"""
 	Schemes:
 		gadgethi server scheme and custom server scheme.
 
 	@params table_list: a list of table that is going to be used by this server. 
 	@params initialized_func_list: a list of functions to init the db tables.
 	@params desc: description of the server
-	@params yaml_exccondition: a function that defines the exception condition. If return 
-		True, don't pull it (exception). Otherwise, False.
 	@params configs: All the other configurations setting
 	@params service_handler: If using gadgethi server scheme, this is the service handler function
 	@params config_path: file path to server config yaml
 	@params credential_path: file path to credential yaml
 	@params custom_event_handler: If using custom server scheme, this is the handler function
-	@params fetch_yaml_from_s3: Defaults to true, fetching yaml from s3. Set it to false if 
-		you don't want to pull anything from s3
 	@params authentication: Set to true if need to turn on header authentication
+
+	# Fetch Yaml Deprecated
+	# New scheme requires user put fetch files definition in config file
+	- s3_bucket_name: e.g. gadgethi-001
+	- fetch_s3_files: e.g. ["database_ini/database.ini", "doday_yamls/*"]
+	- local_s3_locations: e.g. ["util/database.ini", "yamls/*"]
 	"""
 	def __init__(self, table_list=[], initialize_func_list=[], desc="GadgetHi Main", 
-		yaml_exccondition=lambda :False, configs={}, service_handler=lambda: None, 
+		configs={}, service_handler=lambda: None, 
 		config_path="", credential_path="",custom_event_handler=None, 
-		fetch_yaml_from_s3=True, authentication=True, **kwargs):
+		authentication=True, aws_fake_server=False, **kwargs):
+
+		if aws_fake_server:
+			"""
+			This part is for aws handler fake test server
+			"""
+			self.http_handler = GadgetHiHTTPHandler
+			self.service_handler = service_handler
+			
+			GadgetHiHTTPHandler.initialize_service_redirect(self.service_handler)
+
+			self.desc = desc
+			self.host = configs["server_address"]
+			self.port = int(configs["server_port"])
+
+			local_server_address = (self.host, self.port)
+			super().__init__(local_server_address, self.http_handler)
+
+			# Set authentication
+			configs["serverAuthentication"] = authentication
+			GadgetHiHTTPHandler.initialize_configs(configs)
+
+			print("*** Server Initialized ***")
+			return
 
 		self.server_config = load_config(config_path)
 		self.credentials_config = load_config(credential_path)
 
 		init_log(self.server_config["log_file_path"]+self.server_config["program_header"])
 
 		self.service_handler = service_handler
@@ -307,18 +332,21 @@
 		configs["serverAuthentication"] = authentication
 
 		yaml_config = {}
 		yaml_config.update(configs)
 		yaml_config.update(self.server_config)
 		yaml_config.update(self.credentials_config)
 
-		# Initialization
-		if fetch_yaml_from_s3:
-			self.fetch_yamls(yaml_config, yaml_exccondition)
 		GadgetHiHTTPHandler.initialize_configs(yaml_config)
+
+		bucket_name = yaml_config.get("s3_bucket_name", None)
+		fetch_s3_files = yaml_config.get("fetch_s3_files", [])
+		local_s3_locations = yaml_config.get("local_s3_locations", [])
+		if bucket_name:
+			fetch_from_s3(bucket_name, fetch_s3_files, local_s3_locations, **yaml_config)
 		
 		if custom_event_handler:
 			GadgetHiHTTPHandler.initialize_service_redirect(custom_event_handler)
 		else:
 			# Gadgethi Server Scheme
 			self.server_api_path = self.server_config["server_api_path"]
 			self.server_api_dict = read_config_yaml(self.server_api_path)
@@ -341,48 +369,14 @@
 	def run(self):
 		"""
 		execution function
 		"""
 		print('Starting %s Server at ' % self.desc, self.host, ' port: ', self.port)
 		self.serve_forever()
 
-
-	# Fetch yaml function
-	# -----------------------
-	def fetch_yamls(self, yaml_config, exceptcond=lambda :False):
-		"""
-		This is the helper function to fetch yamls from s3
-		"""
-		import boto3
-
-		ACCESS_ID = yaml_config["aws_access_key_id"] 
-		SECRET_KEY = yaml_config["aws_secret_access_key"] 
-		
-		# bucket and document location info
-		bucket_name = yaml_config["yaml_s3_bucket"]
-		s3_folder_header = yaml_config["yaml_s3_folder"] #"doday_yamls/"
-		local_folder_header = yaml_config["yaml_local_folder"] #"sample_menu/"
-
-		# database ini
-		database_ini_path = yaml_config["s3_database_ini_path"] #"database_ini/database.ini"
-		database_ini_local_path = yaml_config["local_database_ini_path"] #"util/database.ini"
-
-		s3 = boto3.client('s3', aws_access_key_id=ACCESS_ID, aws_secret_access_key=SECRET_KEY)
-		objects = s3.list_objects(Bucket=bucket_name, Prefix=s3_folder_header)["Contents"]
-		print("Pulling Yamls....")
-		for obj in objects:
-			obj_name = obj["Key"].replace(s3_folder_header, "")
-			if exceptcond(obj_name=obj_name, **yaml_config):
-				continue
-			print(obj_name)
-			s3.download_file(bucket_name, s3_folder_header+obj_name, local_folder_header+obj_name)
-
-		# Also fetch database ini here -> no need to put the path to config here -> database ini should also be in util/
-		s3.download_file(bucket_name, database_ini_path, database_ini_local_path)
-
 	def redirectToServices(self, request_dict, **server_config):
 		"""
 		This helps redirect to various services
 		in the management server.
 		"""
 		if ("form" in request_dict):
 			srv = request_dict["form"]["service"]
```

## gadgethiServerUtils/_configs.py

```diff
@@ -12,20 +12,21 @@
     """
     basic_configs = {
         # The info of the main server
         "server_address": "127.0.0.1",
         "server_port": "5050",
 
         "log_file_path": "/opt/doday/LOG_FILES/",
-        "log_file_header": "gadgethi-default-server-",
+        "program_header": "gadgethi-default-server-",
 
         "server_api_path": "yamls/server_api.yaml",
         "allowed_ip": ["*"],
 
-        "database_name": "gadgethi-database-001"
+        "database_name": "gadgethi-database-001",
+        "local_database_ini_path": "~/.gserver/database.ini"
     }
 
     doday_configs = {
         # The info of the websocket server which the main server connects
         "websocket_ip": "127.0.0.1",
         "websocket_port": 9001,
         "websocket_mode": "client",
@@ -56,19 +57,17 @@
               "opening_time": "XX", # write "XX" if not in business that day
               "closing_time": "XX"
             }
           }],
     }
 
     aws_configs = {
-        "yaml_s3_bucket": "gadgethi-bucket001",
-        "yaml_s3_folder": "doday_yamls/",
-        "yaml_local_folder": "yamls/",
-        "s3_database_ini_path": "database_ini/database.ini",
-        "local_database_ini_path": "~/.gserver/database.ini"
+        "s3_bucket_name": "gadgethi-bucket001",
+        "fetch_s3_files": ["database_ini/database.ini", "doday_yamls/*"],
+        "local_s3_locations": ["~/.gserver/database.ini", "yamls/*"]
     }
 
     credential_configs = {
         "gadgethi_key": "test",
         "gadgethi_secret": "SECRET"
     }
```

## gadgethiServerUtils/_exceptions.py

```diff
@@ -75,7 +75,36 @@
 		self.header = super().__str__()
 		self.fname, self.line_number, self.tb = error_description()
 		error_message = construct_error_message(self.header,self.bounds,self.description,self.fname,self.line_number, self.tb)
 		logging.error(error_message)
 		return error_message
     
 
+def gexception(function):
+	"""
+	This is the wrapper function to wrap
+	the utility functions and handle error
+	"""
+	def handle_error(*args, **kwargs):
+		"""
+		This wraps try except clause around the function
+		and return the error message. 
+		"""
+		response = None
+		try:
+			response = function(*args, **kwargs)
+			ret = {"indicator": True, "message": response}
+		except Exception as e:
+			_, _, exc_tb = sys.exc_info()
+			fobj = traceback.extract_tb(exc_tb)[-1]
+			fname = fobj.filename
+			line_no = fobj.lineno
+
+			ddyerror = GadosServerError.buildfromexc(str(e), fname, line_no, ''.join(traceback.format_tb(exc_tb)))
+			logging.error("GadosServerError = "+str(ddyerror))
+			print("GadosServerError = "+str(ddyerror))
+			ret = ddyerror.json_response
+
+		if response != None:
+			return ret["message"]
+
+	return handle_error
```

## gadgethiServerUtils/db_basics.py

```diff
@@ -1,13 +1,11 @@
 #!/usr/bin/env python3
 from gadgethiServerUtils.db_operations import *
-import datetime
 import collections
 
-
 def merge_Data(selection_dict, table, multiple_vals=False):
 	"""
 	This function reverses the split Data result given selection criterion (ex.order_id).
 	After reading from database, get all rows that meet the criterion and merge them back.
 	- Input:
 		* selection_dict: dict of selection criterion to merge (ex. {'order_id':101...})
 		* table: table to operate on (ex.'order')
@@ -192,17 +190,31 @@
 			
 			# print ("query = " + query)
 			fetched_data = executeSql(getDb(), query, tuple(where_value_list), db_operations.MODE_DB_W_RETURN_AND_ARGS)
 		else:
 			# multiple execution
 			# If this is the case, I would assume that where value list is a list of tuples
 			# [(10,), (1,), (2,)] -> and we get multiple matches from db
+
+			# Support Multiple columns in multiple conditions
+			# TODO: Need to fix this whole thing in the future.
+			column_number_list = []
+			deflated_where_value_list = []
+			for val in where_value_list:
+				if isinstance(val, list):
+					column_number_list.append(len(val))
+					deflated_where_value_list.extend(val)
+				else:
+					column_number_list.append(len(where_value_list))
+					deflated_where_value_list.extend(where_value_list)
+					break
+
 			multi_query = conditional_generate_query(db_components['table_name'],'SELECT',db_components['columns'],where_columns_list,
-				len(where_value_list),order_by_list=order_by_list,limit_number=limit_number)
-			fetched_data = executeSql(getDb(), multi_query, tuple(where_value_list), db_operations.MODE_DB_W_RETURN_AND_ARGS)
+				column_number_list,order_by_list=order_by_list,limit_number=limit_number)
+			fetched_data = executeSql(getDb(), multi_query, tuple(deflated_where_value_list), db_operations.MODE_DB_W_RETURN_AND_ARGS)
 
 	# print ("fetched_data in get_data = ",fetched_data)
 	data_list = FormatReturnData(fetched_data) 
 	# print ("queue_list = ",queue_list)
 	data_dict = FormatReturnDict(db_components['columns'],data_list)
 
 	return data_dict
@@ -259,58 +271,66 @@
 	- Input:
 		* table: the table to perform operation on
 		* adding_list: list of dictionaries to be add (may be single)
 
 	- Return:
 		* message: indicating if the add operation has been successful
 	"""
-	db_components = generate_db_components(table)
+	try:
+		db_components = generate_db_components(table)
+
+		add_query = generate_query(db_components['table_name'],'INSERT',db_components['columns'])
 
-	add_query = generate_query(db_components['table_name'],'INSERT',db_components['columns'])
+		# print ("db_components columns = ",db_components['columns'])
 
-	# print ("db_components columns = ",db_components['columns'])
+		add_arguments = [extract_data(index, db_components['columns']) for index in adding_list]
 
-	add_arguments = [extract_data(index, db_components['columns']) for index in adding_list]
+	except:
+		return False
 
 	# print ("Add arguments = ",add_arguments)
 
 	if (len(add_arguments) == 1):
-		executeSql(getDb(),add_query,add_arguments[0],db_operations.MODE_DB_W_ARGS)
+		result = executeSql(getDb(),add_query,add_arguments[0],db_operations.MODE_DB_W_ARGS)
+		return False if result == False else True
 	else:
-		execute_multiple_Sql(getDb(),add_query,add_arguments,db_operations.MODE_DB_W_ARGS)
-
-	return "None"
+		result = execute_multiple_Sql(getDb(),add_query,add_arguments,db_operations.MODE_DB_W_ARGS)
+		return False if result == False else True
 
 def add_to_table_general(table, adding_list):
 	"""
 	Assume that the key that is to be inserted might be
 	less than the total columns of the table. So, add the 
 	given keys and keep others to none.
 
 	Also assume that all entries need to have the same columns
 	that is to be added. Although it can be less than the db
 	columns.
 	"""
-	db_components = generate_db_components(table)
+	try:
+		db_components = generate_db_components(table)
 
-	addlist_key = set(adding_list[0].keys())
-	db_header_columns = set(db_components['columns'])
+		addlist_key = set(adding_list[0].keys())
+		db_header_columns = set(db_components['columns'])
 
-	intersect_key = list(addlist_key.intersection(db_header_columns))
+		intersect_key = list(addlist_key.intersection(db_header_columns))
 
-	add_query = generate_query(db_components['table_name'],'INSERT',intersect_key)
+		add_query = generate_query(db_components['table_name'],'INSERT',intersect_key)
 
-	add_arguments = [extract_data(entry, intersect_key) for entry in adding_list]
+		add_arguments = [extract_data(entry, intersect_key) for entry in adding_list]
+	
+	except:
+		return False
 
 	if (len(add_arguments) == 1):
-		executeSql(getDb(),add_query,add_arguments[0],db_operations.MODE_DB_W_ARGS)
+		result = executeSql(getDb(),add_query,add_arguments[0],db_operations.MODE_DB_W_ARGS)
+		return False if result == False else True	
 	else:
-		execute_multiple_Sql(getDb(),add_query,add_arguments,db_operations.MODE_DB_W_ARGS)
-
-	return "None"
+		result = execute_multiple_Sql(getDb(),add_query,add_arguments,db_operations.MODE_DB_W_ARGS)
+		return False if result == False else True
 
 def edit_on_table(table, editing_list, where_columns_list):
 	"""
 	This function edits existing row(s)
 
 	- Input:
 		* table: table executed 
@@ -318,41 +338,47 @@
 		* where_columns_list: the name of the conditional columns (ex.['material'])
 
 	- Return:
 		* message: indicating if the edit operation has been successful
 	"""
 
 	if editing_list == []:
-		return "None"
+		return True
 
 	# print ("editing_list = ",editing_list)
-	db_components = generate_db_components(table)
+	try:
+
+		db_components = generate_db_components(table)
 
-	edit_columns = [key for key in editing_list[0] if key in db_components['columns']]
+		edit_columns = [key for key in editing_list[0] if key in db_components['columns']]
 
-	# print ("edit_columns = ",edit_columns)
+		# print ("edit_columns = ",edit_columns)
 
-	edit_query = generate_query(db_components['table_name'],'UPDATE',edit_columns,where_columns_list)
+		edit_query = generate_query(db_components['table_name'],'UPDATE',edit_columns,where_columns_list)
 
-	# print(edit_query)
-	# print ("edit_query = ",edit_query)
-	# edit_arguments = [tuple(index.values()) + tuple(index[key] for key in where_columns_list) for index in editing_list]
+		# print(edit_query)
+		# print ("edit_query = ",edit_query)
+		# edit_arguments = [tuple(index.values()) + tuple(index[key] for key in where_columns_list) for index in editing_list]
 
-	edit_arguments = [extract_data(index, edit_columns) + tuple(index[key] for key in where_columns_list) for index in editing_list]
+		edit_arguments = [extract_data(index, edit_columns) + tuple(index[key] for key in where_columns_list) for index in editing_list]
 
-	print ("edit_arguments = ",edit_arguments)
+		print ("edit_arguments = ",edit_arguments)
+
+	except:
+		return False
 
 	if (len(edit_arguments) == 1):
 		# print ("single")
-		executeSql(getDb(),edit_query,edit_arguments[0],db_operations.MODE_DB_W_ARGS)
+		result = executeSql(getDb(),edit_query,edit_arguments[0],db_operations.MODE_DB_W_ARGS)
+		return False if result == False else True
+
 		# print ("executed")
 	else:
-		execute_multiple_Sql(getDb(),edit_query,edit_arguments,db_operations.MODE_DB_W_ARGS)
-
-	return "None"
+		result = execute_multiple_Sql(getDb(),edit_query,edit_arguments,db_operations.MODE_DB_W_ARGS)
+		return False if result == False else True
 
 
 def delete_from_table(table, deleting_list, where_columns_list):
 	"""
 	This function edits existing row(s)
 
 	- Input:
@@ -361,27 +387,22 @@
 		* where_columns_list: the name of the conditional columns (ex.['material'])
 
 	- Return:
 		* message: indicating if the edit operation has been successful
 	"""
 
 	if deleting_list == []:
-		return None
+		return True
 
 	db_components = generate_db_components(table)
 
 	delete_arguments = [extract_data(index, where_columns_list) for index in deleting_list]
 
-
-
 	data_dict = get_data(table, where_columns_list, where_value_list)
 
-	pass
-
-
 
 def delete_inventory(delete_data):
 	"""
 	delete an specific inventory from the inventory table
 	"""
 	material = delete_data['material']
 	queue_info = get_inventory(material)
@@ -389,22 +410,14 @@
 		raise GadosServerError( "This inventory doesn't exist in the inventory table")
 
 	delete_entry = generate_query('inventory_table','DELETE',['material'])
 	executeSql(getDb(), delete_entry, (material), db_operations.MODE_DB_W_ARGS)
 	message = "Material {} deleted on inventory table".format(material)	
 	return {"indicator":True, "message": message}
 
-def get_current_time(mode = 'int'):
-	"""
-	Current time epoch, with mode = int 
-	"""
-
-	if mode == 'int':
-		return int(datetime.datetime.now().timestamp())
-
 
 def mass_dictionary(key_list):
 	"""
 	This function converts every element in the keylist to dictionary. Time saving.
 	- Input:
 		* key_list: ['order_id','order_no'....]
 	- Return:
```

## gadgethiServerUtils/db_operations.py

```diff
@@ -105,46 +105,34 @@
 
 # DATABASE INFORMATION
 # -----------------------------------------------------------------------------------------------------
 
 def getDb():
 	return db_name
 
-# def generate_db_components(table):
-# 	"""
-# 	This function generates the database components related to the 
-# 	given table.
-# 	- Input:
-# 		* table: table_name (ex.'inventory')
-# 	- Return:
-# 		components: dictionary of components 
-# 		(ex.{'columns':all_inventory_columns,'table_name':'inventory_table'})
-# 	"""
-# 	components = {}
-# 	components['columns'] = all_db_columns['all_' + table + '_columns']
-# 	components['table_name'] = (table)
-# 	# print ("components = ",components)
-# 	return components
-
-def generate_db_components(table,customize=False):
+def generate_db_components(table):
 	"""
 	This function generates the database components related to the 
 	given table.
 	- Input:
 		* table: table_name (ex.'inventory')
 	- Return:
 		components: dictionary of components 
 		(ex.{'columns':all_inventory_columns,'table_name':'inventory_table'})
 	"""
 	components = {}
 	components['columns'] = all_db_columns['all_' + table + '_columns']
-	if customize:
-		components['table_name'] = (table)
+
+	if table[0] == "@":
+		query_table = table[1:]
 	else:
-		components['table_name'] = (table + '_table')
+		query_table = table + "_table"
+
+
+	components['table_name'] = query_table
 	# print ("components = ",components)
 	return components
 
 
 # DATABASE CONNECTION
 # -----------------------------------------------------------------------------------------------------
 def connect_to_database(test=False):
@@ -306,32 +294,40 @@
 		Select_complex = '''SELECT * FROM queue_table WHERE status = 'waiting' ORDER BY priority DESC, time ASC, _id ASC limit 1;'''
 		Select = '''SELECT * FROM queue_table WHERE order_id = %s ORDER BY priority,time;'''
 		Update = '''UPDATE queue_table SET base = %s, soup = %s, main = %s, food1 = %s, food2 = %s, food3 = %s, special = %s, price = %s, discounted_price = %s ,promotion = %s, promotion_key = %s, priority = %s, status = %s WHERE order_id = %s;'''
 		Delete = '''DELETE FROM queue_table WHERE order_id = %s ;'''
 		Insert = '''INSERT into queue_table (order_id, order_no, base, soup, main, food1, food2, food3, special, price, discounted_price, promotion, promotion_key, priority, status, time) VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s);'''
 
 	"""
-	if conditional_column_number != 1:
-		tuple_str = "(%s"
-		for i in range(conditional_column_number-1):
-			tuple_str += ", %s"
-		tuple_str += ")"
-	else:
-		tuple_str = '(%s)'
-
-	if conditional_column_list != 'None':
-		if conditional_column_number == 1:
-			conditional_column_string = "WHERE %s" % ' in %s AND '.join(map(str,conditional_column_list))
-			conditional_column_string += " in {}".format(tuple_str)
-		else:
-			concatenater = ' in {} AND '.format(tuple_str)
-			conditional_column_string = "WHERE %s" % concatenater.join(map(str,conditional_column_list))
-			conditional_column_string += " in {}".format(tuple_str)
-	else:
-		conditional_column_string = ''
+	# Build Conditional Column String
+	# ---------------------------------
+	conditional_column_string = ''
+
+	if isinstance(conditional_column_number, list):
+		# Build Tuple List
+		tuple_list = []
+		for num in conditional_column_number:
+			tuple_str = "(%s"
+			for i in range(num-1):
+				tuple_str += ", %s"
+			tuple_str += ")"
+			tuple_list.append(tuple_str)
+
+		assert len(tuple_list) == len(conditional_column_list)
+
+		# Concatenate
+		conditional_column_string = "WHERE "
+		for tid in range(len(tuple_list)-1):
+			conditional_column_string += conditional_column_list[tid] + ' in {} AND '.format(tuple_list[tid])
+		conditional_column_string += conditional_column_list[-1] + ' in {}'.format(tuple_list[-1])
+
+	else:
+		# If not list, it has to be 1
+		conditional_column_string = "WHERE %s" % ' in %s AND '.join(map(str,conditional_column_list))
+		conditional_column_string += " in %s" # End condition for the last column
 
 	if order_by_list != 'None':
 		order_by_string = "ORDER BY %s" % ', '.join(map(str,order_by_list))
 		# print ("Order by string = ",order_by_string)
 	else:
 		order_by_string = ''
 
@@ -417,16 +413,14 @@
 				"""
 				If this flag is true, print the database content
 				"""
 				headers = [description[0] for description in c.description]
 				print(tabulate(ret, headers, tablefmt="fancy_grid"))
 
 		elif mode == db_operations.MODE_DB_W_RETURN_AND_ARGS:
-			print("sql in db_operations.MODE_DB_W_RETURN_AND_ARGS = ", sql)
-			print("entries in db_operations.MODE_DB_W_RETURN_AND_ARGS = ", entries)
 			c.execute(sql, entries)
 			ret = c.fetchall()
 			# ret = c.execute(sql, entries).fetchall()
 			if debug_print:
 				"""
 				If this flag is true, print the database content
 				"""
@@ -435,15 +429,15 @@
 
 		conn.commit()
 		c.close()
 
 	except (Exception, psycopg2.DatabaseError) as error:
 		# print("Database execution error = ",error)
 		print_psycopg2_exception(error)
-		return error
+		return False
 
 	finally:
 		if conn is not None:
 			conn.close()
 
 	return ret
 
@@ -504,15 +498,18 @@
 				"""
 				headers = [description[0] for description in c.description]
 				print(tabulate(ret, headers, tablefmt="fancy_grid"))
 
 		conn.commit()
 		c.close()
 	except (Exception, psycopg2.DatabaseError) as error:
-		print(error)
+		# print(error)
+		print_psycopg2_exception(error)
+		return False
+
 	finally:
 		if conn is not None:
 			conn.close()
 
 	return ret
 
 
@@ -660,39 +657,28 @@
 		ordered_component = list(extract_data(dictionary, key_list))
 		ordered_list.append(ordered_component)
 	return ordered_list
 
 
 
 # INIT FUNCTIONS
-# -----------------------------------------------------------------------------------------------------
-# def init_headers():
-# 	global all_db_columns
-
-# 	for columns in all_db_columns_header_data:
-# 		# If no table name specified, see it as a skip
-# 		# print ("Columns in init_headers = ",columns)
-# 		try:
-# 			table_name = all_db_columns_header_data[columns]['table']
-# 			# print ("table name = ",table_name)
-# 		except:
-# 			continue
-
-# 		query_string = '''SELECT * FROM %s;''' % table_name
-# 		all_db_columns[columns] = executeSql(getDb(),query_string,None,db_operations.MODE_DB_W_RETURN_WO_ARGS,header=True)
-
-	# print ("After init headers, all_db_columns = ",all_db_columns)
-
+# ------------------------------------------------------------------
 def init_headers():
 	global all_db_columns
 
 	for columns in all_db_columns_header_data:
 		# If no table name specified, see it as a skip
 		# print ("Columns in init_headers = ",columns)
 		try:
 			table_name = all_db_columns_header_data[columns]['table']
 			# print ("table name = ",table_name)
 		except:
 			continue
 
-		query_string = '''SELECT * FROM %s_table;''' % table_name
+		# If you want full name, add @ in the front of your table name
+		if table_name[0] == "@":
+			query_table_name = table_name[1:]
+		else:
+			query_table_name = table_name + "_table"
+
+		query_string = '''SELECT * FROM %s limit 1;''' % query_table_name
 		all_db_columns[columns] = executeSql(getDb(),query_string,None,db_operations.MODE_DB_W_RETURN_WO_ARGS,header=True)
```

## gadgethiServerUtils/file_basics.py

```diff
@@ -1,13 +1,14 @@
 #!/usr/bin/env python3
 import os 
 import ast 
 import yaml
-import datetime
+import boto3
 import logging
+from gadgethiServerUtils.time_basics import *
 
 default_gserver_location = os.path.expanduser(os.path.join("~", ".gserver"))
 
 # Main API function
 # -------------------------
 # @@@ 1 @@@
 def load_config(cfg_location):
@@ -32,15 +33,15 @@
 			# scalar values to Python the dictionary format
 			config_yaml = yaml.load(file, Loader=yaml.FullLoader)
 			return config_yaml
 	except Exception as e:
 		return e
 
 # @@@ 3 @@@
-def write_yaml(fn, content):
+def write_yaml(fn, content, sort_keys=True):
 	"""
 	This is the helper function that writes to the config yaml and 
 	returns the status indicating whether the operation is successful or not.
 	- Input:
 		* fn: filename
 		* content: resulting yaml to be added 
 	- Returns:
@@ -48,15 +49,15 @@
 		* indicator: True, False whether the operation is completed
 		* message: message of operation
 	"""
 	indicator = True
 	message = "Write to yaml successful"
 	try:
 		with open(fn, "w") as file:
-			yaml.dump(content, file, allow_unicode = True)
+			yaml.dump(content, file, allow_unicode = True, sort_keys=sort_keys)
 	except Exception as e:
 		indicator = False
 		message = str(e) 
 	
 	return {"indicator":indicator, "message":message}
 
 # @@@ 4 @@@
@@ -135,20 +136,40 @@
 	"""
 	This is the helper function to init logger
 	* Usage:
 		After init, use logging.info(msg) to log messages
 		or logging.error(msg) to put different levels of faults
 	"""
 	try:
-		LOG_FILE_PATH = log_parent_directory + str(datetime.datetime.now().strftime("%Y-%m-%d_%H-%M")) + ".txt"
+		LOG_FILE_PATH = log_parent_directory + serverTime(TimeMode.STRING) + ".txt"
 	except:
 		raise Exception("Cannot create log file path")
 
 	# level implies that the logger will write all messages greater than level = INFO
-	logging.basicConfig(filename=LOG_FILE_PATH, level=logging.INFO)
+	logging.basicConfig(filename=LOG_FILE_PATH, 
+						level=logging.INFO, 
+						format='%(asctime)s %(name)-12s %(levelname)-8s %(message)s',
+                    	datefmt='%m-%d %H:%M',
+                    	filemode='w'
+						)
+
+	# define a Handler which writes INFO messages or higher to the sys.stderr
+	console = logging.StreamHandler()
+	console.setLevel(logging.INFO)
+	# set a format which is simpler for console use
+	formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')
+	# tell the handler to use this format
+	console.setFormatter(formatter)
+	# add the handler to the root logger
+	logging.getLogger().addHandler(console)
+
+	# CAN USE THE FOLLOWING TO DEFINE LOGGERS IN DIFFERENT REGIONS, defined in
+	# different files. 
+	# logger1 = logging.getLogger('myapp.area1')
+	# logger2 = logging.getLogger('myapp.area2')
 
 # Helper functions
 # -------------------------
 def get_file_path(parent_directory, file_name):
 	"""
 	This function gets the absolute path given parent directory and file_name  
 
@@ -181,7 +202,59 @@
 		* existence: Bool of whether it exists
 
 	"""
 
 	abs_path = get_file_path(parent_directory, file_name)
 
 	return os.path.exists(abs_path)	
+
+
+# File Handling from S3
+# ----------------------------
+def fetch_from_s3(bucket, files, tolocation, **configs):
+	"""
+	This is the helper function to fetch files from s3.
+	If you want to fetch all files from a directory 
+
+	- Input:
+		* bucket: name of the s3 bucket
+		* files: a list of filenames on s3 bucket. It supports
+			single file or multiple files.
+			e.g. ["database_ini/database.ini", "doday_yamls/*"]
+		* tolocation: the local folder that we 
+			want to put the fetched files in.
+			e.g. ["util/database.ini", "yamls/*"]
+	"""
+	assert isinstance(files, list) and isinstance(tolocation, list)
+	assert len(files) == len(tolocation)
+
+	# connect to s3
+	ACCESS_ID = configs.get("aws_access_key_id", None)
+	SECRET_KEY = configs.get("aws_secret_access_key", None)
+	s3 = boto3.client('s3', aws_access_key_id=ACCESS_ID, aws_secret_access_key=SECRET_KEY)
+
+	logging.info("Pulling Files From S3....")
+
+	for fileid in range(len(files)):
+		# wild card for all files in single folder
+		if "*" == files[fileid][-1]:
+			s3_folder_header = files[fileid][:-1]
+			local_folder_header = tolocation[fileid][:-1]
+			objects = s3.list_objects(Bucket=bucket, Prefix=s3_folder_header)["Contents"]
+			for obj in objects:
+				obj_name = obj["Key"].replace(s3_folder_header, "")
+				logging.info(obj_name)
+				s3.download_file(bucket, s3_folder_header+obj_name, local_folder_header+obj_name)
+		else:
+			s3.download_file(bucket, files[fileid], tolocation[fileid])
+
+def read_yaml_on_s3(bucket_name, file_path):
+	"""
+	This is the helper function to read yaml
+	from s3 and return the dictionary of it. 
+	"""
+	s3 = boto3.client('s3')
+	data = s3.get_object(Bucket=bucket_name, Key=file_path)
+	contents = data['Body'].read()
+	s = contents.decode("utf-8")
+	ret_yaml = yaml.safe_load(s)
+	return ret_yaml
```

## gadgethiServerUtils/pay_integration.py

```diff
@@ -1,104 +1,23 @@
 from gadgethiServerUtils.encryption import *
 from gadgethiServerUtils.file_basics import *
-from datetime import datetime
+from gadgethiServerUtils.time_basics import *
 from os.path import expanduser
 import time
 import requests
 import json
 import logging
 
-credentials = load_config(expanduser("~") + "/.gserver/credentials.yaml")
-
-def verify_finish_payment(intella_payment_data, **configs):
-	"""
-	This function verifies that the payment has been processed 
-	Using dodaytest01 crypto class
-	- Input:
-		* intella_payment_data: Sent from Notification Payment Center
-	- Output:
-		* Integrity: Bool False/True
+def post_to_blue(order_data, **credentials):
 	"""
-	iv =  credentials["intella_iv"].encode() 
-	password = credentials["intella_password"] 
-	cert_path = credentials["public_key_cert_path"]
-	encryptor = GadgetEncryption(base64.b64encode(os.urandom(16)), iv, cert_path)
-
-	try:
-		Sign = intella_payment_data["Sign"]
-		print ("Sign from intella = ",Sign)
-		if Sign == "admin":
-			return True
-	except:
-		pass
-		
-	if encryptor.verify(intella_payment_data):
-		return True
-	else:
-		return False
+	Function to post to 3rd party financial 
+	service blue star. 
 
-
-def post_to_Intella(order_data, number_of_data, **server_config):
-	"""
-	This function posts the order info to intella service and gets a url
-	- Input:
-		* order_data: dictionary of data
-	- Return:
-		* url: url of payment info
+	Need order_data and credentials for input
 	"""
-	StoreOrderNo = order_data['order_id']
-	Body = str(order_data['serial_number'])
-	TotalFee = str(order_data['total_price'])
-	"""
-	Only for AWS
-	"""
-	if server_config["server_location"] == "AWS":
-		shift_timezone = int(server_config["time_zone"])
-	elif server_config["server_location"] == "local":	
-		shift_timezone = 0
-
-	cTime = int(datetime.now().timestamp()) + (shift_timezone*60*60)
-	time_str = time.strftime("%Y%m%d%H%M%S", time.localtime(cTime))
-
-	iv =  credentials["intella_iv"].encode() 
-	cert_path = credentials["public_key_cert_path"]
-	encryptor = GadgetEncryption(base64.b64encode(os.urandom(16)), iv, cert_path)
-
-	password = credentials["intella_password"] 
-	tradekey = encryptor.sha256encrypt_string(password)
-
-	data_info = {"DeviceInfo":"skb0001","StoreOrderNo":StoreOrderNo,"Body":"訂單"+str(Body),"TotalFee":TotalFee,"CallBackUrl":"http://order.doday.com.tw/success_page.html","Delay":"3"}
-
-	test_data ={
-	  "Header": {
-		"Method": "00000",
-		"ServiceType":"OLPay",
-		"MchId": credentials["doday_mchid"],
-		"TradeKey": tradekey,
-		"CreateTime": time_str
-	  },
-		"Data": json.dumps(data_info)
-	}	
-
-	payload = str(encryptor.generateRequestDict(test_data))
-	payload.replace("\'","\"")
-
-	payload = ast.literal_eval(payload)
-
-	intella_response = (encryptor.client_post("https://a.intella.co/allpaypass/api/general", payload))
-	intella_response = ast.literal_eval(intella_response)
-
-	intella_response = encryptor.decodeIntellaResponse(intella_response)
-	intella_response = ast.literal_eval(intella_response)
-
-	return intella_response
-
-
-def post_to_blue(order_data):
-	
 	test_string = {'MerchantID':order_data['MerchantID'],'RespondType':'JSON','TimeStamp':order_data['time'],'Version':1.5,'MerchantOrderNo':order_data['MerchantOrderNo'],'Amt':order_data['Amt'],'ItemDesc':order_data['ItemDesc'],'Email':order_data['Email'],'LoginType':0,'ANDROIDPAY':0}
 	
 	# iv and key position
 	iv = credentials["blue_iv"].encode()
 	key = credentials["blue_key"].encode()
 
 	# str iv,key
@@ -114,121 +33,28 @@
 	SHA = encryptor.hashFunction(SHA256_string)
 	SHA = str.upper(SHA)
 
 	decode_string = encryptor.decrypt_AES(string)
 
 	return string,SHA
 
-def poll_multiple_orders(interval, **server_config):
-	"""
-	This function uses the Intella multiple order polling.
-
-	Request should be 
-
-	{
-	  "Header": {
-		"Method": "00000",
-		"ServiceType": "OrderQuery",
-		"MchId": "myMchId",
-		"TradeKey": "9af15b336e6a9619928537df30b2e6a2376569fcf9d7e773eccede65606529a0",
-		"CreateTime": "20180715105349"
-	  },
-	  "Data": "{\"StartDate\":\"20180715\",\"EndDate\":\"20180716\",\"OrderStatus\":\"1\"}"
-	}
-	
-	Response may be 
-
-	{
-	  "Header": {
-		"StatusCode": "0000",
-		"StatusDesc": "執行成功",
-		"Method": "00000",
-		"ServiceType": "OrderQuery",
-		"MchId": "myMchId"
-	  },
-	  "Data": {
-		"DataValue": [
-		  {
-			"StoreOrderNo": "PO-20180715-004",
-			"SysOrderNo": "104605",
-			"TotalFee": 10,
-			"FeeType": "TWD",
-			"Status": "Trade success",
-			"Description": "-7082",
-			"Method": "11500"
-		  },
-		  {
-			"StoreOrderNo": "PO-20180715-005",
-			"SysOrderNo": "104644",
-			"TotalFee": 10,
-			"FeeType": "TWD",
-			"Status": "Trade success",
-			"RefundStatus": "Refund success",
-			"Description": "Chicken Rice-0247",
-			"Method": "31800"
-		  }
-		]
-	  }
-	}
-
-	"""
-	if server_config["server_location"] == "AWS":
-		shift_timezone = int(server_config["time_zone"])
-	elif server_config["server_location"] == "local":	
-		shift_timezone = 0
-
-	cTime = int(datetime.now().timestamp()) + (shift_timezone*60*60)
-	start_time = int(cTime - interval)
-	current_time_str = time.strftime("%Y%m%d%H%M%S", time.localtime(cTime))
-	start_time_str = time.strftime("%Y%m%d%H%M%S", time.localtime(start_time))
-
-	iv =  credentials["intella_iv"].encode() 
-	cert_path = credentials["public_key_cert_path"]
-	encryptor = GadgetEncryption(base64.b64encode(os.urandom(16)), iv, cert_path)
-	
-	password = credentials["intella_password"] 
-	tradekey = encryptor.sha256encrypt_string(password)
-
-	data_info = {"StartDate":start_time_str,"EndDate":current_time_str,"OrderStatus":"1"}
-	test_data ={
-	  "Header": {
-		"Method": "00000",
-		"ServiceType":"OrderQuery",
-		"MchId": credentials["doday_mchid"],
-		"TradeKey": tradekey,
-		"CreateTime": current_time_str
-	  },
-		"Data": json.dumps(data_info)
-	}	
-
-	payload = str(encryptor.generateRequestDict(test_data))
-	payload.replace("\'","\"")
-
-	payload = ast.literal_eval(payload)
-
-	intella_response = (encryptor.client_post("https://a.intella.co/allpaypass/api/general", payload))
-	intella_response = ast.literal_eval(intella_response)
-
-	intella_response = encryptor.decodeIntellaResponse(intella_response)
-	intella_response = ast.literal_eval(intella_response)
-	return intella_response
 
 class LineOfflinePayment:
 	
 	def __init__(self,channel_secret,channel_id):
 		# required
 		# 1. channel_secret(from Line)
 		# 2. channel_id(from Line)
 		# 3. domain test:"https://sandbox-api-pay.line.me", real: ""
 		# http part
 		# sandbox: https://sandbox-api-pay.line.me/v2/payments/oneTimeKeys/pay
 		# real: https://api-pay.line.me/v2/payments/oneTimeKeys/pay
 		self.domain = "https://api-pay.line.me"
 		self.channel_secret = channel_secret
-		self.nonce = str(time.time())
+		self.nonce = str(serverTime())
 		self.channel_id = channel_id
 		self.headers = {'Content-Type': 'application/json','X-LINE-ChannelId':self.channel_id,'X-LINE-ChannelSecret':self.channel_secret}
 	
 	def oneTimeKeys_api(self,amount,orderId,oneTimeKey):
 		# orderId should always be unique, oneTimeKey comes from the user_phone QR code
 		my_data = {
 		    "productName": "test product",
@@ -249,15 +75,15 @@
 		# required
 		# 1. channel_secret(from Line)
 		# 2. channel_id(from Line)
 		# 3. domain test:"https://sandbox-api-pay.line.me", real: ""
 		super().__init__("","")
 		self.domain = "https://api-pay.line.me"
 		self.channel_secret = channel_secret
-		self.nonce = str(time.time())
+		self.nonce = str(serverTime())
 		self.channel_id = channel_id
 		self.headers = {'Content-Type': 'application/json','X-LINE-ChannelId':self.channel_id,'X-LINE-Authorization-Nonce':self.nonce,'X-LINE-Authorization':''}
 	
 	def request_api(self,amount,orderId,confirmUrl,cancelUrl):
 		# amount(int), orderId(unique) 
 		dictionary = {
 			"amount" : amount,
@@ -325,7 +151,186 @@
 		encode_string = self.channel_secret+url+query_string+self.nonce
 		encode_result = self.HMAC256_digest(self.channel_secret,encode_string)
 		self.headers['X-LINE-Authorization'] = encode_result
 		r = requests.get(str(self.domain+url+'?'+query_string), headers = self.headers)
 		print('r = ',r.json())
 		return r.json()
 
+# INTELLA PAY integration deprecated -> keep code for future references
+# --------------------------------------------------------------
+# credentials = load_config(expanduser("~") + "/.gserver/credentials.yaml")
+
+# def verify_finish_payment(intella_payment_data, **configs):
+# 	"""
+# 	This function verifies that the payment has been processed 
+# 	Using dodaytest01 crypto class
+# 	- Input:
+# 		* intella_payment_data: Sent from Notification Payment Center
+# 	- Output:
+# 		* Integrity: Bool False/True
+# 	"""
+# 	iv =  credentials["intella_iv"].encode() 
+# 	password = credentials["intella_password"] 
+# 	cert_path = credentials["public_key_cert_path"]
+# 	encryptor = GadgetEncryption(base64.b64encode(os.urandom(16)), iv, cert_path)
+
+# 	try:
+# 		Sign = intella_payment_data["Sign"]
+# 		print ("Sign from intella = ",Sign)
+# 		if Sign == "admin":
+# 			return True
+# 	except:
+# 		pass
+		
+# 	if encryptor.verify(intella_payment_data):
+# 		return True
+# 	else:
+# 		return False
+
+
+# def post_to_Intella(order_data, number_of_data, **server_config):
+# 	"""
+# 	This function posts the order info to intella service and gets a url
+# 	- Input:
+# 		* order_data: dictionary of data
+# 	- Return:
+# 		* url: url of payment info
+# 	"""
+# 	StoreOrderNo = order_data['order_id']
+# 	Body = str(order_data['serial_number'])
+# 	TotalFee = str(order_data['total_price'])
+# 	"""
+# 	Only for AWS
+# 	"""
+# 	if server_config["server_location"] == "AWS":
+# 		shift_timezone = int(server_config["time_zone"])
+# 	elif server_config["server_location"] == "local":	
+# 		shift_timezone = 0
+
+# 	cTime = int(datetime.now().timestamp()) + (shift_timezone*60*60)
+# 	time_str = time.strftime("%Y%m%d%H%M%S", time.localtime(cTime))
+
+# 	iv =  credentials["intella_iv"].encode() 
+# 	cert_path = credentials["public_key_cert_path"]
+# 	encryptor = GadgetEncryption(base64.b64encode(os.urandom(16)), iv, cert_path)
+
+# 	password = credentials["intella_password"] 
+# 	tradekey = encryptor.sha256encrypt_string(password)
+
+# 	data_info = {"DeviceInfo":"skb0001","StoreOrderNo":StoreOrderNo,"Body":"訂單"+str(Body),"TotalFee":TotalFee,"CallBackUrl":"http://order.doday.com.tw/success_page.html","Delay":"3"}
+
+# 	test_data ={
+# 	  "Header": {
+# 		"Method": "00000",
+# 		"ServiceType":"OLPay",
+# 		"MchId": credentials["doday_mchid"],
+# 		"TradeKey": tradekey,
+# 		"CreateTime": time_str
+# 	  },
+# 		"Data": json.dumps(data_info)
+# 	}	
+
+# 	payload = str(encryptor.generateRequestDict(test_data))
+# 	payload.replace("\'","\"")
+
+# 	payload = ast.literal_eval(payload)
+
+# 	intella_response = (encryptor.client_post("https://a.intella.co/allpaypass/api/general", payload))
+# 	intella_response = ast.literal_eval(intella_response)
+
+# 	intella_response = encryptor.decodeIntellaResponse(intella_response)
+# 	intella_response = ast.literal_eval(intella_response)
+
+# 	return intella_response
+# def poll_multiple_orders(interval, **server_config):
+# 	"""
+# 	This function uses the Intella multiple order polling.
+
+# 	Request should be 
+
+# 	{
+# 	  "Header": {
+# 		"Method": "00000",
+# 		"ServiceType": "OrderQuery",
+# 		"MchId": "myMchId",
+# 		"TradeKey": "9af15b336e6a9619928537df30b2e6a2376569fcf9d7e773eccede65606529a0",
+# 		"CreateTime": "20180715105349"
+# 	  },
+# 	  "Data": "{\"StartDate\":\"20180715\",\"EndDate\":\"20180716\",\"OrderStatus\":\"1\"}"
+# 	}
+	
+# 	Response may be 
+
+# 	{
+# 	  "Header": {
+# 		"StatusCode": "0000",
+# 		"StatusDesc": "執行成功",
+# 		"Method": "00000",
+# 		"ServiceType": "OrderQuery",
+# 		"MchId": "myMchId"
+# 	  },
+# 	  "Data": {
+# 		"DataValue": [
+# 		  {
+# 			"StoreOrderNo": "PO-20180715-004",
+# 			"SysOrderNo": "104605",
+# 			"TotalFee": 10,
+# 			"FeeType": "TWD",
+# 			"Status": "Trade success",
+# 			"Description": "-7082",
+# 			"Method": "11500"
+# 		  },
+# 		  {
+# 			"StoreOrderNo": "PO-20180715-005",
+# 			"SysOrderNo": "104644",
+# 			"TotalFee": 10,
+# 			"FeeType": "TWD",
+# 			"Status": "Trade success",
+# 			"RefundStatus": "Refund success",
+# 			"Description": "Chicken Rice-0247",
+# 			"Method": "31800"
+# 		  }
+# 		]
+# 	  }
+# 	}
+
+# 	"""
+# 	if server_config["server_location"] == "AWS":
+# 		shift_timezone = int(server_config["time_zone"])
+# 	elif server_config["server_location"] == "local":	
+# 		shift_timezone = 0
+
+# 	cTime = int(datetime.now().timestamp()) + (shift_timezone*60*60)
+# 	start_time = int(cTime - interval)
+# 	current_time_str = time.strftime("%Y%m%d%H%M%S", time.localtime(cTime))
+# 	start_time_str = time.strftime("%Y%m%d%H%M%S", time.localtime(start_time))
+
+# 	iv =  credentials["intella_iv"].encode() 
+# 	cert_path = credentials["public_key_cert_path"]
+# 	encryptor = GadgetEncryption(base64.b64encode(os.urandom(16)), iv, cert_path)
+	
+# 	password = credentials["intella_password"] 
+# 	tradekey = encryptor.sha256encrypt_string(password)
+
+# 	data_info = {"StartDate":start_time_str,"EndDate":current_time_str,"OrderStatus":"1"}
+# 	test_data ={
+# 	  "Header": {
+# 		"Method": "00000",
+# 		"ServiceType":"OrderQuery",
+# 		"MchId": credentials["doday_mchid"],
+# 		"TradeKey": tradekey,
+# 		"CreateTime": current_time_str
+# 	  },
+# 		"Data": json.dumps(data_info)
+# 	}	
+
+# 	payload = str(encryptor.generateRequestDict(test_data))
+# 	payload.replace("\'","\"")
+
+# 	payload = ast.literal_eval(payload)
+
+# 	intella_response = (encryptor.client_post("https://a.intella.co/allpaypass/api/general", payload))
+# 	intella_response = ast.literal_eval(intella_response)
+
+# 	intella_response = encryptor.decodeIntellaResponse(intella_response)
+# 	intella_response = ast.literal_eval(intella_response)
+# 	return intella_response
```

## gadgethiServerUtils/time_basics.py

```diff
@@ -1,17 +1,23 @@
 import datetime
 import time
 import logging
 import re
+import os
 from enum import Enum
 
 # For timeout function
 # ------------------------------
 import concurrent.futures as futures
 
+# timezone_str should be a integer number range from -24 to 24, 
+# this is the offset from UTC. TODO: CAVEAT: Be careful of the daylight saving
+timezone_str = os.environ.get('SERVER_TIMEZONE', '8') #Defaults to UTC +8
+timez = datetime.timezone(datetime.timedelta(hours=int(timezone_str)))
+
 class TimeMode(Enum):
     EPOCH = 1
     STRING = 2
     DATETIME_NOW = 3
 
 def serverTime(mode=TimeMode.EPOCH):
     """
@@ -19,20 +25,20 @@
     Make sure all time related function take 
     on this time. 
     * Input:
         mode: the mode of the serverTime representation. If
             not specified -> epoch time will be returned
     * Returns a datetime object
     """
-    server_time = datetime.datetime.now()
+    server_time = datetime.datetime.now(tz=timez)
     
     if mode == TimeMode.EPOCH:
         return server_time.timestamp()
     elif mode == TimeMode.STRING:
-        return server_time.strftime("%m/%d/%Y, %H:%M:%S")
+        return server_time.strftime("%m-%d-%Y-%H-%M-%S")
     elif mode == TimeMode.DATETIME_NOW:
         return server_time
 
 
 def is_time_between(begin_time, end_time, check_time=None):
     """
     This is the function to check whether the check time is between
@@ -63,15 +69,15 @@
 
     opening_hour, opening_minute = int(opening_time[:2]), int(opening_time[3:])
     closing_hour, closing_minute = int(closing_time[:2]), int(closing_time[3:])
     logging.info("[VerifyOperationHour] opening_hour, closing_hour = "+ str(opening_hour) + str(closing_hour))
 
     start_time = datetime.time(opening_hour,opening_minute)
     end_time = datetime.time(closing_hour,closing_minute)
-    current_time = datetime.datetime.now().time()
+    current_time = serverTime(TimeMode.DATETIME_NOW).time()
 
     return is_time_between(start_time, end_time, current_time)
 
 
 def timeout(timelimit):
     """
     The timeout decorator for functions to raise
```

## gadgethiServerUtils/tests/testTime.py

```diff
@@ -40,35 +40,35 @@
     # covers check_operation_hours
     def test_check_operation_hours(self):
         args_dict = {
             "opening_time": "10:10",
             "closing_time": "12:10"
         }
         self.assertEqual(check_operation_hours(**args_dict), \
-            datetime.datetime.now().time() >= datetime.time(10, 10) and datetime.datetime.now().time() <= datetime.time(12, 10))
+            datetime.datetime.now(tz=timez).time() >= datetime.time(10, 10) and datetime.datetime.now(tz=timez).time() <= datetime.time(12, 10))
 
         args_dict = {
             "opening_time": "XX",
             "closing_time": "XX"
         }
         self.assertFalse(check_operation_hours(**args_dict))
 
         args_dict = {
             "opening_time": "19:10",
             "closing_time": "08:10"
         }
         self.assertEqual(check_operation_hours(**args_dict), \
-            datetime.datetime.now().time() >= datetime.time(19, 10) or datetime.datetime.now().time() <= datetime.time(8, 10))
+            datetime.datetime.now(tz=timez).time() >= datetime.time(19, 10) or datetime.datetime.now(tz=timez).time() <= datetime.time(8, 10))
 
         args_dict = {
             "opening_time": "10:10",
             "closing_time": "10:10"
         }
         self.assertEqual(check_operation_hours(**args_dict), \
-            datetime.datetime.now().time() >= datetime.time(10, 10) and datetime.datetime.now().time() <= datetime.time(10, 10))
+            datetime.datetime.now(tz=timez).time() >= datetime.time(10, 10) and datetime.datetime.now(tz=timez).time() <= datetime.time(10, 10))
 
     # covers all timeout
     def test_timeout(self):
 
         @timeout(0)
         def test_sleep_0(n):
             time.sleep(n)
```

## Comparing `gadgethiServerUtils-0.3.8.dist-info/METADATA` & `gadgethiServerUtils-999.999.dist-info/METADATA`

 * *Files 3% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: gadgethiServerUtils
-Version: 0.3.8
+Version: 999.999
 Summary: Gadgethi server maintenance package
 Home-page: https://github.com/weitung/gadgethiServerUtils.git
 Author: Gadgethi Develop Team
 Author-email: developers@gadget-hitech.com
 License: AGPLv3+
 Platform: UNKNOWN
 Classifier: Intended Audience :: Developers
@@ -14,15 +14,14 @@
 Classifier: Programming Language :: Python :: 3.7
 Classifier: Operating System :: OS Independent
 Classifier: Topic :: Software Development :: Libraries 
 Requires-Python: >=3.5
 Description-Content-Type: text/markdown
 Requires-Dist: pycryptodomex
 Requires-Dist: pyyaml (==5.1)
-Requires-Dist: psycopg2-binary
 Requires-Dist: boto3
 Requires-Dist: discover
 Requires-Dist: requests
 
 # gadgethiServerUtils
 This is the utility helper functions that can support the gadgethi server development.
```

## Comparing `gadgethiServerUtils-0.3.8.dist-info/RECORD` & `gadgethiServerUtils-999.999.dist-info/RECORD`

 * *Files 13% similar despite different names*

```diff
@@ -1,29 +1,29 @@
-gadgethiServerUtils/GadgethiClient.py,sha256=lDc4nRtAwFpc9HsLfcGg3U4xLpDx1kLnZiiaeZBqafY,4807
-gadgethiServerUtils/GadgethiServer.py,sha256=7PY1PLTwOT-dk-uQO_BjaV61T9Yy4Dya8Op0X4Sd3co,12800
+gadgethiServerUtils/GadgethiAWSHandler.py,sha256=R3ownUKFmwEVgtOAdv1W_rJAkr9yVl6p0KkfMUk-LvQ,4572
+gadgethiServerUtils/GadgethiClient.py,sha256=mngKXVgzp5k6FmoM0wqejeDFI8MEym6TtEdObE9y-WQ,4904
+gadgethiServerUtils/GadgethiServer.py,sha256=_4-oFvznLqzUR8SrawWWbM-BbAE9cYgDtj_NEf-Ltk8,12217
+gadgethiServerUtils/GadgethiZMQ.py,sha256=uKS0IsC293STJVKfxl0ErLKEhSrQ3d-Z_IIuSrwNXgo,948
 gadgethiServerUtils/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-gadgethiServerUtils/_configs.py,sha256=2tPWK87dtf3-2b_RX6ccLK29iulL9zT3lxdXljp-rkU,3727
-gadgethiServerUtils/_exceptions.py,sha256=ZBpekOoHzMzRtUg8v0IlmcByMjxnv6pG9eLSQU2SSgI,2785
+gadgethiServerUtils/_configs.py,sha256=wYnEK--FTeSwIOg1dcALkFgzrJ0qJ5GVdvO8rfbE8t8,3728
+gadgethiServerUtils/_exceptions.py,sha256=ZOWDr8nOpIXpv-lLmWrqfedeBRPGbtkdN4u5orbNODU,3606
 gadgethiServerUtils/authentication.py,sha256=ekjGAx3q-bJvH959Y3SJg81GJHXps_Da0cr-JrLZzX8,3811
-gadgethiServerUtils/cash_flow.py,sha256=n1aA0GnmfmQz0X_Pgq8as-RdZNAwZrjYVeQTsluxmL8,6062
-gadgethiServerUtils/db_basics.py,sha256=L3tm4prln4wz-chLv3K4JANzQiLQpmt9SiQ4G5_5-Ew,13657
-gadgethiServerUtils/db_operations.py,sha256=vQhs6X4YhtYys5R_M6rU6_V6RCbU84cvgbPm5-YQiDw,22836
+gadgethiServerUtils/db_basics.py,sha256=VR0_VVeiwvrLzOhujTBvRFT7ZnZZWeC5lG2O7mtOyYY,14313
+gadgethiServerUtils/db_operations.py,sha256=gRSZj98cD-7rlnCP49v4eLIjs59PjSz7ZiqvX3Ter14,22078
 gadgethiServerUtils/encryption.py,sha256=0IhQaLCqOof6GrJGRr8rXYgch8g6jV6VOKkpfxBbACw,6620
-gadgethiServerUtils/exceptions.py,sha256=33Uju5MQHMcdS8YkA9rgujMninfTDQ7bFsV2ps_s9zU,4635
-gadgethiServerUtils/file_basics.py,sha256=dbv4p4bfNtX0yG8EgoKm26ijQDmJXLaffZtR40TEzGI,5459
-gadgethiServerUtils/global_config.py,sha256=ZNK0Q1IED5RL892nX9NIOyvWvv_RlF-ldW9qZTxLQcw,2041
+gadgethiServerUtils/file_basics.py,sha256=hwHNHpcInEty3kNJlwvcOp5YTVwsz5dCpzu3SzgDA6Q,8058
 gadgethiServerUtils/main.py,sha256=ScNVhttgJI1z7efqFS7b6pA0YfE-f9ckEFbioZuP3UE,1437
-gadgethiServerUtils/pay_integration.py,sha256=jYNAZWUHpZS_gz3SLXZhb0ez8b1qp2tKGdx9Uo4PBWI,10225
-gadgethiServerUtils/time_basics.py,sha256=IhIQKq3_rKF67lvPiI2IOR46kF6Lq4q-Qbylgkqm2Lg,3428
+gadgethiServerUtils/pay_integration.py,sha256=1Tq6bfL5xkfjNkaDsDqgPQCgIFzsabhHmj3rMMviivo,10806
+gadgethiServerUtils/time_basics.py,sha256=XpCa_ESfaVrkXBPnigXmpbf1FYCaZ79vdJHck_YltSY,3745
 gadgethiServerUtils/scripts/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 gadgethiServerUtils/scripts/generate_configs.py,sha256=NYcXPkZxfoQ1D7256vhiBGNVprNdA8hPBg2IKXlMnsw,3852
 gadgethiServerUtils/tests/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+gadgethiServerUtils/tests/testAWSHandler.py,sha256=9zHtI-KsR_UFCjSS_Sen2WgMAHuU7fgL0pKCt1Sk01k,14759
 gadgethiServerUtils/tests/testAuth.py,sha256=kwq2cH8s6GNGoTi5nPS6_uSao_IJvwwFVfZKwbiOx5k,6355
 gadgethiServerUtils/tests/testGserver.py,sha256=seA3Bon8V5oeNqsfqNsZGeLwRTo6U3DU5CERj3p8X-Y,6542
 gadgethiServerUtils/tests/testPrimitives.py,sha256=bAmbKWdTl9jxNf-Ny57CQ1oSgk7koaFXggwZZFbF0LM,3505
 gadgethiServerUtils/tests/testScripts.py,sha256=_KwZ-oxDOEKvlkFcS3SNYUOZ3WxKC1u3uX8baZi4n9A,3120
-gadgethiServerUtils/tests/testTime.py,sha256=8OnaPuxuxn8AexYBcnn9rQY1koKUxX_BrFACZT1U50s,3366
-gadgethiServerUtils-0.3.8.dist-info/METADATA,sha256=vPv0i-w-0J-GCvPIhCd06M1Co21oyd5ieqS8QeYf8H0,1702
-gadgethiServerUtils-0.3.8.dist-info/WHEEL,sha256=OqRkF0eY5GHssMorFjlbTIq072vpHpF60fIQA6lS9xA,92
-gadgethiServerUtils-0.3.8.dist-info/entry_points.txt,sha256=-oxqprRyZ2BV9OYqfGn4N9add4LsNUa8ILD0UAhjgBo,77
-gadgethiServerUtils-0.3.8.dist-info/top_level.txt,sha256=DMfWpquEdFhMeIJgfn34Y1LR3e-_dSUTBKGGBr4nMwc,20
-gadgethiServerUtils-0.3.8.dist-info/RECORD,,
+gadgethiServerUtils/tests/testTime.py,sha256=AYkw6BZSXJxPnMEIug4yLp2e327a-7BHBzf8asgA-AQ,3414
+gadgethiServerUtils-999.999.dist-info/METADATA,sha256=odubQ3aSslMyiZFXdYgNDbHAipYAhrDOWEntqtA4coc,1673
+gadgethiServerUtils-999.999.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
+gadgethiServerUtils-999.999.dist-info/entry_points.txt,sha256=-oxqprRyZ2BV9OYqfGn4N9add4LsNUa8ILD0UAhjgBo,77
+gadgethiServerUtils-999.999.dist-info/top_level.txt,sha256=DMfWpquEdFhMeIJgfn34Y1LR3e-_dSUTBKGGBr4nMwc,20
+gadgethiServerUtils-999.999.dist-info/RECORD,,
```

