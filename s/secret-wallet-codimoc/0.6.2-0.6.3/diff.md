# Comparing `tmp/secret_wallet_codimoc-0.6.2-py3-none-any.whl.zip` & `tmp/secret_wallet_codimoc-0.6.3-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,39 +1,39 @@
-Zip file size: 50844 bytes, number of entries: 37
+Zip file size: 54398 bytes, number of entries: 37
 -rw-r--r--  2.0 unx        0 b- defN 23-Mar-26 10:35 secretwallet/__init__.py
--rw-r--r--  2.0 unx      200 b- defN 23-Mar-30 08:10 secretwallet/__main__.py
--rw-r--r--  2.0 unx     8491 b- defN 23-Apr-15 11:47 secretwallet/constants.py
--rw-r--r--  2.0 unx      160 b- defN 23-Apr-10 09:21 secretwallet/__pycache__/__init__.cpython-39.pyc
+-rw-r--r--  2.0 unx      224 b- defN 23-Jun-01 07:42 secretwallet/__main__.py
+-rw-r--r--  2.0 unx     8531 b- defN 23-Jun-01 07:42 secretwallet/constants.py
 -rw-r--r--  2.0 unx      350 b- defN 23-Mar-26 10:35 secretwallet/main/__init__.py
--rw-r--r--  2.0 unx     8899 b- defN 23-Mar-26 10:35 secretwallet/main/configuration.py
--rw-r--r--  2.0 unx    34695 b- defN 23-Apr-15 08:58 secretwallet/main/myparser.py
+-rw-r--r--  2.0 unx    10001 b- defN 23-Jun-01 07:42 secretwallet/main/configuration.py
+-rw-r--r--  2.0 unx    35600 b- defN 23-Jun-01 07:42 secretwallet/main/myparser.py
 -rw-r--r--  2.0 unx        0 b- defN 23-Mar-26 10:35 secretwallet/session/__init__.py
--rw-r--r--  2.0 unx     2101 b- defN 23-Mar-30 08:10 secretwallet/session/client.py
--rw-r--r--  2.0 unx     3465 b- defN 23-Mar-30 08:10 secretwallet/session/service.py
--rw-r--r--  2.0 unx        0 b- defN 23-Mar-30 17:30 secretwallet/storage/__init__.py
--rw-r--r--  2.0 unx    12290 b- defN 23-Apr-09 08:25 secretwallet/storage/aws_dynamo.py
--rw-r--r--  2.0 unx      106 b- defN 23-Apr-15 11:47 secretwallet/utils/__init__.py
--rw-r--r--  2.0 unx     3677 b- defN 23-Apr-06 17:44 secretwallet/utils/cryptutils.py
--rw-r--r--  2.0 unx    14331 b- defN 23-Apr-09 08:46 secretwallet/utils/dbutils.py
+-rw-r--r--  2.0 unx     2131 b- defN 23-Jun-01 07:42 secretwallet/session/client.py
+-rw-r--r--  2.0 unx     3495 b- defN 23-Jun-01 07:42 secretwallet/session/service.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jun-01 07:41 secretwallet/storage/__init__.py
+-rw-r--r--  2.0 unx    12326 b- defN 23-Jun-01 07:42 secretwallet/storage/aws_dynamo.py
+-rw-r--r--  2.0 unx    10773 b- defN 23-Jun-01 07:42 secretwallet/storage/local_sqlite.py
+-rw-r--r--  2.0 unx     2556 b- defN 23-Jun-01 07:42 secretwallet/storage/table.py
+-rw-r--r--  2.0 unx      175 b- defN 23-Jun-01 07:42 secretwallet/utils/__init__.py
+-rw-r--r--  2.0 unx     3677 b- defN 23-Jun-01 07:41 secretwallet/utils/cryptutils.py
+-rw-r--r--  2.0 unx    14554 b- defN 23-Jun-01 07:42 secretwallet/utils/dbutils.py
 -rw-r--r--  2.0 unx      136 b- defN 23-Mar-26 10:35 secretwallet/utils/fileutils.py
--rw-r--r--  2.0 unx     5437 b- defN 23-Apr-07 17:23 secretwallet/utils/ioutils.py
+-rw-r--r--  2.0 unx     5437 b- defN 23-Jun-01 07:41 secretwallet/utils/ioutils.py
 -rw-r--r--  2.0 unx     1204 b- defN 23-Mar-30 08:10 secretwallet/utils/logging.py
 -rw-r--r--  2.0 unx     3911 b- defN 23-Mar-30 08:10 secretwallet/utils/password_manager.py
--rw-r--r--  2.0 unx      166 b- defN 23-Apr-10 09:21 secretwallet/utils/__pycache__/__init__.cpython-39.pyc
--rw-r--r--  2.0 unx     3551 b- defN 23-Apr-10 09:21 secretwallet/utils/__pycache__/cryptutils.cpython-39.pyc
--rw-r--r--  2.0 unx      372 b- defN 23-Apr-03 20:58 tests/__init__.py
+-rw-r--r--  2.0 unx      644 b- defN 23-Jun-01 07:42 tests/__init__.py
 -rw-r--r--  2.0 unx     1748 b- defN 23-Mar-26 10:35 tests/aws_config_test.py
--rw-r--r--  2.0 unx     4761 b- defN 23-Apr-07 11:53 tests/aws_dynamo_test.py
--rw-r--r--  2.0 unx    27504 b- defN 23-Apr-15 11:47 tests/cli_test.py
--rw-r--r--  2.0 unx     2973 b- defN 23-Apr-07 15:38 tests/cryptuils_test.py
--rw-r--r--  2.0 unx    15242 b- defN 23-Apr-07 15:38 tests/dbutils_test.py
--rw-r--r--  2.0 unx     1757 b- defN 23-Apr-03 21:34 tests/parameters_test.py
+-rw-r--r--  2.0 unx     4761 b- defN 23-Jun-01 07:41 tests/aws_dynamo_test.py
+-rw-r--r--  2.0 unx    27504 b- defN 23-Jun-01 07:41 tests/cli_test.py
+-rw-r--r--  2.0 unx     2973 b- defN 23-Jun-01 07:41 tests/cryptuils_test.py
+-rw-r--r--  2.0 unx    17331 b- defN 23-Jun-01 07:42 tests/dbutils_test.py
+-rw-r--r--  2.0 unx     4791 b- defN 23-Jun-01 07:42 tests/local_sqlite_test.py
+-rw-r--r--  2.0 unx     1757 b- defN 23-Jun-01 07:41 tests/parameters_test.py
 -rw-r--r--  2.0 unx      646 b- defN 23-Mar-26 10:35 tests/password_test.py
--rw-r--r--  2.0 unx     1442 b- defN 23-Mar-30 08:10 tests/session_test.py
+-rw-r--r--  2.0 unx     1625 b- defN 23-Jun-01 07:42 tests/session_test.py
 -rw-r--r--  2.0 unx      127 b- defN 23-Mar-30 08:10 tests/data/test_integration.json
--rw-r--r--  2.0 unx     1050 b- defN 23-Apr-15 11:55 secret_wallet_codimoc-0.6.2.dist-info/LICENSE
--rw-r--r--  2.0 unx    29333 b- defN 23-Apr-15 11:55 secret_wallet_codimoc-0.6.2.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Apr-15 11:55 secret_wallet_codimoc-0.6.2.dist-info/WHEEL
--rw-r--r--  2.0 unx      152 b- defN 23-Apr-15 11:55 secret_wallet_codimoc-0.6.2.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       19 b- defN 23-Apr-15 11:55 secret_wallet_codimoc-0.6.2.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     3246 b- defN 23-Apr-15 11:55 secret_wallet_codimoc-0.6.2.dist-info/RECORD
-37 files, 193634 bytes uncompressed, 45594 bytes compressed:  76.5%
+-rw-r--r--  2.0 unx     1050 b- defN 23-Jun-01 08:08 secret_wallet_codimoc-0.6.3.dist-info/LICENSE
+-rw-r--r--  2.0 unx    31313 b- defN 23-Jun-01 08:08 secret_wallet_codimoc-0.6.3.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jun-01 08:08 secret_wallet_codimoc-0.6.3.dist-info/WHEEL
+-rw-r--r--  2.0 unx      152 b- defN 23-Jun-01 08:08 secret_wallet_codimoc-0.6.3.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx       19 b- defN 23-Jun-01 08:08 secret_wallet_codimoc-0.6.3.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     3183 b- defN 23-Jun-01 08:08 secret_wallet_codimoc-0.6.3.dist-info/RECORD
+37 files, 214797 bytes uncompressed, 49282 bytes compressed:  77.1%
```

## zipnote {}

```diff
@@ -3,17 +3,14 @@
 
 Filename: secretwallet/__main__.py
 Comment: 
 
 Filename: secretwallet/constants.py
 Comment: 
 
-Filename: secretwallet/__pycache__/__init__.cpython-39.pyc
-Comment: 
-
 Filename: secretwallet/main/__init__.py
 Comment: 
 
 Filename: secretwallet/main/configuration.py
 Comment: 
 
 Filename: secretwallet/main/myparser.py
@@ -30,14 +27,20 @@
 
 Filename: secretwallet/storage/__init__.py
 Comment: 
 
 Filename: secretwallet/storage/aws_dynamo.py
 Comment: 
 
+Filename: secretwallet/storage/local_sqlite.py
+Comment: 
+
+Filename: secretwallet/storage/table.py
+Comment: 
+
 Filename: secretwallet/utils/__init__.py
 Comment: 
 
 Filename: secretwallet/utils/cryptutils.py
 Comment: 
 
 Filename: secretwallet/utils/dbutils.py
@@ -51,20 +54,14 @@
 
 Filename: secretwallet/utils/logging.py
 Comment: 
 
 Filename: secretwallet/utils/password_manager.py
 Comment: 
 
-Filename: secretwallet/utils/__pycache__/__init__.cpython-39.pyc
-Comment: 
-
-Filename: secretwallet/utils/__pycache__/cryptutils.cpython-39.pyc
-Comment: 
-
 Filename: tests/__init__.py
 Comment: 
 
 Filename: tests/aws_config_test.py
 Comment: 
 
 Filename: tests/aws_dynamo_test.py
@@ -75,38 +72,41 @@
 
 Filename: tests/cryptuils_test.py
 Comment: 
 
 Filename: tests/dbutils_test.py
 Comment: 
 
+Filename: tests/local_sqlite_test.py
+Comment: 
+
 Filename: tests/parameters_test.py
 Comment: 
 
 Filename: tests/password_test.py
 Comment: 
 
 Filename: tests/session_test.py
 Comment: 
 
 Filename: tests/data/test_integration.json
 Comment: 
 
-Filename: secret_wallet_codimoc-0.6.2.dist-info/LICENSE
+Filename: secret_wallet_codimoc-0.6.3.dist-info/LICENSE
 Comment: 
 
-Filename: secret_wallet_codimoc-0.6.2.dist-info/METADATA
+Filename: secret_wallet_codimoc-0.6.3.dist-info/METADATA
 Comment: 
 
-Filename: secret_wallet_codimoc-0.6.2.dist-info/WHEEL
+Filename: secret_wallet_codimoc-0.6.3.dist-info/WHEEL
 Comment: 
 
-Filename: secret_wallet_codimoc-0.6.2.dist-info/entry_points.txt
+Filename: secret_wallet_codimoc-0.6.3.dist-info/entry_points.txt
 Comment: 
 
-Filename: secret_wallet_codimoc-0.6.2.dist-info/top_level.txt
+Filename: secret_wallet_codimoc-0.6.3.dist-info/top_level.txt
 Comment: 
 
-Filename: secret_wallet_codimoc-0.6.2.dist-info/RECORD
+Filename: secret_wallet_codimoc-0.6.3.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## secretwallet/__main__.py

```diff
@@ -1,7 +1,8 @@
 # This is added to faciliting testing without installing secretwallet
 # the executable can be started by
 # python -m secretwallet <add here the arguments that you need>
 
-from .main import main
+from .main import main, configure
 
-main()
+main()
+#configure()
```

## secretwallet/constants.py

```diff
@@ -1,14 +1,12 @@
 from collections import namedtuple
 import datetime
 import json
 import logging
-import os
 from os.path import expanduser, exists
-import sys
 
 from .utils import make_version_number
 
 
 if 'HOME_DIR' in globals():
     HOME_FOLDER = eval('HOME_DIR')
 else:
@@ -45,19 +43,16 @@
 
 LOG_FILE = f"{CONFIG_FOLDER}/secretwallet.log"
 LOG_LEVEL = "info"
 LOG_MAX_FILE_SIZE =  1000000 #1MB
 LOG_BACKUP_COUNT  = 1        #number of rotated backup files that are retained
 
 #type of storage
-DB_AWS_DYNAMO = 0
-DB_LOCAL_SQLITE = 1
-
-def is_posix()->bool:
-    return os.name=='posix'
+DB_AWS_DYNAMO = 'aws_dynamo'
+DB_LOCAL_SQLITE = 'local_sqlite'
 
 
 def make_log_level(level):
     if level.lower()=="critical":
         return logging.CRITICAL
     elif level.lower()=="fatal":
         return logging.FATAL
@@ -154,14 +149,17 @@
             return SECRET_ACCESS_TABLE
         
     def get_storage_type(self):
         if 'storage_type' in self.__data:
             return self.__data['storage_type']
         else:
             return DB_AWS_DYNAMO
+        
+    def set_storage_type(self, storage):
+        self.__data['storage_type'] = storage        
 
     def set_table_name(self, table):
         self.__data['table_name'] = table
 
     def get_salt_key(self):
         if 'key' in self.__data:
             return self.__data['key']
@@ -265,15 +263,15 @@
 #single object
 parameters = Parameters()
 
 # a message class containing secret info
 secret_fields = ['domain','access','user_id','password','info', 'encrypted_info','info_key','info_value','timestamp']
 
 #conditional compilation on python version >= 3.7
-if make_version_number(sys.version_info) >= 3700:
+if make_version_number() >= 3700:
     default_vals = [None]*len(secret_fields)
     Secret = namedtuple('Secret', secret_fields, defaults=default_vals) #this for versions >= 3.7
 else:           
     Secret = namedtuple('Secret', secret_fields) #this for versions < 3.7
     default_vals = (None,)*len(Secret._fields)
     Secret.__new__.__defaults__ = default_vals #this is required for version < 3.7
```

## secretwallet/main/configuration.py

```diff
@@ -135,14 +135,15 @@
     except Exception as e:
         print(e)
         exit(1)
         
 def display_configuration(conf_file, content, conf):
     print(f"\nThe {content} at {conf_file}")
     for k,v in conf.items():
+        if k=='key': continue
         print(f'{k:30} = {v:<40}')
         
         
 def make_configurations():
     "Main configuration script"
     print("\nMain configuration script for your secret wallet.")
     print("Please press return to accept the pre-set values in square brackets, or type a new value:\n")
@@ -198,10 +199,31 @@
             try:
                 set_configuration(conf_key, profile, table, None, CONFIG_FILE)
                 create_table(table)
             except Exception as e:
                 print(e)
                 print("Could not write the configuration file. Make sure you have AWS connection and try again")
         else:
-            exit(1)    
-    
+            exit(1)
+            
+    answ = input("\nDo you want to select or change the storage type: local or remote? (yes|skip) ")
+    if answ.lower().startswith('y'):
+        while (True):
+            storage = input('{0:30}[{1:>30}] = '.format('storage type (aws_dynamo|local_sqlite)',parameters.get_storage_type()))
+            if len(storage) == 0:
+                storage = parameters.get_storage_type()
+            if storage.lower() in ('aws_dynamo','local_sqlite'):
+                break  
+        conf = get_configuration(CONFIG_FILE)
+        conf["storage_type"] = storage
+        display_configuration(CONFIG_FILE, 'secret wallet configuration is located', conf)     
+        answ = input("\nDo you want to set the configuration parameters? (yes|exit) ")
+        if answ.lower().startswith('y'):
+            try:
+                set_configuration_data(conf, CONFIG_FILE)
+            except Exception as e:
+                print(e)
+                print("Could not write the configuration file. Make sure you have AWS connection and try again")
+        else:
+            exit(1)
+
```

## secretwallet/main/myparser.py

```diff
@@ -15,15 +15,15 @@
 from secretwallet.main.configuration import list_configuration, get_configuration, set_configuration_data
 from secretwallet.session.client import get_session_password, set_session_password, stop_service, is_connected
 from secretwallet.session.service import start_my_session
 from secretwallet.utils.cryptutils import encrypt_key
 from secretwallet.utils.dbutils import has_secret, get_secret, insert_secret, insert_encrypted_secret, list_secrets, \
                                        update_secret, update_secret_info_dictionary, delete_secret, delete_secrets, rename_secret, \
                                        reconf_memorable, reconf_salt_key, query_secrets_by_field, query_secrets_by_pattern, \
-                                       get_all_secrets
+                                       get_all_secrets, has_table, create_table
 from secretwallet.utils.logging import get_logger
 
 import pkg_resources as pkg
 import secretwallet.utils.ioutils as iou
 import secretwallet.utils.password_manager as pm
 
 
@@ -94,14 +94,17 @@
                             help='Command to run')
         self._parser = parser
         args = parser.parse_args(sys.argv[1:2])
         if not hasattr(self, args.command):
             iou.my_output('Unrecognized command')
             parser.print_help()
             exit(1)
+        
+        #create table if not there for the first time
+        create_table(silent=True) #if table already there nothing happens
         # use dispatch pattern to invoke method with same name
         getattr(self, args.command)()
 
 
     def set(self):
         """
             Add or change a secret in the wallet. This could be an entire new secret, with all the information passed inline
@@ -381,15 +384,16 @@
     def conf(self):
         """
            Configures some parameters for this application. It is possible to list all parameters with the -l option,
            or to configure the timeout and lifetime (in seconds) or the log level.
            The timeout is the amount of time in seconds along which the memorable password is remembered without been re-asked.
            The lifetime determines the lifetime of the background process that manages the temporary storage of
            the memorable password. The value of the lifetime parameter should be bigger than the password timeout.
-           The logging level is one of debug, info, warning, critical, error or fatal.
+           The logging level is one of debug, info, warning, critical, error or fatal. The srorage_type determines the
+           type of storage used: aws_dynamo for remote storage on AWS or local_sqlite for SQLite based local storage.
         """
         parser = argparse.ArgumentParser(
             description=self.conf.__doc__,
             prog='secret_wallet conf')
         #optional arguments
         parser.add_argument('-l',
                             '--list',
@@ -408,14 +412,18 @@
                             type = int,
                             default = -1,
                             help='Session lifetime in seconds')
         parser.add_argument('-ll',
                             '--loglevel',
                             dest = 'loglevel',
                             help='Logging level. One of debug, info, warning, critical, error or fatal')
+        parser.add_argument('-st',
+                            '--storage',
+                            dest = 'storage',
+                            help='Storage type: aws_dynamo for remote storage on AWS, local_sqlite for local storage')        
 
         args = iou.my_parse(parser,sys.argv[2:])
         if args is None:
             return
 
         iou.my_output('Running conf with arguments %s' % args)
         try:
@@ -428,14 +436,19 @@
                 if args.lifetime is not None and args.lifetime >=0:
                     conf['session_lifetime']=args.lifetime
                 if args.loglevel is not None:
                     if args.loglevel.lower() in ['debug', 'info', 'warning', 'critical', 'error','fatal']:
                         conf['log_level'] = args.loglevel.lower()
                     else:
                         iou.my_output(f"The passed log level {args.loglevel.lower()} is not valid")
+                if args.storage is not None:
+                    if args.storage.lower() in ['aws_dynamo', 'local_sqlite']:
+                        conf['storage_type'] = args.storage.lower()
+                    else:
+                        iou.my_output(f"The passed storage_type {args.storage.lower()} is not valid")                        
                 set_configuration_data(conf)
         except Exception as e:
             iou.my_output(repr(e))
 
     def reconf(self):
         """
            Reconfigures either the memorable or the device password. All secrets will be re-encryted with the changed password.
```

## secretwallet/session/client.py

```diff
@@ -1,11 +1,12 @@
 from multiprocessing.connection import Client
 
-from secretwallet.constants import parameters, is_posix
+from secretwallet.constants import parameters
 from secretwallet.utils.logging import get_logger
+from secretwallet.utils import is_posix
 
 
 logger = get_logger(__name__, parameters.get_log_level())
 parameters.register_logger(__name__, logger)
 
 def get_session_password():
     if not is_posix():
```

## secretwallet/session/service.py

```diff
@@ -1,14 +1,15 @@
 import datetime
 from multiprocessing import Process
 from multiprocessing.connection import Client, Listener
 from time import sleep
 
-from secretwallet.constants import parameters, is_posix
+from secretwallet.constants import parameters
 from secretwallet.utils.logging import get_logger
+from secretwallet.utils import is_posix
 
 logger = get_logger(__name__, parameters.get_log_level())
 parameters.register_logger(__name__, logger)
 
 def session_listener(seed, timeout):
     """ Session service function with an initial value as a seed
     input: seed    the initial value stored in the session
```

## secretwallet/storage/aws_dynamo.py

```diff
@@ -1,12 +1,16 @@
-import boto3
 from datetime import datetime
+
+import boto3
 from boto3.dynamodb.conditions import Key
+
 from ..constants import Secret
 from ..utils.cryptutils import encrypt, encrypt_info
+from .table import Table
+
 
 MAX_REPEAT = 3
 SUCCESS = 200
 
 #some utility functions
 def make_secret(d:dict)->Secret:
         return Secret(domain=d['domain'],
@@ -14,17 +18,17 @@
                       user_id = d['uid'],
                       password = d['pwd'],
                       info = d['info'],
                       timestamp = d['timestamp'])    
 
 """
     Proxy class for a table in a AWS DynamoDB database
-    The methos can throw so the client (dbutils functions) need to capture them
+    The methods can throw so the client (dbutils functions) need to capture them
 """
-class AWSDynamoTable:
+class AWSDynamoTable(Table):
 
     def __init__(self, table_name:str, profile_name:str):
         """
         Construct a table identified by a table name and a AWS profile_name
         """
         self.table_name = table_name
         self.profile_name = profile_name
@@ -138,15 +142,15 @@
                                                    'info'      : secret.info,
                                                    'timestamp' : timestamp})
             status = resp['ResponseMetadata']['HTTPStatusCode']
             rep +=1            
         
     def get_record(self,
                    secret: Secret) -> Secret:
-        "retrieves an encripted record keyed by domain and access, as a dictionary"
+        "retrieves an encrypted record keyed by domain and access, as a dictionary"
         rep = 0
         status = 0
         #if the insert did not work, repeat up to MAX_REPEAT times
         while status != SUCCESS and rep < MAX_REPEAT:        
             resp = self.get_table().get_item(Key={'domain'  : secret.domain,
                                                   'access'  : secret.access})
             status = resp['ResponseMetadata']['HTTPStatusCode']
```

## secretwallet/utils/__init__.py

```diff
@@ -1,3 +1,9 @@
 import sys
-def make_version_number(v:sys.version_info)-> int :
-    return v.major*1000+v.minor*100+v.micro
+import os
+
+def make_version_number()-> int :
+    v = sys.version_info
+    return v.major*1000+v.minor*100+v.micro
+
+def is_posix()->bool:
+    return os.name=='posix'
```

## secretwallet/utils/dbutils.py

```diff
@@ -3,19 +3,21 @@
 
 @author: codimoc
 '''
 
 from datetime import datetime
 import sys
 
-from secretwallet.constants import parameters, Secret
+from secretwallet.constants import parameters, Secret, DB_AWS_DYNAMO, DB_LOCAL_SQLITE
+from secretwallet.storage.aws_dynamo import AWSDynamoTable
+from secretwallet.storage.local_sqlite import LocalSqLiteTable
 from secretwallet.utils.cryptutils import encrypt_key, decrypt, decrypt_info
 from secretwallet.utils.logging import get_logger
-from secretwallet.storage.aws_dynamo import AWSDynamoTable
 
+from secretwallet.storage.table import Table
 import secretwallet.utils.ioutils as iou
 
 
 logger = get_logger(__name__, parameters.get_log_level())
 parameters.register_logger(__name__, logger)
 
 SEPARATOR="#-#"
@@ -39,18 +41,19 @@
                   access = secret.access,
                   user_id = decrypt(secret.user_id, mem_pwd, salt),
                   password = decrypt(secret.password, mem_pwd, salt),
                   info = decrypt_info(secret.info, mem_pwd, salt),
                   timestamp = secret.timestamp
                   )
 
-def _get_table()->object:
-    #we hard-code this to a AWS DynamoDB table for now
-    #TODO: this will require a parameter to decide which storage type
-    return AWSDynamoTable(parameters.get_table_name(), parameters.get_profile_name())
+def _get_table()->Table:
+    if parameters.get_storage_type() == DB_AWS_DYNAMO: 
+        return AWSDynamoTable(parameters.get_table_name(), parameters.get_profile_name())
+    elif parameters.get_storage_type() == DB_LOCAL_SQLITE:
+        return LocalSqLiteTable(parameters.get_table_name())
 
 def _backup_table(backup_name:str)->object:
     return _get_table().backup_table(backup_name)
 
 def _cleanup_table_backups(backup_name:str)->None:
     _get_table().cleanup_table_backups(backup_name)
 
@@ -63,21 +66,21 @@
         return _get_table().has_table(table_name)
     except Exception as e:
         iou.my_output(e)
         logger.error(e)
         sys.exit(1)
 
 
-def create_table(table_name=parameters.get_table_name()):
+def create_table(table_name=parameters.get_table_name(), silent=False):
     "Creates a table if it does not exist"
     try:
         _get_table().create_table(table_name)
     except Exception as e:
         logger.error(e)
-    if has_table(table_name):
+    if has_table(table_name) and not silent:
         logger.info(f"Table {table_name} has been created")
         iou.my_output(f"Table {table_name} has been created")
 
 
 def insert_secret(domain, access, uid, pwd, info, mem_pwd, salt=None, timestamp = None):
     """Insert a secret access record in the cloud DB
     input:
```

## tests/__init__.py

```diff
@@ -1,12 +1,21 @@
 import os
 
-from secretwallet.constants import parameters
+from secretwallet.constants import parameters, DB_AWS_DYNAMO, DB_LOCAL_SQLITE
 from secretwallet.main.configuration import get_configuration
 import secretwallet.utils.dbutils as du
 
 
 path = os.path.dirname(__file__)
 conf_file = os.path.join(path,'data','test_integration.json')
 conf_data = get_configuration(conf_file)
 parameters.set_data(conf_data)
+
+#here create all test tables with different storage types and then reset to default
+
+#local storage
+parameters.set_storage_type(DB_LOCAL_SQLITE)
+du.create_table(parameters.get_table_name())
+
+#aws
+parameters.set_storage_type(DB_AWS_DYNAMO)
 du.create_table(parameters.get_table_name())
```

## tests/dbutils_test.py

```diff
@@ -1,130 +1,149 @@
 import cryptography
 import pytest
-from secretwallet.constants import parameters
+from secretwallet.constants import parameters, DB_AWS_DYNAMO,DB_LOCAL_SQLITE
 
 import secretwallet.utils.cryptutils as cu
 import secretwallet.utils.dbutils as du 
+
+storages = [DB_LOCAL_SQLITE,DB_AWS_DYNAMO]
     
 @pytest.fixture
-def insert_records():
+def insert_records(storage):
+    parameters.set_storage_type(storage)
     m_pwd = 'memorable'
     du.insert_secret("d1", "a1", "u1", "p1", {"k1":"v1","k2":"v2"}, m_pwd)
     du.insert_secret("d1", "a2", "u2", "p2", {"k3":"v3"}, m_pwd)
     du.insert_secret("d2", "a3", "u3", "p3", {"k4":"v4"}, m_pwd)
+    
     yield
     
     du.delete_secrets(du.list_secrets("d1"))
     du.delete_secrets(du.list_secrets("d2"))
         
 @pytest.fixture
 def cleanup_backups():
     pass
     yield
     
     du._cleanup_table_backups('backup')
     
-
-def test_insert_delete_login():
+@pytest.mark.parametrize("storage", storages)
+def test_insert_delete_login(storage):
+    parameters.set_storage_type(storage)
     m_pwd = u"memorabile"
     secret_uid = u"me@home"
     secret_pwd = u"ciao mamma"
     domain = u"my_domain" 
     access = u"my_access"
     ns = du.count_secrets()    
     try:        
         du.insert_secret(domain, access, secret_uid, secret_pwd, None, m_pwd, parameters.get_salt_key())
         assert ns+1 == du.count_secrets()
     finally:
         du.delete_secret(domain, access)
         assert ns == du.count_secrets()
-        
-def test_wrong_salt_key():
+
+@pytest.mark.parametrize("storage", storages)        
+def test_wrong_salt_key(storage):
+    parameters.set_storage_type(storage)
     c_pwd = 'pirillo'
     wrong_key = cu.encrypt_key(c_pwd)
     m_pwd = u"memorabile"
     domain = u"my_domain" 
     access = u"my_access"    
     secret_uid = u"me@home"
     secret_pwd = u"ciao mamma"
     try:        
         du.insert_secret(domain, access, secret_uid, secret_pwd, None, m_pwd, wrong_key)
         with pytest.raises(cryptography.fernet.InvalidToken):
             du.get_secret(domain, access, m_pwd)
     finally:
         du.delete_secret(domain, access)
         
-def test_wrong_memorable():
+@pytest.mark.parametrize("storage", storages)        
+def test_wrong_memorable(storage):
+    parameters.set_storage_type(storage)
     m_pwd = u"memorabile"
     domain = u"my_domain" 
     access = u"my_access"    
     secret_uid = u"me@home"
     secret_pwd = u"ciao mamma"
     try:        
         du.insert_secret(domain, access, secret_uid, secret_pwd, None, m_pwd)
         with pytest.raises(cryptography.fernet.InvalidToken):
             du.get_secret(domain, access, 'pirillo')
     finally:
         du.delete_secret(domain, access)                
-        
-def test_insert_select_compare_login():
+
+@pytest.mark.parametrize("storage", storages)        
+def test_insert_select_compare_login(storage):
+    parameters.set_storage_type(storage)
     m_pwd = u"memorabile"
     secret_uid = u"me@home"
     secret_pwd = u"ciao mamma"
     domain = u"my_domain" 
     access = u"my_access"
     try:        
         du.insert_secret(domain, access, secret_uid, secret_pwd, None, m_pwd, parameters.get_salt_key())
         res = du.get_secret(domain, access, m_pwd, parameters.get_salt_key())
         assert secret_uid == res.user_id
         assert secret_pwd == res.password
     finally:
         du.delete_secret(domain, access)
 
-@pytest.mark.integration        
-def test_insert_select_compare_info():
+@pytest.mark.integration
+@pytest.mark.parametrize("storage", storages)        
+def test_insert_select_compare_info(storage):
+    parameters.set_storage_type(storage)
     m_pwd = u"memorabile"
     secret_info = {'message':'secret'}
     domain = u"my_domain" 
     access = u"my_access"
     try:        
         du.insert_secret(domain, access, None, None, secret_info, m_pwd, parameters.get_salt_key())
         res = du.get_secret(domain, access, m_pwd, parameters.get_salt_key())
         assert secret_info['message'] == res.info['message']
     finally:
         du.delete_secret(domain, access)        
 
-@pytest.mark.integration        
-def test_has_secret():
+@pytest.mark.integration
+@pytest.mark.parametrize("storage", storages)        
+def test_has_secret(storage):
+    parameters.set_storage_type(storage)
     m_pwd = u"memorabile"
     secret_uid = u"me@home"
     secret_pwd = u"ciao mamma"
     domain = u"my_domain" 
     access = u"my_access"    
     try:        
         du.insert_secret(domain, access, secret_uid, secret_pwd, None, m_pwd, parameters.get_salt_key())
         assert du.has_secret(domain, access)
     finally:
         du.delete_secret(domain, access)
 
-@pytest.mark.integration        
-def test_has_not_secret():
+@pytest.mark.integration
+@pytest.mark.parametrize("storage", storages)        
+def test_has_not_secret(storage):
+    parameters.set_storage_type(storage)
     m_pwd = u"memorabile"
     secret_uid = u"me@home"
     secret_pwd = u"ciao mamma"
     domain = u"my_domain" 
     access = u"my_access"    
     try:        
         du.insert_secret(domain, access, secret_uid, secret_pwd, None, m_pwd, parameters.get_salt_key())
         assert not du.has_secret('new_domain', access)
     finally:
         du.delete_secret(domain, access)
 
-@pytest.mark.integration        
-def test_update_secret_login():
+@pytest.mark.integration
+@pytest.mark.parametrize("storage", storages)        
+def test_update_secret_login(storage):
+    parameters.set_storage_type(storage)
     m_pwd = u"memorabile"
     secret_uid = u"me@home"
     secret_uid2 = u"me@office"
     secret_pwd = u"ciao mamma"
     domain = u"my_domain" 
     access = u"my_access"    
     try:        
@@ -140,16 +159,18 @@
         res = du.get_secret(domain, access, m_pwd, parameters.get_salt_key())
         assert secret_uid2 == res.user_id
         assert secret_pwd == res.password 
         assert old_ts <  res.timestamp            
     finally:
         du.delete_secret(domain, access)
 
-@pytest.mark.integration        
-def test_update_secret_info_change_value():
+@pytest.mark.integration
+@pytest.mark.parametrize("storage", storages)        
+def test_update_secret_info_change_value(storage):
+    parameters.set_storage_type(storage)
     m_pwd = u"memorabile"
     domain = u"my_domain" 
     access = u"my_access" 
     secret_info = {'message':'secret'}
     info_key = 'message'
     info_val = 'a new secret'   
     try:        
@@ -162,16 +183,18 @@
         
         res = du.get_secret(domain, access, m_pwd, parameters.get_salt_key())
         assert info_val == res.info[info_key] 
         assert old_ts <  res.timestamp            
     finally:
         du.delete_secret(domain, access)
         
-@pytest.mark.integration        
-def test_update_secret_info_insert_value():
+@pytest.mark.integration
+@pytest.mark.parametrize("storage", storages)
+def test_update_secret_info_insert_value(storage):
+    parameters.set_storage_type(storage)
     m_pwd = u"memorabile"
     domain = u"my_domain" 
     access = u"my_access" 
     secret_info = {'message':'secret'}
     info_key = 'a new message'
     info_val = 'a new secret'   
     try:        
@@ -186,16 +209,18 @@
         assert 2 == len(res.info)
         assert info_val == res.info[info_key]
         assert 'secret' == res.info['message'] 
         assert old_ts <  res.timestamp            
     finally:
         du.delete_secret(domain, access)
         
-@pytest.mark.integration        
-def test_update_secret_info_change_password_and_a_value():
+@pytest.mark.integration
+@pytest.mark.parametrize("storage", storages)        
+def test_update_secret_info_change_password_and_a_value(storage):
+    parameters.set_storage_type(storage)
     m_pwd = u"memorabile"
     domain = u"my_domain" 
     access = u"my_access" 
     secret_uid = u"me@home"
     secret_pwd = u"ciao mamma"
     secret_pwd2 = u"another password"    
     secret_info = {'message':'secret'}
@@ -213,16 +238,18 @@
         res = du.get_secret(domain, access, m_pwd, parameters.get_salt_key())
         assert info_val == res.info[info_key] 
         assert secret_pwd2 == res.password
         assert old_ts <  res.timestamp            
     finally:
         du.delete_secret(domain, access)
         
-@pytest.mark.integration        
-def test_update_missing_secret_no_effect():
+@pytest.mark.integration
+@pytest.mark.parametrize("storage", storages)        
+def test_update_missing_secret_no_effect(storage):
+    parameters.set_storage_type(storage)
     m_pwd = u"memorabile"
     domain = u"my_domain" 
     access = u"my_access"
     access2 = u"my_second access" 
     secret_uid = u"me@home"
     secret_pwd = u"ciao mamma"
     secret_pwd2 = u"my second password"    
@@ -241,16 +268,18 @@
         
         assert ns + 1 == du.count_secrets()
         res = du.get_secret(domain, access, m_pwd, parameters.get_salt_key())
         assert old_ts ==  res.timestamp            
     finally:
         du.delete_secret(domain, access)
         
-@pytest.mark.integration        
-def test_update_info_dict_remove_key():
+@pytest.mark.integration
+@pytest.mark.parametrize("storage", storages)        
+def test_update_info_dict_remove_key(storage):
+    parameters.set_storage_type(storage)
     m_pwd = u"memorabile"
     domain = u"my_domain" 
     access = u"my_access" 
     secret_info = {'key1': 'value1',
                    'key2': 'value2'}
     salt = parameters.get_salt_key()
     try:
@@ -271,21 +300,24 @@
         assert 'value1' == info['key1']
         assert ts != old_ts
         
     finally:
         du.delete_secret(domain, access)        
         
         
-@pytest.mark.integration        
-def test_has_table():
+@pytest.mark.integration
+@pytest.mark.parametrize("storage", storages)        
+def test_has_table(storage):
+    parameters.set_storage_type(storage)
     assert True  == du.has_table(parameters.get_table_name())
     assert False == du.has_table('new_table')
     
-    
-def test_delete_secrets():
+@pytest.mark.parametrize("storage", storages)    
+def test_delete_secrets(storage):
+    parameters.set_storage_type(storage)
     m_pwd = u"memorabile"
     domain = u"my_domain"  
     info = {'message':'secret'}
     #cleanup
     du.delete_secrets(du.list_secrets(None))
     cnt = du.count_secrets()
     for i in range(5):
@@ -295,16 +327,17 @@
     # now get the secret back by domain
     secrets = du.list_secrets(domain)
     #delete them in block
     du.delete_secrets(secrets)    
     #check that they are gone
     assert cnt== du.count_secrets()
     
-    
-def test_rename_secret():
+@pytest.mark.parametrize("storage", storages)    
+def test_rename_secret(storage):
+    parameters.set_storage_type(storage)
     m_pwd = u"memorabile"
     domain = u"my_domain"
     access = u"my_access"
     new_domain = u"new_domain"
     new_access = u"new_access"      
     info = {'message':'secret'}
     try:
@@ -320,16 +353,18 @@
         assert not du.has_secret(domain, access)
         assert du.has_secret(new_domain, new_access)
         res = du.get_secret(new_domain, new_access, m_pwd, parameters.get_salt_key())
         assert info['message'] == res.info['message']
     finally:
         du.delete_secret(domain, access)
         du.delete_secret(new_domain, new_access)
-        
-def test_reconf_memorable(insert_records):
+
+@pytest.mark.parametrize("storage", storages)        
+def test_reconf_memorable(storage, insert_records):
+    parameters.set_storage_type(storage)
     old_mem = "memorable"
     new_mem = 'another'
     secrets = du.list_secrets("d1") + du.list_secrets("d2")
     assert 3 == len(secrets)
     sec = du.get_secret('d1', 'a1', old_mem)
     assert "v1" == sec.info['k1']
     
@@ -339,24 +374,28 @@
     secrets = du.list_secrets("I") + du.list_secrets("D")
     assert 0 == len(secrets)
     sec = du.get_secret('d1', 'a1', new_mem)
     assert "v1" == sec.info['k1']
     
     with pytest.raises(cryptography.fernet.InvalidToken):
         du.get_secret('d1', 'a1', old_mem)
-            
-def test_reconf_memorable_with_backup(insert_records, cleanup_backups):
+
+@pytest.mark.parametrize("storage", storages)
+def test_reconf_memorable_with_backup(storage, insert_records, cleanup_backups):
+    parameters.set_storage_type(storage)
     old_mem = "memorable"
     new_mem = 'another'
     secrets = du.list_secrets("d1") + du.list_secrets("d2")
     assert 3 == len(secrets)
     arn = du.reconf_memorable(secrets, old_mem, new_mem, True)
     assert arn is not None
-        
-def test_reconf_salt_key(insert_records):
+
+@pytest.mark.parametrize("storage", storages)
+def test_reconf_salt_key(storage, insert_records):
+    parameters.set_storage_type(storage)
     old_mem = "memorable"
     c_pwd = 'carpiato'
     new_salt_key = cu.encrypt_key(c_pwd)
     secrets = du.list_secrets("d1") + du.list_secrets("d2")
     assert 3 == len(secrets)
     sec = du.get_secret('d1', 'a1', old_mem)
     assert "v1" == sec.info['k1']
@@ -367,16 +406,18 @@
     secrets = du.list_secrets("I") + du.list_secrets("D")
     assert 0 == len(secrets)
     sec = du.get_secret('d1', 'a1', old_mem, new_salt_key)
     assert "v1" == sec.info['k1']
     
     with pytest.raises(cryptography.fernet.InvalidToken):
         du.get_secret('d1', 'a1', old_mem)
-            
-def test_query_records(insert_records):
+
+@pytest.mark.parametrize("storage", storages)            
+def test_query_records(storage, insert_records):
+    parameters.set_storage_type(storage)
     #test with no filter
     ns = du.count_secrets()
     secrets = du.query_secrets_by_field(None, None)
     assert ns == len(secrets)
     
     #test filter on domain with a d   
     secrets = du.query_secrets_by_field("d", None)
@@ -393,16 +434,18 @@
     #test filter on access with a 1 in it
     secrets = du.query_secrets_by_field(None, "1")
     assert 1 == len(secrets)
     
     #test on both
     secrets = du.query_secrets_by_field("1", "2")
     assert 1 == len(secrets)
-    
-def test_get_all_secrets(insert_records):
+
+@pytest.mark.parametrize("storage", storages)    
+def test_get_all_secrets(storage, insert_records):
+    parameters.set_storage_type(storage)
     secrets = du.get_all_secrets('memorable',False) # return as Secret
     assert 3 == len(secrets)
     assert 'd1' == secrets[0].domain
     assert 'a1' == secrets[0].access
     assert 'u1' == secrets[0].user_id
     assert 'p1' == secrets[0].password
     assert 'v1' == secrets[0].info['k1']
```

## tests/session_test.py

```diff
@@ -1,17 +1,26 @@
 from multiprocessing import Process
 from time import sleep
 
 import pytest
 from secretwallet.session.client import get_session_password, set_session_password, stop_service, is_connected, ping_session_server
 from secretwallet.session.service import my_session
 
+import psutil
+
+def kill_all_procs():
+    pname = 'secret_wallet'
+    for proc in psutil.process_iter():
+        if proc.name() == pname:
+            proc.kill()
+
 
 @pytest.fixture
 def set_up():
+    kill_all_procs()
     lifetime = 12
     timeout = 6
     value = 'message'
 
     #kill the listener
     if is_connected():
         stop_service()
```

## Comparing `secret_wallet_codimoc-0.6.2.dist-info/LICENSE` & `secret_wallet_codimoc-0.6.3.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `secret_wallet_codimoc-0.6.2.dist-info/METADATA` & `secret_wallet_codimoc-0.6.3.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: secret-wallet-codimoc
-Version: 0.6.2
+Version: 0.6.3
 Summary: A cloud-based wallet for personal secrets
 Home-page: https://github.com/codimoc/secret-wallet
 Author: codimoc
 Author-email: codimoc@prismoid.uk
 Classifier: Programming Language :: Python :: 3
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Operating System :: OS Independent
@@ -19,15 +19,15 @@
 Requires-Dist: pyreadline
 
 ## Disclaimers
 
 + **Privacy disclaimer**: This application is entirely open-source and non-commercial. It is free to download and use for securing personal information. The user of this application is uniquely responsible for setting up his/her own storage account on Amazon AWS. This application is simply a tool to facilitate the communication between the user's machine and the remote store. Under no circumstances does this application have access to, collect, manage or transfer information owned by the the final user of the application.
 
 
-+ **Liability disclaimer**: This application does its best to provide means of securing data on a remote store, as explained in the documentation below. By reading this document and/or by browsing through the open source [code](https://github.com/codimoc/secret-wallet), the user will decide if this application satisfies his/her needs. By downloading and using this application the end user accepts full responsibility of any damage incurred as a consequence of the use of this application. To the maximum extent permitted by applicable law, the owner and developers of this application shall not be liable for any indirect, incidental, special, consequential or punitive damages, or any loss of profits or revenues, whether incurred directly or indirectly, or any loss of data, goodwill, or other intangible losses, resulting from the use of this application.
++ **Liability disclaimer**: This application does its best to provide means of securing data on a remote store, as explained in the documentation below. By reading this document and/or by browsing through the open source [code](https://github.com/codimoc/secret-wallet), the user will decide if this application satisfies his/her needs. By downloading and using this application the end user accepts full responsibility of any damage incurred as a consequence of the use of this application. To the maximum extent permitted by applicable law, the owner and developers of this application shall not be liable for any indirect, incidental, special, consequential or punitive damages, or any loss of profits or revenues, whether incurred directly or indirectly, or any loss of data, good-will, or other intangible losses, resulting from the use of this application.
 
 ## Warning
 This application was written and designed for Linux and provides somewhat reduced functionalities on Windows systems. The original design was aimed at a command line tool that integrates inside a Linux shell like bash, with some functionalities running in the background. From version 0.4 onwards, a bespoke secret_wallet **shell** has been added, addressing most of the
 limitations on Windows platforms. By Launching the **shell** with the command line  _secret_wallet_shell(.exe)_  the application runs inside its own environment, hence keeping a short memory of the password used in previous and recent queries, within a specified timeout period.
 This facilitates a repeated usage of the application, without the need of retyping the password. Please see a more detailed explanation in the [shell](#shell) section below.
 
 
@@ -46,14 +46,15 @@
 
 Keeping these secrets on an electronic wallet instead, on a PC, a tablet or a phone, is as safe as the device where these secrets are stored on.
 Data can be encrypted on a hard drive, but the disk can fail, the phone can be stolen, the tablet forgotten on a plane.
 
 ## Index
 *  [motivations](#motivations)
 *  [description](#description)
+*  [local storage](#local_storage)
 *  [concepts](#concepts)
 *  [requirements](#requirements)
 *  [installation](#installation)
 *  [first time configuration](#configuration)
 *  [password strength](#passwords)
 *  [syntax](#syntax)
 *  [commands](#commands)
@@ -103,14 +104,20 @@
 Securing the allowed devices with a configuration password provides safety against misuses of the store, once the memorable password is
 compromised by accident. For example, if the memorable password is confided to others or guessed, only pre-configured devices can access
 the secrets.
 
 On the other hand, if a device is lost or stolen, the memorable password is still required to access the secrets. The AWS security layer does not help in this case,
 with the AWS secure credentials helpfully located on the compromised device's file system.
 
+## <a id="local_storage"></a> Using local storage
+Starting from version 0.6.3, this application expands the storage solutions available beyond Amazon AWS. This is intended
+to allow more flexibility for users to chose their favourite storage providers. As of version 0.6.3, a local storage database, based on Sqlite3, is added. Users can chose this solution as their primary storage instead of-, or in parallel to-, AWS DynamoDB (see instruction on [first configuration](#installation) and [later reconfiguration](#customization)).
+
+A local storage solution is mostly suited for users that intend to run the secret wallet on a single device, because running this application in local-storage mode on multiple devices clearly results in synchronisation issues between the secrets stored on different machines. For this reason, future releases will bring a synchronisation functionality between a master remote storage and the local storage. On the other hand, a local storage solution has some appeal in terms of response speed and functionality when the internet is temporarily down or not available. Hence a good solution for all users is possibly a hybrid solution, with a remote master storage and a local storage. As said this will be targeted by future releases, however it can be achieved already from version 0.6.3 by switching storage type as described [here](#customization) and using the **save** and **load** function for synchronisation. 
+
 ## <a id="concepts"></a>Concepts
 The basic unit of information stored on the remote DB is a **secret**.
 Each secret is identified by a pair of two keys, the domain key and the access key:
 *   **domain**: it is the principal context of that secret,  _e.g_  the name of a service provider for which some access credentials are needed.
 *   **access**: it is a sub-context of the  _domain_ ; for example if the main domain is a utility provider providing both a gas and electricity accounts, we might have two secrets with the same domain but different accesses. This separation of domain and access facilitates queries to the DB, since we might want to know all the accesses for a given domain, or all the available domains in the wallet.
 
 Each secret contains three nullable items of data:
@@ -126,15 +133,15 @@
 
 ## <a id="requirements"></a>Dependencies and requirements
 The **secret wallet** uses the AWS cloud to store the secret information; in particular it relies on the *no-SQL* service, known as AWS *DynamoDB*. This is a database with tables that can be defined by the declaration of one or two primary keys. The remaining part of the schema can change and grow based on the data inserted, depending on the format of the records we want to store. The advantage of this storage solution are:
 *   It is a remote storage widely available on the Amazon cloud.
 *   It is easy to use and create new tables,
 *   It is available in the [AWS Free Tier](https://aws.amazon.com/free/?all-free-tier.sort-by=item.additionalFields.SortRank&all-free-tier.sort-order=asc) package that Amazon offers as an entry point into their echo-system.
 
-In order to use the **secret wallet** it is necessary to use an Amazon AWS account,  or create a new one. This can be done quickly and easily from the [AWS Free Tier](https://aws.amazon.com/free/?all-free-tier.sort-by=item.additionalFields.SortRank&all-free-tier.sort-order=asc) page. Once the account has been created, three pieces of information are required for the **secret wallet**:
+In order to use the **secret wallet** it is necessary to use an Amazon AWS account,  or create a new one. This can be done quickly and easily from the [AWS Free Tier](https://aws.amazon.com/free/?all-free-tier.sort-by=item.additionalFields.SortRank&all-free-tier.sort-order=asc) page. Once the account has been created, three pieces of information are required by the **secret wallet**:
 *   the **aws_access_key_id**: to identify the account
 *   the **aws_secret_access_key**: which can be created after logging into the account; this key can be regenerated several times.
 *   the **region**: the physical location of the server, possibly close to the location of usage.
 
 These three records should be noted down when creating the account or copied onto the clipboard or on a file. They will be needed later, when [configuring](#configuration) the **secret wallet**.
 
 It should be noted that the initial AWS keys, produced on creation of the new account, are root credentials for that account. It is safer, once logged into this new AWS account, to generate a different IAM role with limited access, for example a programmatic user, and to use the relative credentials instead. Instruction on how to do this can be found [here](https://aws.amazon.com/iam/).
@@ -150,19 +157,20 @@
 *   **secret_wallet_conf** for the first time configuration as described below
 *   **secret_wallet_shell** to operate the secret wallet directly in shell mode (mostly for Windows users)
 
 ## <a id="configuration"></a>First time configuration
 Configuring the **secret wallet** is required in order to save both the AWS credentials for the Amazon cloud and the device's configuration key, which is the first layer of security to protect your secrets. This configuration also creates the DynamoDB table used to store the secrets.
 
 This *first time configuration* is performed by running the **secret_wallet_conf** script from the command line. This script is interactive, in the old way of *questions and answers*, and provides some default values when possible.
-It is divided into two separate steps, each of which can be skipped. Skipping a step allows to avoid overwriting credentials, if the system was partially configured, and a partial change of configuration is desired.
+It is divided into three separate steps, each of which can be skipped. Skipping a step allows to avoid overwriting credentials, if the system was partially configured, and a partial change of configuration is desired.
 
 These steps are:
 *   Storing the **AWS credentials**: this results in creating or modifying the *credentials* file in the *.aws*  directory, located in the user home directory. This file is typically divided into separate sections. This allows to persist  different connections to different services on the Amazon cloud. The section relevant to the **secret-wallet** is market with the heading [secret-wallet].
-*   Storing the **secret wallet configuration**: this step persists the information in the *secretwallet.json* file in the *.secretwallet* directory, located in the user home directory. This configuration file is used to store the device encryption key, the name of the AWS connection profile and the table name where the secrets are stored. This file is also used to store customization parameters as described in [this section](#customization).
+*   Storing the **secret wallet configuration**: this step persists the information in the **secretwallet.json** file in the *.secretwallet* directory, located in the user home directory. This configuration file is used to store the device encryption key, the name of the AWS connection profile and the table name where the secrets are stored. This file is also used to store customization parameters as described in [this section](#customization).
+* Choosing the **storage type** between **aws_dynamo** and **local_sqlite**. This information is stored in the **secretwallet.json** file together with the other customization settings.
 
 When questions are asked during the configuration, please type the first letter of the answer (e.g. *s* for *skip*) to select that choice. Whenever a default value is suggested, simply hit the *Return* button to confirm that choice.
 
 ## <a id="passwords"></a>Password strength
 Strong passwords are required by this application.
 Whenever a new password is needed, two verification steps are performed:
 *   verify that the password is strong
@@ -212,15 +220,21 @@
 *	**get**: Retrieves the information stored inside a secret, as identified by the domain, access pair. These two fields need to be passed by using the -d and -a options.
 *	**delete**: Deletes an existing secret, as identified by the domain, access pair. These two fields can be passed by using the -d and -a options. If only the domain is given, all secrets for that domain are deleted. When the -ik option is given with a key name, the corresponding entry in the info dictionary is removed, only if both domain and access are given and they identify an existing secret.
 *	**rename**: Renames a secret, as identified by the domain, access pair. A new domain name can be passed with the -nd option and a new access name can be passed with the -na option. Both domain and access can be changed at the same time or on their own.
 *	**list**: List a set of secrets. With no option passed, all secrets are returned. Alternatively it is possible to filter secrets by passing a domain name: all secrets for that domain will be returned.
 *	**query**: Searches for secrets containig a given subtext in either their domain or access names, or both. By using the explicit -d and -a options, it is possible to limit the search to domain names or access names only. Alternatively it is possible to pass a subtext without any specification in front (i.e. without -d or -a) and the search of that pattern will include both domain and access names.
 *	**qget**: Searches for secrets containig a given subtext in their domain or access names. Once a list of secrets
 that match the given pattern is found, the secrets are tagged with a progressive number and the user can select the one to retrieve and display.
-*	**conf**: Configures some parameters for this application. It is possible to list all parameters with the -l option, or to configure the timeout and lifetime (in seconds). The timeout is the amount of time in seconds along which the memorable password is remembered without been re-asked. The lifetime determines the lifetime of the background   process that manages the temporary storage of the memorable password. The value of the lifetime parameter should be bigger than the value of the password timeout.
+*	**conf**: Configures some parameters for this application. It is possible to list all parameters with the -l option,
+ or to configure the timeout and lifetime (in seconds) or the log level.
+ The timeout is the amount of time in seconds along which the memorable password is remembered without been re-asked.
+ The lifetime determines the lifetime of the background process that manages the temporary storage of
+ the memorable password. The value of the lifetime parameter should be bigger than the password timeout.
+ The logging level is one of debug, info, warning, critical, error or fatal. The srorage_type determines the
+ type of storage used: aws_dynamo for remote storage on AWS or local_sqlite for SQLite based local storage.
 *	**reconf**: Reconfigures either the memorable or the device password. All secrets will be re-encryted with the changed password. It is not possible to change both passwords at the same time. Depending on the size of the wallet, this operation might take some time. A backup of the old table is also performed.
 *	**help**: Display the main help.
 *	**version**: Returns the release version number.
 *	**shell**: Works in a separate shell. This is to facilitate usage on a Windows platform, in the absence of backround processes.
 *	**session**: Starts a background session for keeping track of the memorable password for a short while. This is only for testing since this process is started automatically when needed by the secret_wallet. The lifetime parameter sets the lifetime of the session in seconds, the timeout the time in second for which the memorable password is kept, and the value is what has to be remembered.
 *	**client**: Client command to invoke the background session. This is for testing only. The action allows to get the session value, set the value, stop the background session and test if it is running.
 *   **dump**: This command is used to dump a full text representation of the entire secret wallet. This full dump goes directly to the screen terminal or to a chosen file path, if the  _-f_  option is used. Clearly it is up to the user to secure or delete this file, since it contains all the un-encrypted secrets.
@@ -305,14 +319,18 @@
 
         secret_wallet conf -to 30 -lf 120
 
 where the values are in seconds, *i.e.* timeout of 30 seconds and a lifetime of 2 minutes.
 
 It is also possible to change the verbosity of information logged int the  _secretwallet.log_  file located in the  _.secretwallet_  home directory, by passing a logging level with the  _-ll_  option.
 
+Finally this configuration function can be used to change the storage type, for example selecting a local storage by typing:
+
+        secret_wallet conf -st local_sqlite    
+
 ## <a id="reconfiguration"></a>Reconfiguration
 The reconfiguration process allows the re-encryption of all existing secrets when the device password or the memorable password are changed. In this scenario all secrets need to be retrieved, decrypted and re-encrypted with the new key(s). This can be done with the **reconf** command, with optional parameters set to *-d* for a change of device password, and to *-m* for a change of memorable password.
 
 When this action is performed, a backup copy of the table containing the secrets is stored on the cloud. This can be used to restore the state of the table later on, if a roll-back is required.
 
 ## <a id="shell"></a>The Shell and Windows usage
 It is possible to run the  _secret_wallet_  inside its own shell by either calling the shell sub-command or by invoking directly the shell start-up script as below:
@@ -344,18 +362,18 @@
 *   A timed-out memory of the recently used memorable password facilitates repeated queries, without the need of retyping the memorable password. This is particularly aimed at *Windows* users, who don't rely on the bash shell and Linux background daemons and who did not have access to this feature in previous versions. The configuration of this password time-out (the default is 60 seconds) can be done inside the shell. For a two minutes' time-out, for example, the command would be:
 
         conf -to 120
 
 
 
 ## <a id="work"></a>Work in progress
-Coming soon, in the next releases, there will be some feature improvements and fixes, like:
+Work scheduled for up & coming releases:
 
-*   adding new commands to the command line interface, like query capabilities,
-*   adding batch processing of secrets' insertion
+*   extending storage solutions
+*   synchroniaation between local and remote storages 
 *   required bug fixes.
 
 On a longer time scale:
 *   Adding a graphical user interface
 
 ## <a id="help"></a>Help needed
 This simple application has the potential of becoming a useful productivity tool, and will require lot's of work for new features and better user interaction.
```

## Comparing `secret_wallet_codimoc-0.6.2.dist-info/RECORD` & `secret_wallet_codimoc-0.6.3.dist-info/RECORD`

 * *Files 15% similar despite different names*

```diff
@@ -1,37 +1,37 @@
 secretwallet/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-secretwallet/__main__.py,sha256=HffrDPkueYEQormArbPbjQK51iqvGWvs-N7kE92XK70,200
-secretwallet/constants.py,sha256=AggZhc_jNxDyO0qpCyRIlVrwVOMyj9MDNuacf6imsjA,8491
-secretwallet/__pycache__/__init__.cpython-39.pyc,sha256=cnrwcqbEzTQa_eVAVsnLSHRp3-i1F1PwIVSY74PNJtI,160
+secretwallet/__main__.py,sha256=9vHfzZM6FWXWis6q5O3qOn3LH9gDNiEDQ8HeSrTq9EI,224
+secretwallet/constants.py,sha256=KRfj7hWXTu9qK908FYkjraKOM8bmTErjDUOwk4RHMwk,8531
 secretwallet/main/__init__.py,sha256=5LyEMvZRQEIph_hKGwifqaaBP2e9ahx6aiZSpVeAW8s,350
-secretwallet/main/configuration.py,sha256=RdMe4K80H0h3DN0wzl3CCX-0jSqkqLGfxzPCMPZlsTg,8899
-secretwallet/main/myparser.py,sha256=jmbUoVfOp9ZM9NXLS8cUplVxfJvDbEWLdx4uBAF2ohI,34695
+secretwallet/main/configuration.py,sha256=dySIKuWDGIlECnuWN34J9ot9yosEK1DgDMxpmDsn8bs,10001
+secretwallet/main/myparser.py,sha256=Jt73h_tWX1g_ERLlAKhxXTQQJoqhsVP5Q-ra6eMZCK0,35600
 secretwallet/session/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-secretwallet/session/client.py,sha256=tKa8ywXCTc1gG_fakDmdjqspxrQDkZAbwmDSNQWIXzY,2101
-secretwallet/session/service.py,sha256=9aH7CLLfFHx0D7q9-ZLgfv7i2xsDIOPfq-Iy1LwxeFo,3465
+secretwallet/session/client.py,sha256=ln-er2YVcf9I1ROYz42QWz7vf_IrL9RDK5Q7KGRaibw,2131
+secretwallet/session/service.py,sha256=nD4v2mG_6yyhjG9stmBRr7pjG021XTyOnZxarYHtDdI,3495
 secretwallet/storage/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-secretwallet/storage/aws_dynamo.py,sha256=HVcVP6BQZEvK48PPjzlbWuiCutO_OeogaPGYy3rtnm8,12290
-secretwallet/utils/__init__.py,sha256=14-x4YGdArZY5N3GUv-45DSl2gsjWXy-9nfQfsNdl6A,106
+secretwallet/storage/aws_dynamo.py,sha256=lkUCRe0oGuS_MWZiOGKmMUk-Oa8V_fKf9m1vdmLecOY,12326
+secretwallet/storage/local_sqlite.py,sha256=hqnR8JJ_vxczhvppT5IaId46Wc21PbzN1U0Agm9kKoc,10773
+secretwallet/storage/table.py,sha256=nbhsaJ5rOsmv2OTObbSUrPKmsrY_G1bvmWDV36V66X8,2556
+secretwallet/utils/__init__.py,sha256=EjpMAcOa5QLJ3sUZLBmQWvv_j9m4NCsg3T9WD5JoJrc,175
 secretwallet/utils/cryptutils.py,sha256=-OEtJXAL3atJTYCvsNggh77K0pZ1QEtTh3-d2-ppfKg,3677
-secretwallet/utils/dbutils.py,sha256=BX98aMonKxFPnPoliRndVTrR4IKgES8Vi36CcJBRmfE,14331
+secretwallet/utils/dbutils.py,sha256=fEzJtroTCW4pRzTD7jytoxel9FsDxqJuo5Orp3JvcHA,14554
 secretwallet/utils/fileutils.py,sha256=0mds_kCNN0hfFEuF8yXESi51PDbn_4ybHNxbbHyJvqk,136
 secretwallet/utils/ioutils.py,sha256=W2myoLgayB6lXlFKLpWmvvuqiKDT2DqifFylyAm0Ayg,5437
 secretwallet/utils/logging.py,sha256=l9cQGAubH4AiwlVxzgUYUbBpn9ZmNSL3pRB3De4E4Gs,1204
 secretwallet/utils/password_manager.py,sha256=lGtPffWYtyUHjGicR9exZMBgT78sGsNGGVDM9C1TnuU,3911
-secretwallet/utils/__pycache__/__init__.cpython-39.pyc,sha256=xlktBgEpoIA80MrsBGNBagM-RIZkf7ZGtTQbbiWL-xE,166
-secretwallet/utils/__pycache__/cryptutils.cpython-39.pyc,sha256=uccbNxD3lWk5Qjj4c5tMVRSel5Lhl5A_gYC8TJp-xdg,3551
-tests/__init__.py,sha256=RFJo0k-P3zYD0Oam6dYCwc_WicFpc4VUtVLUCK2dL7Q,372
+tests/__init__.py,sha256=Vbxsnxq-NshusNwWtCSxfKSo_im8DOm23JFh7nLk8n0,644
 tests/aws_config_test.py,sha256=HsKwa6-Gx4yIHBaK9rhLby3MYKE0Wq16CDj1axDnkrU,1748
 tests/aws_dynamo_test.py,sha256=9UXZAjcb-lui1Uooy-gABpfPuZATNEYO5kcbSCWsdDk,4761
 tests/cli_test.py,sha256=i7_LPHJRrBbQ4N-LZpXUVqTjdDqDS4QKY3DPwBWYRRk,27504
 tests/cryptuils_test.py,sha256=jOh_R-1ViPwkyepEakExwnDNSjFfio4UQyBu--IRUQo,2973
-tests/dbutils_test.py,sha256=0_rmFeaUs_hnGm0EyOcOfZ_kP3A5SEDvo8ArNVRwVe4,15242
+tests/dbutils_test.py,sha256=z7lRaZ34gjolYtbwzULCZhUVjGcoVszimu4uM3Xaas0,17331
+tests/local_sqlite_test.py,sha256=8CUGYelidyJeF9JqlPXZeUiySHkK6tg5a6jC1Loe3hI,4791
 tests/parameters_test.py,sha256=y3wqJFgClL-oZe4Nre5kK9Qj1dsi5T9ww_huFrh-VTc,1757
 tests/password_test.py,sha256=dJFWvMTTx5wZmq_J5q7eTfGGXRtokORvDHT2R-VjWb0,646
-tests/session_test.py,sha256=hgMVmJOwvEllWQiTQTR9cWNwJqCsVIDUno592zqtHE0,1442
+tests/session_test.py,sha256=_feEkG65UOkURLIvgT6F8sF1-Ylm7HgVEYklW5wmdb0,1625
 tests/data/test_integration.json,sha256=8tngqrS4N9WV3ijpIb8UUja5BjRfo4eP8J0fygvZmw8,127
-secret_wallet_codimoc-0.6.2.dist-info/LICENSE,sha256=IBXSgfX0buUOUc9OoTg1oEBJ6bP7QIIGMzWWuyylciA,1050
-secret_wallet_codimoc-0.6.2.dist-info/METADATA,sha256=xVvZoohvGQqcCmRUg3gvbvOTtCCrrP4CpyWbddvEN5k,29333
-secret_wallet_codimoc-0.6.2.dist-info/WHEEL,sha256=g4nMs7d-Xl9-xC9XovUrsDHGXt-FT0E17Yqo92DEfvY,92
-secret_wallet_codimoc-0.6.2.dist-info/entry_points.txt,sha256=vZgzbpJIjnUYqAIpt_HEaADVcCxpyJBk5gPmDRpN4Ok,152
-secret_wallet_codimoc-0.6.2.dist-info/top_level.txt,sha256=ZQugHfbeohjvYTYj_HnbRHIzcros1wQjm0bksN4cYgY,19
-secret_wallet_codimoc-0.6.2.dist-info/RECORD,,
+secret_wallet_codimoc-0.6.3.dist-info/LICENSE,sha256=IBXSgfX0buUOUc9OoTg1oEBJ6bP7QIIGMzWWuyylciA,1050
+secret_wallet_codimoc-0.6.3.dist-info/METADATA,sha256=zWQ9UNDvJMK-AlPrcQbBzAzc7z81ufN3pu6JL7ez7VA,31313
+secret_wallet_codimoc-0.6.3.dist-info/WHEEL,sha256=g4nMs7d-Xl9-xC9XovUrsDHGXt-FT0E17Yqo92DEfvY,92
+secret_wallet_codimoc-0.6.3.dist-info/entry_points.txt,sha256=vZgzbpJIjnUYqAIpt_HEaADVcCxpyJBk5gPmDRpN4Ok,152
+secret_wallet_codimoc-0.6.3.dist-info/top_level.txt,sha256=ZQugHfbeohjvYTYj_HnbRHIzcros1wQjm0bksN4cYgY,19
+secret_wallet_codimoc-0.6.3.dist-info/RECORD,,
```

