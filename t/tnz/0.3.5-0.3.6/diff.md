# Comparing `tmp/tnz-0.3.5-py3-none-any.whl.zip` & `tmp/tnz-0.3.6-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,21 +1,21 @@
-Zip file size: 129099 bytes, number of entries: 19
--rw-r--r--  2.0 unx      702 b- defN 22-Jul-18 23:43 tnz/__init__.py
--rw-r--r--  2.0 unx     3195 b- defN 22-Jul-18 23:43 tnz/_sigx.py
--rw-r--r--  2.0 unx    59893 b- defN 22-Jul-18 23:43 tnz/_termlib.py
--rw-r--r--  2.0 unx     1654 b- defN 22-Jul-18 23:43 tnz/_util.py
--rw-r--r--  2.0 unx       21 b- defN 22-Jul-18 23:43 tnz/_version.py
--rw-r--r--  2.0 unx   108882 b- defN 22-Jul-18 23:43 tnz/ati.py
--rw-r--r--  2.0 unx    11424 b- defN 22-Jul-18 23:43 tnz/cp310.py
--rw-r--r--  2.0 unx    13186 b- defN 22-Jul-18 23:43 tnz/ditto.py
--rw-r--r--  2.0 unx      538 b- defN 22-Jul-18 23:43 tnz/logging.json
--rw-r--r--  2.0 unx    42197 b- defN 22-Jul-18 23:43 tnz/py3270.py
--rw-r--r--  2.0 unx    10662 b- defN 22-Jul-18 23:43 tnz/rexx.py
--rw-r--r--  2.0 unx   163365 b- defN 22-Jul-18 23:43 tnz/tnz.py
--rw-r--r--  2.0 unx   124926 b- defN 22-Jul-18 23:43 tnz/zti.py
--rw-r--r--  2.0 unx    11357 b- defN 22-Jul-18 23:43 tnz-0.3.5.dist-info/LICENSE
--rw-r--r--  2.0 unx     5470 b- defN 22-Jul-18 23:43 tnz-0.3.5.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 22-Jul-18 23:43 tnz-0.3.5.dist-info/WHEEL
--rw-r--r--  2.0 unx       37 b- defN 22-Jul-18 23:43 tnz-0.3.5.dist-info/entry_points.txt
--rw-r--r--  2.0 unx        4 b- defN 22-Jul-18 23:43 tnz-0.3.5.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     1368 b- defN 22-Jul-18 23:43 tnz-0.3.5.dist-info/RECORD
-19 files, 558973 bytes uncompressed, 126957 bytes compressed:  77.3%
+Zip file size: 128983 bytes, number of entries: 19
+-rw-r--r--  2.0 unx      702 b- defN 23-Jun-01 13:23 tnz/__init__.py
+-rw-r--r--  2.0 unx     3195 b- defN 23-Jun-01 13:23 tnz/_sigx.py
+-rw-r--r--  2.0 unx    59893 b- defN 23-Jun-01 13:23 tnz/_termlib.py
+-rw-r--r--  2.0 unx     1654 b- defN 23-Jun-01 13:23 tnz/_util.py
+-rw-r--r--  2.0 unx       21 b- defN 23-Jun-01 13:24 tnz/_version.py
+-rw-r--r--  2.0 unx   109544 b- defN 23-Jun-01 13:23 tnz/ati.py
+-rw-r--r--  2.0 unx    11424 b- defN 23-Jun-01 13:23 tnz/cp310.py
+-rw-r--r--  2.0 unx    13231 b- defN 23-Jun-01 13:23 tnz/ditto.py
+-rw-r--r--  2.0 unx      538 b- defN 23-Jun-01 13:23 tnz/logging.json
+-rw-r--r--  2.0 unx    42197 b- defN 23-Jun-01 13:23 tnz/py3270.py
+-rw-r--r--  2.0 unx    10662 b- defN 23-Jun-01 13:23 tnz/rexx.py
+-rw-r--r--  2.0 unx   163996 b- defN 23-Jun-01 13:23 tnz/tnz.py
+-rw-r--r--  2.0 unx   120430 b- defN 23-Jun-01 13:23 tnz/zti.py
+-rw-r--r--  2.0 unx    11357 b- defN 23-Jun-01 13:24 tnz-0.3.6.dist-info/LICENSE
+-rw-r--r--  2.0 unx     5495 b- defN 23-Jun-01 13:24 tnz-0.3.6.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jun-01 13:24 tnz-0.3.6.dist-info/WHEEL
+-rw-r--r--  2.0 unx       37 b- defN 23-Jun-01 13:24 tnz-0.3.6.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx        4 b- defN 23-Jun-01 13:24 tnz-0.3.6.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     1368 b- defN 23-Jun-01 13:24 tnz-0.3.6.dist-info/RECORD
+19 files, 555840 bytes uncompressed, 126841 bytes compressed:  77.2%
```

## zipnote {}

```diff
@@ -33,26 +33,26 @@
 
 Filename: tnz/tnz.py
 Comment: 
 
 Filename: tnz/zti.py
 Comment: 
 
-Filename: tnz-0.3.5.dist-info/LICENSE
+Filename: tnz-0.3.6.dist-info/LICENSE
 Comment: 
 
-Filename: tnz-0.3.5.dist-info/METADATA
+Filename: tnz-0.3.6.dist-info/METADATA
 Comment: 
 
-Filename: tnz-0.3.5.dist-info/WHEEL
+Filename: tnz-0.3.6.dist-info/WHEEL
 Comment: 
 
-Filename: tnz-0.3.5.dist-info/entry_points.txt
+Filename: tnz-0.3.6.dist-info/entry_points.txt
 Comment: 
 
-Filename: tnz-0.3.5.dist-info/top_level.txt
+Filename: tnz-0.3.6.dist-info/top_level.txt
 Comment: 
 
-Filename: tnz-0.3.5.dist-info/RECORD
+Filename: tnz-0.3.6.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## tnz/_version.py

```diff
@@ -1 +1 @@
-__version__ = '0.3.5'
+__version__ = '0.3.6'
```

## tnz/ati.py

```diff
@@ -75,24 +75,24 @@
         file, log entries will be appended to the existing file.
         After LOGDEST is set to a file, LOGTRUNC is set to 0.
 
 Environment variables used:
     COLORTERM (see _termlib.py)
     DATEFORM
     ESCDELAY (see zti.py)
-    SESSION_PS_SIZE (see tnz.py)
+    SESSION_PS_SIZE
     TERM_PROGRAM (see _termlib.py)
     TNZ_COLORS (see tnz.py)
     TNZ_LOGGING (see tnz.py)
     ZTI_AUTOSIZE (see zti.py)
     ZTI_SECLEVEL (see tnz.py)
     ZTI_TITLE (see zti.py)
     _BPX_TERMPATH (see _termlib.py)
 
-Copyright 2021 IBM Inc. All Rights Reserved.
+Copyright 2021, 2023 IBM Inc. All Rights Reserved.
 
 SPDX-License-Identifier: Apache-2.0
 """
 import functools
 import inspect
 import logging
 from logging import handlers
@@ -268,15 +268,15 @@
 
         if unam == "AGE":
             return self.age
 
         rval = self.__uv.get(unam, None)
 
         if rval is not None:
-            if rval is _GLOBAL:
+            if rval is Ati.__GLOBAL:
                 return self.__gv.get(unam, None)
 
             return rval
 
         if unam in ("MAXWAIT", "SHOWLINE"):
             raise ValueError(unam+" cannot be accessed")
 
@@ -352,14 +352,19 @@
         self.ses_exc = None
         self.__pgm_number = 1
 
         self.__session_tnz = {}
         self.__inwhen = False
         self.__ranwhen = False
 
+        for name, value in os.environ.items():
+            if name == "SESSION24" or name.startswith("SESSION_"):
+                if name.isupper():
+                    self.__uv[name] = value
+
     # public methods
 
     def drop(self, *args):
         """Delete user-defined variable(s).
 
         Drops one or more user-defined variable(s) or host sessions
         from memory. DROP will cause the value of a variable to be
@@ -411,15 +416,15 @@
                 self.__logresult("%s = %r", unam, session)
 
             elif unam in self.__ikeys:
                 raise ValueError("Internal variables cannot be dropped")
 
             elif unam in self.__uv:
                 value = self.__uv[unam]
-                if value is not _GLOBAL:
+                if value is not Ati.__GLOBAL:
                     del self.__uv[unam]
                 else:
                     self.__gv.pop(unam, None)
 
                 self.__logresult("%s = %r", unam, unam)
 
     def extract(self, *args, wc=None):
@@ -721,14 +726,20 @@
 
         else:  # do not share globals (nor internal variables)
             new_ati = Ati()
             if share_sessions:
                 new_ati.__session_tnz = self.__session_tnz
                 new_ati.__gv["SESSION"] = self.session
 
+        for name, value in self.__uv.items():
+            if name == "SESSION24" or name.startswith("SESSION_"):
+                if name.isupper():
+                    if name not in new_ati.__gv:
+                        new_ati.__uv[name] = value
+
         return new_ati
 
     def numvalue(self, name, trace=None):  # numvalue:
         """Shorthand for num(value(varname))
         """
         return self.num(self.value(name, trace=trace))
 
@@ -753,15 +764,15 @@
             return
 
         session = self.session
         if session == name:
             return  # TODO rc=4
 
         if unam in self.__session_tnz:
-            raise RuntimeError(unam+" already established")
+            raise AtiError(unam+" already established")
 
         tns = self.__session_tnz[session]
         self.__session_tnz[unam] = tns
         self.__gv["SESSION"] = unam
         del self.__session_tnz[session]
 
         self.__logresult("SESSION = %r", unam)
@@ -780,15 +791,15 @@
             print(value)
 
         if str(self.trace).upper() != "NONE":
             logger = self.__gv["logger"]
             logger.critical(value)
 
     def scrcomp(self, value):
-        raise RuntimeError("not implemented")
+        raise AtiError("not implemented")
 
     def scrhas(self, *args, wc=None):
         """Check current screen for a string.
 
         Return True if the specified character string exists on
         the current host screen. Otherwise return False.
 
@@ -1628,15 +1639,15 @@
             valstr = "1"
         elif value is False:
             valstr = "0"
         else:
             valstr = str(value)
 
         if verifycert is not None and unam != "SESSION":
-            raise RuntimeError("Using verifycert requires SESSION")
+            raise AtiError("Using verifycert requires SESSION")
 
         if unam == "SESSION":
             self.__set_session(value,
                                verifycert=verifycert,
                                lognew=False)
             rval = self.rc
             if xtern and trace is not False:
@@ -1689,15 +1700,15 @@
                 self.__logresult("%s = FLASE", unam)
 
         elif unam == "WAITSLEEP":
             self.waitsleep = value
             self.__logresult("%s = %r", unam, str(self.__gv[unam]))
 
         elif unam == "SCRUPDATE":
-            raise RuntimeError('not implemented')
+            raise AtiError('not implemented')
 
         elif unam == "KEYUNLOCK":
             self.keyunlock = value
             self.__logresult("%s = %r", unam, str(self.__gv[unam]))
 
         elif unam == "LOGDEST":
             self.logdest = value
@@ -1716,15 +1727,15 @@
             self.__logresult("%s = %r", unam, str(self.__gv[unam]))
 
         elif unam == "SHOWLINE":
             self.showline = value
             self.__logresult("%s = %r", unam, valstr)
 
         elif unam == "SCRLIBS":
-            raise RuntimeError('not implemented')
+            raise AtiError('not implemented')
 
         elif xtern and unam in ("SESSIONS",
                                 "MAXCOL",
                                 "MAXROW",
                                 "CURCOL",
                                 "CURROW",
                                 "HITCOL",
@@ -1732,27 +1743,27 @@
                                 "HISTRL",
                                 "KEYLOCK",
                                 "TIME",
                                 "DATE",
                                 "DATETIME",
                                 "SENDSTR",
                                 "SESLOST"):
-            raise RuntimeError(unam+" is read-only")
+            raise AtiError(unam+" is read-only")
 
         elif unam == "SESLOST":
             self.__drop_session()
             self.__gv[unam] = value
 
         elif unam in self.__ikeys:
             self.__gv[unam] = value
             self.__logresult("%s = %s", unam, self.__snip(valstr))
 
         elif unam in self.__uv:
             old_value = self.__uv[unam]
-            if old_value is _GLOBAL:
+            if old_value is Ati.__GLOBAL:
                 self.__gv[unam] = valstr
             else:
                 self.__uv[unam] = valstr
 
             self.__logresult("%s = %s", unam, self.__snip(valstr))
 
         else:
@@ -1767,24 +1778,24 @@
         self.__logcode("share%s", args)
         for name in args:
             unam = name.upper()
             if unam in self.__ikeys:
                 continue
 
             value = self.__uv.get(unam)
-            if value is _GLOBAL:
+            if value is Ati.__GLOBAL:
                 continue
 
             if value is not None:
                 if unam in self.__gv:
-                    raise RuntimeError(unam+" already set")
+                    raise AtiError(unam+" already set")
 
                 self.__gv[unam] = value
 
-            self.__uv[unam] = _GLOBAL
+            self.__uv[unam] = Ati.__GLOBAL
 
     def value(self, name, trace=None):
         """returns the contents of the ATI variable
            for the input name
         """
         if trace is not False:
             self.__logcode("value(%r)", name)
@@ -1981,15 +1992,15 @@
                                 rval = self.__zti.onerror()
                                 if rval is None:  # user force ati_rc=1
                                     ati_rc = 1
 
                         self.__shell_mode()
 
                     if raise_it:
-                        raise RuntimeError("WAIT TIMEOUT occurred")
+                        raise AtiError("WAIT TIMEOUT occurred")
 
                 self.set("RC", ati_rc, xtern=False)
                 return ati_rc
 
         self.set("RC", "1", xtern=False)
         return 1
 
@@ -2072,15 +2083,15 @@
                 self.__logcode("when(%s, ON)", func.__name__)
 
             func.active = True
             unam = func.__name__.upper().strip()
             wlist = self.__whens
             if unam not in wlist:
                 wlist.append(unam)
-                if self.__uv.get(unam, None) is _GLOBAL:
+                if self.__uv.get(unam, None) is Ati.__GLOBAL:
                     # TODO global/shared when not fully handled yet
                     self.__gv[unam] = func
                 else:
                     self.__uv[unam] = func
 
             if not self.__inwhen:
                 try:
@@ -2331,15 +2342,15 @@
         """
         self.__log_check()
         logger = self.__gv["logger"]
         logger.debug("in __refresh(%d)", timeout)
 
         in_wait = self.__in_wait
         if in_wait and timeout != 0:
-            raise RuntimeError("Already in wait")
+            raise AtiError("Already in wait")
 
         okeylock = self.__gv["KEYLOCK"]
         if okeylock != "1":
             self.__refresh_vars()
             okeylock = self.__gv["KEYLOCK"]
 
         session = self.session
@@ -2439,15 +2450,15 @@
                     if unam not in donel:
                         break
                 else:
                     break  # did all
 
                 donel.append(unam)
                 func = self.__uv[unam]
-                if func is _GLOBAL:
+                if func is Ati.__GLOBAL:
                     func = self.__gv[unam]
 
                 func()
 
         finally:
             self.__inwhen = False
 
@@ -2475,21 +2486,20 @@
                     ses_exc = None
             else:
                 ses_exc = None
 
             self.ses_exc = ses_exc
             self.set("SESLOST", session, xtern=False, trace=trace)
 
-        lostwarncnt = self.__gv["lostwarncnt"]
+        lostwarncnt = self.__gv["lostwarncnt"] + 1
         maxlostwarn = self.__gv["MAXLOSTWARN"]
 
         if 0 < maxlostwarn <= lostwarncnt:
-            raise RuntimeError("Excessive lost session warnings")
+            raise AtiError("Excessive lost session warnings")
 
-        lostwarncnt += 1
         self.__gv["lostwarncnt"] = lostwarncnt
 
         logger = self.__gv["logger"]
         if ati_rc == 14:
             logger.warning(
                 "WARNING 14: excessive keyboard lock: %s",
                 session)
@@ -2542,15 +2552,15 @@
             zti.rewrite = True
 
         if (unam in self.__session_tnz or
                 (unam == self.session and unam != "NONE")):
             # existing session
 
             if verifycert is not None:
-                raise RuntimeError("Used verifycert with old session")
+                raise AtiError("Used verifycert with old session")
 
             self.__gv["SESSION"] = unam
             self.__refresh()
             if self.__sescheck(trace=False):
                 return
 
             self.rc = 1
@@ -2593,15 +2603,20 @@
 
         self.__session_tnz[unam] = tns
 
         ps_size = self["SESSION_PS_SIZE"]  # __getitem__
         if ps_size:
             self.__logresult("%s = %r", "SESSION_PS_SIZE", ps_size)
             try:
-                asize = _util.session_ps_size(ps_size)
+                if ps_size in ("MAX", "MAX255", "FULL", "FULL255"):
+                    from .zti import Zti
+                    asize = Zti._rows_cols(ps_size)
+                else:
+                    asize = _util.session_ps_size(ps_size)
+
                 tns.amaxrow, tns.amaxcol = asize
             except ValueError:
                 pass
 
         self.__logresult("%s = %r", "HA", tns.amaxrow)
         self.__logresult("%s = %r", "WA", tns.amaxcol)
 
@@ -2634,15 +2649,15 @@
 
     def __shell_mode(self):
         if self.__zti:
             self.__zti.shell_mode()
 
     def __when_priority(self, name):
         whenv = self.__uv[name]
-        if whenv is _GLOBAL:
+        if whenv is Ati.__GLOBAL:
             whenv = self.__gv[name]
 
         return whenv.pri[0]
 
     # static methods
 
     @staticmethod
@@ -3204,15 +3219,15 @@
 
         Not implemented
         """
         return self.__gv["SCRLIBS"]
 
     @scrlibs.setter
     def scrlibs(self, value):
-        raise RuntimeError('not implemented')
+        raise AtiError('not implemented')
 
     @property
     def scrupdate(self):
         """Screen Comparison/Save Control
 
         Not implemented.
         """
@@ -3487,25 +3502,29 @@
         self.__gv["showline"] = value
 
     showline = property(None, __showline, None, __showline.__doc__)
 
     # private class data
 
     __ati_stack = []
+    __GLOBAL = {}  # use as value in __uv to indicate to look in __gv
 
 
 class _AtiConst():
     def __init__(self, name):
         self.name = name
 
     def __repr__(self):
         return self.name
 
 
-_GLOBAL = {}  # use as value in __uv to indicate to look in __gv
+class AtiError(Exception):
+    """General Ati error.
+    """
+
 
 CASI = _AtiConst("CASI")  # use for scrhas
 EOL = _AtiConst("EOL")  # use for extract
 FIRST = _AtiConst("FIRST")  # use for extract,scrhas
 LAST = _AtiConst("LAST")  # use for extract,scrhas
 OFF = _AtiConst("OFF")  # use for when
 ON = _AtiConst("ON")  # use for when
```

## tnz/ditto.py

```diff
@@ -131,18 +131,18 @@
             raise ValueError(f"session {session} unavailable")
 
         for k in props:
             ati.set(k, props[k])
 
         ati_rc = ati.set("SESSION", session)
         if ati_rc == 1:  # reestablished session
-            raise RuntimeError("already connected")
+            raise DittoError("already connected")
 
         if ati_rc != 0:  # new session
-            raise RuntimeError(f"set session error {ati_rc}")
+            raise DittoError(f"set session error {ati_rc}")
 
     def cursor_after(self, session, identifier_string):
         """Use for Ditto @=identifier_string command text.
         """
         # would tab be more useful than curright
         key = _ati.curright * len(identifier_string)
         self.__key_at(session, identifier_string, key)
@@ -190,15 +190,15 @@
             self.send_without_enter(session, text, pos)
 
         else:
             self.set_session(session)
 
         ati_rc = self.__ati.send(_ati.enter)
         if ati_rc != 0:
-            raise RuntimeError(f"send enter error {ati_rc}")
+            raise DittoError(f"send enter error {ati_rc}")
 
     def enter_after(self, session, identifier_string, text):
         """Shorthand for cursor_after followed by enter.
         """
         self.cursor_after(session, identifier_string)
         self.enter(text=text)
 
@@ -263,15 +263,15 @@
         else:
             row = 0  # assume same row
             col = 0 - matching_len - offset - length
 
         rval = ati.extract(length, f_or_l, matching, (row, col))
         ati_rc = _ati.num(ati.rc)
         if ati_rc != 0:
-            raise RuntimeError(f"extract error {ati_rc}")
+            raise DittoError(f"extract error {ati_rc}")
 
         return rval
 
     def log(self):
         """Use for Ditto C=LOG command text.
         """
         self.__ati.set("TRACE", "CAPTURE")
@@ -301,48 +301,48 @@
 
         if pos is None:
             ati_rc = self.__ati.send(text)
         else:
             ati_rc = self.__ati.send(pos, text)
 
         if ati_rc != 0:
-            raise RuntimeError(f"send error {ati_rc}")
+            raise DittoError(f"send error {ati_rc}")
 
     def set_session(self, session):
         ati = self.__ati
         if session != ati.session:
             ati_rc = ati.set("SESSION", session)
             if ati_rc != 1:  # reestablished session
-                raise RuntimeError(f"set session error {ati_rc}")
+                raise DittoError(f"set session error {ati_rc}")
 
     def verify(self, session, text, timeout=None):
         """Use for Ditto verify commands.
         """
         ati = self.__ati
         if session is not None:
             self.set_session(session)
 
         if timeout is None:
             ati_rc = ati.wait(lambda: ati.scrhas(text))
         else:
             ati_rc = ati.wait(timeout, lambda: ati.scrhas(text))
 
         if ati_rc != 1:
-            raise RuntimeError(f"wait error {ati_rc}")
+            raise DittoError(f"wait error {ati_rc}")
 
     def waitfor(self, session):
         """Use for Ditto C=WAITFOR command text.
         """
         ati = self.__ati
         if session is not None:
             self.set_session(session)
 
         ati_rc = ati.wait(self.__active)
         if ati_rc != 1:
-            raise RuntimeError(f"wait error {ati_rc}")
+            raise DittoError(f"wait error {ati_rc}")
 
     # properties
 
     @property
     def VerifyDelay(self):
         return self.__verify_delay
 
@@ -398,16 +398,21 @@
         ati = self.__ati
 
         if session is not None:
             self.set_session(session)
 
         ati_rc = ati.wait(self.__unlocked)  # needed?
         if ati_rc != 1:
-            raise RuntimeError(f"wait error {ati_rc}")
+            raise DittoError(f"wait error {ati_rc}")
 
         if not ati.scrhas(identifier_string):
-            raise RuntimeError("identifier string not found")
+            raise DittoError("identifier string not found")
 
         pos = (ati.numvalue("HITROW"), ati.numvalue("HITCOL"))
         ati_rc = ati.send(pos, key)
         if ati_rc != 0:
-            raise RuntimeError(f"send error {ati_rc}")
+            raise DittoError(f"send error {ati_rc}")
+
+
+class DittoError(Exception):
+    """General Ditto error.
+    """
```

## tnz/tnz.py

```diff
@@ -7,15 +7,15 @@
 
 Environment variables used:
     SESSION_PS_SIZE
     TNZ_COLORS
     TNZ_LOGGING
     ZTI_SECLEVEL
 
-Copyright 2021 IBM Inc. All Rights Reserved.
+Copyright 2021, 2023 IBM Inc. All Rights Reserved.
 
 SPDX-License-Identifier: Apache-2.0
 """
 import asyncio
 import enum
 import json
 import logging
@@ -214,27 +214,27 @@
         self.__proc_eh = 0  # extended highlighting
         self.__proc_cs = 0  # character set
         self.__proc_fg = 0  # foreground color
         self.__proc_bg = 0  # background color
 
         self.codec_info = {}
         self.encoding = "cp037"
-        self.encoding = "cp037", 1
+        self.encoding = "cp037", 0xf1
 
         self.alt = 0  # No support for GE (default)
         if sys.stdout.isatty():
             if str(sys.stdout.encoding).upper().startswith("UTF"):
                 from . import cp310 as _
-                self.encoding = "cp310", 1
+                self.encoding = "cp310", 0xf1
         else:
             import locale
             preferredencoding = locale.getpreferredencoding()
             if preferredencoding.upper().startswith("UTF"):
                 from . import cp310 as _
-                self.encoding = "cp310", 1
+                self.encoding = "cp310", 0xf1
 
         if name:
             self.name = name
         else:
             self.name = str(hash(self))
 
         self.need_shutdown = False
@@ -247,15 +247,15 @@
             pass
 
         if self.colors >= 8 and sys.stdin.isatty():
             # Claim capable of color for zti
             self.capable_color = True
 
         ps_size = os.getenv("SESSION_PS_SIZE", None)
-        if ps_size:
+        if ps_size not in (None, "MAX", "MAX255", "FULL", "FULL255"):
             try:
                 from . import _util
                 asize = _util.session_ps_size(ps_size)
                 self.amaxrow, self.amaxcol = asize
             except ValueError:
                 self.__logger.exception("SESSION_PS_SIZE error")
                 ps_size = None
@@ -682,14 +682,19 @@
                 # do not enter IND$FILE until file is open
                 # (avoids an inconstent state if error opening file)
                 self.__log_debug("entering IND$FILE GET %s", parms)
                 self.enter("IND$FILE GET "+parms)
 
                 while (not self.__ddmmsg and not self.seslost):
                     self.wait(3)  # query reply, command acknowledge
+
+                # error if not 'TRANS03   File transfer complete$'
+                if not f"{self.__ddmmsg}".startswith("TRANS03"):
+                    raise TnzTransferError(self.__ddmmsg)
+
         finally:
             self.__log_debug("clearing __indsfile")
             self.__indsfile = None
 
         self.__log_info("get_file: %s", self.__ddmmsg)
 
         return self.__ddmmsg
@@ -1471,14 +1476,18 @@
 
                 while (not self.__ddmmsg and not self.seslost):
                     self.wait(3)  # query reply, command acknowledge
 
                 if self.__ddmerr:
                     raise TnzTransferError(self.__ddmerr)
 
+                # error if not 'TRANS03   File transfer complete$'
+                if not f"{self.__ddmmsg}".startswith("TRANS03"):
+                    raise TnzTransferError(self.__ddmmsg)
+
         finally:
             self.__log_debug("clearing __indsfile")
             self.__indsfile = None
 
         self.__log_info("put_file: %s", self.__ddmmsg)
 
         return self.__ddmmsg
@@ -3093,15 +3102,15 @@
 
         if zti:
             zti.write_data_prep(self, addr1, 1)
 
         self.plane_dc[addr1] = ge_byte
         self.plane_fa[addr1] = 0
         self.plane_eh[addr1] = self.__proc_eh
-        self.plane_cs[addr1] = 1
+        self.plane_cs[addr1] = 0xf1
         self.plane_fg[addr1] = self.__proc_fg
         self.plane_bg[addr1] = self.__proc_bg
 
         self.bufadd = (addr1+1) % self.buffer_size
 
         if zti:
             # Use force=True to indicate that the data that was
@@ -3166,16 +3175,16 @@
 
     def _process_order_0x1d(self, order, start, stop, zti=None):
         """Process Start Field (SF) order.
 
         Called by process_order.
         """
         order_len = stop - start
-        if order_len < 1:
-            raise TnzError(f"SF requires 1 bytes, got {order_len}")
+        if order_len < 2:
+            raise TnzError(f"SF requires 2 bytes, got {order_len}")
 
         self.__pt_erase = False
         fattr = order[start+1]
         bufadd = self.bufadd
         self.__log_debug(" Start Field Value=x%02x @ %r", fattr, bufadd)
         self.plane_dc[bufadd] = 0
         self.plane_fa[bufadd] = bit6(fattr)
@@ -3305,15 +3314,15 @@
         self.__pt_erase = False
         stop_address = self.address(order[(start+1):(start+3)])
         cs_attr = self.__proc_cs
         getxt = ""
         return_value = start + 4
         data_byte = order[start+3]
         if data_byte == 0x08:  # if GE (Graphic Escape)
-            cs_attr = 1
+            cs_attr = 0xf1
             data_byte = order[return_value]
             getxt = "GE "
             return_value += 1
 
         self.__log_debug(" Repeat to Address %r, %s0x%02x",
                          stop_address, getxt, data_byte)
         self.__check_address(stop_address)
@@ -3651,15 +3660,15 @@
         rcba = self.rcba
         addr0 = saddr
         for addr1 in self.__iterbs_addr(self.plane_cs, saddr, eaddr):
             cii = self.plane_cs[addr0]
             if cii == 0:
                 blst.append(rcba(plane_dc, addr0, addr1))
 
-            elif cii == 1:
+            elif cii == 0xf1:
                 for addr2 in self.__range_addr(addr0, addr1):
                     blst.append(b"\x08")  # GE (Graphic Escape)
                     blst.append(plane_dc[addr2:addr2+1])
             else:
                 raise TnzError(f"cs={cii} not implemented")
 
             addr0 = addr1
@@ -4153,16 +4162,16 @@
             # sfb += b"\x00"  # SH Height of the character slots
             # SUBSN only present if CH2=1
             # sfb += b"\x00"  # SUBSN Starting subsection
             # sfb += b"\x00"  # SUBSN Ending subsection
 
             # CGCSGID made up of 2-byte chararacter set number followed
             # by 2-byte code page number.
-            sfb += (self.cs_01).to_bytes(2, byteorder="big")
-            sfb += (self.cp_01).to_bytes(2, byteorder="big")
+            sfb += (self.cs_F1).to_bytes(2, byteorder="big")
+            sfb += (self.cp_F1).to_bytes(2, byteorder="big")
 
         # End of Character Sets)
         sfb = b"\x81"+sfb  # Query Reply
         sfb = (len(sfb)+2).to_bytes(2, byteorder="big")+sfb
         rec += sfb
 
         # 87 Query Reply (Highlight)
@@ -4279,35 +4288,40 @@
                 sfb = [0x1d, fattr]  # SF (Start Field) fattr
                 if reply_mode:  # Extended Field or Character
                     sfe = [0x29, 0]  # SFE (Start Field Extended) 0
 
                     attr = self.plane_eh[addr]
                     if attr:  # if not default
                         sfe[1] += 1
-                        sfe.append(0x41, attr)
+                        sfe.append(0x41)
+                        sfe.append(attr)
 
                     attr = self.plane_fg[addr]
                     if attr:  # if not default
                         sfe[1] += 1
-                        sfe.append(0x42, attr)
+                        sfe.append(0x42)
+                        sfe.append(attr)
 
                     attr = self.plane_cs[addr]
                     if attr:  # if not default
                         sfe[1] += 1
-                        sfe.append(0x43, attr)
+                        sfe.append(0x43)
+                        sfe.append(attr)
 
                     attr = self.plane_bg[addr]
                     if attr:  # if not default
                         sfe[1] += 1
-                        sfe.append(0x45, attr)
+                        sfe.append(0x45)
+                        sfe.append(attr)
 
                     if sfe[1] != 0x40:  # if not default`
                         if fattr:
                             sfe[1] += 1
-                            sfe.append(0xc0, fattr)
+                            sfe.append(0xc0)
+                            sfe.append(fattr)
 
                         sfb = sfe
 
                 rec += bytes(sfb)
                 addr += 1
             else:
                 break
@@ -4376,16 +4390,16 @@
                 keep_all):
             self.__readlines_maxrow = self.maxrow - 2
             addr = self.__readlines_maxrow * self.maxcol
             if (not self.is_protected(addr) and
                     self.is_protected(addr - 1)):
                 self.__addlines(keep_all)
 
-        elif self.is_unprotected():  # TSO?
-            self.__readlines_maxrow = self.maxrow - 1
+        elif self.is_unprotected():  # TSO
+            self.__readlines_maxrow = self.maxrow
             self.__addlines()
             if self.readlines:
                 line = self.readlines.pop()
                 if line not in ("***", " ***"):
                     self.readlines.append(line)
 
     def __set_attributes(self, addr, b_str, b_idx, zti=None):
@@ -4747,22 +4761,22 @@
         self.codec_info[idx] = codecs.lookup(encoding)
 
         if idx == 0:
             self.__encoding = encoding
             self.cs_00 = 697  # FIXME how do we determine?
             self.cp_00 = code_page
 
-        elif idx == 1:
+        elif idx == 0xf1:
             if code_page == 310:
-                self.alt = 1  # Support GE for char set ID 01
-                self.cs_01 = 963
+                self.alt = 1  # Support GE for char set ID F1
+                self.cs_F1 = 963
             else:
-                self.cs_01 = 697  # FIXME how do we determine?
+                self.cs_F1 = 697  # FIXME how do we determine?
 
-            self.cp_01 = code_page
+            self.cp_F1 = code_page
 
     # Class data
 
     __logger = None  # will be set by __log_check
 
     # Private class data
 
@@ -4812,15 +4826,15 @@
                     b"\x19": "END-OF-RECORD",
                     b"\x1d": "3270-REGIME",
                     b"\x28": "TN3270E",
                     b"\x2e": "START_TLS",
                     }
 
 
-class TnzError(RuntimeError):
+class TnzError(Exception):
     """General Tnz error.
     """
 
 
 class TnzTerminalError(TnzError):
     """May be related to terminal characteristics.
     """
```

## tnz/zti.py

```diff
@@ -17,61 +17,60 @@
 Create a command plugin by creating a "zti.commands" entry
 point through setup.py that takes a single argument of a
 command line string.
 
 Environment variables used:
     COLORTERM (see _termlib.py)
     ESCDELAY
-    SESSION_PS_SIZE (see tnz.py)
+    SESSION_PS_SIZE
     TERM_PROGRAM (see _termlib.py)
     TNZ_COLORS (see tnz.py)
     TNZ_LOGGING (see tnz.py)
     ZTI_AUTOSIZE
     ZTI_SECLEVEL (see tnz.py)
     ZTI_TITLE
     _BPX_TERMPATH (see _termlib.py)
 
-Copyright 2021 IBM Inc. All Rights Reserved.
+Copyright 2021, 2023 IBM Inc. All Rights Reserved.
 
 SPDX-License-Identifier: Apache-2.0
 """
 if __name__ == "__main__":
     # We want to support starting by 'python -m tnz.zti', but that can
     # generally be problematic because the zti module is imported as
     # __main__. Subsequent imports of tnz.zti will import as tnz.zti -
     # treating it as a different module. That causes a __main__.Zti and
     # a tnz.zti.Zti class. Since there is the intention for there to be
     # a single instance of Zti static data, it is undesirable to have
-    # both instance of Zti. Route the the main in tnz.zti (not __main__)
+    # both instance of Zti. Route to the main in tnz.zti (not __main__)
     # to use the one desired instance of the Zti class. Consider
     # eventually dropping support for 'python -m tnz.zti' so that we can
     # avoid this.
     from tnz import zti
     raise SystemExit(zti.main())
 
 import atexit
 import cmd
 import ctypes
 import logging
 import os
 import platform
 import signal
-import socket
 import sys
 import tempfile
 import threading
 import time
 import traceback
 
 from . import _sigx as sigx
 from ._termlib import Term as curses
-from ._util import session_ps_14bit
 from . import ati
 from . import rexx
 from . import tnz
+from . import _util
 from . import __version__
 
 __author__ = "Neil Johnson"
 
 
 class Zti(cmd.Cmd):
     """
@@ -421,248 +420,124 @@
 
         text = tns.scrstr(saddr, eaddr)
         print(repr((saddr, eaddr)), repr(text))
 
     def do_goto(self, arg):
         """Command to go to a session in full-screen.
 
-        This is modelled after the ATI GOTO interactive trace
-        command. GOTO suspends execution and transfers control to the
-        indicated session. If no session is supplied, the active
-        session is used. If the selected session does not exist, a
-        warning is issued. ATI execution resumes upon returning
-        (through use of hot-key, disconnection, logoff, etc.). GOTO
-        ? will show all sessions under the parent ID.
+        GOTO transfers control to the indicated session. If no
+        session is supplied, the active session is used. If no
+        session is supplied and no session exists, the command will
+        be processed as "goto a".
 
-        This is also modelled after the ATI GOTO EXEC that is often
-        used with the ATI Session Manager:
-
-        <TODO need syntax diagram>
-
-        session
-            The name of a session to which control is transferred.
-
-        userid
-            A user ID on the same node as the current node. The
-            session name is simply userid.
-
-        userid AT node
-            Information by which the session name is hashed. The
-            session name is made by concatenating the last five
-            characters of userid, an = sign, and the sixth and
-            seventh characters of node. For example, MICHAELG AT
-            STLVM3 becomes HAELG=3, and RONB AT STLVM1 becomes
-            RONB=1.
-
-        nickname
-            A nickname from a NAMES file on the A-disk where a user
-            ID and node are stored that specify the session to which
-            control is to be transferred.
+        Usage:
+            goto [? | name | sesname hostname[:port]]
 
         ?
             Lists the available current session names.
 
-        DROP
-            Disconnects a session. See DROP command.
-
-        INIT
-            Initiated a session (brings up a new one).
+        name
+            The name of an existing session to which control is
+            transferred. If no existing session exists and
+            SESSION_HOST is set, a new session is established with
+            that host. If SESSION_HOST is NOT set, a new session is
+            established using name as the hostname and the first part
+            of name as the sesname.
 
-        QUIET
-            Suppresses informational messages.
-
-        RENAME
-            Changes the name of the current session to the session
-            name specified. See RENAME command.
+        sesname
+            The name of a session to which control is transferred.
+            Each session has a unique name.
 
-        This is NOT modelled after the ATI GOTO statement.
+        hostname[:port]
+            The hostname (and optional port) to use to establish a
+            new session.
+
+        Note: This is modelled after the ATI GOTO interactive trace
+        command and the ATI GOTO EXEC. It is NOT modelled after the
+        ATI GOTO statement.
         """
         self.__bg_wait_end()
-
-        self.__downcnt = len(self.downloads)
         sessions = ati.ati.sessions
-        session = ati.ati.session
-
-        oldsize = ati.ati["SESSION_PS_SIZE"]
-        newsize = oldsize
-
-        if arg == "" and sessions == "":
-
-            ati.ati.session = "A"
-            session = "A"
-
-        elif arg == "":
-
-            ati.ati.session = session
-
-        elif arg == "?":
 
+        if arg == "?":
             print(sessions)
             return
 
-        elif rexx.words(arg) == 1:
-
-            port = None
-            hostname = arg
-            sesname = arg
-
-            if ":" in arg:
-                parts = arg.split(":", 1)
-                hostname = parts[0]
-                sesname = parts[0]
-                port = parts[1]
-
-            if "." not in hostname:
-                fqdn = socket.getfqdn()
-                fqdn = fqdn.split(".")
-                if len(fqdn) > 1:
-                    hostname += "."+".".join(fqdn[1:])
-
-            if "." in hostname:
-                parts = hostname.split(".", 1)
-                sesname = parts[0]
-
-            if sesname != arg:
-                basename = sesname
-                sesname = sesname.upper()
-                i = 1
-                while " "+sesname+" " in " "+sessions+" ":
-                    sesname = basename+"~"+str(i)
-                    i += 1
-
-            if port is not None:
-                oldport = ati.ati["SESSION_PORT"]
-                if oldport != port:
-                    ati.set("SESSION_PORT", port)
-
-            session_host = ati.ati["SESSION_HOST"]
-            if session_host is None or sesname != arg:
-                ati.set("SESSION_HOST", hostname)
-
-            if not oldsize:
-                if os.environ.get("SESSION_PS_SIZE", "") == "MAX":
-                    (columns, lines) = os.get_terminal_size()
-                    lines -= 4
-                    columns = min(columns - 17, 160)
-                    lines, columns = session_ps_14bit(lines, columns)
-                    newsize = f"{lines}x{columns}"
-                    ati.set("SESSION_PS_SIZE", newsize)
-                elif os.environ.get("SESSION_PS_SIZE", "") == "MAX255":
-                    (columns, lines) = os.get_terminal_size()
-                    lines -= 4
-                    columns = max(columns - 17, 255)
-                    lines, columns = session_ps_14bit(lines, columns)
-                    newsize = f"{lines}x{columns}"
-                    ati.set("SESSION_PS_SIZE", newsize)
-                elif os.environ.get("SESSION_PS_SIZE", "") == "FULL":
-                    (columns, lines) = os.get_terminal_size()
-                    columns = min(columns, 160)  # 160 for ispf
-                    lines, columns = session_ps_14bit(lines, columns)
-                    newsize = f"{lines}x{columns}"
-                    ati.set("SESSION_PS_SIZE", newsize)
-                elif os.environ.get("SESSION_PS_SIZE", "") == "FULL255":
-                    (columns, lines) = os.get_terminal_size()
-                    columns = min(columns, 255)
-                    lines, columns = session_ps_14bit(lines, columns)
-                    newsize = f"{lines}x{columns}"
-                    ati.set("SESSION_PS_SIZE", newsize)
-
-            ati.ati.session = sesname
-            if self.single_session and ati.ati.rc == 0:
-                if ati.ati.session != ati.ati.sessions:
-                    self.single_session = False
-
-            if session_host is None:
-                ati.drop("SESSION_HOST")
-            elif sesname != arg:
-                ati.set("SESSION_HOST", session_host)
+        self.__downcnt = len(self.downloads)
+        new_session = None
 
-            if port is not None:
-                if oldport != port:
-                    if oldport is None:
-                        ati.drop("SESSION_PORT")
-                    else:
-                        ati.set("SESSION_PORT", oldport)
-        else:
+        if not arg and not sessions:
+            new_session = "A"
+            hostname = os.getenv("SESSION_HOST", None)
+            hostname = ati.ati["SESSION_HOST"] or hostname
+
+        elif not arg:
+            ati.ati.session = ati.ati.session
+
+        else:
+            args = arg.split(maxsplit=1)
+            sesname = args[0]
+            if sesname.upper() in sessions.split():
+                ati.ati.session = sesname
+
+            else:
+                new_session = sesname
+                hostname = args[-1]
+                if len(args) == 1:
+                    hostname = os.getenv("SESSION_HOST", None)
+                    hostname = ati.ati["SESSION_HOST"] or hostname
+                    if not hostname:
+                        hostname = sesname
+                        new_session = sesname.split(".", maxsplit=1)[0]
+                        if new_session.upper() in sessions.split():
+                            new_session = None
+                            ati.ati.session = sesname
 
+        if new_session:
             port = None
-            hostname = rexx.subword(arg, 2)
-            sesname = rexx.word(arg, 1)
-
-            if ":" in hostname:
-                parts = hostname.split(":", 1)
-                hostname = parts[0]
-                port = parts[1]
-
-            if "." not in hostname:
-                fqdn = socket.getfqdn()
-                fqdn = fqdn.split(".")
-                if len(fqdn) > 1:
-                    hostname += "."+".".join(fqdn[1:])
-
-            if port is not None:
+            if hostname and ":" in hostname:
+                hostname, port = hostname.split(":", maxsplit=1)
                 oldport = ati.ati["SESSION_PORT"]
                 if oldport != port:
                     ati.set("SESSION_PORT", port)
 
             oldhost = ati.ati["SESSION_HOST"]
-            if oldhost != hostname:
+            if hostname and oldhost != hostname:
                 ati.set("SESSION_HOST", hostname)
 
+            oldsize = ati.ati["SESSION_PS_SIZE"]
+            newsize = oldsize
             if not oldsize:
-                if os.environ.get("SESSION_PS_SIZE", "") == "MAX":
-                    (columns, lines) = os.get_terminal_size()
-                    lines -= 4
-                    columns = min(columns - 17, 160)
-                    lines, columns = session_ps_14bit(lines, columns)
-                    newsize = f"{lines}x{columns}"
-                    ati.set("SESSION_PS_SIZE", newsize)
-                elif os.environ.get("SESSION_PS_SIZE", "") == "MAX255":
-                    (columns, lines) = os.get_terminal_size()
-                    lines -= 4
-                    columns = max(columns - 17, 255)
-                    lines, columns = session_ps_14bit(lines, columns)
-                    newsize = f"{lines}x{columns}"
-                    ati.set("SESSION_PS_SIZE", newsize)
-                elif os.environ.get("SESSION_PS_SIZE", "") == "FULL":
-                    (columns, lines) = os.get_terminal_size()
-                    columns = min(columns, 160)  # 160 for ispf
-                    lines, columns = session_ps_14bit(lines, columns)
-                    newsize = f"{lines}x{columns}"
-                    ati.set("SESSION_PS_SIZE", newsize)
-                elif os.environ.get("SESSION_PS_SIZE", "") == "FULL255":
-                    (columns, lines) = os.get_terminal_size()
-                    columns = min(columns, 255)
-                    lines, columns = session_ps_14bit(lines, columns)
-                    newsize = f"{lines}x{columns}"
+                ps_size = os.getenv("SESSION_PS_SIZE", None)
+                if ps_size:
+                    newsize = ps_size
                     ati.set("SESSION_PS_SIZE", newsize)
 
-            ati.ati.session = sesname
+            ati.ati.session = new_session
             if self.single_session and ati.ati.rc == 0:
                 if ati.ati.session != ati.ati.sessions:
                     self.single_session = False
 
-            if oldhost != hostname:
+            if hostname and oldhost != hostname:
                 if oldhost is None:
                     ati.drop("SESSION_HOST")
                 else:
                     ati.set("SESSION_HOST", oldhost)
 
-            if port is not None:
-                if oldport != port:
-                    if oldport is None:
-                        ati.drop("SESSION_PORT")
-                    else:
-                        ati.set("SESSION_PORT", oldport)
+            if port is not None and oldport != port:
+                if oldport is None:
+                    ati.drop("SESSION_PORT")
+                else:
+                    ati.set("SESSION_PORT", oldport)
 
-        if oldsize != newsize:
-            if oldsize is None:
-                ati.drop("SESSION_PS_SIZE")
-            else:
-                ati.set("SESSION_PS_SIZE", oldsize)
+            if oldsize != newsize:
+                if oldsize is None:
+                    ati.drop("SESSION_PS_SIZE")
+                else:
+                    ati.set("SESSION_PS_SIZE", oldsize)
 
         if ati.ati.seslost:
             self.__session_check()
             return
 
         if len(self.cmdqueue) > 0:  # if more from SOURCE command
             return
@@ -900,15 +775,15 @@
 
         print(f" SESSION_CODE_PAGE={tns.codec_info[0].name}")
         print(f" SESSION_PS_SIZE={tns.amaxrow}x{tns.amaxcol}")
         print(f" SESSION_TN_ENHANCED={tns.tn3270e:d}")
         print(f" SESSION_DEVICE_TYPE={tns.terminal_type}")
 
         if tns.alt:
-            print(" Alternate code page IBM-"+str(tns.cp_01))
+            print(" Alternate code page IBM-"+str(tns.cp_F1))
         else:
             print(" Alternate code page not supported")
 
         print(" socket type: "+repr(tns.getsockettype()))
 
         if tns.extended_color_mode():
             print(" Extended color mode")
@@ -981,29 +856,34 @@
         if not self.__in_wait:
             print("Not in a wait")
             return
 
         self.__wait_rc = -2
         return 0
 
-    def do_source(self, arg):
+    def do_source(self, arg, default_rcfile=False):
         """Execute a file of commands.
-            Usage:
-                source filename
+
+        Usage:
+            source filename
+
+        filename
+            Path to file where each line is executed as a zti command.
         """
         if not arg:
             print(">>> Source file is a required argument")
             return
 
         try:
             with open(os.path.expanduser(arg)) as myfile:
                 self.cmdqueue += myfile.readlines()
 
         except FileNotFoundError:
-            print(">>> Source file "+repr(arg)+" not found.")
+            if not default_rcfile:
+                print(f">>> Source file {arg!r} not found.")
 
     def do_strs(self, arg):
         # Debug strings for current session.
         # This is intentionally not a docstring so that STRS will not
         # appear as a 'documented command'.
 
         self.__bg_wait_end()
@@ -1498,75 +1378,51 @@
         if eaddr < 0:
             self.__dirty_range(saddr, daddr, tns=tns)
         else:
             self.__dirty_range(saddr, eaddr, tns=tns)
 
     # Private methods
 
-    def __bg_wait(self):
+    def __bg_wait(self, ztl):
         """Keep sessions alive
            while at the command prompt.
         """
-        ztl = []
         while True:
-            self.__lock.acquire()
-            run_in_bg = self.__bg
-            if run_in_bg:
-                sessions = ati.ati.sessions.split()
-                if not sessions:
+            with self.__lock:
+                if not ztl:
                     self.__bg = False
-                    run_in_bg = False
-
-            self.__lock.release()
-
-            if not run_in_bg:
-                return
-
-            # TODO FIXME what if all sessions lost?
 
-            # choose a Zti to use for wait
-            # round robin that choice
-            # round robin might only matter
-            # if seslost is not handled properly
-            # which it is not yet
-
-            for session in sessions:
-                tns = ati.ati.get_tnz(session)
-                if tns not in ztl:
-                    break
+                if not self.__bg:
+                    return
 
-                ztn = tns
-                tns = None
+            tns = ztl.pop(0)
+            if not tns.seslost:
+                tns.wait()
 
-            if tns:
+            if not tns.seslost:
                 ztl.append(tns)
-            else:
-                tns = ztn
-                ztl = [ztn]
-
-            tns.wait()
 
     def __bg_wait_start(self):
         """Ensure the background
            thread is running to keep
            sessions alive while at
            the command prompt.
         """
-        self.__lock.acquire()
-        run_in_bg = self.__bg
-        self.__lock.release()
-
-        if run_in_bg:
-            return  # already running
+        with self.__lock:
+            if self.__bg:
+                return  # already running
 
-        if not ati.ati.sessions:
+        sessions = ati.ati.sessions.split()
+        if not sessions:
             return  # no sessions
 
         self.__bg = True
-        self.__thread = threading.Thread(target=self.__bg_wait)
+        ztl = [ati.ati.get_tnz(session) for session in sessions]
+        self.__thread = threading.Thread(target=self.__bg_wait,
+                                         args=(ztl,))
         self.__thread.start()
 
     def __bg_wait_end(self):
         """Ensure the background
            thread that may use
            sessions is NOT running.
            Needed so that command
@@ -2949,20 +2805,14 @@
                                     import webbrowser
                                     webbrowser.open_new_tab(wstr)
                                 else:
                                     tns.set_cursor_position(ypos+1,
                                                             xpos+1)
                                     self.rewrite_cursor = True
 
-                            elif tns.is_pen_detectable(addr):
-                                # right action ?
-                                tns.set_cursor_position(ypos+1, xpos+1)
-                                tns.enter()
-                                self.rewrite_keylock = True
-                                self.rewrite_cursor = True
                             else:
                                 tns.set_cursor_position(ypos+1, xpos+1)
                                 self.rewrite_cursor = True
 
                     elif (not mouserr and
                           mpx > self.__sessel_x and
                           mpy < len(self.__sessel)):
@@ -3749,14 +3599,44 @@
             return "  ".join((str(mtime),
                               self.file.name,
                               self.name,
                               actdone,
                               actcmd,
                               stat))
 
+    # Private static methods
+
+    @staticmethod
+    def _rows_cols(session_ps_size):
+        """rows, cols for SESSION_PS_SIZE value
+        """
+        if session_ps_size == "MAX":
+            columns, lines = os.get_terminal_size()
+            lines -= 4
+            columns = min(columns - 17, 160)
+            return _util.session_ps_14bit(lines, columns)
+
+        if session_ps_size == "MAX255":
+            columns, lines = os.get_terminal_size()
+            lines -= 4
+            columns = max(columns - 17, 255)
+            return _util.session_ps_14bit(lines, columns)
+
+        if session_ps_size == "FULL":
+            columns, lines = os.get_terminal_size()
+            columns = min(columns, 160)  # 160 for ispf
+            return _util.session_ps_14bit(lines, columns)
+
+        if session_ps_size == "FULL255":
+            columns, lines = os.get_terminal_size()
+            columns = min(columns, 255)
+            return _util.session_ps_14bit(lines, columns)
+
+        return _util.session_ps_size(session_ps_size)
+
     # Internal data and other attributes
 
     _zti = None
     _stdscr = None
 
 
 class _ZtiAbort(BaseException):
@@ -3807,37 +3687,38 @@
                         help="Do not set LOGDEST to zti.log")
     rcgroup = parser.add_mutually_exclusive_group()
     rcgroup.add_argument("--noztirc",
                          action="store_true",
                          help="Do not SOURCE .ztirc in home directory")
     rcgroup.add_argument("--rcfile",
                          metavar="rcfile",
-                         default="~/.ztirc",
                          help="Filename to run using SOURCE")
     parser.add_argument("host", nargs="?",
                         help="hostname[:port] to connect/go to")
     args = parser.parse_args()
 
     if not args.nolog:
         ati.ati.logdest = "zti.log"
 
     zti = Zti()
     ati.ati.maxlostwarn = 0
 
     if not args.noztirc:
+        default_rcfile = args.rcfile is None
+        rcfile = "~/.ztirc" if default_rcfile else args.rcfile
         try:
-            zti.do_source(args.rcfile)
+            zti.do_source(rcfile, default_rcfile=default_rcfile)
         except Exception:
             pass
 
     if args.host:
         zti.cmdqueue.append(" ".join(("goto", args.host)))
         zti.single_session = True
 
-    if args.rcfile != "~/.ztirc":
+    if args.rcfile is not None and ati.ati.session == ati.ati.sessions:
         zti.single_session = True
 
     intro = """
 Welcome to the Z terminal interface!
 Enter the GOTO hostname command to get started and
 use the Esc key to get back to this command prompt.
 Use the HELP and HELP KEYS commands for more information.
```

## Comparing `tnz-0.3.5.dist-info/LICENSE` & `tnz-0.3.6.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `tnz-0.3.5.dist-info/METADATA` & `tnz-0.3.6.dist-info/METADATA`

 * *Files 14% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: tnz
-Version: 0.3.5
+Version: 0.3.6
 Summary: Telnet-3270 to Z tool and library
 Home-page: https://github.com/IBM/tnz
 Author: Neil Johnson
 Author-email: najohnsn@us.ibm.com
 License: Apache-2.0
 Project-URL: Bug Reports, https://github.com/IBM/tnz/issues
 Project-URL: Source, https://github.com/IBM/tnz
@@ -20,14 +20,17 @@
 )](https://github.com/IBM/tnz/actions/workflows/pipeline.yml)
 [![PyPi Status](
 https://img.shields.io/pypi/v/tnz.svg
 )](https://pypi.org/project/tnz)
 [![PyPi Downloads](
 https://img.shields.io/pypi/dm/tnz
 )](https://pypi.org/project/tnz)
+[![OpenSSF Best Practices](
+https://bestpractices.coreinfrastructure.org/projects/6762/badge
+)](https://bestpractices.coreinfrastructure.org/projects/6762)
 
 # tnz
 
 Use a standard terminal emulator as a 3270 terminal interface. Write
 scripts to automate 3270 terminal interaction. This is both a 3270
 terminal emulator and a Python libary. The zti module provides a 3270
 user interface through a Windows Command Prompt or a unix/ascii
@@ -45,52 +48,58 @@
 
 Python 3.6 or later is required.
 Although not required, on platforms other than z/OS, it is suggested
 you also install the [ebcdic](https://pypi.org/project/ebcdic)
 package from PyPI.
 Use pip to install the latest tnz:
 ```console
-pip install ebcdic tnz
+pip3 install ebcdic tnz
 ```
 
 ## Usage
 ### Automation
-See [examples](https://github.com/IBM/tnz/blob/main/examples/) to get started writing a script to automate
-3270 interaction.
+See [examples](examples/) to get started writing a script to automate 3270 interaction.
 
 ### Emulator
 Run the installed zti (Z Terminal Interface) script to start the
 emulator:
 ```console
 zti
 ```
 
 If your path is not set up for running the installed zti console script,
 you can run zti with `python -m tnz.zti` instead.
 
 Starting `zti` takes you into the zti command line interface shell.
 Key tab for command completion, up/down for command history.
-![screenshot](https://github.com/IBM/tnz/blob/main/png/zti-prompt1.png?raw=true "shell")
+![screenshot](docs/png/zti-prompt1.png "shell")
 
 The `goto` command takes you to a full screen 3270 interface. When
 space is available in the terminal screen/window, a status line is
 provided as well as a session selector.
-![screenshot](https://github.com/IBM/tnz/blob/main/png/zti-host1.png?raw=true "3270 full screen")
+
+The basic syntax of `goto` is: 
+
+```
+goto fully-qualified-host-name[:port]
+```
+
+![screenshot](docs/png/zti-host1.png "3270 full screen")
 
 In Windows, the Lucida Console font works well with graphic character
 APL symbols exploited by ISPF.
-![screenshot](https://github.com/IBM/tnz/blob/main/png/zti-host2.png?raw=true "Screenshot with APL symbols")
+![screenshot](docs/png/zti-host2.png "Screenshot with APL symbols")
 
 Large and arbitrarily-sized screens are supported.
-![screenshot](https://github.com/IBM/tnz/blob/main/png/zti-host3.png?raw=true "Screenshot with large size")
+![screenshot](docs/png/zti-host3.png "Screenshot with large size")
 
 Standard unix/ascii terminals are supported. In the screenshot below,
 PuTTY is used as the terminal emulator. The connection was made from
 PuTTY to z/OS via ssh and zti is running on z/OS.
-![screenshot](https://github.com/IBM/tnz/blob/main/png/zti-host4.png?raw=true "Screenshot using PuTTY")
+![screenshot](docs/png/zti-host4.png "Screenshot using PuTTY")
 
 The code in this repository aims to be portable. To achieve this, the
 number of dependencies is kept to a minimum. The only hard
 requirement across platforms is Python and the Python Standard
 Library. Though it is likely you will also want additional ebcdic
 code pages in order to use your code page of choice (i.e. the ebcdic
 package).
@@ -129,16 +138,19 @@
 Control-menu->Properties will take you to properties for the
 terminal. The character size and font can be set. I recommend
 **Lucida Console** - it is readable and the graphic symbols are
 fairly good at connecting like they are supposed to.
 
 
 ## Documentation
-See docstrings in source code.
+
+See [here](https://ibm.github.io/tnz/).
+
+For additional details, see docstrings in source code.
 
 ## Contributing
-See [CONTRIBUTING.md](https://github.com/IBM/tnz/blob/main/CONTRIBUTING.md).
+See [CONTRIBUTING.md](CONTRIBUTING.md).
 
 ## Acknowledgments
 Hats off to the team responsible for the IBM internal Automated Task
 Interpreter (ATI) tool:
 Richard Lynch, Karen Eickemeyer, and Ronald Barber.
```

## Comparing `tnz-0.3.5.dist-info/RECORD` & `tnz-0.3.6.dist-info/RECORD`

 * *Files 21% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 tnz/__init__.py,sha256=V6nyGwagu1MAj-K50FzUJWjZ8yPYr5m8lYRBdUsWPbI,702
 tnz/_sigx.py,sha256=0_5E-WdcTgpiizAgl5mT32wBk9_WzPdBdhvJb-Ox1no,3195
 tnz/_termlib.py,sha256=jEV3TRezaqtuc8yDwAu6ORvRvsWSbAuzUCjDBsD5Omo,59893
 tnz/_util.py,sha256=ZSr-pdMKlJL5nrc2J9oUbxZnVK6rLUsu1ngqwyvtSkw,1654
-tnz/_version.py,sha256=e9arv8KorBrIZFQXAlN4DOQTh91btae1iR36M_3Wafk,21
-tnz/ati.py,sha256=jNZY_dB2KsDdxRGETu300duMqGhq-NmevWOtT1jEEy4,108882
+tnz/_version.py,sha256=IbpUPwvtjLOqowcOFsWQ6LKq-FH6cI19IpvfQlxufq0,21
+tnz/ati.py,sha256=VWjUdj2hkMwKX8xdGTT8dYeGoC4tTPr-kS7wZnCQTsg,109544
 tnz/cp310.py,sha256=IErPOswiOWSHtstFCHSvP0HnP1n8vcsWqG-mLE-HykI,11424
-tnz/ditto.py,sha256=1waYpNlyJPfabbGWF5W2xoYk7o8W8aAGhKKJZFr9NHQ,13186
+tnz/ditto.py,sha256=nqbqL1SXXmASbvMSdb2NPwlbdjTzRwOXEZEqNRJ0d8I,13231
 tnz/logging.json,sha256=_TPcI0ool74lTSXXhzyprd-YU5b8ESuURrPbms7gLVQ,538
 tnz/py3270.py,sha256=RcS3vJTserEFGkv0-g-Yd6OfAzGrZqdcgIUj6d7CqQ4,42197
 tnz/rexx.py,sha256=e7Qv-GTvBujlHKz0MFZ9SG9RM7pX_FNWJL7QvvIc-4M,10662
-tnz/tnz.py,sha256=CfeX4g39nsfkhtdPGHe_J_RFnDDXpHZ7-J17-1XVThw,163365
-tnz/zti.py,sha256=NK0Pbj2rSrfVzjjkOKYT82wS4qsvM-iOAkjQh2b8HSo,124926
-tnz-0.3.5.dist-info/LICENSE,sha256=xx0jnfkXJvxRnG63LTGOxlggYnIysveWIZ6H3PNdCrQ,11357
-tnz-0.3.5.dist-info/METADATA,sha256=6BSSgTe2VSC5tdRgPS55FZOwEy5CEpD5GTaX_vidtBc,5470
-tnz-0.3.5.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
-tnz-0.3.5.dist-info/entry_points.txt,sha256=iC3voc0DyMIYrHEOplhOmMmTdv9VQlCDK1rAB5Hn5fg,37
-tnz-0.3.5.dist-info/top_level.txt,sha256=_flJAXmHbd1vXI70kJF70nfbXcFUWSpAB5SLAiAEEOk,4
-tnz-0.3.5.dist-info/RECORD,,
+tnz/tnz.py,sha256=a2DW_X4KVv5qKG2EliXhVthFxpCjiJ6tz2smrfozzL0,163996
+tnz/zti.py,sha256=eXkMvJ7R8ad-kBC2brnUG3-q4r8jCYk0ucsgxQyX3aY,120430
+tnz-0.3.6.dist-info/LICENSE,sha256=xx0jnfkXJvxRnG63LTGOxlggYnIysveWIZ6H3PNdCrQ,11357
+tnz-0.3.6.dist-info/METADATA,sha256=5ZThEqFLP2I_nZ65-VToASaxLj86xhR2Aak69JddxIw,5495
+tnz-0.3.6.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+tnz-0.3.6.dist-info/entry_points.txt,sha256=iC3voc0DyMIYrHEOplhOmMmTdv9VQlCDK1rAB5Hn5fg,37
+tnz-0.3.6.dist-info/top_level.txt,sha256=_flJAXmHbd1vXI70kJF70nfbXcFUWSpAB5SLAiAEEOk,4
+tnz-0.3.6.dist-info/RECORD,,
```

