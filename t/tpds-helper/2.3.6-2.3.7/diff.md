# Comparing `tmp/tpds_helper-2.3.6-py3-none-any.whl.zip` & `tmp/tpds_helper-2.3.7-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,103 +1,106 @@
-Zip file size: 335714 bytes, number of entries: 101
--rw-r--r--  2.0 unx       65 b- defN 23-Apr-13 17:00 tpds/__init__.py
--rw-r--r--  2.0 unx      308 b- defN 23-Apr-13 17:00 tpds/certs/__init__.py
--rw-r--r--  2.0 unx       67 b- defN 23-Apr-13 17:00 tpds/certs/cert.py
--rw-r--r--  2.0 unx     1640 b- defN 23-Apr-13 17:00 tpds/certs/cert_utils.py
--rw-r--r--  2.0 unx     3434 b- defN 23-Apr-13 17:00 tpds/certs/certs_backup.py
--rw-r--r--  2.0 unx    22405 b- defN 23-Apr-13 17:00 tpds/certs/create_cert_defs.py
--rw-r--r--  2.0 unx      131 b- defN 23-Apr-13 17:00 tpds/certs/ext_builder.py
--rw-r--r--  2.0 unx       81 b- defN 23-Apr-13 17:00 tpds/certs/sign_csr.py
--rw-r--r--  2.0 unx     1643 b- defN 23-Apr-13 17:01 tpds/certs/sign_csr.zip
--rw-r--r--  2.0 unx    15887 b- defN 23-Apr-13 17:00 tpds/certs/tflex_certs.py
--rw-r--r--  2.0 unx      109 b- defN 23-Apr-13 17:00 tpds/certs/timefix_backend.py
--rw-r--r--  2.0 unx    23117 b- defN 23-Apr-13 17:00 tpds/certs/wpc_cert_def.py
--rw-r--r--  2.0 unx     7238 b- defN 23-Apr-13 17:00 tpds/certs/x509_find_elements.py
--rw-r--r--  2.0 unx     1312 b- defN 23-Apr-13 17:00 tpds/certs/sign_csr/readme.md
--rw-r--r--  2.0 unx       22 b- defN 23-Apr-13 17:00 tpds/certs/sign_csr/requirements.txt
--rw-r--r--  2.0 unx     1266 b- defN 23-Apr-13 17:00 tpds/certs/sign_csr/sign_csr.py
--rw-r--r--  2.0 unx      271 b- defN 23-Apr-13 17:00 tpds/cloud_connect/__init__.py
--rw-r--r--  2.0 unx    21672 b- defN 23-Apr-13 17:00 tpds/cloud_connect/aws_connect.py
--rw-r--r--  2.0 unx    15839 b- defN 23-Apr-13 17:00 tpds/cloud_connect/azureRTOS_connect.py
--rw-r--r--  2.0 unx    20014 b- defN 23-Apr-13 17:00 tpds/cloud_connect/azure_connect.py
--rw-r--r--  2.0 unx     1364 b- defN 23-Apr-13 17:00 tpds/cloud_connect/cloud_connect.py
--rw-r--r--  2.0 unx     9654 b- defN 23-Apr-13 17:00 tpds/cloud_connect/gcp_connect.py
--rw-r--r--  2.0 unx      182 b- defN 23-Apr-13 17:00 tpds/flash_program/__init__.py
--rw-r--r--  2.0 unx     7827 b- defN 23-Apr-13 17:00 tpds/flash_program/flash_program.py
--rw-r--r--  2.0 unx     6246 b- defN 23-Apr-13 17:00 tpds/flash_program/kit_connect.py
--rw-r--r--  2.0 unx      139 b- defN 23-Apr-13 17:00 tpds/manifest/__init__.py
--rw-r--r--  2.0 unx    17832 b- defN 23-Apr-13 17:00 tpds/manifest/manifest.py
--rw-r--r--  2.0 unx     4131 b- defN 23-Apr-13 17:00 tpds/manifest/tflx_manifest.py
--rw-r--r--  2.0 unx     3694 b- defN 23-Apr-13 17:00 tpds/manifest/tng_manifest.py
--rw-r--r--  2.0 unx      101 b- defN 23-Apr-13 17:00 tpds/output_grabber/__init__.py
--rw-r--r--  2.0 unx     2927 b- defN 23-Apr-13 17:00 tpds/output_grabber/library_output_grabber.py
--rw-r--r--  2.0 unx      252 b- defN 23-Apr-13 17:00 tpds/proto_provision/__init__.py
--rw-r--r--  2.0 unx     4344 b- defN 23-Apr-13 17:00 tpds/proto_provision/ecc204_provision.py
--rw-r--r--  2.0 unx     2544 b- defN 23-Apr-13 17:00 tpds/proto_provision/ecc_provision.py
--rw-r--r--  2.0 unx     1660 b- defN 23-Apr-13 17:00 tpds/proto_provision/proto_provision.py
--rw-r--r--  2.0 unx     1420 b- defN 23-Apr-13 17:00 tpds/proto_provision/ta010_provision.py
--rw-r--r--  2.0 unx    10387 b- defN 23-Apr-13 17:00 tpds/proto_provision/ta100_provision.py
--rw-r--r--  2.0 unx    17044 b- defN 23-Apr-13 17:00 tpds/proto_provision/tflxtls_provision.py
--rw-r--r--  2.0 unx    17370 b- defN 23-Apr-13 17:00 tpds/proto_provision/tflxwpc_provision.py
--rw-r--r--  2.0 unx      140 b- defN 23-Apr-13 17:00 tpds/pubkey_validation/__init__.py
--rw-r--r--  2.0 unx     8318 b- defN 23-Apr-13 17:00 tpds/pubkey_validation/device_pubkey_validation.py
--rw-r--r--  2.0 unx     6594 b- defN 23-Apr-13 17:00 tpds/pubkey_validation/pubkey_validation.py
--rw-r--r--  2.0 unx      181 b- defN 23-Apr-13 17:00 tpds/resource_generation/__init__.py
--rw-r--r--  2.0 unx     6477 b- defN 23-Apr-13 17:00 tpds/resource_generation/resource_generation.py
--rw-r--r--  2.0 unx    21893 b- defN 23-Apr-13 17:00 tpds/resource_generation/tflx_resource_generation.py
--rw-r--r--  2.0 unx     5235 b- defN 23-Apr-13 17:00 tpds/resource_generation/tng_manifest_generation.py
--rw-r--r--  2.0 unx      252 b- defN 23-Apr-13 17:00 tpds/secure_element/__init__.py
--rw-r--r--  2.0 unx     6062 b- defN 23-Apr-13 17:00 tpds/secure_element/ca_element.py
--rw-r--r--  2.0 unx     1865 b- defN 23-Apr-13 17:00 tpds/secure_element/constants.py
--rw-r--r--  2.0 unx     5558 b- defN 23-Apr-13 17:00 tpds/secure_element/ecc204.py
--rw-r--r--  2.0 unx     5699 b- defN 23-Apr-13 17:00 tpds/secure_element/ecc608a.py
--rw-r--r--  2.0 unx     3691 b- defN 23-Apr-13 17:00 tpds/secure_element/sha204a.py
--rw-r--r--  2.0 unx     2343 b- defN 23-Apr-13 17:00 tpds/secure_element/sha206a.py
--rw-r--r--  2.0 unx     1808 b- defN 23-Apr-13 17:00 tpds/secure_element/ta010.py
--rw-r--r--  2.0 unx     7316 b- defN 23-Apr-13 17:00 tpds/secure_element/ta_element.py
--rw-r--r--  2.0 unx      351 b- defN 23-Apr-13 17:00 tpds/ta_attribute_parser/__init__.py
--rw-r--r--  2.0 unx     2799 b- defN 23-Apr-13 17:00 tpds/ta_attribute_parser/attr_common.py
--rw-r--r--  2.0 unx      591 b- defN 23-Apr-13 17:00 tpds/ta_attribute_parser/attr_crl_property.py
--rw-r--r--  2.0 unx      788 b- defN 23-Apr-13 17:00 tpds/ta_attribute_parser/attr_data_property.py
--rw-r--r--  2.0 unx     1639 b- defN 23-Apr-13 17:00 tpds/ta_attribute_parser/attr_extractedcert_property.py
--rw-r--r--  2.0 unx      827 b- defN 23-Apr-13 17:00 tpds/ta_attribute_parser/attr_fca_property.py
--rw-r--r--  2.0 unx     1605 b- defN 23-Apr-13 17:00 tpds/ta_attribute_parser/attr_privkey_property.py
--rw-r--r--  2.0 unx     1752 b- defN 23-Apr-13 17:00 tpds/ta_attribute_parser/attr_pubkey_property.py
--rw-r--r--  2.0 unx     2485 b- defN 23-Apr-13 17:00 tpds/ta_attribute_parser/attr_symkey_property.py
--rw-r--r--  2.0 unx     3730 b- defN 23-Apr-13 17:00 tpds/ta_attribute_parser/attributes.py
--rw-r--r--  2.0 unx      213 b- defN 23-Apr-13 17:00 tpds/tp_utils/__init__.py
--rw-r--r--  2.0 unx     1730 b- defN 23-Apr-13 17:00 tpds/tp_utils/tp_client.py
--rw-r--r--  2.0 unx     4670 b- defN 23-Apr-13 17:00 tpds/tp_utils/tp_input_dialog.py
--rw-r--r--  2.0 unx    13581 b- defN 23-Apr-13 17:00 tpds/tp_utils/tp_keys.py
--rw-r--r--  2.0 unx     2099 b- defN 23-Apr-13 17:00 tpds/tp_utils/tp_print.py
--rw-r--r--  2.0 unx     4340 b- defN 23-Apr-13 17:00 tpds/tp_utils/tp_settings.py
--rw-r--r--  2.0 unx     6954 b- defN 23-Apr-13 17:00 tpds/tp_utils/tp_utils.py
--rw-r--r--  2.0 unx      216 b- defN 23-Apr-13 17:00 tpds/usecase_diagram/__init__.py
--rw-r--r--  2.0 unx    22932 b- defN 23-Apr-13 17:00 tpds/usecase_diagram/canvas.py
--rw-r--r--  2.0 unx      852 b- defN 23-Apr-13 17:00 tpds/usecase_diagram/click_icon.png
--rw-r--r--  2.0 unx   141278 b- defN 23-Apr-13 17:00 tpds/usecase_diagram/done_icon.png
--rw-r--r--  2.0 unx     8557 b- defN 23-Apr-13 17:00 tpds/usecase_diagram/menu_icons.py
--rw-r--r--  2.0 unx    21422 b- defN 23-Apr-13 17:00 tpds/usecase_diagram/mplab.png
--rw-r--r--  2.0 unx     6972 b- defN 23-Apr-13 17:00 tpds/usecase_diagram/popup.py
--rw-r--r--  2.0 unx     6420 b- defN 23-Apr-13 17:00 tpds/usecase_diagram/proto_boards.py
--rw-r--r--  2.0 unx     1154 b- defN 23-Apr-13 17:00 tpds/usecase_diagram/select.png
--rw-r--r--  2.0 unx     2948 b- defN 23-Apr-13 17:00 tpds/usecase_diagram/terminal.py
--rw-r--r--  2.0 unx     6096 b- defN 23-Apr-13 17:00 tpds/usecase_diagram/usecase_diagram.py
--rw-r--r--  2.0 unx    10469 b- defN 23-Apr-13 17:00 tpds/xml_handler/ECC608A-MAH-TFLXWPC.xml
--rw-r--r--  2.0 unx    15669 b- defN 23-Apr-13 17:00 tpds/xml_handler/ECC608B_TFLXTLS.xml
--rw-r--r--  2.0 unx    14735 b- defN 23-Apr-13 17:00 tpds/xml_handler/PIC32CMLS60_ECC608.xml
--rw-r--r--  2.0 unx      245 b- defN 23-Apr-13 17:00 tpds/xml_handler/__init__.py
--rw-r--r--  2.0 unx     1363 b- defN 23-Apr-13 17:00 tpds/xml_handler/caencryption.py
--rw-r--r--  2.0 unx     6403 b- defN 23-Apr-13 17:00 tpds/xml_handler/ciphers.py
--rw-r--r--  2.0 unx     8583 b- defN 23-Apr-13 17:00 tpds/xml_handler/ecc_xml_encryption.py
--rw-r--r--  2.0 unx    15650 b- defN 23-Apr-13 17:00 tpds/xml_handler/tflxtls_xml_updates.py
--rw-r--r--  2.0 unx    18226 b- defN 23-Apr-13 17:00 tpds/xml_handler/tflxwpc_xml_updates.py
--rw-r--r--  2.0 unx     2558 b- defN 23-Apr-13 17:00 tpds/xml_handler/xml_processing.py
--rw-r--r--  2.0 unx      113 b- defN 23-Apr-13 17:00 tpds/xml_handler/encrypt/__init__.py
--rw-r--r--  2.0 unx     6436 b- defN 23-Apr-13 17:00 tpds/xml_handler/encrypt/ciphers.py
--rw-r--r--  2.0 unx    18273 b- defN 23-Apr-13 17:00 tpds/xml_handler/encrypt/encrypt.py
--rw-r--r--  2.0 unx     1121 b- defN 23-Apr-13 17:02 tpds_helper-2.3.6.dist-info/LICENSE
--rw-r--r--  2.0 unx     3291 b- defN 23-Apr-13 17:02 tpds_helper-2.3.6.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Apr-13 17:02 tpds_helper-2.3.6.dist-info/WHEEL
--rw-r--r--  2.0 unx        5 b- defN 23-Apr-13 17:02 tpds_helper-2.3.6.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     9124 b- defN 23-Apr-13 17:02 tpds_helper-2.3.6.dist-info/RECORD
-101 files, 730428 bytes uncompressed, 321152 bytes compressed:  56.0%
+Zip file size: 344439 bytes, number of entries: 104
+-rw-r--r--  2.0 unx       65 b- defN 23-May-31 23:14 tpds/__init__.py
+-rw-r--r--  2.0 unx     1460 b- defN 23-May-31 23:14 tpds/certs/__init__.py
+-rw-r--r--  2.0 unx       67 b- defN 23-May-31 23:14 tpds/certs/cert.py
+-rw-r--r--  2.0 unx     2108 b- defN 23-May-31 23:14 tpds/certs/cert_utils.py
+-rw-r--r--  2.0 unx     3518 b- defN 23-May-31 23:14 tpds/certs/certs_backup.py
+-rw-r--r--  2.0 unx    21764 b- defN 23-May-31 23:14 tpds/certs/create_cert_defs.py
+-rw-r--r--  2.0 unx      157 b- defN 23-May-31 23:14 tpds/certs/ext_builder.py
+-rw-r--r--  2.0 unx      105 b- defN 23-May-31 23:14 tpds/certs/sign_csr.py
+-rw-r--r--  2.0 unx     1642 b- defN 23-May-31 23:15 tpds/certs/sign_csr.zip
+-rw-r--r--  2.0 unx    15728 b- defN 23-May-31 23:14 tpds/certs/tflex_certs.py
+-rw-r--r--  2.0 unx      140 b- defN 23-May-31 23:14 tpds/certs/timefix_backend.py
+-rw-r--r--  2.0 unx    22358 b- defN 23-May-31 23:14 tpds/certs/wpc_cert_def.py
+-rw-r--r--  2.0 unx     6995 b- defN 23-May-31 23:14 tpds/certs/x509_find_elements.py
+-rw-r--r--  2.0 unx     1312 b- defN 23-May-31 23:14 tpds/certs/sign_csr/readme.md
+-rw-r--r--  2.0 unx       22 b- defN 23-May-31 23:14 tpds/certs/sign_csr/requirements.txt
+-rw-r--r--  2.0 unx     1265 b- defN 23-May-31 23:14 tpds/certs/sign_csr/sign_csr.py
+-rw-r--r--  2.0 unx      804 b- defN 23-May-31 23:14 tpds/cloud_connect/__init__.py
+-rw-r--r--  2.0 unx    21146 b- defN 23-May-31 23:14 tpds/cloud_connect/aws_connect.py
+-rw-r--r--  2.0 unx     9004 b- defN 23-May-31 23:14 tpds/cloud_connect/azureRTOS_connect.py
+-rw-r--r--  2.0 unx    16174 b- defN 23-May-31 23:14 tpds/cloud_connect/azure_connect.py
+-rw-r--r--  2.0 unx    16733 b- defN 23-May-31 23:14 tpds/cloud_connect/azure_sdk.py
+-rw-r--r--  2.0 unx     1390 b- defN 23-May-31 23:14 tpds/cloud_connect/cloud_connect.py
+-rw-r--r--  2.0 unx     9280 b- defN 23-May-31 23:14 tpds/cloud_connect/gcp_connect.py
+-rw-r--r--  2.0 unx      182 b- defN 23-May-31 23:14 tpds/flash_program/__init__.py
+-rw-r--r--  2.0 unx     7727 b- defN 23-May-31 23:14 tpds/flash_program/flash_program.py
+-rw-r--r--  2.0 unx     6108 b- defN 23-May-31 23:14 tpds/flash_program/kit_connect.py
+-rw-r--r--  2.0 unx      272 b- defN 23-May-31 23:14 tpds/manifest/__init__.py
+-rw-r--r--  2.0 unx    17816 b- defN 23-May-31 23:14 tpds/manifest/manifest.py
+-rw-r--r--  2.0 unx     4248 b- defN 23-May-31 23:14 tpds/manifest/tflx_manifest.py
+-rw-r--r--  2.0 unx     3782 b- defN 23-May-31 23:14 tpds/manifest/tng_manifest.py
+-rw-r--r--  2.0 unx      157 b- defN 23-May-31 23:14 tpds/output_grabber/__init__.py
+-rw-r--r--  2.0 unx     2930 b- defN 23-May-31 23:14 tpds/output_grabber/library_output_grabber.py
+-rw-r--r--  2.0 unx      695 b- defN 23-May-31 23:14 tpds/proto_provision/__init__.py
+-rw-r--r--  2.0 unx     4409 b- defN 23-May-31 23:14 tpds/proto_provision/ecc204_provision.py
+-rw-r--r--  2.0 unx     2411 b- defN 23-May-31 23:14 tpds/proto_provision/ecc_provision.py
+-rw-r--r--  2.0 unx     1658 b- defN 23-May-31 23:14 tpds/proto_provision/proto_provision.py
+-rw-r--r--  2.0 unx     2761 b- defN 23-May-31 23:14 tpds/proto_provision/sha10x_provision.py
+-rw-r--r--  2.0 unx     1421 b- defN 23-May-31 23:14 tpds/proto_provision/ta010_provision.py
+-rw-r--r--  2.0 unx    10444 b- defN 23-May-31 23:14 tpds/proto_provision/ta100_provision.py
+-rw-r--r--  2.0 unx    16866 b- defN 23-May-31 23:14 tpds/proto_provision/tflxtls_provision.py
+-rw-r--r--  2.0 unx    16564 b- defN 23-May-31 23:14 tpds/proto_provision/tflxwpc_provision.py
+-rw-r--r--  2.0 unx      234 b- defN 23-May-31 23:14 tpds/pubkey_validation/__init__.py
+-rw-r--r--  2.0 unx     8503 b- defN 23-May-31 23:14 tpds/pubkey_validation/device_pubkey_validation.py
+-rw-r--r--  2.0 unx     6659 b- defN 23-May-31 23:14 tpds/pubkey_validation/pubkey_validation.py
+-rw-r--r--  2.0 unx      320 b- defN 23-May-31 23:14 tpds/resource_generation/__init__.py
+-rw-r--r--  2.0 unx     6265 b- defN 23-May-31 23:14 tpds/resource_generation/resource_generation.py
+-rw-r--r--  2.0 unx    21716 b- defN 23-May-31 23:14 tpds/resource_generation/tflx_resource_generation.py
+-rw-r--r--  2.0 unx     4910 b- defN 23-May-31 23:14 tpds/resource_generation/tng_manifest_generation.py
+-rw-r--r--  2.0 unx      551 b- defN 23-May-31 23:14 tpds/secure_element/__init__.py
+-rw-r--r--  2.0 unx     5876 b- defN 23-May-31 23:14 tpds/secure_element/ca_element.py
+-rw-r--r--  2.0 unx     1862 b- defN 23-May-31 23:14 tpds/secure_element/constants.py
+-rw-r--r--  2.0 unx     5798 b- defN 23-May-31 23:14 tpds/secure_element/ecc204.py
+-rw-r--r--  2.0 unx     5557 b- defN 23-May-31 23:14 tpds/secure_element/ecc608a.py
+-rw-r--r--  2.0 unx     4009 b- defN 23-May-31 23:14 tpds/secure_element/sha10x.py
+-rw-r--r--  2.0 unx     3580 b- defN 23-May-31 23:14 tpds/secure_element/sha204a.py
+-rw-r--r--  2.0 unx     2309 b- defN 23-May-31 23:14 tpds/secure_element/sha206a.py
+-rw-r--r--  2.0 unx     1809 b- defN 23-May-31 23:14 tpds/secure_element/ta010.py
+-rw-r--r--  2.0 unx     7231 b- defN 23-May-31 23:14 tpds/secure_element/ta_element.py
+-rw-r--r--  2.0 unx     1619 b- defN 23-May-31 23:14 tpds/ta_attribute_parser/__init__.py
+-rw-r--r--  2.0 unx     3270 b- defN 23-May-31 23:14 tpds/ta_attribute_parser/attr_common.py
+-rw-r--r--  2.0 unx      600 b- defN 23-May-31 23:14 tpds/ta_attribute_parser/attr_crl_property.py
+-rw-r--r--  2.0 unx      806 b- defN 23-May-31 23:14 tpds/ta_attribute_parser/attr_data_property.py
+-rw-r--r--  2.0 unx     1838 b- defN 23-May-31 23:14 tpds/ta_attribute_parser/attr_extractedcert_property.py
+-rw-r--r--  2.0 unx      856 b- defN 23-May-31 23:14 tpds/ta_attribute_parser/attr_fca_property.py
+-rw-r--r--  2.0 unx     1759 b- defN 23-May-31 23:14 tpds/ta_attribute_parser/attr_privkey_property.py
+-rw-r--r--  2.0 unx     1923 b- defN 23-May-31 23:14 tpds/ta_attribute_parser/attr_pubkey_property.py
+-rw-r--r--  2.0 unx     3114 b- defN 23-May-31 23:14 tpds/ta_attribute_parser/attr_symkey_property.py
+-rw-r--r--  2.0 unx     4863 b- defN 23-May-31 23:14 tpds/ta_attribute_parser/attributes.py
+-rw-r--r--  2.0 unx     1079 b- defN 23-May-31 23:14 tpds/tp_utils/__init__.py
+-rw-r--r--  2.0 unx     1647 b- defN 23-May-31 23:14 tpds/tp_utils/tp_client.py
+-rw-r--r--  2.0 unx     4601 b- defN 23-May-31 23:14 tpds/tp_utils/tp_input_dialog.py
+-rw-r--r--  2.0 unx    13175 b- defN 23-May-31 23:14 tpds/tp_utils/tp_keys.py
+-rw-r--r--  2.0 unx     2097 b- defN 23-May-31 23:14 tpds/tp_utils/tp_print.py
+-rw-r--r--  2.0 unx     3875 b- defN 23-May-31 23:14 tpds/tp_utils/tp_settings.py
+-rw-r--r--  2.0 unx     7095 b- defN 23-May-31 23:14 tpds/tp_utils/tp_utils.py
+-rw-r--r--  2.0 unx      612 b- defN 23-May-31 23:14 tpds/usecase_diagram/__init__.py
+-rw-r--r--  2.0 unx    23172 b- defN 23-May-31 23:14 tpds/usecase_diagram/canvas.py
+-rw-r--r--  2.0 unx      852 b- defN 23-May-31 23:14 tpds/usecase_diagram/click_icon.png
+-rw-r--r--  2.0 unx   141278 b- defN 23-May-31 23:14 tpds/usecase_diagram/done_icon.png
+-rw-r--r--  2.0 unx     7913 b- defN 23-May-31 23:14 tpds/usecase_diagram/menu_icons.py
+-rw-r--r--  2.0 unx    21422 b- defN 23-May-31 23:14 tpds/usecase_diagram/mplab.png
+-rw-r--r--  2.0 unx     6962 b- defN 23-May-31 23:14 tpds/usecase_diagram/popup.py
+-rw-r--r--  2.0 unx     6013 b- defN 23-May-31 23:14 tpds/usecase_diagram/proto_boards.py
+-rw-r--r--  2.0 unx     1154 b- defN 23-May-31 23:14 tpds/usecase_diagram/select.png
+-rw-r--r--  2.0 unx     2663 b- defN 23-May-31 23:14 tpds/usecase_diagram/terminal.py
+-rw-r--r--  2.0 unx     5598 b- defN 23-May-31 23:14 tpds/usecase_diagram/usecase_diagram.py
+-rw-r--r--  2.0 unx    10469 b- defN 23-May-31 23:14 tpds/xml_handler/ECC608A-MAH-TFLXWPC.xml
+-rw-r--r--  2.0 unx    15669 b- defN 23-May-31 23:14 tpds/xml_handler/ECC608B_TFLXTLS.xml
+-rw-r--r--  2.0 unx    14735 b- defN 23-May-31 23:14 tpds/xml_handler/PIC32CMLS60_ECC608.xml
+-rw-r--r--  2.0 unx      595 b- defN 23-May-31 23:14 tpds/xml_handler/__init__.py
+-rw-r--r--  2.0 unx     1362 b- defN 23-May-31 23:14 tpds/xml_handler/caencryption.py
+-rw-r--r--  2.0 unx     6379 b- defN 23-May-31 23:14 tpds/xml_handler/ciphers.py
+-rw-r--r--  2.0 unx     8332 b- defN 23-May-31 23:14 tpds/xml_handler/ecc_xml_encryption.py
+-rw-r--r--  2.0 unx    15090 b- defN 23-May-31 23:14 tpds/xml_handler/tflxtls_xml_updates.py
+-rw-r--r--  2.0 unx    17529 b- defN 23-May-31 23:14 tpds/xml_handler/tflxwpc_xml_updates.py
+-rw-r--r--  2.0 unx     2558 b- defN 23-May-31 23:14 tpds/xml_handler/xml_processing.py
+-rw-r--r--  2.0 unx      249 b- defN 23-May-31 23:14 tpds/xml_handler/encrypt/__init__.py
+-rw-r--r--  2.0 unx     6621 b- defN 23-May-31 23:14 tpds/xml_handler/encrypt/ciphers.py
+-rw-r--r--  2.0 unx    18345 b- defN 23-May-31 23:14 tpds/xml_handler/encrypt/encrypt.py
+-rw-r--r--  2.0 unx     1121 b- defN 23-May-31 23:15 tpds_helper-2.3.7.dist-info/LICENSE
+-rw-r--r--  2.0 unx     3957 b- defN 23-May-31 23:15 tpds_helper-2.3.7.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-May-31 23:15 tpds_helper-2.3.7.dist-info/WHEEL
+-rw-r--r--  2.0 unx        5 b- defN 23-May-31 23:15 tpds_helper-2.3.7.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     9399 b- defN 23-May-31 23:15 tpds_helper-2.3.7.dist-info/RECORD
+104 files, 745240 bytes uncompressed, 329449 bytes compressed:  55.8%
```

## zipnote {}

```diff
@@ -54,14 +54,17 @@
 
 Filename: tpds/cloud_connect/azureRTOS_connect.py
 Comment: 
 
 Filename: tpds/cloud_connect/azure_connect.py
 Comment: 
 
+Filename: tpds/cloud_connect/azure_sdk.py
+Comment: 
+
 Filename: tpds/cloud_connect/cloud_connect.py
 Comment: 
 
 Filename: tpds/cloud_connect/gcp_connect.py
 Comment: 
 
 Filename: tpds/flash_program/__init__.py
@@ -99,14 +102,17 @@
 
 Filename: tpds/proto_provision/ecc_provision.py
 Comment: 
 
 Filename: tpds/proto_provision/proto_provision.py
 Comment: 
 
+Filename: tpds/proto_provision/sha10x_provision.py
+Comment: 
+
 Filename: tpds/proto_provision/ta010_provision.py
 Comment: 
 
 Filename: tpds/proto_provision/ta100_provision.py
 Comment: 
 
 Filename: tpds/proto_provision/tflxtls_provision.py
@@ -147,14 +153,17 @@
 
 Filename: tpds/secure_element/ecc204.py
 Comment: 
 
 Filename: tpds/secure_element/ecc608a.py
 Comment: 
 
+Filename: tpds/secure_element/sha10x.py
+Comment: 
+
 Filename: tpds/secure_element/sha204a.py
 Comment: 
 
 Filename: tpds/secure_element/sha206a.py
 Comment: 
 
 Filename: tpds/secure_element/ta010.py
@@ -282,23 +291,23 @@
 
 Filename: tpds/xml_handler/encrypt/ciphers.py
 Comment: 
 
 Filename: tpds/xml_handler/encrypt/encrypt.py
 Comment: 
 
-Filename: tpds_helper-2.3.6.dist-info/LICENSE
+Filename: tpds_helper-2.3.7.dist-info/LICENSE
 Comment: 
 
-Filename: tpds_helper-2.3.6.dist-info/METADATA
+Filename: tpds_helper-2.3.7.dist-info/METADATA
 Comment: 
 
-Filename: tpds_helper-2.3.6.dist-info/WHEEL
+Filename: tpds_helper-2.3.7.dist-info/WHEEL
 Comment: 
 
-Filename: tpds_helper-2.3.6.dist-info/top_level.txt
+Filename: tpds_helper-2.3.7.dist-info/top_level.txt
 Comment: 
 
-Filename: tpds_helper-2.3.6.dist-info/RECORD
+Filename: tpds_helper-2.3.7.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## tpds/__init__.py

```diff
@@ -1 +1 @@
-__path__ = __import__('pkgutil').extend_path(__path__, __name__)
+__path__ = __import__("pkgutil").extend_path(__path__, __name__)
```

## tpds/certs/__init__.py

```diff
@@ -1,12 +1,60 @@
 """
     Trust Platform core package Certs module
 """
-from .cert import *
-from .cert_utils import *
-from .create_cert_defs import *
-from .tflex_certs import *
-from .sign_csr import *
-from .ext_builder import *
-from .timefix_backend import *
-from .certs_backup import *
-from .wpc_cert_def import *
+from .cert import Cert
+from .cert_utils import (
+    add_signer_extensions,
+    get_backend,
+    get_ca_status,
+    get_cert_content,
+    get_cert_print_bytes,
+    get_certificate_CN,
+    get_certificate_issuer_CN,
+    get_certificate_tbs,
+    get_certificate_thumbprint,
+    get_device_public_key,
+    get_device_sn_cert,
+    get_device_sn_number,
+    get_org_name,
+    is_key_file_password_protected,
+    is_signature_valid,
+    pubkey_cert_sn,
+    random_cert_sn,
+)
+from .certs_backup import CertsBackup
+from .create_cert_defs import CertDef
+from .ext_builder import ExtBuilder
+from .sign_csr import SignCSR
+from .tflex_certs import TFLEXCerts
+from .timefix_backend import TimeFixBackend
+from .wpc_cert_def import WPCCertDef
+
+__all__ = [
+    "Cert",
+    "CertsBackup",
+    "CertDef",
+    "ExtBuilder",
+    "SignCSR",
+    "TFLEXCerts",
+    "TimeFixBackend",
+    "WPCCertDef",
+]
+__all__ += [
+    "get_backend",
+    "get_org_name",
+    "get_device_sn_cert",
+    "get_ca_status",
+    "random_cert_sn",
+    "pubkey_cert_sn",
+    "is_key_file_password_protected",
+    "add_signer_extensions",
+    "get_device_sn_number",
+    "get_device_public_key",
+    "get_certificate_thumbprint",
+    "get_certificate_CN",
+    "get_certificate_issuer_CN",
+    "get_certificate_tbs",
+    "get_cert_content",
+    "get_cert_print_bytes",
+    "is_signature_valid",
+]
```

## tpds/certs/cert_utils.py

```diff
@@ -5,15 +5,15 @@
     return cert_utils.get_backend()
 
 
 def get_org_name(name):
     return cert_utils.get_org_name(name)
 
 
-def get_device_sn_cert(cert, find_value='0123'):
+def get_device_sn_cert(cert, find_value="0123"):
     return cert_utils.get_device_sn_cert(cert, find_value)
 
 
 def get_ca_status(cert):
     return cert_utils.get_ca_status(cert)
 
 
@@ -29,15 +29,15 @@
     return cert_utils.is_key_file_password_protected(key_filename)
 
 
 def add_signer_extensions(builder, public_key=None, authority_cert=None):
     return cert_utils.add_signer_extensions(builder, public_key, authority_cert)
 
 
-def get_device_sn_number(device_sn, prefix='sn'):
+def get_device_sn_number(device_sn, prefix="sn"):
     return cert_utils.get_device_sn_number(device_sn, prefix)
 
 
 def get_device_public_key(device_public_key):
     return cert_utils.get_device_public_key(device_public_key)
 
 
@@ -63,7 +63,28 @@
 
 def get_cert_print_bytes(cert):
     return cert_utils.get_cert_print_bytes(cert)
 
 
 def is_signature_valid(certificate, public_key):
     return cert_utils.is_signature_valid(certificate, public_key)
+
+
+__all__ = [
+    "get_backend",
+    "get_org_name",
+    "get_device_sn_cert",
+    "get_ca_status",
+    "random_cert_sn",
+    "pubkey_cert_sn",
+    "is_key_file_password_protected",
+    "add_signer_extensions",
+    "get_device_sn_number",
+    "get_device_public_key",
+    "get_certificate_thumbprint",
+    "get_certificate_CN",
+    "get_certificate_issuer_CN",
+    "get_certificate_tbs",
+    "get_cert_content",
+    "get_cert_print_bytes",
+    "is_signature_valid",
+]
```

## tpds/certs/certs_backup.py

```diff
@@ -14,63 +14,72 @@
 # PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY
 # KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 
-import os
 import binascii
+import os
+
 from tpds.tp_utils.tp_settings import TPSettings
 
 
-class CertsBackup():
+class CertsBackup:
     def __init__(self):
         pass
 
     def store_to_file(self, certs, file_path=None, device_sn=None):
         self.__set_file_path(file_path, device_sn)
 
         if not isinstance(certs, dict):
-            raise ValueError('certs must be dict with keys as root, signer and device')
+            raise ValueError("certs must be dict with keys as root, signer and device")
 
-        with open(self.file_path, 'w') as fp:
-            fp.write(certs.get('device').get_certificate_in_pem().decode("utf-8")) if certs.get('device') else None
-            fp.write(certs.get('signer').get_certificate_in_pem().decode("utf-8")) if certs.get('signer') else None
-            fp.write(certs.get('root').get_certificate_in_pem().decode("utf-8")) if certs.get('root') else None
+        with open(self.file_path, "w") as fp:
+            fp.write(certs.get("device").get_certificate_in_pem().decode("utf-8")) if certs.get(
+                "device"
+            ) else None
+            fp.write(certs.get("signer").get_certificate_in_pem().decode("utf-8")) if certs.get(
+                "signer"
+            ) else None
+            fp.write(certs.get("root").get_certificate_in_pem().decode("utf-8")) if certs.get(
+                "root"
+            ) else None
 
     def fetch_from_file(self, file_path=None, device_sn=None):
         self.__set_file_path(file_path, device_sn)
 
         certs = dict()
         if os.path.exists(self.file_path):
-            match_str = '-----BEGIN CERTIFICATE-----'
-            with open(self.file_path, 'r') as fp:
+            match_str = "-----BEGIN CERTIFICATE-----"
+            with open(self.file_path, "r") as fp:
                 file_content = fp.read()
                 pem_certs = file_content.split(match_str)
-                cert_names = ['device', 'signer', 'root']
+                cert_names = ["device", "signer", "root"]
                 index = 0
                 for cert in pem_certs:
-                    if 'CERTIFICATE' in cert:
+                    if "CERTIFICATE" in cert:
                         cert = match_str + cert
                         certs.update({cert_names[index]: cert})
                         index += 1
 
         return certs
 
     def __set_file_path(self, file_path, device_sn):
         if file_path is None and device_sn is None:
-            raise ValueError('Either file_path or device_sn is must')
+            raise ValueError("Either file_path or device_sn is must")
 
         self.file_path = file_path
         if file_path is None:
             tp_settings = TPSettings()
-            base_path = os.path.join(
-                                tp_settings.get_base_folder(), 'mchp_certs')
+            base_path = os.path.join(tp_settings.get_base_folder(), "mchp_certs")
             if not os.path.exists(base_path):
                 os.mkdir(base_path)
 
             if not isinstance(device_sn, bytearray):
-                raise ValueError('device_sn must be byte array')
+                raise ValueError("device_sn must be byte array")
+
+            device_sn = str(binascii.hexlify(device_sn), "utf-8").upper()
+            self.file_path = os.path.join(base_path, f"{device_sn}.pem")
+
 
-            device_sn = str(binascii.hexlify(device_sn), 'utf-8').upper()
-            self.file_path = os.path.join(base_path, f'{device_sn}.pem')
+__all__ = ["CertsBackup"]
```

## tpds/certs/create_cert_defs.py

```diff
@@ -15,34 +15,39 @@
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 
 import os
 import re
+from ctypes import POINTER, c_uint8, cast, create_string_buffer, pointer, string_at
+from pathlib import Path
+
+import _pickle
 import asn1crypto
 import cryptoauthlib as cal
-from pathlib import Path
-from .cert_utils import get_ca_status, get_device_sn_cert
 from cryptography import x509
-from .x509_find_elements import (
-    tbs_location, public_key_location,
-    signature_location, validity_location,
-    name_search_location, sn_location,
-    auth_key_id_location, subj_key_id_location,
-    name_search_location_last)
-from ctypes import (
-    cast, c_uint8, POINTER, string_at,
-    pointer, create_string_buffer)
 from cryptography.hazmat.primitives import serialization
-import _pickle
+
+from .cert_utils import get_ca_status, get_device_sn_cert
+from .x509_find_elements import (
+    auth_key_id_location,
+    name_search_location,
+    name_search_location_last,
+    public_key_location,
+    signature_location,
+    sn_location,
+    subj_key_id_location,
+    tbs_location,
+    validity_location,
+)
 
 
-class CertDef():
-    def __init__(self, device_name=''):
+class CertDef:
+    def __init__(self, device_name=""):
         self.set_cert = False
         self.device_name = device_name
         pass
 
     def set_certificate(self, cert, ca_cert, template_id=0):
         """
         Sets a certificate along with its CA to be processed for definition
@@ -53,70 +58,65 @@
         self.template_id = template_id
         self.chain_id = 0
         if get_ca_status(cert):
             self.chain_level = 1
             self.serial_num = None
             self.ca_cert_def = None
             self.signer_id = self.__get_signer_id(cert)
-            self.cert_def_name = 'signer'
+            self.cert_def_name = "signer"
             self.ca_include_filename = None
             self.ca_cert_def_var_name = None
-            self.filename_base = \
-                f'cust_def_{self.cert_def_name}'
+            self.filename_base = f"cust_def_{self.cert_def_name}"
         else:
             self.chain_level = 0
-            find_value = '9618' if self.device_name == 'ECC204' else '0123'
+            find_value = "9618" if self.device_name == "ECC204" else "0123"
             self.serial_num = get_device_sn_cert(cert, find_value)
             self.ca_cert_def = self.__get_signer_template(ca_cert)
             self.signer_id = self.__get_signer_id(ca_cert)
-            self.cert_def_name = 'device'
-            self.ca_include_filename = 'cust_def_signer.h'
-            self.ca_cert_def_var_name = 'g_cert_def_1_signer'
-            self.filename_base = \
-                f'cust_def_{self.cert_def_name}'
+            self.cert_def_name = "device"
+            self.ca_include_filename = "cust_def_signer.h"
+            self.ca_cert_def_var_name = "g_cert_def_1_signer"
+            self.filename_base = f"cust_def_{self.cert_def_name}"
 
         self.cert_def = None
         self.cert_files = None
         self.set_cert = True
 
-    def get_py_definition(self, src_def_file='', dest_def_file=''):
+    def get_py_definition(self, src_def_file="", dest_def_file=""):
         """
         Returns the certificate definition and optionally saves to file
         """
         if src_def_file and os.path.exists(src_def_file):
             with open(src_def_file, "rb") as fp:
                 definition = _pickle.load(fp)
-            if definition is not None and \
-                    'params' in definition and \
-                    'elements' in definition and \
-                    'template_data' in definition:
-                params = definition.get('params')
-                elements = definition.get('elements')
-                template_data = definition.get('template_data')
-                cert_def = self.__params_atcacert_definitions(
-                    template_data, params, elements)
+            if (
+                definition is not None
+                and "params" in definition
+                and "elements" in definition
+                and "template_data" in definition
+            ):
+                params = definition.get("params")
+                elements = definition.get("elements")
+                template_data = definition.get("template_data")
+                cert_def = self.__params_atcacert_definitions(template_data, params, elements)
             else:
-                raise ValueError('Invalid certificate definition file')
+                raise ValueError("Invalid certificate definition file")
         elif self.set_cert:
             cert_def = self.__build_py_definition()
             self.cert_def = cert_def
 
         if self.set_cert and dest_def_file:
             cert = dict()
             params = self.get_cert_params()
-            params.update({'ca_cert_def': None})
-            cert.update({
-                'template_data':
-                    self.cert.public_bytes(encoding=serialization.Encoding.DER)
-                })
-            cert.update({
-                'elements':
-                    self.get_cert_elements()
-                })
-            cert.update({'params': params})
+            params.update({"ca_cert_def": None})
+            cert.update(
+                {"template_data": self.cert.public_bytes(encoding=serialization.Encoding.DER)}
+            )
+            cert.update({"elements": self.get_cert_elements()})
+            cert.update({"params": params})
             Path(dest_def_file).write_bytes(_pickle.dumps(cert))
 
         return cert_def
 
     def get_c_definition(self, save_files=False):
         """
         Returns the certificate C definitions and optionally saves to file
@@ -131,399 +131,381 @@
 
             return self.cert_files
 
     def __build_py_definition(self):
         """
         Function to build and return the certificate definition
         """
-        template_data = self.cert.public_bytes(
-                                    encoding=serialization.Encoding.DER)
+        template_data = self.cert.public_bytes(encoding=serialization.Encoding.DER)
         params = self.get_cert_params()
         elements = self.get_cert_elements()
-        return self.__params_atcacert_definitions(
-                                    template_data, params, elements)
+        return self.__params_atcacert_definitions(template_data, params, elements)
 
     def __build_c_definition(self):
         """
         Function to build and return the C certificate definition
         """
-        template_var_name = f'g_template_{self.cert_def.template_id}_{self.cert_def_name}'
-        pk_var_name = f'g_cert_ca_public_key_{self.cert_def.template_id}_{self.cert_def_name}'
-        elements_var_name = f'g_cert_elements_{self.cert_def.template_id}_{self.cert_def_name}'
-        cert_def_var_name = f'g_cert_def_{self.cert_def.template_id}_{self.cert_def_name}'
+        template_var_name = f"g_template_{self.cert_def.template_id}_{self.cert_def_name}"
+        pk_var_name = f"g_cert_ca_public_key_{self.cert_def.template_id}_{self.cert_def_name}"
+        elements_var_name = f"g_cert_elements_{self.cert_def.template_id}_{self.cert_def_name}"
+        cert_def_var_name = f"g_cert_def_{self.cert_def.template_id}_{self.cert_def_name}"
 
-        c_file = ''
+        c_file = ""
         c_file += '#include "atcacert/atcacert_def.h"\n'
         if self.ca_include_filename:
             c_file += f'#include "{self.ca_include_filename}"\n'
-        c_file += '\n'
+        c_file += "\n"
 
-        template_data = string_at(
-                        self.cert_def.cert_template,
-                        self.cert_def.cert_template_size)
-        c_file += f'const uint8_t {template_var_name}[{len(template_data)}] = {self.__c_hex_array(template_data)};\n'
-        c_file += '\n'
+        template_data = string_at(self.cert_def.cert_template, self.cert_def.cert_template_size)
+        c_file += f"const uint8_t {template_var_name}[{len(template_data)}] = {self.__c_hex_array(template_data)};\n"
+        c_file += "\n"
 
         if self.chain_level == 1:
             pk_data = self.ca_cert.public_key().public_bytes(
                 format=serialization.PublicFormat.UncompressedPoint,
-                encoding=serialization.Encoding.X962
+                encoding=serialization.Encoding.X962,
             )[1:]
-            c_file += f'const uint8_t {pk_var_name}[{len(pk_data)}] = \
-                    {self.__c_hex_array(pk_data)};\n'
-            c_file += '\n'
+            c_file += f"const uint8_t {pk_var_name}[{len(pk_data)}] = \
+                    {self.__c_hex_array(pk_data)};\n"
+            c_file += "\n"
 
         if self.cert_def.cert_elements_count:
             element_strs = []
             for i in range(self.cert_def.cert_elements_count):
                 element = self.cert_def.cert_elements[i]
-                element_str = ''
-                element_str += f'    {{\n'
+                element_str = ""
+                element_str += "    {{\n"
                 element_str += f'        .id = "{element.id if isinstance(element.id, str) else element.id.decode("ascii")}",\n'
-                element_str += f'        .device_loc = {{\n'
-                element_str += \
-                    self.__device_loc_to_c(
-                        element.device_loc, indent='            ') + '\n'
-                element_str += f'        }},\n'
-                element_str += f'        .cert_loc = {{\n'
-                element_str += self.__cert_loc_to_c(
-                    element.cert_loc, indent='            ') + '\n'
-                element_str += f'        }},\n'
-                element_str += f'        .transforms = {{\n'
-                element_str += ',\n'.join(
-                    [f'            {cal.atcacert_transform_t(v).name}'
-                        for v in element.transforms]) + '\n'
-                element_str += f'        }}\n'
-                element_str += f'    }}'
+                element_str += "        .device_loc = {{\n"
+                element_str += (
+                    self.__device_loc_to_c(element.device_loc, indent="            ") + "\n"
+                )
+                element_str += "        }},\n"
+                element_str += "        .cert_loc = {{\n"
+                element_str += self.__cert_loc_to_c(element.cert_loc, indent="            ") + "\n"
+                element_str += "        }},\n"
+                element_str += "        .transforms = {{\n"
+                element_str += (
+                    ",\n".join(
+                        [
+                            f"            {cal.atcacert_transform_t(v).name}"
+                            for v in element.transforms
+                        ]
+                    )
+                    + "\n"
+                )
+                element_str += "        }}\n"
+                element_str += "    }}"
                 element_strs.append(element_str)
 
-            c_file += \
-                f'const atcacert_cert_element_t {elements_var_name}[{self.cert_def.cert_elements_count}] = {{\n'
-            c_file += ',\n'.join(element_strs) + '\n'
-            c_file += '};\n'
-            c_file += '\n'
-
-        c_file += f'const atcacert_def_t {cert_def_var_name} = {{\n'
-        c_file += f'    .type = {cal.atcacert_cert_type_t(self.cert_def.type).name},\n'
-        c_file += f'    .template_id = {self.cert_def.template_id},\n'
-        c_file += f'    .chain_id = {self.cert_def.chain_id},\n'
-        c_file += f'    .private_key_slot = {self.cert_def.private_key_slot},\n'
-        c_file += f'    .sn_source = {cal.atcacert_cert_sn_src_t(self.cert_def.sn_source).name},\n'
-        c_file += f'    .cert_sn_dev_loc = {{\n'
-        c_file += self.__device_loc_to_c(
-            self.cert_def.cert_sn_dev_loc,
-            indent='        ') + '\n'
-        c_file += f'    }},\n'
+            c_file += f"const atcacert_cert_element_t {elements_var_name}[{self.cert_def.cert_elements_count}] = {{\n"
+            c_file += ",\n".join(element_strs) + "\n"
+            c_file += "};\n"
+            c_file += "\n"
+
+        c_file += f"const atcacert_def_t {cert_def_var_name} = {{\n"
+        c_file += f"    .type = {cal.atcacert_cert_type_t(self.cert_def.type).name},\n"
+        c_file += f"    .template_id = {self.cert_def.template_id},\n"
+        c_file += f"    .chain_id = {self.cert_def.chain_id},\n"
+        c_file += f"    .private_key_slot = {self.cert_def.private_key_slot},\n"
+        c_file += f"    .sn_source = {cal.atcacert_cert_sn_src_t(self.cert_def.sn_source).name},\n"
+        c_file += "    .cert_sn_dev_loc = {{\n"
+        c_file += self.__device_loc_to_c(self.cert_def.cert_sn_dev_loc, indent="        ") + "\n"
+        c_file += "    }},\n"
         date_format = self.cert_def.issue_date_format
-        c_file += f'    .issue_date_format = {cal.atcacert_date_format_t(date_format).name},\n'
+        c_file += f"    .issue_date_format = {cal.atcacert_date_format_t(date_format).name},\n"
         date_format = self.cert_def.expire_date_format
-        c_file += f'    .expire_date_format = {cal.atcacert_date_format_t(date_format).name},\n'
-        c_file += f'    .tbs_cert_loc = {{\n'
-        c_file += self.__cert_loc_to_c(
-            self.cert_def.tbs_cert_loc,
-            indent='        ') + '\n'
-        c_file += f'    }},\n'
-        c_file += f'    .expire_years = {self.cert_def.expire_years},\n'
-        c_file += f'    .public_key_dev_loc = {{\n'
-        c_file += self.__device_loc_to_c(
-            self.cert_def.public_key_dev_loc,
-            indent='        ') + '\n'
-        c_file += f'    }},\n'
-        c_file += f'    .comp_cert_dev_loc = {{\n'
-        c_file += self.__device_loc_to_c(
-            self.cert_def.comp_cert_dev_loc,
-            indent='        ') + '\n'
-        c_file += f'    }},\n'
+        c_file += f"    .expire_date_format = {cal.atcacert_date_format_t(date_format).name},\n"
+        c_file += "    .tbs_cert_loc = {{\n"
+        c_file += self.__cert_loc_to_c(self.cert_def.tbs_cert_loc, indent="        ") + "\n"
+        c_file += "    }},\n"
+        c_file += f"    .expire_years = {self.cert_def.expire_years},\n"
+        c_file += "    .public_key_dev_loc = {{\n"
+        c_file += self.__device_loc_to_c(self.cert_def.public_key_dev_loc, indent="        ") + "\n"
+        c_file += "    }},\n"
+        c_file += "    .comp_cert_dev_loc = {{\n"
+        c_file += self.__device_loc_to_c(self.cert_def.comp_cert_dev_loc, indent="        ") + "\n"
+        c_file += "    }},\n"
         std_element_names = [
-            'STDCERT_PUBLIC_KEY',
-            'STDCERT_SIGNATURE',
-            'STDCERT_ISSUE_DATE',
-            'STDCERT_EXPIRE_DATE',
-            'STDCERT_SIGNER_ID',
-            'STDCERT_CERT_SN',
-            'STDCERT_AUTH_KEY_ID',
-            'STDCERT_SUBJ_KEY_ID'
+            "STDCERT_PUBLIC_KEY",
+            "STDCERT_SIGNATURE",
+            "STDCERT_ISSUE_DATE",
+            "STDCERT_EXPIRE_DATE",
+            "STDCERT_SIGNER_ID",
+            "STDCERT_CERT_SN",
+            "STDCERT_AUTH_KEY_ID",
+            "STDCERT_SUBJ_KEY_ID",
         ]
-        c_file += f'    .std_cert_elements = {{\n'
+        c_file += "    .std_cert_elements = {{\n"
         for i, name in enumerate(std_element_names):
-            c_file += f'        {{ // {name}\n'
-            c_file += self.__cert_loc_to_c(
-                self.cert_def.std_cert_elements[i],
-                indent='            ') + '\n'
-            c_file += f'        }},\n'
-        c_file += f'    }},\n'
+            c_file += f"        {{ // {name}\n"
+            c_file += (
+                self.__cert_loc_to_c(self.cert_def.std_cert_elements[i], indent="            ")
+                + "\n"
+            )
+            c_file += "        }},\n"
+        c_file += "    }},\n"
         if self.cert_def.cert_elements:
-            c_file += f'    .cert_elements = {elements_var_name},\n'
-            c_file += f'    .cert_elements_count = sizeof({elements_var_name}) / sizeof({elements_var_name}[0]),\n'
+            c_file += f"    .cert_elements = {elements_var_name},\n"
+            c_file += f"    .cert_elements_count = sizeof({elements_var_name}) / sizeof({elements_var_name}[0]),\n"
         else:
-            c_file += f'    .cert_elements = NULL,\n'
-            c_file += f'    .cert_elements_count = 0,\n'
-        c_file += f'    .cert_template = {template_var_name},\n'
-        c_file += f'    .cert_template_size = sizeof({template_var_name}),\n'
+            c_file += "    .cert_elements = NULL,\n"
+            c_file += "    .cert_elements_count = 0,\n"
+        c_file += f"    .cert_template = {template_var_name},\n"
+        c_file += f"    .cert_template_size = sizeof({template_var_name}),\n"
         if self.ca_cert_def_var_name:
-            c_file += f'    .ca_cert_def = &{self.ca_cert_def_var_name}\n'
+            c_file += f"    .ca_cert_def = &{self.ca_cert_def_var_name}\n"
         else:
-            c_file += f'    .ca_cert_def = NULL\n'
-        c_file += f'}};\n'
+            c_file += "    .ca_cert_def = NULL\n"
+        c_file += "}};\n"
 
-        h_file = ''
-        h_file += f'#ifndef {self.filename_base.upper()}_H\n'
-        h_file += f'#define {self.filename_base.upper()}_H\n'
-        h_file += f'\n'
-        h_file += f'#include "atcacert/atcacert_def.h"\n'
-        h_file += f'\n'
-        h_file += f'#ifdef __cplusplus\n'
-        h_file += f'extern "C" {{\n'
-        h_file += f'#endif\n'
-        h_file += f'extern const atcacert_def_t {cert_def_var_name};\n'
+        h_file = ""
+        h_file += f"#ifndef {self.filename_base.upper()}_H\n"
+        h_file += f"#define {self.filename_base.upper()}_H\n"
+        h_file += "\n"
+        h_file += '#include "atcacert/atcacert_def.h"\n'
+        h_file += "\n"
+        h_file += "#ifdef __cplusplus\n"
+        h_file += 'extern "C" {{\n'
+        h_file += "#endif\n"
+        h_file += f"extern const atcacert_def_t {cert_def_var_name};\n"
         if self.chain_level == 1:
-            h_file += f'extern const uint8_t {pk_var_name}[];\n'
-        h_file += f'#ifdef __cplusplus\n'
-        h_file += f'}}\n'
-        h_file += f'#endif\n'
-        h_file += '\n'
-        h_file += '#endif\n'
+            h_file += f"extern const uint8_t {pk_var_name}[];\n"
+        h_file += "#ifdef __cplusplus\n"
+        h_file += "}}\n"
+        h_file += "#endif\n"
+        h_file += "\n"
+        h_file += "#endif\n"
 
         return {
-            f'{self.filename_base}.c': c_file.encode('utf-8'),
-            f'{self.filename_base}.h': h_file.encode('utf-8')
+            f"{self.filename_base}.c": c_file.encode("utf-8"),
+            f"{self.filename_base}.h": h_file.encode("utf-8"),
         }
 
     def get_cert_params(self):
-        template_data = self.cert.public_bytes(
-            encoding=serialization.Encoding.DER)
-        asn1_cert = asn1crypto.x509.Certificate().load(
-            template_data, strict=True)
+        template_data = self.cert.public_bytes(encoding=serialization.Encoding.DER)
+        asn1_cert = asn1crypto.x509.Certificate().load(template_data, strict=True)
 
         tbs_offset, tbs_count = tbs_location(asn1_cert)
-        expire_years = self.cert.not_valid_after.year \
-            - self.cert.not_valid_before.year
+        expire_years = self.cert.not_valid_after.year - self.cert.not_valid_before.year
         if expire_years > 31:
             expire_years = 0  # Assume no expiration
         pk_offset, pk_count = public_key_location(asn1_cert)
         sig_offset, sig_count = signature_location(asn1_cert)
-        nb_offset, nb_count = validity_location(asn1_cert, 'not_before')
-        na_offset, na_count = validity_location(asn1_cert, 'not_after')
+        nb_offset, nb_count = validity_location(asn1_cert, "not_before")
+        na_offset, na_count = validity_location(asn1_cert, "not_after")
         sid_offset, sid_count = name_search_location_last(
             cert=asn1_cert,
-            name='issuer' if self.chain_level == 0 else 'subject',
-            search=self.signer_id
+            name="issuer" if self.chain_level == 0 else "subject",
+            search=self.signer_id,
         )
         sn_offset, sn_count = sn_location(asn1_cert)
         akid_offset, akid_count = auth_key_id_location(asn1_cert)
         skid_offset, skid_count = subj_key_id_location(asn1_cert)
-        if self.device_name == 'ECC204':
+        if self.device_name == "ECC204":
             public_key_dev_loc = {
-                    'zone': cal.atcacert_device_zone_t.DEVZONE_DATA,
-                    'slot': 0 if self.chain_level == 0 else 1,
-                    'is_genkey': 1 if self.chain_level == 0 else 0,
-                    'offset': 0 if self.chain_level == 0 else 128,
-                    'count': 64}
+                "zone": cal.atcacert_device_zone_t.DEVZONE_DATA,
+                "slot": 0 if self.chain_level == 0 else 1,
+                "is_genkey": 1 if self.chain_level == 0 else 0,
+                "offset": 0 if self.chain_level == 0 else 128,
+                "count": 64,
+            }
             comp_cert_dev_loc = {
-                    'zone': cal.atcacert_device_zone_t.DEVZONE_DATA,
-                    'slot': 1,
-                    'is_genkey': 0,
-                    'offset': 0 if self.chain_level == 0 else 192,
-                    'count': 72}
+                "zone": cal.atcacert_device_zone_t.DEVZONE_DATA,
+                "slot": 1,
+                "is_genkey": 0,
+                "offset": 0 if self.chain_level == 0 else 192,
+                "count": 72,
+            }
         else:
             public_key_dev_loc = {
-                    'zone': cal.atcacert_device_zone_t.DEVZONE_DATA,
-                    'slot': 0 if self.chain_level == 0 else 11,
-                    'is_genkey': 1 if self.chain_level == 0 else 0,
-                    'offset': 0,
-                    'count': 64 if self.chain_level == 0 else 72}
+                "zone": cal.atcacert_device_zone_t.DEVZONE_DATA,
+                "slot": 0 if self.chain_level == 0 else 11,
+                "is_genkey": 1 if self.chain_level == 0 else 0,
+                "offset": 0,
+                "count": 64 if self.chain_level == 0 else 72,
+            }
             comp_cert_dev_loc = {
-                    'zone': cal.atcacert_device_zone_t.DEVZONE_DATA,
-                    'slot': 10 if self.chain_level == 0 else 12,
-                    'is_genkey': 0,
-                    'offset': 0,
-                    'count': 72}
+                "zone": cal.atcacert_device_zone_t.DEVZONE_DATA,
+                "slot": 10 if self.chain_level == 0 else 12,
+                "is_genkey": 0,
+                "offset": 0,
+                "count": 72,
+            }
 
         params = {
-            'type': cal.atcacert_cert_type_t.CERTTYPE_X509,
-            'template_id': self.template_id,
-            'chain_id': self.chain_id,
-            'private_key_slot': 0,
-            'sn_source': cal.atcacert_cert_sn_src_t.SNSRC_PUB_KEY_HASH,
-            'cert_sn_dev_loc': {
-                'zone': cal.atcacert_device_zone_t.DEVZONE_NONE,
-                'slot': 0,
-                'is_genkey': 0,
-                'offset': 0,
-                'count': 0,
+            "type": cal.atcacert_cert_type_t.CERTTYPE_X509,
+            "template_id": self.template_id,
+            "chain_id": self.chain_id,
+            "private_key_slot": 0,
+            "sn_source": cal.atcacert_cert_sn_src_t.SNSRC_PUB_KEY_HASH,
+            "cert_sn_dev_loc": {
+                "zone": cal.atcacert_device_zone_t.DEVZONE_NONE,
+                "slot": 0,
+                "is_genkey": 0,
+                "offset": 0,
+                "count": 0,
             },
-            'issue_date_format':
-                cal.atcacert_date_format_t.DATEFMT_RFC5280_UTC,
-            'expire_date_format':
-                cal.atcacert_date_format_t.DATEFMT_RFC5280_GEN,
-            'tbs_cert_loc': {
-                'offset': tbs_offset,
-                'count': tbs_count
-            },
-            'expire_years': expire_years,
-            'public_key_dev_loc': public_key_dev_loc,
-            'comp_cert_dev_loc': comp_cert_dev_loc,
-            'std_cert_elements': [
+            "issue_date_format": cal.atcacert_date_format_t.DATEFMT_RFC5280_UTC,
+            "expire_date_format": cal.atcacert_date_format_t.DATEFMT_RFC5280_GEN,
+            "tbs_cert_loc": {"offset": tbs_offset, "count": tbs_count},
+            "expire_years": expire_years,
+            "public_key_dev_loc": public_key_dev_loc,
+            "comp_cert_dev_loc": comp_cert_dev_loc,
+            "std_cert_elements": [
                 # STDCERT_PUBLIC_KEY
-                {'offset': pk_offset, 'count': pk_count},
+                {"offset": pk_offset, "count": pk_count},
                 # STDCERT_SIGNATURE
-                {'offset': sig_offset, 'count': sig_count},
+                {"offset": sig_offset, "count": sig_count},
                 # STDCERT_ISSUE_DATE
-                {'offset': nb_offset, 'count': nb_count},
+                {"offset": nb_offset, "count": nb_count},
                 # STDCERT_EXPIRE_DATE
-                {'offset': na_offset, 'count': na_count},
+                {"offset": na_offset, "count": na_count},
                 # STDCERT_SIGNER_ID
-                {'offset': sid_offset, 'count': sid_count},
+                {"offset": sid_offset, "count": sid_count},
                 # STDCERT_CERT_SN
-                {'offset': sn_offset, 'count': sn_count},
+                {"offset": sn_offset, "count": sn_count},
                 # STDCERT_AUTH_KEY_ID
-                {'offset': akid_offset, 'count': akid_count},
+                {"offset": akid_offset, "count": akid_count},
                 # STDCERT_SUBJ_KEY_ID
-                {'offset': skid_offset, 'count': skid_count}
+                {"offset": skid_offset, "count": skid_count},
             ],
-            'ca_cert_def':
-                pointer(self.ca_cert_def) if self.ca_cert_def else None
+            "ca_cert_def": pointer(self.ca_cert_def) if self.ca_cert_def else None,
         }
         return params
 
     def get_cert_elements(self):
-        template_data = \
-            self.cert.public_bytes(encoding=serialization.Encoding.DER)
-        asn1_cert = \
-            asn1crypto.x509.Certificate().load(template_data, strict=True)
+        template_data = self.cert.public_bytes(encoding=serialization.Encoding.DER)
+        asn1_cert = asn1crypto.x509.Certificate().load(template_data, strict=True)
 
         elements = []
         if self.serial_num is not None:
-            if self.device_name == 'ECC204':
+            if self.device_name == "ECC204":
                 sn_offset, sn_count = name_search_location(
-                    asn1_cert, 'subject', self.serial_num[0:18])
+                    asn1_cert, "subject", self.serial_num[0:18]
+                )
                 elements.append(
                     {
-                        'id': 'SN08',
-                        'device_loc': {
-                            'zone': cal.atcacert_device_zone_t.DEVZONE_CONFIG,
-                            'slot': 0,
-                            'is_genkey': 0,
-                            'offset': 0,
-                            'count': 9
+                        "id": "SN08",
+                        "device_loc": {
+                            "zone": cal.atcacert_device_zone_t.DEVZONE_CONFIG,
+                            "slot": 0,
+                            "is_genkey": 0,
+                            "offset": 0,
+                            "count": 9,
                         },
-                        'cert_loc': {
-                            'offset': sn_offset,
-                            'count': sn_count
-                        },
-                        'transforms': [
+                        "cert_loc": {"offset": sn_offset, "count": sn_count},
+                        "transforms": [
                             cal.atcacert_transform_t.TF_BIN2HEX_UC,
-                            cal.atcacert_transform_t.TF_NONE
-                        ]
+                            cal.atcacert_transform_t.TF_NONE,
+                        ],
                     }
                 )
             else:
                 sn03_offset, sn03_count = name_search_location(
-                    asn1_cert, 'subject', self.serial_num[0:8])
+                    asn1_cert, "subject", self.serial_num[0:8]
+                )
                 elements.append(
                     {
-                        'id': 'SN03',
-                        'device_loc': {
-                            'zone': cal.atcacert_device_zone_t.DEVZONE_CONFIG,
-                            'slot': 0,
-                            'is_genkey': 0,
-                            'offset': 0,
-                            'count': 4
-                        },
-                        'cert_loc': {
-                            'offset': sn03_offset,
-                            'count': sn03_count
+                        "id": "SN03",
+                        "device_loc": {
+                            "zone": cal.atcacert_device_zone_t.DEVZONE_CONFIG,
+                            "slot": 0,
+                            "is_genkey": 0,
+                            "offset": 0,
+                            "count": 4,
                         },
-                        'transforms': [
+                        "cert_loc": {"offset": sn03_offset, "count": sn03_count},
+                        "transforms": [
                             cal.atcacert_transform_t.TF_BIN2HEX_UC,
-                            cal.atcacert_transform_t.TF_NONE
-                        ]
+                            cal.atcacert_transform_t.TF_NONE,
+                        ],
                     }
                 )
                 sn48_offset, sn48_count = name_search_location(
-                    asn1_cert, 'subject', self.serial_num[8:18])
+                    asn1_cert, "subject", self.serial_num[8:18]
+                )
                 elements.append(
                     {
-                        'id': 'SN48',
-                        'device_loc': {
-                            'zone': cal.atcacert_device_zone_t.DEVZONE_CONFIG,
-                            'slot': 0,
-                            'is_genkey': 0,
-                            'offset': 8,
-                            'count': 5
-                        },
-                        'cert_loc': {
-                            'offset': sn48_offset,
-                            'count': sn48_count
+                        "id": "SN48",
+                        "device_loc": {
+                            "zone": cal.atcacert_device_zone_t.DEVZONE_CONFIG,
+                            "slot": 0,
+                            "is_genkey": 0,
+                            "offset": 8,
+                            "count": 5,
                         },
-                        'transforms': [
+                        "cert_loc": {"offset": sn48_offset, "count": sn48_count},
+                        "transforms": [
                             cal.atcacert_transform_t.TF_BIN2HEX_UC,
-                            cal.atcacert_transform_t.TF_NONE
-                        ]
+                            cal.atcacert_transform_t.TF_NONE,
+                        ],
                     }
                 )
         return elements
 
     def __get_signer_template(self, cert):
         signer = CertDef(self.device_name)
         signer.set_certificate(cert, None)
         return signer.__build_py_definition()
 
     @staticmethod
     def __params_atcacert_definitions(template_data, params, elements):
         cert_def = cal.atcacert_def_t(**params)
         cert_def.cert_template_size = len(template_data)
-        cert_def.cert_template = cast(create_string_buffer(
-            template_data, cert_def.cert_template_size), POINTER(c_uint8))
+        cert_def.cert_template = cast(
+            create_string_buffer(template_data, cert_def.cert_template_size), POINTER(c_uint8)
+        )
 
         if elements:
             cert_def.cert_elements_count = len(elements)
             elems = [cal.atcacert_cert_element_t(**x) for x in elements]
-            elems_array = \
-                (cal.atcacert_cert_element_t * cert_def.cert_elements_count)(
-                    *elems)
-            cert_def.cert_elements = cast(elems_array, POINTER(
-                cal.atcacert_cert_element_t))
+            elems_array = (cal.atcacert_cert_element_t * cert_def.cert_elements_count)(*elems)
+            cert_def.cert_elements = cast(elems_array, POINTER(cal.atcacert_cert_element_t))
         return cert_def
 
     @staticmethod
-    def __device_loc_to_c(device_loc, indent=''):
+    def __device_loc_to_c(device_loc, indent=""):
         lines = [
-            f'.zone = {cal.atcacert_device_zone_t(device_loc.zone).name}',
-            f'.slot = {device_loc.slot}',
-            f'.is_genkey = {device_loc.is_genkey}',
-            f'.offset = {device_loc.offset}',
-            f'.count = {device_loc.count}',
+            f".zone = {cal.atcacert_device_zone_t(device_loc.zone).name}",
+            f".slot = {device_loc.slot}",
+            f".is_genkey = {device_loc.is_genkey}",
+            f".offset = {device_loc.offset}",
+            f".count = {device_loc.count}",
         ]
 
-        return ',\n'.join([f'{indent}{line}' for line in lines])
+        return ",\n".join([f"{indent}{line}" for line in lines])
 
     @staticmethod
-    def __cert_loc_to_c(cert_loc, indent=''):
+    def __cert_loc_to_c(cert_loc, indent=""):
         lines = [
-            f'.offset = {cert_loc.offset}',
-            f'.count = {cert_loc.count}',
+            f".offset = {cert_loc.offset}",
+            f".count = {cert_loc.count}",
         ]
 
-        return ',\n'.join([f'{indent}{line}' for line in lines])
+        return ",\n".join([f"{indent}{line}" for line in lines])
 
     @staticmethod
-    def __c_hex_array(data, indent='    ', bytes_per_line=16):
+    def __c_hex_array(data, indent="    ", bytes_per_line=16):
         lines = []
         for i in range(0, len(data), bytes_per_line):
-            lines.append(indent + ', '.join([
-                f'0x{v:02x}' for v in data[i:i+bytes_per_line]]) + ',')
-        return '{\n' + '\n'.join(lines) + '\n}'
+            lines.append(
+                indent + ", ".join([f"0x{v:02x}" for v in data[i : i + bytes_per_line]]) + ","
+            )
+        return "{\n" + "\n".join(lines) + "\n}"
 
     @staticmethod
     def __get_signer_id(cert):
         """
         Get the signer id from the certificate.
         """
         for attr in cert.subject:
             if attr.oid == x509.oid.NameOID.COMMON_NAME:
                 signer_id = attr.value[-4:]
-                if re.search('^[0-9A-F]{4}$', signer_id) is None:
+                if re.search("^[0-9A-F]{4}$", signer_id) is None:
                     raise ValueError(
-                            'signer_id={} must be 4 uppercase hex digits'
-                            .format(signer_id))
+                        "signer_id={} must be 4 uppercase hex digits".format(signer_id)
+                    )
                 return signer_id
+
+
+__all__ = ["CertDef"]
```

## tpds/certs/ext_builder.py

```diff
@@ -1,8 +1,10 @@
 from tpds.cert_tools import ext_builder
 
-
 TimeFormat = ext_builder.TimeFormat
 
 
 class ExtBuilder(ext_builder.ExtBuilder):
     pass
+
+
+__all__ = ["ExtBuilder"]
```

## tpds/certs/sign_csr.py

```diff
@@ -1,5 +1,8 @@
 from tpds.cert_tools import sign_csr
 
 
 class SignCSR(sign_csr.SignCSR):
     pass
+
+
+__all__ = ["SignCSR"]
```

## tpds/certs/sign_csr.zip

### zipinfo {}

```diff
@@ -1,5 +1,5 @@
-Zip file size: 1643 bytes, number of entries: 3
--rw-r--r--  2.0 unx     1312 b- defN 23-Apr-13 17:00 readme.md
--rw-r--r--  2.0 unx       22 b- defN 23-Apr-13 17:00 requirements.txt
--rw-r--r--  2.0 unx     1266 b- defN 23-Apr-13 17:00 sign_csr.py
-3 files, 2600 bytes uncompressed, 1321 bytes compressed:  49.2%
+Zip file size: 1642 bytes, number of entries: 3
+-rw-r--r--  2.0 unx     1312 b- defN 23-May-31 23:14 readme.md
+-rw-r--r--  2.0 unx       22 b- defN 23-May-31 23:14 requirements.txt
+-rw-r--r--  2.0 unx     1265 b- defN 23-May-31 23:14 sign_csr.py
+3 files, 2599 bytes uncompressed, 1320 bytes compressed:  49.2%
```

### sign_csr.py

```diff
@@ -14,10 +14,9 @@
 # KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 from tpds.cert_tools.sign_csr import sign_csr_main
 
-
-if __name__ == '__main__':
+if __name__ == "__main__":
     sign_csr_main()
```

## tpds/certs/tflex_certs.py

```diff
@@ -14,263 +14,298 @@
 # KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 
 import warnings
+
 from cryptography import utils
-warnings.filterwarnings(action= 'ignore', category=utils.CryptographyDeprecationWarning)
+
+warnings.filterwarnings(action="ignore", category=utils.CryptographyDeprecationWarning)
 import os
 import re
+from datetime import datetime, timezone
+
 from cryptography import x509
 from cryptography.hazmat.primitives.asymmetric import ec
-from datetime import datetime, timezone, timedelta
+
+from tpds.tp_utils.tp_keys import TPAsymmetricKey
+
 from .cert import Cert
-from .ext_builder import TimeFormat
-from .create_cert_defs import CertDef
 from .cert_utils import (
-    random_cert_sn, add_signer_extensions, get_device_sn_number,
-    get_device_public_key, get_backend, pubkey_cert_sn)
-from tpds.tp_utils.tp_keys import TPAsymmetricKey
+    add_signer_extensions,
+    get_backend,
+    get_device_public_key,
+    get_device_sn_number,
+    pubkey_cert_sn,
+    random_cert_sn,
+)
+from .create_cert_defs import CertDef
+from .ext_builder import TimeFormat
 
 
-class TFLEXCerts():
-    def __init__(self, device_name=''):
-        self.device_name=device_name
+class TFLEXCerts:
+    def __init__(self, device_name=""):
+        self.device_name = device_name
         self.root = Cert()
         self.signer_csr = Cert()
         self.signer = Cert()
         self.device = Cert()
 
         self.root.key = TPAsymmetricKey()
         self.signer_csr.key = TPAsymmetricKey()
         self.signer.key = TPAsymmetricKey()
         self.device.key = TPAsymmetricKey()
 
-    def build_root(self, key=None,
-                   org_name='Microchip Technology Inc',
-                   common_name='Crypto Authentication Root CA 002',
-                   validity=40, user_pub_key=None):
+    def build_root(
+        self,
+        key=None,
+        org_name="Microchip Technology Inc",
+        common_name="Crypto Authentication Root CA 002",
+        validity=40,
+        user_pub_key=None,
+    ):
         """
         Function to build the root certificate
 
         Inputs:
             key           the private key used for generating the root
                             certificate.
             org_name      Organisation name to be set in the certificate
             common_name   Common name to be set in the certificate
             validity      Validity to be set in the certificate
         """
 
         if key:
             self.root.key.set_private_key(key)
 
-        self.root.builder = self.root.builder.subject_name(x509.Name([
-            x509.NameAttribute(x509.oid.NameOID.ORGANIZATION_NAME, org_name),
-            x509.NameAttribute(x509.oid.NameOID.COMMON_NAME, common_name)]))
+        self.root.builder = self.root.builder.subject_name(
+            x509.Name(
+                [
+                    x509.NameAttribute(x509.oid.NameOID.ORGANIZATION_NAME, org_name),
+                    x509.NameAttribute(x509.oid.NameOID.COMMON_NAME, common_name),
+                ]
+            )
+        )
         # Names are the same for a self-signed certificate
-        self.root.builder = self.root.builder.issuer_name(
-            self.root.builder._subject_name)
+        self.root.builder = self.root.builder.issuer_name(self.root.builder._subject_name)
         self.root.builder = self.root.builder.not_valid_before(
-            datetime.utcnow().replace(tzinfo=timezone.utc))
+            datetime.utcnow().replace(tzinfo=timezone.utc)
+        )
         self.root.builder = self.root.builder.not_valid_after(
-                self.root.builder._not_valid_before.replace(
-                    year=self.root.builder._not_valid_before.year + 40))
+            self.root.builder._not_valid_before.replace(
+                year=self.root.builder._not_valid_before.year + 40
+            )
+        )
         if user_pub_key:
             root_pub_key = ec.EllipticCurvePublicNumbers(
-                        x=int(user_pub_key[:64], 16),
-                        y=int(user_pub_key[64:], 16),
-                        curve=ec.SECP256R1()).public_key(get_backend())
+                x=int(user_pub_key[:64], 16), y=int(user_pub_key[64:], 16), curve=ec.SECP256R1()
+            ).public_key(get_backend())
             self.root.builder = self.root.builder.public_key(root_pub_key)
         else:
-            self.root.builder = self.root.builder.public_key(
-                self.root.key.get_public_key())
-        self.root.builder = self.root.builder.serial_number(
-            random_cert_sn(16))
+            self.root.builder = self.root.builder.public_key(self.root.key.get_public_key())
+        self.root.builder = self.root.builder.serial_number(random_cert_sn(16))
         self.root.builder = self.root.builder.add_extension(
-            x509.SubjectKeyIdentifier.from_public_key(
-                self.root.builder._public_key),
-            critical=False)
+            x509.SubjectKeyIdentifier.from_public_key(self.root.builder._public_key), critical=False
+        )
         self.root.builder = self.root.builder.add_extension(
-            x509.AuthorityKeyIdentifier.from_issuer_public_key(
-                self.root.builder._public_key),
-            critical=False)
+            x509.AuthorityKeyIdentifier.from_issuer_public_key(self.root.builder._public_key),
+            critical=False,
+        )
         self.root.builder = self.root.builder.add_extension(
-            x509.BasicConstraints(ca=True, path_length=None),
-            critical=True)
+            x509.BasicConstraints(ca=True, path_length=None), critical=True
+        )
 
         self.root.sign_builder(self.root.key.private_key)
 
-    def build_signer_csr(self, key=None,
-                         org_name='Microchip Technology Inc',
-                         common_name='Crypto Authentication Signer ',
-                         signer_id='FFFF'):
+    def build_signer_csr(
+        self,
+        key=None,
+        org_name="Microchip Technology Inc",
+        common_name="Crypto Authentication Signer ",
+        signer_id="FFFF",
+    ):
         """
         Function to build the signer csr certificate
 
         Inputs:
             key           the private key used for generating the signer csr.
             org_name      Organisation name to be set in the certificate
             common_name   Common name to be set in the certificate
             signer_id     Signer ID to be set in the certificate
         """
 
         if key:
             self.signer_csr.key.set_private_key(key)
 
-        if re.search('^[0-9A-F]{4}$', signer_id) is None:
-            raise ValueError(
-                'signer_id={} must be 4 uppercase hex digits'.format(
-                    signer_id))
+        if re.search("^[0-9A-F]{4}$", signer_id) is None:
+            raise ValueError("signer_id={} must be 4 uppercase hex digits".format(signer_id))
 
         self.signer_csr.builder = x509.CertificateSigningRequestBuilder()
         self.signer_csr.builder = self.signer_csr.builder.subject_name(
-            x509.Name([
-                x509.NameAttribute(
-                    x509.oid.NameOID.ORGANIZATION_NAME, org_name),
-                x509.NameAttribute(
-                    x509.oid.NameOID.COMMON_NAME, common_name + signer_id)]))
+            x509.Name(
+                [
+                    x509.NameAttribute(x509.oid.NameOID.ORGANIZATION_NAME, org_name),
+                    x509.NameAttribute(x509.oid.NameOID.COMMON_NAME, common_name + signer_id),
+                ]
+            )
+        )
         # Add extensions
         self.signer_csr.builder = add_signer_extensions(
-            builder=self.signer_csr.builder,
-            public_key=self.signer_csr.key.get_public_key())
+            builder=self.signer_csr.builder, public_key=self.signer_csr.key.get_public_key()
+        )
 
         self.signer_csr.sign_builder(self.signer_csr.key.private_key)
 
     def build_signer(self, key=None, validity=31):
-
         """
         Function to build the signer certificate
 
         Inputs:
             key           the private key used for generating the signer.
             validity      the validity to be set for the signer certificate.
         """
 
         if key:
             self.signer.key.set_private_key(key)
         else:
             self.signer.key.private_key = self.signer_csr.key.private_key
 
         if not self.root.certificate:
-            raise ValueError('Root cert MUST be built/set before Signer')
+            raise ValueError("Root cert MUST be built/set before Signer")
         if not self.signer_csr.certificate:
-            raise ValueError('Signer csr MUST be built/set before Signer')
+            raise ValueError("Signer csr MUST be built/set before Signer")
 
-        self.signer.builder = self.signer.builder.issuer_name(
-            self.root.certificate.subject)
+        self.signer.builder = self.signer.builder.issuer_name(self.root.certificate.subject)
         self.signer.builder = self.signer.builder.not_valid_before(
-            datetime.utcnow().replace(
-                minute=0, second=0, microsecond=0, tzinfo=timezone.utc))
+            datetime.utcnow().replace(minute=0, second=0, microsecond=0, tzinfo=timezone.utc)
+        )
         # If validity is set to zero the code should fix the max possible
         # date and time under Generalized time format according to RFC5280
-        if validity==0:
+        if validity == 0:
             self.signer.builder = self.signer.builder.not_valid_after(
                 datetime(9999, 12, 31, 23, 59, 59, tzinfo=timezone.utc),
-                format=TimeFormat.GENERALIZED_TIME)
+                format=TimeFormat.GENERALIZED_TIME,
+            )
         else:
             self.signer.builder = self.signer.builder.not_valid_after(
                 self.signer.builder._not_valid_before.replace(
-                    year=self.signer.builder._not_valid_before.year + validity),
-                    format=TimeFormat.GENERALIZED_TIME)
-        self.signer.builder = self.signer.builder.subject_name(
-            self.signer_csr.certificate.subject)
+                    year=self.signer.builder._not_valid_before.year + validity
+                ),
+                format=TimeFormat.GENERALIZED_TIME,
+            )
+        self.signer.builder = self.signer.builder.subject_name(self.signer_csr.certificate.subject)
         self.signer.builder = self.signer.builder.public_key(
-            self.signer_csr.certificate.public_key())
+            self.signer_csr.certificate.public_key()
+        )
         self.signer.builder = self.signer.builder.serial_number(
-            pubkey_cert_sn(16, self.signer.builder))
+            pubkey_cert_sn(16, self.signer.builder)
+        )
         self.signer.builder = add_signer_extensions(
-            builder=self.signer.builder,
-            authority_cert=self.root.certificate)
+            builder=self.signer.builder, authority_cert=self.root.certificate
+        )
 
         self.signer.sign_builder(self.root.key.private_key)
 
-    def build_device(self, device_sn=None, device_public_key=None,
-                     org_name='Microchip Technology Inc', validity=28):
-
+    def build_device(
+        self,
+        device_sn=None,
+        device_public_key=None,
+        org_name="Microchip Technology Inc",
+        validity=28,
+    ):
         """
         Function to build the device certificate
 
         Inputs:
             device_sn         the device serial number to be used for
                                 certificate
             device_public_key the device public key to be used for certificate
             org_name          Organisation name to be set in the certificate
             validity          the validity to be set for the certificate.
         """
 
         if not self.signer.certificate:
-            raise ValueError('Signer cert MUST be built/set before Device')
+            raise ValueError("Signer cert MUST be built/set before Device")
 
         device_sn = get_device_sn_number(device_sn)
         device_public_key = get_device_public_key(device_public_key)
         public_key = ec.EllipticCurvePublicNumbers(
             x=int(device_public_key[:64], 16),
             y=int(device_public_key[64:], 16),
-            curve=ec.SECP256R1()).public_key(get_backend())
+            curve=ec.SECP256R1(),
+        ).public_key(get_backend())
 
-        self.device.builder = self.device.builder.issuer_name(
-            self.signer.certificate.subject)
+        self.device.builder = self.device.builder.issuer_name(self.signer.certificate.subject)
         self.device.builder = self.device.builder.not_valid_before(
-            datetime.utcnow().replace(tzinfo=timezone.utc, minute=0, second=0))
+            datetime.utcnow().replace(tzinfo=timezone.utc, minute=0, second=0)
+        )
         # If validity is set to zero the code should fix the max possible
         # date and time under Generalized time format according to RFC5280
-        if validity==0:
+        if validity == 0:
             self.device.builder = self.device.builder.not_valid_after(
                 datetime(9999, 12, 31, 23, 59, 59, tzinfo=timezone.utc),
-                format=TimeFormat.GENERALIZED_TIME)
+                format=TimeFormat.GENERALIZED_TIME,
+            )
         else:
             self.device.builder = self.device.builder.not_valid_after(
                 self.device.builder._not_valid_before.replace(
-                    year=self.device.builder._not_valid_before.year + validity),
-                    format=TimeFormat.GENERALIZED_TIME)
-        self.device.builder = self.device.builder.subject_name(x509.Name([
-                x509.NameAttribute(
-                    x509.oid.NameOID.ORGANIZATION_NAME, org_name),
-                x509.NameAttribute(
-                    x509.oid.NameOID.COMMON_NAME, device_sn)]))
+                    year=self.device.builder._not_valid_before.year + validity
+                ),
+                format=TimeFormat.GENERALIZED_TIME,
+            )
+        self.device.builder = self.device.builder.subject_name(
+            x509.Name(
+                [
+                    x509.NameAttribute(x509.oid.NameOID.ORGANIZATION_NAME, org_name),
+                    x509.NameAttribute(x509.oid.NameOID.COMMON_NAME, device_sn),
+                ]
+            )
+        )
         self.device.builder = self.device.builder.public_key(public_key)
         # Device certificate is generated from certificate dates and public key
         self.device.builder = self.device.builder.serial_number(
-            pubkey_cert_sn(16, self.device.builder))
+            pubkey_cert_sn(16, self.device.builder)
+        )
         # Add in extensions
         self.device.builder = self.device.builder.add_extension(
-            x509.BasicConstraints(ca=False, path_length=None),
-            critical=True)
+            x509.BasicConstraints(ca=False, path_length=None), critical=True
+        )
         self.device.builder = self.device.builder.add_extension(
             x509.KeyUsage(
                 digital_signature=True,
                 content_commitment=False,
                 key_encipherment=False,
                 data_encipherment=False,
                 key_agreement=True,
                 key_cert_sign=False,
                 crl_sign=False,
                 encipher_only=False,
-                decipher_only=False),
-            critical=True)
+                decipher_only=False,
+            ),
+            critical=True,
+        )
         self.device.builder = self.device.builder.add_extension(
-            x509.SubjectKeyIdentifier.from_public_key(public_key),
-            critical=False)
-        issuer_ski = \
-            self.signer.certificate.extensions.get_extension_for_class(
-                x509.SubjectKeyIdentifier)
+            x509.SubjectKeyIdentifier.from_public_key(public_key), critical=False
+        )
+        issuer_ski = self.signer.certificate.extensions.get_extension_for_class(
+            x509.SubjectKeyIdentifier
+        )
         self.device.builder = self.device.builder.add_extension(
-            x509.AuthorityKeyIdentifier.from_issuer_subject_key_identifier(
-                issuer_ski.value),
-            critical=False)
+            x509.AuthorityKeyIdentifier.from_issuer_subject_key_identifier(issuer_ski.value),
+            critical=False,
+        )
 
         self.device.sign_builder(self.signer.key.private_key)
 
-    def set_tflex_certificates(self, root_cert=None,
-                               signer_cert=None, device_cert=None):
-        '''
+    def set_tflex_certificates(self, root_cert=None, signer_cert=None, device_cert=None):
+        """
         Sets TrustFLEX certificates to be processed
-        '''
+        """
         if root_cert:
             self.root.set_certificate(root_cert)
 
         if signer_cert:
             self.signer.set_certificate(signer_cert)
 
         if device_cert:
@@ -278,81 +313,69 @@
 
     def is_certificate_chain_valid(self):
         """
         Function to verify the certificate chain
         and return the status of it.
         """
         return (
-            self.root.is_signature_valid(self.root.key.get_public_key()) and
-            self.signer.is_signature_valid(self.root.key.get_public_key()) and
-            self.device.is_signature_valid(self.signer.key.get_public_key()))
+            self.root.is_signature_valid(self.root.key.get_public_key())
+            and self.signer.is_signature_valid(self.root.key.get_public_key())
+            and self.device.is_signature_valid(self.signer.key.get_public_key())
+        )
 
-    def get_tflex_py_definitions(self, signer_def_file='', device_def_file=''):
+    def get_tflex_py_definitions(self, signer_def_file="", device_def_file=""):
         py_def = dict()
 
         cert_def = CertDef(self.device_name)
         if signer_def_file and os.path.exists(signer_def_file):
-            py_def.update({
-                'signer': cert_def.get_py_definition(signer_def_file)
-            })
+            py_def.update({"signer": cert_def.get_py_definition(signer_def_file)})
         elif self.signer.certificate and self.root.certificate:
-            cert_def.set_certificate(
-                self.signer.certificate, self.root.certificate, 1)
-            py_def.update({
-                'signer': cert_def.get_py_definition()
-            })
+            cert_def.set_certificate(self.signer.certificate, self.root.certificate, 1)
+            py_def.update({"signer": cert_def.get_py_definition()})
         else:
-            raise ValueError('Neither Signer certificate set nor def file passed')
+            raise ValueError("Neither Signer certificate set nor def file passed")
 
         cert_def = CertDef(self.device_name)
         if device_def_file and os.path.exists(device_def_file):
-            py_def.update({
-                'device': cert_def.get_py_definition(device_def_file)
-            })
+            py_def.update({"device": cert_def.get_py_definition(device_def_file)})
         elif self.device.certificate and self.signer.certificate:
-            cert_def.set_certificate(
-                self.device.certificate, self.signer.certificate, 3)
-            py_def.update({
-                'device': cert_def.get_py_definition()
-            })
+            cert_def.set_certificate(self.device.certificate, self.signer.certificate, 3)
+            py_def.update({"device": cert_def.get_py_definition()})
         else:
-            raise ValueError('Neither Device certificate set nor def file passed')
+            raise ValueError("Neither Device certificate set nor def file passed")
 
         return py_def
 
     def save_tflex_c_definitions(self):
         cert_def = CertDef(self.device_name)
         if self.signer.certificate and self.root.certificate:
-            cert_def.set_certificate(
-                self.signer.certificate, self.root.certificate, 1)
+            cert_def.set_certificate(self.signer.certificate, self.root.certificate, 1)
             cert_def.get_c_definition(True)
         else:
-            raise ValueError('Signer and Root should be set first')
+            raise ValueError("Signer and Root should be set first")
 
         cert_def = CertDef(self.device_name)
         if self.device.certificate and self.signer.certificate:
-            cert_def.set_certificate(
-                self.device.certificate, self.signer.certificate, 3)
+            cert_def.set_certificate(self.device.certificate, self.signer.certificate, 3)
             cert_def.get_c_definition(True)
         else:
-            raise ValueError('Device and Signer should be set first')
-
-    def save_tflex_py_definitions(self, signer_def_file='',
-                                  device_def_file=''):
+            raise ValueError("Device and Signer should be set first")
 
+    def save_tflex_py_definitions(self, signer_def_file="", device_def_file=""):
         if signer_def_file:
             cert_def = CertDef(self.device_name)
             if self.signer.certificate and self.root.certificate:
-                cert_def.set_certificate(
-                    self.signer.certificate, self.root.certificate, 1)
+                cert_def.set_certificate(self.signer.certificate, self.root.certificate, 1)
                 cert_def.get_py_definition(dest_def_file=signer_def_file)
             else:
-                raise ValueError('Signer and Root should be set first')
+                raise ValueError("Signer and Root should be set first")
 
         if device_def_file:
             cert_def = CertDef(self.device_name)
             if self.device.certificate and self.signer.certificate:
-                cert_def.set_certificate(
-                    self.device.certificate, self.signer.certificate, 3)
+                cert_def.set_certificate(self.device.certificate, self.signer.certificate, 3)
                 cert_def.get_py_definition(dest_def_file=device_def_file)
             else:
-                raise ValueError('Device and Signer should be set first')
+                raise ValueError("Device and Signer should be set first")
+
+
+__all__ = ["TFLEXCerts"]
```

## tpds/certs/timefix_backend.py

```diff
@@ -1,5 +1,8 @@
 from tpds.cert_tools import timefix_backend
 
 
 class TimeFixBackend(timefix_backend.TimeFixBackend):
     pass
+
+
+__all__ = ["TimeFixBackend"]
```

## tpds/certs/wpc_cert_def.py

```diff
@@ -15,33 +15,38 @@
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 
 import os
 import re
+from ctypes import POINTER, c_uint8, cast, create_string_buffer, pointer, string_at
+from pathlib import Path
+
+import _pickle
 import asn1crypto
 import cryptoauthlib as cal
-from pathlib import Path
-from .cert_utils import get_ca_status, get_device_sn_cert
 from cryptography import x509
-from .x509_find_elements import (
-    tbs_location, public_key_location,
-    signature_location, validity_location,
-    name_search_location, sn_location,
-    auth_key_id_location, subj_key_id_location,
-    diff_offset)
-from ctypes import (
-    cast, c_uint8, POINTER, string_at,
-    pointer, create_string_buffer)
 from cryptography.hazmat.primitives import serialization
-import _pickle
+
+from .cert_utils import get_ca_status
+from .x509_find_elements import (
+    auth_key_id_location,
+    diff_offset,
+    name_search_location,
+    public_key_location,
+    signature_location,
+    sn_location,
+    subj_key_id_location,
+    tbs_location,
+    validity_location,
+)
 
 
-class WPCCertDef():
+class WPCCertDef:
     def __init__(self):
         self.set_cert = False
         pass
 
     def set_certificate(self, cert, ca_cert, template_id=0, serial_no=None):
         """
         Sets a certificate along with its CA to be processed for definition
@@ -51,68 +56,63 @@
         self.ca_cert = ca_cert
         self.template_id = template_id
         self.chain_id = 3
         if get_ca_status(cert):
             self.chain_level = 1
             self.ca_cert_def = None
             self.signer_id = None
-            self.cert_def_name = 'signer'
+            self.cert_def_name = "signer"
             self.ca_include_filename = None
             self.ca_cert_def_var_name = None
-            self.filename_base = \
-                f'cust_def_{self.cert_def_name}'
+            self.filename_base = f"cust_def_{self.cert_def_name}"
         else:
             self.chain_level = 0
             self.ca_cert_def = self.__get_signer_template(ca_cert)
             self.signer_id = None
-            self.cert_def_name = 'device'
-            self.ca_include_filename = 'cust_def_1_signer.h'
-            self.ca_cert_def_var_name = 'g_cert_def_1_signer'
-            self.filename_base = \
-                f'cust_def_{self.cert_def_name}'
+            self.cert_def_name = "device"
+            self.ca_include_filename = "cust_def_1_signer.h"
+            self.ca_cert_def_var_name = "g_cert_def_1_signer"
+            self.filename_base = f"cust_def_{self.cert_def_name}"
 
         self.cert_def = None
         self.cert_files = None
         self.set_cert = True
 
-    def get_py_definition(self, src_def_file='', dest_def_file=''):
+    def get_py_definition(self, src_def_file="", dest_def_file=""):
         """
         Returns the certificate definition and optionally saves to file
         """
         if src_def_file and os.path.exists(src_def_file):
             with open(src_def_file, "rb") as fp:
                 definition = _pickle.load(fp)
-            if definition is not None and \
-                    'params' in definition and \
-                    'elements' in definition and \
-                    'template_data' in definition:
-                params = definition.get('params')
-                elements = definition.get('elements')
-                template_data = definition.get('template_data')
-                cert_def = self.__params_atcacert_definitions(
-                    template_data, params, elements)
+            if (
+                definition is not None
+                and "params" in definition
+                and "elements" in definition
+                and "template_data" in definition
+            ):
+                params = definition.get("params")
+                elements = definition.get("elements")
+                template_data = definition.get("template_data")
+                cert_def = self.__params_atcacert_definitions(template_data, params, elements)
             else:
-                raise ValueError('Invalid certificate definition file')
+                raise ValueError("Invalid certificate definition file")
         elif self.set_cert:
             cert_def = self.__build_py_definition()
             self.cert_def = cert_def
 
         if self.set_cert and dest_def_file:
             cert = dict()
             params = self.__get_cert_params()
-            params.update({'ca_cert_def': None})
-            cert.update({
-                'template_data':
-                    self.cert.public_bytes(encoding=serialization.Encoding.DER)
-                })
-            cert.update({
-                'elements':
-                    self.__get_cert_elements()
-                })
-            cert.update({'params': params})
+            params.update({"ca_cert_def": None})
+            cert.update(
+                {"template_data": self.cert.public_bytes(encoding=serialization.Encoding.DER)}
+            )
+            cert.update({"elements": self.__get_cert_elements()})
+            cert.update({"params": params})
             Path(dest_def_file).write_bytes(_pickle.dumps(cert))
 
         return cert_def
 
     def get_c_definition(self, save_files=False):
         """
         Returns the certificate C definitions and optionally saves to file
@@ -127,442 +127,411 @@
 
             return self.cert_files
 
     def __build_py_definition(self):
         """
         Function to build and return the certificate definition
         """
-        template_data = self.cert.public_bytes(
-                                    encoding=serialization.Encoding.DER)
+        template_data = self.cert.public_bytes(encoding=serialization.Encoding.DER)
         params = self.__get_cert_params()
         elements = self.__get_cert_elements()
-        return self.__params_atcacert_definitions(
-                                    template_data, params, elements)
+        return self.__params_atcacert_definitions(template_data, params, elements)
 
     def __build_c_definition(self):
         """
         Function to build and return the C certificate definition
         """
-        template_var_name = f'g_template_{self.cert_def.template_id}_{self.cert_def_name}'
-        pk_var_name = f'g_cert_ca_public_key_{self.cert_def.template_id}_{self.cert_def_name}'
-        elements_var_name = f'g_cert_elements_{self.cert_def.template_id}_{self.cert_def_name}'
-        cert_def_var_name = f'g_cert_def_{self.cert_def.template_id}_{self.cert_def_name}'
+        template_var_name = f"g_template_{self.cert_def.template_id}_{self.cert_def_name}"
+        pk_var_name = f"g_cert_ca_public_key_{self.cert_def.template_id}_{self.cert_def_name}"
+        elements_var_name = f"g_cert_elements_{self.cert_def.template_id}_{self.cert_def_name}"
+        cert_def_var_name = f"g_cert_def_{self.cert_def.template_id}_{self.cert_def_name}"
 
-        c_file = ''
+        c_file = ""
         c_file += '#include "atcacert/atcacert_def.h"\n'
         if self.ca_include_filename:
             c_file += f'#include "{self.ca_include_filename}"\n'
-        c_file += '\n'
+        c_file += "\n"
 
-        template_data = string_at(
-                        self.cert_def.cert_template,
-                        self.cert_def.cert_template_size)
-        c_file += f'const uint8_t {template_var_name}[{len(template_data)}] = {self.__c_hex_array(template_data)};\n'
-        c_file += '\n'
+        template_data = string_at(self.cert_def.cert_template, self.cert_def.cert_template_size)
+        c_file += f"const uint8_t {template_var_name}[{len(template_data)}] = {self.__c_hex_array(template_data)};\n"
+        c_file += "\n"
 
         if self.chain_level == 1:
             pk_data = self.ca_cert.public_key().public_bytes(
                 format=serialization.PublicFormat.UncompressedPoint,
-                encoding=serialization.Encoding.X962
+                encoding=serialization.Encoding.X962,
             )[1:]
-            c_file += f'const uint8_t {pk_var_name}[{len(pk_data)}] = \
-                    {self.__c_hex_array(pk_data)};\n'
-            c_file += '\n'
+            c_file += f"const uint8_t {pk_var_name}[{len(pk_data)}] = \
+                    {self.__c_hex_array(pk_data)};\n"
+            c_file += "\n"
 
         if self.cert_def.cert_elements_count:
             element_strs = []
             for i in range(self.cert_def.cert_elements_count):
                 element = self.cert_def.cert_elements[i]
-                element_str = ''
-                element_str += f'    {{\n'
+                element_str = ""
+                element_str += "    {{\n"
                 element_str += f'        .id = "{element.id if isinstance(element.id, str) else element.id.decode("ascii")}",\n'
-                element_str += f'        .device_loc = {{\n'
-                element_str += \
-                    self.__device_loc_to_c(
-                        element.device_loc, indent='            ') + '\n'
-                element_str += f'        }},\n'
-                element_str += f'        .cert_loc = {{\n'
-                element_str += self.__cert_loc_to_c(
-                    element.cert_loc, indent='            ') + '\n'
-                element_str += f'        }},\n'
-                element_str += f'        .transforms = {{\n'
-                element_str += ',\n'.join(
-                    [f'            {cal.atcacert_transform_t(v).name}'
-                        for v in element.transforms]) + '\n'
-                element_str += f'        }}\n'
-                element_str += f'    }}'
+                element_str += "        .device_loc = {{\n"
+                element_str += (
+                    self.__device_loc_to_c(element.device_loc, indent="            ") + "\n"
+                )
+                element_str += "        }},\n"
+                element_str += "        .cert_loc = {{\n"
+                element_str += self.__cert_loc_to_c(element.cert_loc, indent="            ") + "\n"
+                element_str += "        }},\n"
+                element_str += "        .transforms = {{\n"
+                element_str += (
+                    ",\n".join(
+                        [
+                            f"            {cal.atcacert_transform_t(v).name}"
+                            for v in element.transforms
+                        ]
+                    )
+                    + "\n"
+                )
+                element_str += "        }}\n"
+                element_str += "    }}"
                 element_strs.append(element_str)
 
-            c_file += \
-                f'const atcacert_cert_element_t {elements_var_name}[{self.cert_def.cert_elements_count}] = {{\n'
-            c_file += ',\n'.join(element_strs) + '\n'
-            c_file += '};\n'
-            c_file += '\n'
-
-        c_file += f'const atcacert_def_t {cert_def_var_name} = {{\n'
-        c_file += f'    .type = {cal.atcacert_cert_type_t(self.cert_def.type).name},\n'
-        c_file += f'    .template_id = {self.cert_def.template_id},\n'
-        c_file += f'    .chain_id = {self.cert_def.chain_id},\n'
-        c_file += f'    .private_key_slot = {self.cert_def.private_key_slot},\n'
-        c_file += f'    .sn_source = {cal.atcacert_cert_sn_src_t(self.cert_def.sn_source).name},\n'
-        c_file += f'    .cert_sn_dev_loc = {{\n'
-        c_file += self.__device_loc_to_c(
-            self.cert_def.cert_sn_dev_loc,
-            indent='        ') + '\n'
-        c_file += f'    }},\n'
+            c_file += f"const atcacert_cert_element_t {elements_var_name}[{self.cert_def.cert_elements_count}] = {{\n"
+            c_file += ",\n".join(element_strs) + "\n"
+            c_file += "};\n"
+            c_file += "\n"
+
+        c_file += f"const atcacert_def_t {cert_def_var_name} = {{\n"
+        c_file += f"    .type = {cal.atcacert_cert_type_t(self.cert_def.type).name},\n"
+        c_file += f"    .template_id = {self.cert_def.template_id},\n"
+        c_file += f"    .chain_id = {self.cert_def.chain_id},\n"
+        c_file += f"    .private_key_slot = {self.cert_def.private_key_slot},\n"
+        c_file += f"    .sn_source = {cal.atcacert_cert_sn_src_t(self.cert_def.sn_source).name},\n"
+        c_file += "    .cert_sn_dev_loc = {{\n"
+        c_file += self.__device_loc_to_c(self.cert_def.cert_sn_dev_loc, indent="        ") + "\n"
+        c_file += "    }},\n"
         date_format = self.cert_def.issue_date_format
-        c_file += f'    .issue_date_format = {cal.atcacert_date_format_t(date_format).name},\n'
+        c_file += f"    .issue_date_format = {cal.atcacert_date_format_t(date_format).name},\n"
         date_format = self.cert_def.expire_date_format
-        c_file += f'    .expire_date_format = {cal.atcacert_date_format_t(date_format).name},\n'
-        c_file += f'    .tbs_cert_loc = {{\n'
-        c_file += self.__cert_loc_to_c(
-            self.cert_def.tbs_cert_loc,
-            indent='        ') + '\n'
-        c_file += f'    }},\n'
-        c_file += f'    .expire_years = {self.cert_def.expire_years},\n'
-        c_file += f'    .public_key_dev_loc = {{\n'
-        c_file += self.__device_loc_to_c(
-            self.cert_def.public_key_dev_loc,
-            indent='        ') + '\n'
-        c_file += f'    }},\n'
-        c_file += f'    .comp_cert_dev_loc = {{\n'
-        c_file += self.__device_loc_to_c(
-            self.cert_def.comp_cert_dev_loc,
-            indent='        ') + '\n'
-        c_file += f'    }},\n'
+        c_file += f"    .expire_date_format = {cal.atcacert_date_format_t(date_format).name},\n"
+        c_file += "    .tbs_cert_loc = {{\n"
+        c_file += self.__cert_loc_to_c(self.cert_def.tbs_cert_loc, indent="        ") + "\n"
+        c_file += "    }},\n"
+        c_file += f"    .expire_years = {self.cert_def.expire_years},\n"
+        c_file += "    .public_key_dev_loc = {{\n"
+        c_file += self.__device_loc_to_c(self.cert_def.public_key_dev_loc, indent="        ") + "\n"
+        c_file += "    }},\n"
+        c_file += "    .comp_cert_dev_loc = {{\n"
+        c_file += self.__device_loc_to_c(self.cert_def.comp_cert_dev_loc, indent="        ") + "\n"
+        c_file += "    }},\n"
         std_element_names = [
-            'STDCERT_PUBLIC_KEY',
-            'STDCERT_SIGNATURE',
-            'STDCERT_ISSUE_DATE',
-            'STDCERT_EXPIRE_DATE',
-            'STDCERT_SIGNER_ID',
-            'STDCERT_CERT_SN',
-            'STDCERT_AUTH_KEY_ID',
-            'STDCERT_SUBJ_KEY_ID'
+            "STDCERT_PUBLIC_KEY",
+            "STDCERT_SIGNATURE",
+            "STDCERT_ISSUE_DATE",
+            "STDCERT_EXPIRE_DATE",
+            "STDCERT_SIGNER_ID",
+            "STDCERT_CERT_SN",
+            "STDCERT_AUTH_KEY_ID",
+            "STDCERT_SUBJ_KEY_ID",
         ]
-        c_file += f'    .std_cert_elements = {{\n'
+        c_file += "    .std_cert_elements = {{\n"
         for i, name in enumerate(std_element_names):
-            c_file += f'        {{ // {name}\n'
-            c_file += self.__cert_loc_to_c(
-                self.cert_def.std_cert_elements[i],
-                indent='            ') + '\n'
-            c_file += f'        }},\n'
-        c_file += f'    }},\n'
+            c_file += f"        {{ // {name}\n"
+            c_file += (
+                self.__cert_loc_to_c(self.cert_def.std_cert_elements[i], indent="            ")
+                + "\n"
+            )
+            c_file += "        }},\n"
+        c_file += "    }},\n"
         if self.cert_def.cert_elements:
-            c_file += f'    .cert_elements = {elements_var_name},\n'
-            c_file += f'    .cert_elements_count = sizeof({elements_var_name}) / sizeof({elements_var_name}[0]),\n'
+            c_file += f"    .cert_elements = {elements_var_name},\n"
+            c_file += f"    .cert_elements_count = sizeof({elements_var_name}) / sizeof({elements_var_name}[0]),\n"
         else:
-            c_file += f'    .cert_elements = NULL,\n'
-            c_file += f'    .cert_elements_count = 0,\n'
-        c_file += f'    .cert_template = {template_var_name},\n'
-        c_file += f'    .cert_template_size = sizeof({template_var_name}),\n'
+            c_file += "    .cert_elements = NULL,\n"
+            c_file += "    .cert_elements_count = 0,\n"
+        c_file += f"    .cert_template = {template_var_name},\n"
+        c_file += f"    .cert_template_size = sizeof({template_var_name}),\n"
         if self.ca_cert_def_var_name:
-            c_file += f'    .ca_cert_def = &{self.ca_cert_def_var_name}\n'
+            c_file += f"    .ca_cert_def = &{self.ca_cert_def_var_name}\n"
         else:
-            c_file += f'    .ca_cert_def = NULL\n'
-        c_file += f'}};\n'
+            c_file += "    .ca_cert_def = NULL\n"
+        c_file += "}};\n"
 
-        h_file = ''
-        h_file += f'#ifndef {self.filename_base.upper()}_H\n'
-        h_file += f'#define {self.filename_base.upper()}_H\n'
-        h_file += f'\n'
-        h_file += f'#include "atcacert/atcacert_def.h"\n'
-        h_file += f'\n'
-        h_file += f'#ifdef __cplusplus\n'
-        h_file += f'extern "C" {{\n'
-        h_file += f'#endif\n'
-        h_file += f'extern const atcacert_def_t {cert_def_var_name};\n'
+        h_file = ""
+        h_file += f"#ifndef {self.filename_base.upper()}_H\n"
+        h_file += f"#define {self.filename_base.upper()}_H\n"
+        h_file += "\n"
+        h_file += '#include "atcacert/atcacert_def.h"\n'
+        h_file += "\n"
+        h_file += "#ifdef __cplusplus\n"
+        h_file += 'extern "C" {{\n'
+        h_file += "#endif\n"
+        h_file += f"extern const atcacert_def_t {cert_def_var_name};\n"
         if self.chain_level == 1:
-            h_file += f'extern const uint8_t {pk_var_name}[];\n'
-        h_file += f'#ifdef __cplusplus\n'
-        h_file += f'}}\n'
-        h_file += f'#endif\n'
-        h_file += '\n'
-        h_file += '#endif\n'
+            h_file += f"extern const uint8_t {pk_var_name}[];\n"
+        h_file += "#ifdef __cplusplus\n"
+        h_file += "}}\n"
+        h_file += "#endif\n"
+        h_file += "\n"
+        h_file += "#endif\n"
 
         return {
-            f'{self.filename_base}.c': c_file.encode('utf-8'),
-            f'{self.filename_base}.h': h_file.encode('utf-8')
+            f"{self.filename_base}.c": c_file.encode("utf-8"),
+            f"{self.filename_base}.h": h_file.encode("utf-8"),
         }
 
     def __get_cert_params(self):
-        template_data = self.cert.public_bytes(
-            encoding=serialization.Encoding.DER)
-        asn1_cert = asn1crypto.x509.Certificate().load(
-            template_data, strict=True)
+        template_data = self.cert.public_bytes(encoding=serialization.Encoding.DER)
+        asn1_cert = asn1crypto.x509.Certificate().load(template_data, strict=True)
 
         tbs_offset, tbs_count = tbs_location(asn1_cert)
-        expire_years = self.cert.not_valid_after.year \
-            - self.cert.not_valid_before.year
+        expire_years = self.cert.not_valid_after.year - self.cert.not_valid_before.year
         if expire_years > 31:
             expire_years = 0  # Assume no expiration
         pk_offset, pk_count = public_key_location(asn1_cert)
         sig_offset, sig_count = signature_location(asn1_cert)
-        nb_offset, nb_count = validity_location(
-            asn1_cert,
-            'not_before')
+        nb_offset, nb_count = validity_location(asn1_cert, "not_before")
         na_offset, na_count = (0, 0)
         sid_offset, sid_count = (0, 0)
         sn_offset, sn_count = sn_location(asn1_cert)
         akid_offset, akid_count = auth_key_id_location(asn1_cert)
         skid_offset, skid_count = subj_key_id_location(asn1_cert)
         if self.chain_level == 0:
             sn_source = cal.atcacert_cert_sn_src_t.SNSRC_PUB_KEY_HASH
             cert_sn_dev_loc = {
-                'zone': cal.atcacert_device_zone_t.DEVZONE_NONE,
-                'slot': 0,
-                'is_genkey': 0,
-                'offset': 0,
-                'count': 0,
+                "zone": cal.atcacert_device_zone_t.DEVZONE_NONE,
+                "slot": 0,
+                "is_genkey": 0,
+                "offset": 0,
+                "count": 0,
             }
             issue_date_format = cal.atcacert_date_format_t.DATEFMT_RFC5280_GEN
         else:
             sn_source = cal.atcacert_cert_sn_src_t.SNSRC_STORED_DYNAMIC
             cert_sn_dev_loc = {
-                'zone': cal.atcacert_device_zone_t.DEVZONE_DATA,
-                'slot': 4,
-                'is_genkey': 0,
-                'offset': 0,
-                'count': sn_count+1,
+                "zone": cal.atcacert_device_zone_t.DEVZONE_DATA,
+                "slot": 4,
+                "is_genkey": 0,
+                "offset": 0,
+                "count": sn_count + 1,
             }
             issue_date_format = cal.atcacert_date_format_t.DATEFMT_RFC5280_UTC
 
         params = {
-            'type': cal.atcacert_cert_type_t.CERTTYPE_X509,
-            'template_id': self.template_id,
-            'chain_id': self.chain_id,
-            'private_key_slot': 0,
-            'sn_source': sn_source,
-            'cert_sn_dev_loc': cert_sn_dev_loc,
-            'issue_date_format': issue_date_format,
-            'expire_date_format': cal.atcacert_date_format_t.DATEFMT_RFC5280_GEN,
-            'tbs_cert_loc': {
-                'offset': tbs_offset,
-                'count': tbs_count
+            "type": cal.atcacert_cert_type_t.CERTTYPE_X509,
+            "template_id": self.template_id,
+            "chain_id": self.chain_id,
+            "private_key_slot": 0,
+            "sn_source": sn_source,
+            "cert_sn_dev_loc": cert_sn_dev_loc,
+            "issue_date_format": issue_date_format,
+            "expire_date_format": cal.atcacert_date_format_t.DATEFMT_RFC5280_GEN,
+            "tbs_cert_loc": {"offset": tbs_offset, "count": tbs_count},
+            "expire_years": expire_years,
+            "public_key_dev_loc": {
+                "zone": cal.atcacert_device_zone_t.DEVZONE_DATA,
+                "slot": 0 if self.chain_level == 0 else 9,
+                "is_genkey": 1 if self.chain_level == 0 else 0,
+                "offset": 0,
+                "count": 64 if self.chain_level == 0 else 72,
             },
-            'expire_years': expire_years,
-            'public_key_dev_loc': {
-                'zone': cal.atcacert_device_zone_t.DEVZONE_DATA,
-                'slot': 0 if self.chain_level == 0 else 9,
-                'is_genkey': 1 if self.chain_level == 0 else 0,
-                'offset': 0,
-                'count': 64 if self.chain_level == 0 else 72
+            "comp_cert_dev_loc": {
+                "zone": cal.atcacert_device_zone_t.DEVZONE_DATA,
+                "slot": 13 if self.chain_level == 0 else 14,
+                "is_genkey": 0,
+                "offset": 0,
+                "count": 72,
             },
-            'comp_cert_dev_loc': {
-                'zone': cal.atcacert_device_zone_t.DEVZONE_DATA,
-                'slot': 13 if self.chain_level == 0 else 14,
-                'is_genkey': 0,
-                'offset': 0,
-                'count': 72
-            },
-            'std_cert_elements': [
+            "std_cert_elements": [
                 # STDCERT_PUBLIC_KEY
-                {'offset': pk_offset, 'count': pk_count},
+                {"offset": pk_offset, "count": pk_count},
                 # STDCERT_SIGNATURE
-                {'offset': sig_offset, 'count': sig_count},
+                {"offset": sig_offset, "count": sig_count},
                 # STDCERT_ISSUE_DATE
-                {'offset': nb_offset, 'count': nb_count},
+                {"offset": nb_offset, "count": nb_count},
                 # STDCERT_EXPIRE_DATE
-                {'offset': na_offset, 'count': na_count},
+                {"offset": na_offset, "count": na_count},
                 # STDCERT_SIGNER_ID
-                {'offset': sid_offset, 'count': sid_count},
+                {"offset": sid_offset, "count": sid_count},
                 # STDCERT_CERT_SN
-                {'offset': sn_offset-self.chain_level, 'count': sn_count+self.chain_level},
+                {"offset": sn_offset - self.chain_level, "count": sn_count + self.chain_level},
                 # STDCERT_AUTH_KEY_ID
-                {'offset': akid_offset, 'count': akid_count},
+                {"offset": akid_offset, "count": akid_count},
                 # STDCERT_SUBJ_KEY_ID
-                {'offset': skid_offset, 'count': skid_count}
+                {"offset": skid_offset, "count": skid_count},
             ],
-            'ca_cert_def':
-                pointer(self.ca_cert_def) if self.ca_cert_def else None
+            "ca_cert_def": pointer(self.ca_cert_def) if self.ca_cert_def else None,
         }
         return params
 
     def __get_cert_elements(self):
-        template_data = \
-            self.cert.public_bytes(encoding=serialization.Encoding.DER)
-        asn1_cert = \
-            asn1crypto.x509.Certificate().load(template_data, strict=True)
+        template_data = self.cert.public_bytes(encoding=serialization.Encoding.DER)
+        asn1_cert = asn1crypto.x509.Certificate().load(template_data, strict=True)
         elements = []
 
         if self.chain_level:
-            nb_offset, nb_count = validity_location(asn1_cert, 'not_before')
+            nb_offset, nb_count = validity_location(asn1_cert, "not_before")
             elements.append(
                 {
-                    'id': 'IssueDate',
-                    'device_loc': {
-                        'zone': cal.atcacert_device_zone_t.DEVZONE_DATA,
-                        'slot': 4,
-                        'is_genkey': 0,
-                        'offset': 12,
-                        'count': nb_count
+                    "id": "IssueDate",
+                    "device_loc": {
+                        "zone": cal.atcacert_device_zone_t.DEVZONE_DATA,
+                        "slot": 4,
+                        "is_genkey": 0,
+                        "offset": 12,
+                        "count": nb_count,
                     },
-                    'cert_loc': {
-                        'offset': nb_offset,
-                        'count': nb_count
-                    }
+                    "cert_loc": {"offset": nb_offset, "count": nb_count},
                 }
             )
             sub_offset, sub_count = name_search_location(
                 cert=asn1_cert,
-                name='subject',
-                search=asn1_cert['tbs_certificate']['subject'].native.get('common_name', ''))
+                name="subject",
+                search=asn1_cert["tbs_certificate"]["subject"].native.get("common_name", ""),
+            )
             elements.append(
                 {
-                    'id': 'subject',
-                    'device_loc': {
-                        'zone': cal.atcacert_device_zone_t.DEVZONE_DATA,
-                        'slot': 4,
-                        'is_genkey': 0,
-                        'offset': 25,
-                        'count': sub_count
+                    "id": "subject",
+                    "device_loc": {
+                        "zone": cal.atcacert_device_zone_t.DEVZONE_DATA,
+                        "slot": 4,
+                        "is_genkey": 0,
+                        "offset": 25,
+                        "count": sub_count,
                     },
-                    'cert_loc': {
-                        'offset': sub_offset,
-                        'count': sub_count
-                    }
+                    "cert_loc": {"offset": sub_offset, "count": sub_count},
                 }
             )
             qi_offset, qi_count = self.get_qi_extension_location(asn1_cert)
             elements.append(
                 {
-                    'id': 'qiPolicy',
-                    'device_loc': {
-                        'zone': cal.atcacert_device_zone_t.DEVZONE_DATA,
-                        'slot': 4,
-                        'is_genkey': 0,
-                        'offset': 32,
-                        'count': qi_count-2
+                    "id": "qiPolicy",
+                    "device_loc": {
+                        "zone": cal.atcacert_device_zone_t.DEVZONE_DATA,
+                        "slot": 4,
+                        "is_genkey": 0,
+                        "offset": 32,
+                        "count": qi_count - 2,
                     },
-                    'cert_loc': {
-                        'offset': qi_offset+2,
-                        'count': qi_count-2
-                    }
+                    "cert_loc": {"offset": qi_offset + 2, "count": qi_count - 2},
                 }
             )
         else:
             sub_offset, sub_count = name_search_location(
                 cert=asn1_cert,
-                name='issuer',
-                search=asn1_cert['tbs_certificate']['issuer'].native.get('common_name', ''))
+                name="issuer",
+                search=asn1_cert["tbs_certificate"]["issuer"].native.get("common_name", ""),
+            )
             elements.append(
                 {
-                    'id': 'issuer',
-                    'device_loc': {
-                        'zone': cal.atcacert_device_zone_t.DEVZONE_DATA,
-                        'slot': 5,
-                        'is_genkey': 0,
-                        'offset': 25,
-                        'count': sub_count
+                    "id": "issuer",
+                    "device_loc": {
+                        "zone": cal.atcacert_device_zone_t.DEVZONE_DATA,
+                        "slot": 5,
+                        "is_genkey": 0,
+                        "offset": 25,
+                        "count": sub_count,
                     },
-                    'cert_loc': {
-                        'offset': sub_offset,
-                        'count': sub_count
-                    }
+                    "cert_loc": {"offset": sub_offset, "count": sub_count},
                 }
             )
             qi_offset, qi_count = self.get_qi_extension_location(asn1_cert)
             elements.append(
                 {
-                    'id': 'RSID',
-                    'device_loc': {
-                        'zone': cal.atcacert_device_zone_t.DEVZONE_DATA,
-                        'slot': 5,
-                        'is_genkey': 0,
-                        'offset': 1,
-                        'count': qi_count-2
+                    "id": "RSID",
+                    "device_loc": {
+                        "zone": cal.atcacert_device_zone_t.DEVZONE_DATA,
+                        "slot": 5,
+                        "is_genkey": 0,
+                        "offset": 1,
+                        "count": qi_count - 2,
                     },
-                    'cert_loc': {
-                        'offset': qi_offset+2,
-                        'count': qi_count-2
-                    }
+                    "cert_loc": {"offset": qi_offset + 2, "count": qi_count - 2},
                 }
             )
         return elements
 
     def get_qi_extension_location(self, cert):
         cert_mod = cert.copy()
         if self.chain_level:
-            oid = asn1crypto.x509.ExtensionId('2.23.148.1.1')
+            oid = asn1crypto.x509.ExtensionId("2.23.148.1.1")
         else:
-            oid = asn1crypto.x509.ExtensionId('2.23.148.1.2')
+            oid = asn1crypto.x509.ExtensionId("2.23.148.1.2")
         is_found = False
-        for extension in cert_mod['tbs_certificate']['extensions']:
-            if extension['extn_id'] == oid:
+        for extension in cert_mod["tbs_certificate"]["extensions"]:
+            if extension["extn_id"] == oid:
                 is_found = True
                 break
         if not is_found:
             return (0, 0)
 
-        mod_key_id = bytearray(extension['extn_value'].native)
+        mod_key_id = bytearray(extension["extn_value"].native)
         mod_key_id[0] ^= 0xFF
         mod_auth_key_id = asn1crypto.core.ParsableOctetString(bytes(mod_key_id))
-        extension['extn_value'] = mod_auth_key_id
+        extension["extn_value"] = mod_auth_key_id
 
-        return (
-            diff_offset(cert, cert_mod),
-            len(mod_key_id))
+        return (diff_offset(cert, cert_mod), len(mod_key_id))
 
     def __get_signer_template(self, cert):
         signer = WPCCertDef()
         signer.set_certificate(cert, None)
         return signer.__build_py_definition()
 
     @staticmethod
     def __params_atcacert_definitions(template_data, params, elements):
         cert_def = cal.atcacert_def_t(**params)
         cert_def.cert_template_size = len(template_data)
-        cert_def.cert_template = cast(create_string_buffer(
-            template_data, cert_def.cert_template_size), POINTER(c_uint8))
+        cert_def.cert_template = cast(
+            create_string_buffer(template_data, cert_def.cert_template_size), POINTER(c_uint8)
+        )
 
         if elements:
             cert_def.cert_elements_count = len(elements)
             elems = [cal.atcacert_cert_element_t(**x) for x in elements]
-            elems_array = \
-                (cal.atcacert_cert_element_t * cert_def.cert_elements_count)(
-                    *elems)
-            cert_def.cert_elements = cast(elems_array, POINTER(
-                cal.atcacert_cert_element_t))
+            elems_array = (cal.atcacert_cert_element_t * cert_def.cert_elements_count)(*elems)
+            cert_def.cert_elements = cast(elems_array, POINTER(cal.atcacert_cert_element_t))
         return cert_def
 
     @staticmethod
-    def __device_loc_to_c(device_loc, indent=''):
+    def __device_loc_to_c(device_loc, indent=""):
         lines = [
-            f'.zone = {cal.atcacert_device_zone_t(device_loc.zone).name}',
-            f'.slot = {device_loc.slot}',
-            f'.is_genkey = {device_loc.is_genkey}',
-            f'.offset = {device_loc.offset}',
-            f'.count = {device_loc.count}',
+            f".zone = {cal.atcacert_device_zone_t(device_loc.zone).name}",
+            f".slot = {device_loc.slot}",
+            f".is_genkey = {device_loc.is_genkey}",
+            f".offset = {device_loc.offset}",
+            f".count = {device_loc.count}",
         ]
 
-        return ',\n'.join([f'{indent}{line}' for line in lines])
+        return ",\n".join([f"{indent}{line}" for line in lines])
 
     @staticmethod
-    def __cert_loc_to_c(cert_loc, indent=''):
+    def __cert_loc_to_c(cert_loc, indent=""):
         lines = [
-            f'.offset = {cert_loc.offset}',
-            f'.count = {cert_loc.count}',
+            f".offset = {cert_loc.offset}",
+            f".count = {cert_loc.count}",
         ]
 
-        return ',\n'.join([f'{indent}{line}' for line in lines])
+        return ",\n".join([f"{indent}{line}" for line in lines])
 
     @staticmethod
-    def __c_hex_array(data, indent='    ', bytes_per_line=16):
+    def __c_hex_array(data, indent="    ", bytes_per_line=16):
         lines = []
         for i in range(0, len(data), bytes_per_line):
-            lines.append(indent + ', '.join([
-                f'0x{v:02x}' for v in data[i:i+bytes_per_line]]) + ',')
-        return '{\n' + '\n'.join(lines) + '\n}'
+            lines.append(
+                indent + ", ".join([f"0x{v:02x}" for v in data[i : i + bytes_per_line]]) + ","
+            )
+        return "{\n" + "\n".join(lines) + "\n}"
 
     @staticmethod
     def __get_signer_id(cert):
         """
         Get the signer id from the certificate.
         """
         for attr in cert.subject:
             if attr.oid == x509.oid.NameOID.COMMON_NAME:
                 signer_id = attr.value[-4:]
-                if re.search('^[0-9A-F]{4}$', signer_id) is None:
+                if re.search("^[0-9A-F]{4}$", signer_id) is None:
                     raise ValueError(
-                            'signer_id={} must be 4 uppercase hex digits'
-                            .format(signer_id))
+                        "signer_id={} must be 4 uppercase hex digits".format(signer_id)
+                    )
                 return signer_id
+
+
+__all__ = ["WPCCertDef"]
```

## tpds/certs/x509_find_elements.py

```diff
@@ -14,177 +14,159 @@
 # KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 
 import asn1crypto.core
-import asn1crypto.x509
 import asn1crypto.keys
+import asn1crypto.x509
 
 
 def diff_offset(base, diff):
     """Return the index where the two parameters differ."""
     base = base.dump()
     diff = diff.dump()
     if len(base) != len(diff):
-        raise ValueError(
-            'len(base)=%d != len(diff)=%d' % (len(base), len(diff)))
+        raise ValueError("len(base)=%d != len(diff)=%d" % (len(base), len(diff)))
     for i in range(0, len(base)):
         if base[i] != diff[i]:
             return i
-    raise ValueError('base and diff are identical')
+    raise ValueError("base and diff are identical")
 
 
 def sn_location(cert):
     cert_mod = cert.copy()
-    sn = bytearray(cert_mod['tbs_certificate']['serial_number'].contents)
+    sn = bytearray(cert_mod["tbs_certificate"]["serial_number"].contents)
     # Alter the serial number to find offset, but retain encoding size
     sn[0] = 0x01 if sn[0] != 0x01 else 0x02
-    cert_mod['tbs_certificate']['serial_number'] = asn1crypto.core.Integer(
-        int().from_bytes(sn, byteorder='big', signed=True))
-    return (
-        diff_offset(cert, cert_mod),
-        len(cert['tbs_certificate']['serial_number'].contents))
+    cert_mod["tbs_certificate"]["serial_number"] = asn1crypto.core.Integer(
+        int().from_bytes(sn, byteorder="big", signed=True)
+    )
+    return (diff_offset(cert, cert_mod), len(cert["tbs_certificate"]["serial_number"].contents))
 
 
 def validity_location(cert, name):
     cert_mod = cert.copy()
-    time = cert['tbs_certificate']['validity'][name]
+    time = cert["tbs_certificate"]["validity"][name]
     if time.chosen.tag == asn1crypto.core.UTCTime.tag:
         if time.chosen.native.year >= 2000 and time.chosen.native.year < 2010:
             new_time = time.chosen.native.replace(year=2010)
         else:
             new_time = time.chosen.native.replace(year=2000)
-        cert_mod['tbs_certificate']['validity'][name] = asn1crypto.x509.Time(
-            name='utc_time',
-            value=asn1crypto.core.UTCTime(new_time))
+        cert_mod["tbs_certificate"]["validity"][name] = asn1crypto.x509.Time(
+            name="utc_time", value=asn1crypto.core.UTCTime(new_time)
+        )
     elif time.chosen.tag == asn1crypto.core.GeneralizedTime.tag:
         if time.chosen.native.year >= 2000 and time.chosen.native.year < 3000:
             new_time = time.chosen.native.replace(year=3000)
         else:
             new_time = time.chosen.native.replace(year=2000)
-        cert_mod['tbs_certificate']['validity'][name] = asn1crypto.x509.Time(
-            name='general_time',
-            value=asn1crypto.core.GeneralizedTime(new_time))
+        cert_mod["tbs_certificate"]["validity"][name] = asn1crypto.x509.Time(
+            name="general_time", value=asn1crypto.core.GeneralizedTime(new_time)
+        )
     else:
-        raise ValueError(
-            'Unexpected tag value ({}) for validity {}'.format(
-                time.chosen.tag, name))
+        raise ValueError("Unexpected tag value ({}) for validity {}".format(time.chosen.tag, name))
     return (
         diff_offset(cert, cert_mod),
-        len(cert['tbs_certificate']['validity'][name].chosen.contents))
+        len(cert["tbs_certificate"]["validity"][name].chosen.contents),
+    )
 
 
 def public_key_location(cert):
     cert_mod = cert.copy()
-    public_key = bytearray(cert[
-        'tbs_certificate']['subject_public_key_info'][
-            'public_key'].native)
+    public_key = bytearray(cert["tbs_certificate"]["subject_public_key_info"]["public_key"].native)
     # Change the first byte of the public key skipping the key-compression byte
     public_key[1] ^= 0xFF
-    cert_mod['tbs_certificate']['subject_public_key_info']['public_key'] \
-        = asn1crypto.keys.ECPointBitString(bytes(public_key))
+    cert_mod["tbs_certificate"]["subject_public_key_info"][
+        "public_key"
+    ] = asn1crypto.keys.ECPointBitString(bytes(public_key))
     return (
         diff_offset(cert, cert_mod),
-        len(cert[
-            'tbs_certificate']['subject_public_key_info'][
-                'public_key'].native)-1)
+        len(cert["tbs_certificate"]["subject_public_key_info"]["public_key"].native) - 1,
+    )
 
 
 def name_search_location(cert, name, search):
     cert_mod = cert.copy()
     # Change the first character of the search text for the replacement text
     search = search.encode()
-    replace = (b'F' if search[0] != ord(b'F') else b'0') + search[1:]
-    name_der = cert['tbs_certificate'][name].dump()
+    replace = (b"F" if search[0] != ord(b"F") else b"0") + search[1:]
+    name_der = cert["tbs_certificate"][name].dump()
     if search not in name_der:
-        raise ValueError(
-            'Could not find "{}" in certificate {} name.'.format(search, name))
-    cert_mod['tbs_certificate'][name] \
-        = asn1crypto.x509.Name().load(name_der.replace(search, replace))
-    return (
-        diff_offset(cert, cert_mod),
-        len(search))
+        raise ValueError('Could not find "{}" in certificate {} name.'.format(search, name))
+    cert_mod["tbs_certificate"][name] = asn1crypto.x509.Name().load(
+        name_der.replace(search, replace)
+    )
+    return (diff_offset(cert, cert_mod), len(search))
+
 
 def name_search_location_last(cert, name, search):
-    # Gives offset and length information of certain search string, searched from 
+    # Gives offset and length information of certain search string, searched from
     # right to left and finds the first instance.
     cert_mod = cert.copy()
     # Change the first character of the search text for the replacement text
     search = search.encode()
-    replace = (b'F' if search[0] != ord(b'F') else b'0') + search[1:]
-    name_der = cert['tbs_certificate'][name].dump()
+    replace = (b"F" if search[0] != ord(b"F") else b"0") + search[1:]
+    name_der = cert["tbs_certificate"][name].dump()
     if search not in name_der:
-        raise ValueError(
-            'Could not find "{}" in certificate {} name.'.format(search, name))
-    cert_mod['tbs_certificate'][name] \
-        = asn1crypto.x509.Name().load(replace.join(name_der.rsplit(search, 1)))
-    return (
-        diff_offset(cert, cert_mod),
-        len(search))
+        raise ValueError('Could not find "{}" in certificate {} name.'.format(search, name))
+    cert_mod["tbs_certificate"][name] = asn1crypto.x509.Name().load(
+        replace.join(name_der.rsplit(search, 1))
+    )
+    return (diff_offset(cert, cert_mod), len(search))
+
 
 def auth_key_id_location(cert):
     cert_mod = cert.copy()
-    oid = asn1crypto.x509.ExtensionId('authority_key_identifier')
+    oid = asn1crypto.x509.ExtensionId("authority_key_identifier")
     is_found = False
-    for extension in cert_mod['tbs_certificate']['extensions']:
-        if extension['extn_id'] == oid:
+    for extension in cert_mod["tbs_certificate"]["extensions"]:
+        if extension["extn_id"] == oid:
             is_found = True
             break
     if not is_found:
         return (0, 0)
 
     # Modify the first byte of the key ID value
-    mod_key_id \
-        = bytearray(extension['extn_value'].parsed['key_identifier'].native)
+    mod_key_id = bytearray(extension["extn_value"].parsed["key_identifier"].native)
     mod_key_id[0] ^= 0xFF
-    mod_auth_key_id = extension['extn_value'].parsed.copy()
-    mod_auth_key_id['key_identifier'] \
-        = asn1crypto.core.OctetString(bytes(mod_key_id))
-    extension['extn_value'] = mod_auth_key_id
+    mod_auth_key_id = extension["extn_value"].parsed.copy()
+    mod_auth_key_id["key_identifier"] = asn1crypto.core.OctetString(bytes(mod_key_id))
+    extension["extn_value"] = mod_auth_key_id
 
-    return (
-        diff_offset(cert, cert_mod),
-        len(mod_key_id))
+    return (diff_offset(cert, cert_mod), len(mod_key_id))
 
 
 def subj_key_id_location(cert):
     cert_mod = cert.copy()
-    oid = asn1crypto.x509.ExtensionId('key_identifier')
+    oid = asn1crypto.x509.ExtensionId("key_identifier")
     is_found = False
-    for extension in cert_mod['tbs_certificate']['extensions']:
-        if extension['extn_id'] == oid:
+    for extension in cert_mod["tbs_certificate"]["extensions"]:
+        if extension["extn_id"] == oid:
             is_found = True
             break
     if not is_found:
         return (0, 0)
 
     # Modify the first byte of the key ID value
-    mod_key_id = bytearray(extension['extn_value'].parsed.native)
+    mod_key_id = bytearray(extension["extn_value"].parsed.native)
     mod_key_id[0] ^= 0xFF
     mod_auth_key_id = asn1crypto.core.OctetString(bytes(mod_key_id))
-    extension['extn_value'] = mod_auth_key_id
+    extension["extn_value"] = mod_auth_key_id
 
-    return (
-        diff_offset(cert, cert_mod),
-        len(mod_key_id))
+    return (diff_offset(cert, cert_mod), len(mod_key_id))
 
 
 def signature_location(cert):
-    signature_der = cert['signature_value'].dump()
-    return (
-        cert.dump().find(signature_der), 64)
+    signature_der = cert["signature_value"].dump()
+    return (cert.dump().find(signature_der), 64)
     #     len(signature_der))
 
 
 def tbs_location(cert):
-    tbs_der = cert['tbs_certificate'].dump()
-    return (
-        cert.dump().find(tbs_der),
-        len(tbs_der))
+    tbs_der = cert["tbs_certificate"].dump()
+    return (cert.dump().find(tbs_der), len(tbs_der))
 
 
 def cert_search(cert, search):
-    return (
-        cert.dump().find(search),
-        len(search))
+    return (cert.dump().find(search), len(search))
```

## tpds/certs/sign_csr/sign_csr.py

```diff
@@ -14,10 +14,9 @@
 # KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 from tpds.cert_tools.sign_csr import sign_csr_main
 
-
-if __name__ == '__main__':
+if __name__ == "__main__":
     sign_csr_main()
```

## tpds/cloud_connect/__init__.py

```diff
@@ -1,12 +1,30 @@
 """
     Trust Platform core package - cloud_connect module
 """
+from .cloud_connect import CloudConnect
+
+__all__ = ["CloudConnect"]
+
 try:
-    from .aws_connect import *
-    from .azure_connect import *
-    from .gcp_connect import *
-    from .azureRTOS_connect import *
-except ModuleNotFoundError as e:
+    from .aws_connect import AWSConnect, AWSZTKitError
+
+    __all__ += ["AWSZTKitError", "AWSConnect"]
+
+except ModuleNotFoundError:
     pass
 
-from .cloud_connect import *
+try:
+    from .azure_connect import AzureConnect, AzureConnectBase
+    from .azure_sdk import AzureSDK, AzureSDK_IotAuthentication, AzureSDK_RTOS
+    from .azureRTOS_connect import AzurertosConnect, make_valid_filename
+
+    __all__ += ["AzureConnect", "AzurertosConnect", "make_valid_filename", "AzureSDK", "AzureSDK_IotAuthentication", "AzureSDK_RTOS", "AzureConnectBase"]
+except ModuleNotFoundError:
+    pass
+
+try:
+    from .gcp_connect import GCPConnect
+
+    __all__ += ["GCPConnect"]
+except ModuleNotFoundError:
+    pass
```

## tpds/cloud_connect/aws_connect.py

```diff
@@ -14,196 +14,188 @@
 # PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY
 # KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 
+import json
 import os
-import csv
 import re
-import json
 import sys
+from datetime import datetime, timedelta, timezone
+from pathlib import Path
+
 import boto3
 import botocore
 import yaml
-from datetime import datetime, timezone, timedelta
-from pathlib import Path
 from cryptography import x509
 from cryptography.hazmat.primitives import serialization
-from .cloud_connect import CloudConnect
-from tpds.certs import Cert, cert_utils
+
 import tpds.tp_utils
+from tpds.certs import Cert, cert_utils
 from tpds.manifest import Manifest, ManifestIterator
 from tpds.tp_utils.tp_settings import TPSettings
 
+from .cloud_connect import CloudConnect
 
 _DEFAULT_POLICY = {
-    'Version': '2012-10-17',
-    'Statement': [
+    "Version": "2012-10-17",
+    "Statement": [
         {
-            'Effect': 'Allow',
-            'Action': [
-                'iot:Connect'
-            ],
-            'Resource': [
-                'arn:aws:iot:*:*:client/${iot:Connection.Thing.ThingName}'
-            ]
+            "Effect": "Allow",
+            "Action": ["iot:Connect"],
+            "Resource": ["arn:aws:iot:*:*:client/${iot:Connection.Thing.ThingName}"],
         },
         {
-            'Effect': 'Allow',
-            'Action': [
-                'iot:Publish',
-                'iot:Receive'
+            "Effect": "Allow",
+            "Action": ["iot:Publish", "iot:Receive"],
+            "Resource": [
+                "arn:aws:iot:*:*:topic/${iot:Connection.Thing.ThingName}/*",
+                "arn:aws:iot:*:*:topic/$aws/things/${iot:Connection.Thing.ThingName}/shadow/*",
+                "arn:aws:iot:*:*:topic/$aws/things/${iot:Connection.Thing.ThingName}/streams/*",
+                "arn:aws:iot:*:*:topic/$aws/things/${iot:Connection.Thing.ThingName}/jobs/*",
             ],
-            'Resource': [
-                'arn:aws:iot:*:*:topic/${iot:Connection.Thing.ThingName}/*',
-                'arn:aws:iot:*:*:topic/$aws/things/${iot:Connection.Thing.ThingName}/shadow/*',
-                'arn:aws:iot:*:*:topic/$aws/things/${iot:Connection.Thing.ThingName}/streams/*',
-                'arn:aws:iot:*:*:topic/$aws/things/${iot:Connection.Thing.ThingName}/jobs/*'
-            ]
         },
         {
-            'Effect': 'Allow',
-            'Action': [
-                'iot:Subscribe'
+            "Effect": "Allow",
+            "Action": ["iot:Subscribe"],
+            "Resource": [
+                "arn:aws:iot:*:*:topicfilter/${iot:Connection.Thing.ThingName}/#",
+                "arn:aws:iot:*:*:topicfilter/$aws/things/${iot:Connection.Thing.ThingName}/shadow/*",
+                "arn:aws:iot:*:*:topicfilter/$aws/things/${iot:Connection.Thing.ThingName}/streams/*",
+                "arn:aws:iot:*:*:topicfilter/$aws/things/${iot:Connection.Thing.ThingName}/jobs/*",
             ],
-            'Resource': [
-                'arn:aws:iot:*:*:topicfilter/${iot:Connection.Thing.ThingName}/#',
-                'arn:aws:iot:*:*:topicfilter/$aws/things/${iot:Connection.Thing.ThingName}/shadow/*',
-                'arn:aws:iot:*:*:topicfilter/$aws/things/${iot:Connection.Thing.ThingName}/streams/*',
-                'arn:aws:iot:*:*:topicfilter/$aws/things/${iot:Connection.Thing.ThingName}/jobs/*'
-            ]
         },
         {
-            'Effect': 'Allow',
-            'Action': [
-                'iot:UpdateThingShadow',
-                'iot:GetThingShadow'
+            "Effect": "Allow",
+            "Action": ["iot:UpdateThingShadow", "iot:GetThingShadow"],
+            "Resource": [
+                "arn:aws:iot:*:*:topic/$aws/things/${iot:Connection.Thing.ThingName}/shadow/*"
             ],
-            'Resource': [
-                'arn:aws:iot:*:*:topic/$aws/things/${iot:Connection.Thing.ThingName}/shadow/*'
-            ]
-        }
-    ]
+        },
+    ],
 }
 
 
 class AWSZTKitError(RuntimeError):
     pass
 
 
 class AWSConnect(CloudConnect):
     def __init__(self):
         self.default_creds = {
-            'title': 'AWS IoT Credentials',
-            'access_key_id': '',
-            'secret_access_key': '',
-            'region': ''
+            "title": "AWS IoT Credentials",
+            "access_key_id": "",
+            "secret_access_key": "",
+            "region": "",
         }
-        self.creds_file = os.path.join(
-                            TPSettings().get_base_folder(),
-                            'aws_credentials.yaml')
+        self.creds_file = os.path.join(TPSettings().get_base_folder(), "aws_credentials.yaml")
         if not os.path.exists(self.creds_file):
-            Path(self.creds_file).write_text(
-                    yaml.dump(self.default_creds, sort_keys=False))
+            Path(self.creds_file).write_text(yaml.dump(self.default_creds, sort_keys=False))
 
     def set_credentials(self, credentials=None):
         """
         Method aids in logging into aws portal via cli and
         set the credentials in aws cli
 
         Inputs:
               credentials    contain aws access key ID and
                              secrey access key
         """
         # do aws configure
         if not isinstance(credentials, dict):
-            raise ValueError('Unsupported User credentials type')
+            raise ValueError("Unsupported User credentials type")
 
         # Setting the aws cli for the access key
-        print("Setting aws access key...", end='')
-        sys_shell = True if sys.platform == 'win32' else False
+        print("Setting aws access key...", end="")
+        sys_shell = True if sys.platform == "win32" else False
         subProcessOut = tpds.tp_utils.run_subprocess_cmd(
-            cmd=[
-                "aws", "configure", "set",
-                "aws_access_key_id", credentials.get('access_key_id')],
-            sys_shell=sys_shell)
-        print('Failed with {}'.format(
-            subProcessOut.returncode) if subProcessOut.returncode else 'OK')
+            cmd=["aws", "configure", "set", "aws_access_key_id", credentials.get("access_key_id")],
+            sys_shell=sys_shell,
+        )
+        print(
+            "Failed with {}".format(subProcessOut.returncode) if subProcessOut.returncode else "OK"
+        )
 
-        print("Setting aws secret access key...", end='')
+        print("Setting aws secret access key...", end="")
         subProcessOut = tpds.tp_utils.run_subprocess_cmd(
             cmd=[
-                "aws", "configure", "set",
-                "aws_secret_access_key", credentials.get('secret_access_key')],
-            sys_shell=sys_shell)
-        print('Failed with {}'.format(
-            subProcessOut.returncode) if subProcessOut.returncode else 'OK')
+                "aws",
+                "configure",
+                "set",
+                "aws_secret_access_key",
+                credentials.get("secret_access_key"),
+            ],
+            sys_shell=sys_shell,
+        )
+        print(
+            "Failed with {}".format(subProcessOut.returncode) if subProcessOut.returncode else "OK"
+        )
 
-        print("Setting aws region...", end='')
+        print("Setting aws region...", end="")
         subProcessOut = tpds.tp_utils.run_subprocess_cmd(
-            cmd=[
-                "aws", "configure", "set",
-                "region", credentials.get('region')],
-            sys_shell=sys_shell)
-        print('Failed with {}'.format(
-            subProcessOut.returncode) if subProcessOut.returncode else 'OK')
+            cmd=["aws", "configure", "set", "region", credentials.get("region")],
+            sys_shell=sys_shell,
+        )
+        print(
+            "Failed with {}".format(subProcessOut.returncode) if subProcessOut.returncode else "OK"
+        )
 
         # initiate session
-        self.__get_session('default')
-        self.__install_policy('Default', _DEFAULT_POLICY)
-        print('Getting aws endpoint...{}'.format(
-            self.iot.describe_endpoint(endpointType='iot:Data').get(
-                'endpointAddress')))
+        self.__get_session("default")
+        self.__install_policy("Default", _DEFAULT_POLICY)
+        print(
+            "Getting aws endpoint...{}".format(
+                self.iot.describe_endpoint(endpointType="iot:Data").get("endpointAddress")
+            )
+        )
 
-    def register_signer(self, signer_cert, signer_key='', verify_cert=''):
+    def register_signer(self, signer_cert, signer_key="", verify_cert=""):
         """Method registers signer CA with AWS IoT
 
         Inputs:
             signer_cert          signer certificate to be registered
             signer_key           signer key which sign the verify cert
             verify_cert          verify certificate to be registered
         """
 
         if not signer_cert:
-            raise ValueError(
-                'Signer certificate is required to register')
+            raise ValueError("Signer certificate is required to register")
 
         signer = Cert()
         signer.set_certificate(signer_cert)
         verify = Cert()
         if not verify_cert:
             if not signer_key:
-                raise ValueError(
-                    'Either signer key or verify cert is req to register')
+                raise ValueError("Either signer key or verify cert is req to register")
             else:
-                verify_cert = 'verify_cert.crt'
-                self.get_verification_cert(signer_key,
-                                           signer_cert,
-                                           verify_cert)
+                verify_cert = "verify_cert.crt"
+                self.get_verification_cert(signer_key, signer_cert, verify_cert)
         verify.set_certificate(verify_cert)
 
-        print('Registering signer CA with AWS IoT...')
+        print("Registering signer CA with AWS IoT...")
         try:
             response = self.iot.register_ca_certificate(
                 caCertificate=signer.certificate.public_bytes(
-                    encoding=serialization.Encoding.PEM).decode('ascii'),
+                    encoding=serialization.Encoding.PEM
+                ).decode("ascii"),
                 verificationCertificate=verify.certificate.public_bytes(
-                    encoding=serialization.Encoding.PEM).decode('ascii'),
+                    encoding=serialization.Encoding.PEM
+                ).decode("ascii"),
                 setAsActive=True,
-                allowAutoRegistration=True)
-            print('    Cert ID: ' + response.get('certificateId'))
+                allowAutoRegistration=True,
+            )
+            print("    Cert ID: " + response.get("certificateId"))
         except botocore.exceptions.ClientError as e:
-            e_error = e.response.get('Error')
-            if e_error.get('Code') == 'ResourceAlreadyExistsException':
-                ca_id = re.search('ID:([0-9a-zA-Z]+)', e_error.get(
-                    'Message')).group(1)
-                print('    Its already exists in AWS IoT.')
-                print('    Cert ID: ' + ca_id)
+            e_error = e.response.get("Error")
+            if e_error.get("Code") == "ResourceAlreadyExistsException":
+                ca_id = re.search("ID:([0-9a-zA-Z]+)", e_error.get("Message")).group(1)
+                print("    Its already exists in AWS IoT.")
+                print("    Cert ID: " + ca_id)
             else:
                 print(e)
                 raise
 
     def register_device_without_ca(self, device_id, device_cert):
         """Method registers device without CA
 
@@ -215,93 +207,89 @@
             dict: dictionary with certArn, certId, thingArn,
                   registered or not values.
         """
         device = Cert()
         device.set_certificate(device_cert)
         reg_resp = thing_resp = dict()
 
-        print('Registering device with AWS IoT...')
+        print("Registering device with AWS IoT...")
         try:
             # import certificate...
             # Load a certificate into AWS IoT and attach policy to it
             reg_resp = self.iot.register_certificate_without_ca(
-                certificatePem=device.get_certificate_in_pem().decode(
-                    encoding='UTF-8'))
-            self.iot.attach_policy(
-                policyName=self.policy, target=reg_resp.get('certificateArn'))
+                certificatePem=device.get_certificate_in_pem().decode(encoding="UTF-8")
+            )
+            self.iot.attach_policy(policyName=self.policy, target=reg_resp.get("certificateArn"))
             self.iot.update_certificate(
-                certificateId=reg_resp.get('certificateId'),
-                newStatus='ACTIVE')
-            print('    Cert ARN: ' + reg_resp.get('certificateArn'))
-            print('    Cert ID: ' + reg_resp.get('certificateId'))
+                certificateId=reg_resp.get("certificateId"), newStatus="ACTIVE"
+            )
+            print("    Cert ARN: " + reg_resp.get("certificateArn"))
+            print("    Cert ID: " + reg_resp.get("certificateId"))
 
             # make thing...
             # Create an AWS IoT "thing" and attach the certificate
             thing_resp = self.iot.create_thing(thingName=device_id)
             self.iot.attach_thing_principal(
-                thingName=device_id, principal=reg_resp.get('certificateArn'))
-            print('    Thing ARN: ' + thing_resp.get('thingArn'))
+                thingName=device_id, principal=reg_resp.get("certificateArn")
+            )
+            print("    Thing ARN: " + thing_resp.get("thingArn"))
 
             is_registered = self.is_device_registered(device_id, device_cert)
-            print('OK' if is_registered else 'Verification failed')
+            print("OK" if is_registered else "Verification failed")
 
         except botocore.exceptions.ClientError as e:
-            e_error = e.response.get('Error')
-            if e_error.get('Code') == 'ResourceAlreadyExistsException':
+            e_error = e.response.get("Error")
+            if e_error.get("Code") == "ResourceAlreadyExistsException":
                 is_registered = True
-                print('    '+e_error.get('Message'))
+                print("    " + e_error.get("Message"))
             else:
-                print('     {}'.format(e))
+                print("     {}".format(e))
                 raise
 
         return {
-            'cert_arn': reg_resp.get('certificateArn'),
-            'cert_id': reg_resp.get('certificateId'),
-            'thing_arn': thing_resp.get('thingArn'),
-            'is_registered': is_registered,
+            "cert_arn": reg_resp.get("certificateArn"),
+            "cert_id": reg_resp.get("certificateId"),
+            "thing_arn": thing_resp.get("thingArn"),
+            "is_registered": is_registered,
         }
 
-    def register_from_manifest(
-            self, device_manifest, device_manifest_ca, key_slot=0):
+    def register_from_manifest(self, device_manifest, device_manifest_ca, key_slot=0):
         """
         Method registers device from given manifest
         Inputs:
               device_manifest     manifest contains certs and public keys
               device_manifest_ca  manifest signer key
               key_slot            slot where device private key present
 
         Raises:
             ValueError: Occurs when device registration failed.
         """
-        if os.path.exists(device_manifest) \
-                and device_manifest.endswith('.json'):
+        if os.path.exists(device_manifest) and device_manifest.endswith(".json"):
             with open(device_manifest) as json_data:
                 device_manifest = json.load(json_data)
 
         if not isinstance(device_manifest, list):
-            raise ValueError('Unsupport manifest format to process')
+            raise ValueError("Unsupport manifest format to process")
 
         manifest_ca = Cert()
         manifest_ca.set_certificate(device_manifest_ca)
         iterator = ManifestIterator(device_manifest)
-        print('Number of certificates: {}'.format(iterator.index))
+        print("Number of certificates: {}".format(iterator.index))
 
         while iterator.index != 0:
-            se = Manifest().decode_manifest(
-                 iterator.__next__(), manifest_ca.certificate)
+            se = Manifest().decode_manifest(iterator.__next__(), manifest_ca.certificate)
             se_certs = Manifest().extract_public_data_pem(se)
-            slot = next((sub for sub in se_certs if sub.get(
-                'id') == str(key_slot)), None)
-            no_of_certs = len(slot.get('certs'))
+            slot = next((sub for sub in se_certs if sub.get("id") == str(key_slot)), None)
+            no_of_certs = len(slot.get("certs"))
             if no_of_certs:
                 self.register_device_without_ca(
-                    se.get('uniqueId').upper(),
-                    slot.get('certs')[no_of_certs-2])
+                    se.get("uniqueId").upper(), slot.get("certs")[no_of_certs - 2]
+                )
 
-    def get_verification_cert(self, signer_key, signer_cert, file=''):
+    def get_verification_cert(self, signer_key, signer_cert, file=""):
         """
         Method gets the verification code and generate verification cert
 
         Inputs:
               signer_key      signer key which sign the verification cert
               signer_cert     signer certificate
               file            path where verification cert loaded
@@ -310,38 +298,41 @@
         """
         ca_key = tpds.tp_utils.TPAsymmetricKey(signer_key)
         ca_cert = Cert()
         ca_cert.set_certificate(signer_cert)
 
         # Request a registration code required for registering a CA
         # certificate (signer)
-        print('Getting CA registration code from AWS IoT...')
-        reg_code = self.iot.get_registration_code()['registrationCode']
-        print('    Code: %s' % reg_code)
+        print("Getting CA registration code from AWS IoT...")
+        reg_code = self.iot.get_registration_code()["registrationCode"]
+        print("    Code: %s" % reg_code)
 
         # Generate a verification certificate around the registration code
         # (subject common name)
-        print('Generating signer CA AWS verification certificate...', end='')
+        print("Generating signer CA AWS verification certificate...", end="")
         self.verify_cert = Cert()
         self.verify_cert.builder = x509.CertificateBuilder()
         self.verify_cert.builder = self.verify_cert.builder.serial_number(
-            cert_utils.random_cert_sn(16))
-        self.verify_cert.builder = self.verify_cert.builder.issuer_name(
-            ca_cert.certificate.subject)
+            cert_utils.random_cert_sn(16)
+        )
+        self.verify_cert.builder = self.verify_cert.builder.issuer_name(ca_cert.certificate.subject)
         self.verify_cert.builder = self.verify_cert.builder.not_valid_before(
-            datetime.utcnow().replace(tzinfo=timezone.utc))
+            datetime.utcnow().replace(tzinfo=timezone.utc)
+        )
         self.verify_cert.builder = self.verify_cert.builder.not_valid_after(
-            self.verify_cert.builder._not_valid_before + timedelta(days=1))
+            self.verify_cert.builder._not_valid_before + timedelta(days=1)
+        )
         self.verify_cert.builder = self.verify_cert.builder.subject_name(
-            x509.Name(
-                [x509.NameAttribute(x509.oid.NameOID.COMMON_NAME, reg_code)]))
+            x509.Name([x509.NameAttribute(x509.oid.NameOID.COMMON_NAME, reg_code)])
+        )
         self.verify_cert.builder = self.verify_cert.builder.public_key(
-            ca_cert.certificate.public_key())
+            ca_cert.certificate.public_key()
+        )
         self.verify_cert.sign_builder(ca_key.get_private_key())
-        print('OK')
+        print("OK")
 
         if file:
             Path(file).write_bytes(self.verify_cert.get_certificate_in_pem())
 
         return self.verify_cert
 
     def is_device_registered(self, device_id, device_cert):
@@ -351,70 +342,63 @@
              device_id      device certificate common name
 
             return true if device is registered else false
         """
         device = Cert()
         device.set_certificate(device_cert)
         try:
-            response = self.iot.list_thing_principals(
-                thingName=device_id)
+            response = self.iot.list_thing_principals(thingName=device_id)
             response = self.iot.describe_certificate(
-                certificateId=response['principals'][0].split('/')[-1])
+                certificateId=response["principals"][0].split("/")[-1]
+            )
 
-            if response.get('certificateDescription').get(
-                'certificatePem') != device.get_certificate_in_pem().decode(
-                    encoding='UTF-8'):
-                raise BaseException('Certificate Mismatch for {}'.format(
-                    device_id))
+            if response.get("certificateDescription").get(
+                "certificatePem"
+            ) != device.get_certificate_in_pem().decode(encoding="UTF-8"):
+                raise BaseException("Certificate Mismatch for {}".format(device_id))
         except BaseException as e:
             print("Exception occurred: {}".format(e))
             return False
 
         return True
 
-    def get_thing_details(self, thingName=''):
+    def get_thing_details(self, thingName=""):
         try:
-            thing_details = self.iot.describe_thing(
-                thingName=thingName)
-            thing_principal = self.iot.list_thing_principals(
-                thingName=thingName)
+            thing_details = self.iot.describe_thing(thingName=thingName)
+            thing_principal = self.iot.list_thing_principals(thingName=thingName)
             cert_description = self.iot.describe_certificate(
-                certificateId=thing_principal['principals'][0].split(
-                    '/')[-1]).get('certificateDescription')
+                certificateId=thing_principal["principals"][0].split("/")[-1]
+            ).get("certificateDescription")
             return {
-                'thingArn': thing_details.get('thingArn'),
-                'thingID': thing_details.get('thingId'),
-                'certificateArn': cert_description.get('certificateArn'),
-                'certificateId': cert_description.get('certificateId'),
-                'certificatePem': cert_description.get('certificatePem')
+                "thingArn": thing_details.get("thingArn"),
+                "thingID": thing_details.get("thingId"),
+                "certificateArn": cert_description.get("certificateArn"),
+                "certificateId": cert_description.get("certificateId"),
+                "certificatePem": cert_description.get("certificatePem"),
             }
         except Exception as e:
             print(e)
 
     def get_signer_cert_description(self, signer_cert):
         try:
             ca_cert = Cert()
             ca_cert.set_certificate(signer_cert)
             ca_list = self.iot.list_ca_certificates()
-            print('Number of CAs listed {}'.format(len(ca_list.get(
-                'certificates'))))
-            for ca in ca_list.get('certificates'):
+            print("Number of CAs listed {}".format(len(ca_list.get("certificates"))))
+            for ca in ca_list.get("certificates"):
                 cert_description = self.iot.describe_ca_certificate(
-                    certificateId=ca.get('certificateId')).get(
-                        'certificateDescription')
+                    certificateId=ca.get("certificateId")
+                ).get("certificateDescription")
                 if cert_description is not None and cert_description.get(
-                    'certificatePem') == ca_cert.get_certificate_in_pem(
-                        ).decode(encoding='UTF-8'):
+                    "certificatePem"
+                ) == ca_cert.get_certificate_in_pem().decode(encoding="UTF-8"):
                     return {
-                        'certificateArn':
-                            cert_description.get('certificateArn'),
-                        'certificateId':
-                            cert_description.get('certificateId'),
-                        'certificatePem':
-                            cert_description.get('certificatePem')
+                        "certificateArn": cert_description.get("certificateArn"),
+                        "certificateId": cert_description.get("certificateId"),
+                        "certificatePem": cert_description.get("certificatePem"),
                     }
         except Exception as e:
             print(e)
 
     def execute_aws_gui(self, thing_id, qtUiFile):
         # app = QtWidgets.QApplication.instance()
         # if app is None:
@@ -422,43 +406,45 @@
         # AWS_GUI(aws_iot_data=self.aws_session.client('iot-data'),
         #         thing_name=thing_id,
         #         qtUiFile=qtUiFile)
         # app.exec_()
         pass
 
     def __get_session(self, aws_profile):
-        """Create an AWS session with the credentials from the specified profile
-        """
+        """Create an AWS session with the credentials from the specified profile"""
         try:
             self.aws_session = boto3.session.Session(profile_name=aws_profile)
-            self.iot = self.aws_session.client('iot')
+            self.iot = self.aws_session.client("iot")
         except botocore.exceptions.ProfileNotFound as e:
             print(e)
             raise AWSZTKitError(
                 'AWS profile not found. Please make sure you have the AWS CLI \
                 installed and run "aws configure --profile %s" \
-                to setup profile.' % aws_profile)
+                to setup profile.'
+                % aws_profile
+            )
 
     def __install_policy(self, policy_name, policy_document):
         try:
             self.iot.get_policy(policyName=policy_name)
         except botocore.exceptions.ClientError as e:
-            if 'ResourceNotFoundException' == e.response.get('Error').get(
-                                                'Code'):
+            if "ResourceNotFoundException" == e.response.get("Error").get("Code"):
                 self.iot.create_policy(
-                    policyName=policy_name,
-                    policyDocument=json.dumps(policy_document))
-                print('Created policy {}'.format(policy_name))
+                    policyName=policy_name, policyDocument=json.dumps(policy_document)
+                )
+                print("Created policy {}".format(policy_name))
             else:
                 print("Exception occurred: {}".format(e))
                 raise
 
         self.policy = policy_name
 
 
+__all__ = ["AWSZTKitError", "AWSConnect"]
+
 # class AWS_GUI(QtWidgets.QMainWindow):
 #     def __init__(self, aws_iot_data, thing_name, qtUiFile):
 #         super(AWS_GUI, self).__init__(parent=None)
 #         self.aws_iot_data = aws_iot_data
 #         self.thing_name = thing_name
 #         self.qtUiFile = qtUiFile
 #         self.state = ''
@@ -525,9 +511,9 @@
 #                 raise
 
 #         QtCore.QTimer.singleShot(2000, self.on_update)
 
 
 # Standard boilerplate to call the main() function to begin
 # the program.
-if __name__ == '__main__':
+if __name__ == "__main__":
     pass
```

## tpds/cloud_connect/azureRTOS_connect.py

```diff
@@ -2,314 +2,105 @@
 import yaml
 import os
 import re
 import sys
 import unicodedata
 import struct
 import ctypes
-from cryptography import x509
+import base64
 from cryptography.hazmat.primitives.serialization import Encoding
-from pathlib import Path
 from tpds.certs.cert import Cert
-from tpds.certs.certs_backup import CertsBackup
 from tpds.certs.cert_utils import get_certificate_CN
-from tpds.tp_utils.tp_utils import run_subprocess_cmd
 from tpds.manifest import ManifestIterator, Manifest
 from tpds.secure_element import ECC608B
-from tpds.tp_utils.tp_settings import TPSettings
-from tpds.resource_generation import TFLXResources, TNGManifest
 import cryptoauthlib as cal
 from tpds.secure_element.constants import Constants
-from tpds.certs.cert import Cert
-from tpds.certs.tflex_certs import TFLEXCerts
-from tpds.certs.create_cert_defs import CertDef
-from tpds.certs.certs_backup import CertsBackup
-from tpds.manifest import ManifestIterator, Manifest
+from .azure_sdk import AzureSDK_RTOS
+from .azure_connect import AzureConnectBase
 
 
 ATCA_SUCCESS = 0x00
 
 
 def make_valid_filename(s):
     """
     Convert an arbitrary string into one that can be used in an ascii filename.
     """
     if sys.version_info[0] <= 2:
-        if not isinstance(s, unicode):
+        if not isinstance(s, str):
             s = str(s).decode("utf-8")
     else:
         s = str(s)
     # Normalize unicode characters
-    s = unicodedata.normalize("NFKD", s).encode("ascii", "ignore").decode("ascii")
+    s = unicodedata.normalize("NFKD", s).encode(
+        "ascii", "ignore").decode("ascii")
     # Remove non-word and non-whitespace characters
     s = re.sub(r"[^\w\s-]", "", s).strip()
     # Replace repeated whitespace with an underscore
     s = re.sub(r"\s+", "_", s)
     # Replace repeated dashes with a single dash
     s = re.sub(r"-+", "-", s)
     return s
 
 
-class AzurertosConnect:
+class AzurertosConnect(AzureConnectBase):
     def __init__(self):
+        super().__init__(AzureSDK_RTOS)
         self.cfg = cal.ATCAIfaceCfg()
-        self.default_creds = {
-            "title": "Azure IoT Credentials",
-            "subscription_id": "",
-            "resourcegroup": "",
-            "hubname": "",
-            "dpsname": "",
-            "idScope": "",
+        self.dps_name = ""
+        self.az_credentials = {
+            'title': 'Azure RTOS Credentials',
+            'subscription_id': '',
+            'resource_group': '',
+            'iot_hub': '',
+            'dps_name': '',
         }
 
-        self.creds_file = os.path.join(
-            TPSettings().get_base_folder(), "azure_credentials.yaml"
-        )
-
         if not os.path.exists(self.creds_file):
-            Path(self.creds_file).write_text(
-                yaml.dump(self.default_creds, sort_keys=False)
-            )
-            with open(self.creds_file) as f:
-                self.azure_credentials = yaml.safe_load(f)
-
+            self.save_credentials()
         else:
-            with open(self.creds_file) as f:
-                self.azure_credentials = yaml.safe_load(f)
-                self.resourceGroup = self.azure_credentials.get("resourcegroup")
-                self.hname = self.azure_credentials.get("hubname")
-                self.dname = self.azure_credentials.get("dpsname")
-
-    def azure_connect(self, credentials):
-        """
-        Method login azure portal via cli and
-        set the credentials in azure cli
-
-        Inputs:
-              credentials    contain azure iot hub name and
-                             subscription id
-        """
-
-        # login to acccount
-        sys_shell = True if sys.platform == "win32" else False
-        print("Login to Azure account....", end="")
-        subProcessOut = run_subprocess_cmd(cmd=["az", "login"], sys_shell=True)
-        if subProcessOut.returncode:
-            raise ValueError("Azure login failed with {}".format(subProcessOut))
-        print("OK")
-
-        # Setting up azure subscription id
-        print("Setting the Subscription ID....\n", end="")
-        self.az_subscription_id = credentials
-        subProcessOut = run_subprocess_cmd(
-            cmd=["az", "account", "set", "--subscription", self.az_subscription_id],
-            sys_newlines=True,
-            sys_shell=sys_shell,
-        )
-        if subProcessOut.returncode:
-            raise ValueError(
-                "Setting subscription failed with {}".format(subProcessOut)
-            )
-        print("Subscription ID ------- Valid")
-        self.default_creds["subscription_id"] = self.az_subscription_id
-
-    def azure_iot_extension(self):
-        
-        subProcessOut = run_subprocess_cmd(
-            cmd=["az", "config", "set", "extension.use_dynamic_install=yes_prompt"], sys_shell=True
-        )
-        if subProcessOut.returncode:
-            raise ValueError(
-                "Azure extension config failed with {}".format(subProcessOut)
-            )
-
-        subProcessOut = run_subprocess_cmd(
-            cmd=["az", "extension", "add", "--name", "azure-iot"], sys_shell=True
-        )
-        if subProcessOut.returncode:
-            raise ValueError(
-                "Azure iot Install failed with {}".format(subProcessOut)
-            )
-
-        print("Azure iot Extension installed successfully")
-
-    def az_group_create(self, resourceGroup):
-        print("Checking if the resourcegroup exists...")
-        subProcessOut = run_subprocess_cmd(
-            cmd=[
-                "az",
-                "group",
-                "exists",
-                "--name",
-                resourceGroup,
-                "--location",
-                "centralus",
-            ],
-            sys_newlines=True,
-            sys_shell=True,
-        )
-
-        print("Creating the Resource group .....")
-        subProcessOut = run_subprocess_cmd(
-            cmd=[
-                "az",
-                "group",
-                "create",
-                "--name",
-                resourceGroup,
-                "--location",
-                "centralus",
-            ],
-            sys_newlines=True,
-            sys_shell=True,
-        )
-        if subProcessOut.returncode:
-            raise ValueError("Resource group creation failed. {}".format(subProcessOut))
+            with open(self.creds_file, 'r') as f:
+                self.az_credentials = yaml.safe_load(f)
 
-        self.resourceGroup = resourceGroup
-        print("Azure Resource group created successfully")
-        self.default_creds["resourcegroup"] = self.resourceGroup
-
-    def az_hub_create(self, hostName):
-        print("Creating the iot Hub.....")
-        print("Please wait, this may take up to 2 minutes...")
-        subProcessOut = run_subprocess_cmd(
-            cmd=[
-                "az",
-                "iot",
-                "hub",
-                "create",
-                "--resource-group",
-                self.resourceGroup,
-                "--name",
-                hostName,
-            ],
-            sys_newlines=True,
-            sys_shell=True,
-        )
-
-        if subProcessOut.returncode:
-            raise ValueError(
-                "Hub creation creation failed with {}".format(subProcessOut.returncode)
-            )
-
-        self.hname = json.loads(subProcessOut.stdout)["name"]
-        self.hostname = json.loads(subProcessOut.stdout)["properties"]["hostName"]
-        print("Hub creation was successful")
-        self.default_creds["hubname"] = self.hname
-
-    def az_dps_create(self, dpsName):
-        print("Creating the dps.... ")
-        subProcessOut = run_subprocess_cmd(
-            cmd=[
-                "az",
-                "iot",
-                "dps",
-                "create",
-                "--resource-group",
-                self.resourceGroup,
-                "--name",
-                dpsName,
-            ],
-            sys_newlines=True,
-            sys_shell=True,
-        )
-        if subProcessOut.returncode:
-            raise ValueError(
-                "DPS creation creation failed with {}".format(subProcessOut.returncode)
-            )
-
-        self.serviceOpHostName = json.loads(subProcessOut.stdout)["properties"][
-            "serviceOperationsHostName"
-        ]
-        self.idScope = json.loads(subProcessOut.stdout)["properties"]["idScope"]
-        self.dname = json.loads(subProcessOut.stdout)["name"]
-        print("DPS creation was successful")
-
-        self.default_creds["dpsname"] = self.dname
-        self.default_creds["idScope"] = self.idScope
-        Path(self.creds_file).write_text(yaml.dump(self.default_creds, sort_keys=False))
-
-    def link_hub_dps(self):
-        print("Linking the Iot Hub to the DPS ")
-        subProcessOut = run_subprocess_cmd(
-            cmd=["az", "iot", "hub", "show-connection-string", "--name", self.hname],
-            sys_newlines=True,
-            sys_shell=True,
-        )
-
-        self.hubConnectionString = json.loads(subProcessOut.stdout)["connectionString"]
-        subProcessOut = run_subprocess_cmd(
-            cmd=[
-                "az",
-                "iot",
-                "dps",
-                "linked-hub",
-                "create",
-                "--dps-name",
-                self.dname,
-                "--resource-group",
-                self.resourceGroup,
-                "--connection-string",
-                self.hubConnectionString,
-            ],
-            sys_newlines=True,
-            sys_shell=True,
-        )
-
-        if subProcessOut.returncode:
-            raise ValueError(
-                "Linking DPS to the Hub failed with {}".format(subProcessOut.returncode)
-            )
-        print("DPS linked successfully")
-
-    def register_dps(self, path):
-        sys_shell = True if sys.platform == "win32" else False
-        subProcessOut = run_subprocess_cmd(
-            cmd=[
-                "az",
-                "iot",
-                "dps",
-                "enrollment",
-                "show",
-                "--dps-name",
-                self.dname,
-                "--eid",
-                self.device_id,
-            ],
-            sys_newlines=True,
-            sys_shell=sys_shell,
-        )
-        if subProcessOut.returncode:
-            subProcessOut = run_subprocess_cmd(
-                cmd=[
-                    "az",
-                    "iot",
-                    "dps",
-                    "enrollment",
-                    "create",
-                    "-g",
-                    self.resourceGroup,
-                    "--dps-name",
-                    self.dname,
-                    "--enrollment-id",
-                    self.device_id,
-                    "--attestation-type",
-                    "x509",
-                    "--certificate-path",
-                    path,
-                ],
-                sys_newlines=True,
-                sys_shell=sys_shell,
-            )
-            if subProcessOut.returncode:
-                raise ValueError("Enrollment failed {}".format(subProcessOut.stdout))
+    def connect_azure(self, resource_group: str, dps_name: str):
+        self.az_resource_group = resource_group
+        self.dps_name = dps_name
+        self.az_sdk.connect_azure(self.az_resource_group, self.dps_name)
+
+    def az_dps_create(self, resource_group: str, dps_name: str):
+        print("Checking if the DPS exists...")
+        dps_instance = self.az_sdk.get_dps(resource_group, dps_name)
+        if (dps_instance is None):
+            print("Creating the dps....")
+            try:
+                dps_instance = self.az_sdk.create_dps(resource_group, dps_name)
+                print("DPS creation was successful")
+            except BaseException as e:
+                raise ValueError(
+                    "DPS creation creation failed with {}".format(e)
+                )
+        else:
+            print("Ok")
+        self.id_Scope = dps_instance.properties.id_scope
+        self.dps_name = dps_instance.name
+
+    def register_dps(self, cert_path: str) -> None:
+        enrollment = self.az_sdk.get_individual_enrollment(self.device_id)
+        if enrollment is None:
+            cert_content = None
+            with open(cert_path, 'rb') as f:
+                pem_data = f.read()
+                base64_data = base64.b64encode(pem_data)
+                cert_content = base64_data.decode('utf-8')
+            enrollment = self.az_sdk.enroll_device(
+                self.az_iot_hub,
+                self.device_id, cert_content)
             print("Device enrolled successfully")
         else:
-            print("Your devcie is already enrolled")
+            print("Devcie is already enrolled")
 
     def enroll_device(self, i2c_address, port, manifest, b):
         self.element = ECC608B(i2c_address, port)
         self.serial_number = self.element.get_device_serial_number()
         self.kit_atcab_init(i2c_address, port)
 
         device_manifest = manifest.get("json_file")
@@ -328,86 +119,90 @@
         print("Number of Devices: {}".format(iterator.index))
 
         while iterator.index != 0:
             se = Manifest().decode_manifest(
                 iterator.__next__(), manifest_ca.certificate
             )
             se_certs = Manifest().extract_public_data_pem(se)
-            slot = next((sub for sub in se_certs if sub.get("id") == str(0)), None)
+            slot = next(
+                (sub for sub in se_certs if sub.get("id") == str(0)), None)
             no_of_certs = len(slot.get("certs"))
             if no_of_certs:
                 device_cert = "device.crt"
 
                 with open(device_cert, "w") as f:
                     f.write(slot.get("certs")[no_of_certs - 2])
                     f.close()
 
                 self.device_id = get_certificate_CN(device_cert)
 
                 filename = make_valid_filename(self.device_id) + ".pem"
                 crt = Cert()
                 crt.set_certificate(device_cert)
                 with open(filename, "wb") as f:
-                    f.write(crt.certificate.public_bytes(encoding=Encoding.PEM))
+                    f.write(crt.certificate.public_bytes(
+                        encoding=Encoding.PEM))
                 cert_path = os.path.join(os.getcwd(), filename)
                 self.register_dps(cert_path)
 
     def kit_atcab_init(self, address, port):
         self.cfg.iface_type = int(cal.ATCAIfaceType.ATCA_UART_IFACE)
         self.cfg.devtype = int(cal.ATCADeviceType.ATECC608B)
         self.cfg.wake_delay = 1500
         self.cfg.rx_retries = 10
 
-        self.cfg.cfg.atcauart.dev_interface = int(cal.ATCAKitType.ATCA_KIT_I2C_IFACE)
+        self.cfg.cfg.atcauart.dev_interface = int(
+            cal.ATCAKitType.ATCA_KIT_I2C_IFACE)
         self.cfg.cfg.atcauart.dev_identity = address
         if isinstance(port, str):
             self.cfg.cfg.cfg_data = ctypes.c_char_p(port.encode("ascii"))
         else:
             self.cfg.cfg.atcauart.port = port
         self.cfg.cfg.atcauart.baud = 115200
         self.cfg.cfg.atcauart.wordsize = 8
         self.cfg.cfg.atcauart.parity = 2
         self.cfg.cfg.atcauart.stopbits = 1
         assert cal.atcab_init(self.cfg) == ATCA_SUCCESS
         # Initialize the stack
 
     def saveDataSlot(self, address, port):
         # Saving azure data to slot 8
-        if self.azure_credentials.get("idScope") != "":
-            self.idScope = self.azure_credentials.get("idScope")
+        dps_instance = self.az_sdk.get_dps(self.az_resource_group, self.dps_name)
+        self.id_Scope = dps_instance.properties.id_scope
 
         self.kit_atcab_init(address, port)
-        idScope_len = len(bytes(self.idScope, "utf-8"))
+        idScope_len = len(bytes(self.id_Scope, "utf-8"))
         data = struct.pack(
-            "BB {var1}s ".format(var1=len(self.idScope)),
+            "BB {var1}s ".format(var1=len(self.id_Scope)),
             address,
             idScope_len,
-            bytes(self.idScope, "utf-8"),
+            bytes(self.id_Scope, "utf-8"),
         )
         bytePads = len(data) % 4
         if bytePads != 0:
             bytePads = 4 - bytePads
             data = struct.pack(
-                "BB {var1}s  {bd}x".format(var1=len(self.idScope), bd=bytePads),
+                "BB {var1}s  {bd}x".format(
+                    var1=len(self.id_Scope), bd=bytePads),
                 address,
                 idScope_len,
-                bytes(self.idScope, "utf-8"),
+                bytes(self.id_Scope, "utf-8"),
             )
 
         offst = 0
         block_size = 32
         end_block = block_size
 
         if len(data) <= block_size:
             assert (
                 cal.atcab_write_bytes_zone(
                     Constants.ATCA_DATA_ZONE,
                     8,
                     offst,
-                    data[offst : len(data)],
+                    data[offst: len(data)],
                     len(data),
                 )
                 == ATCA_SUCCESS
             )
             print("Saving data to slot 8 was successful")
         else:
             while end_block < len(data):
@@ -439,15 +234,15 @@
                     )
                     print("Saving data to slot 8 was successful")
                     break
 
         cal.atcab_release()
 
     def save_i2c_add(self, address, port):
-        self.kit_atcab_init(0x6A, port)
+        self.kit_atcab_init(address, port)
         data = address.to_bytes(1, "big")
         assert (
             cal.atcab_write_bytes_zone(Constants.ATCA_DATA_ZONE, 8, 0, data, 4)
             == ATCA_SUCCESS
         )
         print("Secure element address saved successfully")
         cal.atcab_release()
```

## tpds/cloud_connect/azure_connect.py

```diff
@@ -16,149 +16,153 @@
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 
 import json
 import os
-import re
-import sys
 import yaml
+import base64
 from cryptography import x509
 from datetime import datetime, timezone, timedelta
 from pathlib import Path
-from .cloud_connect import CloudConnect
 from tpds.certs.cert import Cert
-from tpds.certs.cert_utils import (get_certificate_CN,
-                              get_certificate_thumbprint,
-                              random_cert_sn)
-from tpds.tp_utils.tp_utils import run_subprocess_cmd
 from tpds.tp_utils.tp_settings import TPSettings
 from tpds.tp_utils.tp_keys import TPAsymmetricKey
 from tpds.manifest import ManifestIterator, Manifest
+from tpds.certs.cert_utils import (
+    get_certificate_CN,
+    get_certificate_thumbprint,
+    random_cert_sn
+)
+from .cloud_connect import CloudConnect
+from .azure_sdk import AzureSDK_IotAuthentication
 
 
-class AzureConnect(CloudConnect):
+class AzureConnectBase(CloudConnect):
+    def __init__(self, SDK):
+        self.az_sdk = SDK()
+        self.az_credentials = {}
+        self.az_resource_group = ""
+        self.az_iot_hub = ""
+        self.az_subscription_id = ""
+        self.creds_file = os.path.join(TPSettings().get_base_folder(), 'azure_credentials.yaml')
+
+    def login(self):
+        self.az_sdk.login()
+
+    def save_credentials(self):
+        Path(self.creds_file).write_text(
+            yaml.dump(self.az_credentials, sort_keys=False))
+
+    def az_group_create(self, resource_group: str):
+        print("Checking if the resource group exists...")
+        if (not self.az_sdk.check_resource_existence(resource_group)):
+            print("Creating the Resource group...")
+            try:
+                self.az_sdk.create_resource_group(resource_group)
+                print("Azure Resource group created successfully")
+            except BaseException as e:
+                # print the error message in teriminal log
+                print(e)
+                raise ValueError(
+                    '''
+                    The creation of the resource group has failed. For more information,
+                    please check the terminal for detailed error messages.
+                    Try Creating manually in the Azure Portal.
+                    For additional guidance, please refer to the usecase helper.
+                    '''
+                )
+        else:
+            print("Ok")
+
+    def az_hub_create(self, resource_group: str, iot_hub: str):
+        print("Checking if the IoT Hub exists...")
+        hubInstance = self.az_sdk.get_iothub(resource_group, iot_hub)
+        if (hubInstance is None):
+            print("Creating the iot Hub.....")
+            print("Please wait, this may take up to 2 minutes...")
+            try:
+                self.az_sdk.create_iot_hub(resource_group, iot_hub)
+                print("Hub creation was successful")
+            except BaseException as e:
+                raise ValueError(
+                    "Hub creation creation failed with {}".format(e))
+        else:
+            print("Ok")
+
+    def set_subscription_id(self, subscription_id):
+        """
+        Setup Azure Client using subscription ID
+        """
+        if (not self.az_sdk.is_subscription_valid(subscription_id)):
+            raise ValueError("Subscription is not valid or does not exist.")
+
+        self.az_subscription_id = subscription_id
+        self.az_sdk.setup_client(self.az_subscription_id)
+
+
+class AzureConnect(AzureConnectBase):
     def __init__(self):
-        self.default_creds = {
+        super().__init__(AzureSDK_IotAuthentication)
+        self.az_credentials = {
             'title': 'Azure IoT Credentials',
             'subscription_id': '',
-            'resourcegroup': '',
-            'hubname': '',
-            'dpsname': '',
-            'idScope': ''
+            'resource_group': '',
+            'iot_hub': '',
         }
-        self.creds_file = os.path.join(
-                            TPSettings().get_base_folder(),
-                            'azure_credentials.yaml')
-        if not os.path.exists(self.creds_file):
-            Path(self.creds_file).write_text(
-                    yaml.dump(self.default_creds, sort_keys=False))
-
-    def set_credentials(self, credentials):
-        """
-        Method login azure portal via cli and
-        set the credentials in azure cli
-
-        Inputs:
-              credentials    contain azure iot hub name and
-                             subscription id
-        """
-        if not isinstance(credentials, dict):
-            raise ValueError('Unsupported User credentials type')
 
-        self.n_tail = '.azure-devices.net'
-        if credentials.get('iot_hub') is not None:
-            self.az_hub_name = credentials.get('iot_hub')
+        if not os.path.exists(self.creds_file):
+            self.save_credentials()
         else:
-            self.az_hub_name = credentials.get('hubname')
-        if self.az_hub_name.endswith(self.n_tail):
-            self.az_hub_name = self.az_hub_name[:-len(self.n_tail)]
-        self.az_subscription_id = credentials.get('subscription_id')
-
-        # login to acccount
-        sys_shell = True if sys.platform == 'win32' else False
-        print("Login to Azure account....", end='')
-        subProcessOut = run_subprocess_cmd(
-            cmd=["az", "login"], sys_shell=sys_shell)
-        if subProcessOut.returncode:
-            raise ValueError('Azure login failed with {}'.format(
-                                            subProcessOut.returncode))
-        print('OK')
+            with open(self.creds_file, 'r') as f:
+                self.az_credentials = yaml.safe_load(f)
 
-        # Setting up azure subscription id
-        print("Setting the Subscription ID....", end='')
-        subProcessOut = run_subprocess_cmd(
-            cmd=[
-                "az", "account", "set",
-                "--subscription", self.az_subscription_id],
-            sys_newlines=True, sys_shell=sys_shell)
-        if subProcessOut.returncode:
-            raise ValueError('Setting subscription failed with {}'.format(
-                                            subProcessOut.returncode))
-        print('OK')
+    def connect_azure(self, resource_group: str, iot_hub: str):
+        self.az_resource_group = resource_group
+        self.az_iot_hub = iot_hub
+        self.az_sdk.connect_azure(self.az_resource_group, self.az_iot_hub)
 
-    def register_device_as_self_signed(self, device_cert):
+    def register_device_as_self_signed(self, device_cert: str) -> None:
         """
         Method register device with authentication method as
         X509 self signed authentication. In this method, it will
         register device certificate thumbprint to Azure
 
         Inputs:
               device_cert      device certificate to be registered
         """
         device_id = get_certificate_CN(device_cert)
         thumbprint = get_certificate_thumbprint(device_cert)
 
         if self.is_device_registered(device_id):
             self.delete_registered_device(device_id)
 
-        sys_shell = True if sys.platform == 'win32' else False
         print('Registering device with thumbprint {}...'.format(
               thumbprint), end='')
-        subProcessOut = run_subprocess_cmd(
-            cmd=[
-                "az", "iot", "hub", "device-identity", "create",
-                "-n", self.az_hub_name,
-                "-d", device_id,
-                "--am", "x509_thumbprint",
-                "--ptp", thumbprint,
-                "--stp", thumbprint],
-            sys_newlines=True, sys_shell=sys_shell)
-        if subProcessOut.returncode:
-            raise ValueError('Device registration failed with {}'.format(
-                                                    subProcessOut.returncode))
+        self.az_sdk.register_device_with_x509(
+            device_id, thumbprint, thumbprint)
         print('OK')
 
-    def register_device_as_CA_signed(self, device_cert):
+    def register_device_as_CA_signed(self, device_cert: str) -> None:
         """
         Method register device with authentication method as
         X509 CA signed authentication. In this method, device certificate
         common name is registered as device id
 
         Inputs:
               device_cert     device certificate to be registered
         """
         device_id = get_certificate_CN(device_cert)
 
         if self.is_device_registered(device_id):
             self.delete_registered_device(device_id)
 
         print('Registering device with id {}...'.format(device_id), end='')
-        sys_shell = True if sys.platform == 'win32' else False
-        subProcessOut = run_subprocess_cmd(
-            cmd=[
-                "az", "iot", "hub", "device-identity", "create",
-                "-n", self.az_hub_name,
-                "-d", device_id,
-                "--am", "x509_ca"],
-            sys_newlines=True, sys_shell=sys_shell)
-        if subProcessOut.returncode:
-            raise ValueError('Device registration failed with {}'.format(
-                                                subProcessOut.returncode))
+        self.az_sdk.register_device_with_CA(device_id)
         print('OK')
 
     def register_device_from_manifest(
             self, device_manifest, device_manifest_ca,
             key_slot=0, as_self_signed=True):
         """
         Method register device from given manifest
@@ -196,57 +200,41 @@
                     f.close()
 
                 if as_self_signed:
                     self.register_device_as_self_signed(device_cert)
                 else:
                     self.register_device_as_CA_signed(device_cert)
 
-    def is_device_registered(self, device_id):
+    def is_device_registered(self, device_id: str) -> bool:
         """
         Method checks whether device is registered or not
         Inputs:
-             device_id      device certificate common name
+            device_id      device certificate common name
 
             return true if device is registered else false
         """
-        sys_shell = True if sys.platform == 'win32' else False
-        subProcessOut = run_subprocess_cmd(
-            cmd=[
-                "az", "iot", "hub", "device-identity", "list",
-                "--hub-name", self.az_hub_name,
-                "--query", "[].deviceId"],
-            sys_newlines=True, sys_shell=sys_shell)
-        if subProcessOut.returncode:
-            raise ValueError('Device id query failed with {}'.format(
-                                                subProcessOut.returncode))
+        devices = self.az_sdk.get_devices()
 
-        reg_device_id = re.findall(r'"(.*?)"', subProcessOut.stdout)
-        return (device_id in reg_device_id)
+        # filter the device_ids from the devices
+        device_ids = [dev.device_id for dev in devices]
 
-    def delete_registered_device(self, device_id):
+        return device_id in device_ids
+
+    def delete_registered_device(self, device_id: str) -> None:
         '''
         Method delete the registered device in Azure IoT hub
         Inputs:
             device_id        device certificate common name
         '''
-        print('Try Deleting device...', end='')
-        sys_shell = True if sys.platform == 'win32' else False
-        subProcessOut = run_subprocess_cmd(
-            cmd=[
-                "az", "iot", "hub", "device-identity", "delete",
-                "-n", self.az_hub_name,
-                "-d", device_id],
-            sys_newlines=True, sys_shell=sys_shell)
-        if subProcessOut.returncode:
-            raise ValueError('Device deletion failed with {}'.format(
-                                                subProcessOut.returncode))
+        print(f'Try Deleting device: {device_id}', end='')
+        self.az_sdk.delete_device(device_id)
         print('OK')
 
     def register_signer_certificate(
-                        self, signer_cert, signer_key='', verify_cert=''):
+            self, signer_cert, signer_key='', verify_cert=''):
         '''
         Method register the signer certificate in Azure IoT hub
         Steps followed to register signer:
         1. Upload signer certificate
         2. Get verification code and generate verification certificate
         3. Upload verification certificate
 
@@ -279,115 +267,80 @@
         Inputs:
             signer_cert      signer certificate
         """
         if not isinstance(signer_cert, str) or not os.path.exists(signer_cert):
             raise FileNotFoundError("Unknown Signer certificate type")
 
         signer_name = 'signer_{}'.format(
-                            get_certificate_thumbprint(signer_cert))
+            get_certificate_thumbprint(signer_cert))
 
         # Upload the signer certificate
         print('Uploading signer certificate to Azure IoT hub...', end='')
-        sys_shell = True if sys.platform == 'win32' else False
-        subProcessOut = run_subprocess_cmd(
-            cmd=[
-                "az", "iot", "hub", "certificate", "create",
-                "--hub-name", self.az_hub_name,
-                "--name", signer_name,
-                "--path", signer_cert],
-            sys_newlines=True, sys_shell=sys_shell)
-        if subProcessOut.returncode:
-            raise ValueError('Uploading Signer failed with {}'.format(
-                                                subProcessOut.returncode))
+
+        with open(signer_cert, 'rb') as f:
+            data = f.read()
+            cert_content = base64.b64encode(data).decode('utf-8')
+            self.az_sdk.create_certificate(self.az_resource_group, self.az_iot_hub, signer_name, cert_content)
         print('OK')
 
     def activate_signer_cert(self, signer_cert, verify_cert):
         """
         Method upload verification certificate, by validating this
         certificate, signer certificate will be registered successfully
 
         Inputs:
             signer_cert    path to signer certificate
             verify_cert    path to verification certificate
         """
         if not isinstance(signer_cert, str) or not os.path.exists(signer_cert):
             raise FileNotFoundError("Unknown Signer certificate type")
 
-        if (not isinstance(verify_cert, str) or
-           not os.path.exists(verify_cert)):
+        if (not isinstance(verify_cert, str) or not os.path.exists(verify_cert)):
             raise FileNotFoundError("Unknown Verification certificate type")
 
         signer_name = 'signer_{}'.format(
-                            get_certificate_thumbprint(signer_cert))
+            get_certificate_thumbprint(signer_cert))
         etag = self.get_signer_certificate_etag(signer_cert)
 
         # Uploading verification certificate
         print('Uploading verification certificate to azure IoT hub...', end='')
-        sys_shell = True if sys.platform == 'win32' else False
-        subProcessOut = run_subprocess_cmd(
-            cmd=[
-                "az", "iot", "hub", "certificate", "verify",
-                "--hub-name", self.az_hub_name,
-                "--name", signer_name,
-                "--path", verify_cert,
-                "--etag", etag],
-            sys_newlines=True, sys_shell=sys_shell)
-        if subProcessOut.returncode:
-            raise ValueError('Uploading Verify cert failed with {}'.format(
-                                                subProcessOut.returncode))
+
+        with open(verify_cert, 'rb') as f:
+            data = f.read()
+            cert_content = base64.b64encode(data).decode('utf-8')
+            self.az_sdk.verify_certificate(self.az_resource_group, self.az_iot_hub, signer_name, cert_content, etag)
         print('OK')
 
     def is_signer_registered(self, signer_cert):
         """
         Method check whether signer certificate is registered or not
         Inputs:
               signer_cert    signer certificate
 
             return true if signer certificate registered else false
         """
         signer_fingerprint = get_certificate_thumbprint(signer_cert)
 
-        sys_shell = True if sys.platform == 'win32' else False
-        subProcessOut = run_subprocess_cmd(
-            cmd=[
-                "az", "iot", "hub", "certificate", "list",
-                "--hub-name", self.az_hub_name,
-                "--query", "value[].properties[].thumbprint"],
-            sys_newlines=True, sys_shell=sys_shell)
-        if subProcessOut.returncode:
-            raise ValueError('Certificate list failed with {}'.format(
-                                                subProcessOut.returncode))
-
-        reg_signer_fignerprint = re.findall(r'"(.*?)"', subProcessOut.stdout)
-        return (signer_fingerprint in reg_signer_fignerprint)
+        thumbprints = self.az_sdk.get_certificates_thumbprint(self.az_resource_group, self.az_iot_hub)
+        return (signer_fingerprint in thumbprints)
 
     def delete_registered_signer(self, signer_cert):
         """
         Method delete the registered signer certificate in Azure IoT hub
         Inputs:
              signer_cert      signer certificate registered already
         """
         signer_name = 'signer_{}'.format(
-                            get_certificate_thumbprint(signer_cert))
+            get_certificate_thumbprint(signer_cert))
 
         # Get eTag
         eTag = self.get_signer_certificate_etag(signer_cert)
 
         print('Try Deleting Signer...', end='')
-        sys_shell = True if sys.platform == 'win32' else False
-        subProcessOut = run_subprocess_cmd(
-            cmd=[
-                "az", "iot", "hub", "certificate", "delete",
-                "--etag", eTag,
-                "--name", signer_name,
-                "--hub-name", self.az_hub_name],
-            sys_newlines=True, sys_shell=sys_shell)
-        if subProcessOut.returncode:
-            raise ValueError('Device deletion failed with {}'.format(
-                                                subProcessOut.returncode))
+        self.az_sdk.delete_certificate(self.az_resource_group, self.az_iot_hub, signer_name, eTag)
         print('OK')
 
     def get_verification_cert(self, signer_key, signer_cert, file=''):
         """
         Method get the verification code and generate verification cert
 
         Inputs:
@@ -403,35 +356,24 @@
 
         etag_id = self.get_signer_certificate_etag(signer_cert)
         signer_fingerprint = get_certificate_thumbprint(signer_cert)
         signer_name = 'signer_{}'.format(signer_fingerprint)
 
         # Request a verification code for signer certificate
         print('Getting verification code from azure IoT hub...', end='')
-        sys_shell = True if sys.platform == 'win32' else False
-        subProcessOut = run_subprocess_cmd(
-            cmd=[
-                "az", "iot", "hub", "certificate",
-                "generate-verification-code", "--hub-name", self.az_hub_name,
-                "--name", signer_name, "--etag", etag_id],
-            sys_newlines=True, sys_shell=sys_shell)
-        if subProcessOut.returncode:
-            raise ValueError('Verification code request failed with {}'.format(
-                                                    subProcessOut.returncode))
-        reg_code = json.loads(subProcessOut.stdout).get(
-            'properties').get('verificationCode')
+        reg_code = self.az_sdk.generate_verification_code(self.az_resource_group, self.az_iot_hub, signer_name, etag_id)
         print('{}'.format(reg_code))
 
         # Generate a verification certificate around the registration code
         # (subject common name)
         print('Generating signer CA verification certificate...', end='')
         verify_cert = Cert()
         verify_cert.builder = x509.CertificateBuilder()
         verify_cert.builder = verify_cert.builder.serial_number(
-                                random_cert_sn(16))
+            random_cert_sn(16))
         verify_cert.builder = verify_cert.builder.issuer_name(
             ca_cert.certificate.subject)
         verify_cert.builder = verify_cert.builder.not_valid_before(
             datetime.utcnow().replace(tzinfo=timezone.utc))
         verify_cert.builder = verify_cert.builder.not_valid_after(
             verify_cert.builder._not_valid_before + timedelta(days=1))
         verify_cert.builder = verify_cert.builder.subject_name(
@@ -452,29 +394,15 @@
         Methos get the etag from Azure IoT hub for given signer certificate
         Inputs:
               signer_cert       signer certificate
         Outputs:
               etag              etag for signer certifcate
         """
         signer_name = 'signer_{}'.format(
-                            get_certificate_thumbprint(signer_cert))
-
-        sys_shell = True if sys.platform == 'win32' else False
-        subProcessOut = run_subprocess_cmd(
-            cmd=[
-                "az", "iot", "hub", "certificate", "show",
-                "--hub-name", self.az_hub_name,
-                "--name", signer_name,
-                "--query", "etag"],
-            sys_newlines=True, sys_shell=sys_shell)
-        if subProcessOut.returncode:
-            raise ValueError('Certificate list failed with {}'.format(
-                                                subProcessOut.returncode))
+            get_certificate_thumbprint(signer_cert))
 
-        # Get eTag
-        return subProcessOut.stdout.rstrip("\n")
+        # get eTag
+        return self.az_sdk.get_certificate_etag(self.az_resource_group, self.az_iot_hub, signer_name)
 
 
-# Standard boilerplate to call the main() function to begin
-# the program.
 if __name__ == '__main__':
     pass
```

## tpds/cloud_connect/cloud_connect.py

```diff
@@ -15,16 +15,18 @@
 # KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 
 
-class CloudConnect():
+class CloudConnect:
     def __init__(self):
         pass
 
 
+__all__ = ["CloudConnect"]
+
 # Standard boilerplate to call the main() function to begin
 # the program.
-if __name__ == '__main__':
+if __name__ == "__main__":
     pass
```

## tpds/cloud_connect/gcp_connect.py

```diff
@@ -14,156 +14,139 @@
 # PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY
 # KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 
-import csv
 import json
 import os
-import yaml
 from pathlib import Path
-from google.cloud import iot_v1
-from .cloud_connect import CloudConnect
+
+import yaml
 from google.api_core.exceptions import AlreadyExists
+from google.cloud import iot_v1
+
 from tpds.certs import Cert
-from tpds.manifest import ManifestIterator, Manifest
+from tpds.manifest import Manifest, ManifestIterator
 from tpds.tp_utils.tp_settings import TPSettings
 
+from .cloud_connect import CloudConnect
+
 
 class GCPConnect(CloudConnect):
     def __init__(self):
-        self.project_id = ''
-        self.registry_id = ''
-        self.region = ''
-        self.default_creds = {
-            'title': 'GCP IoT Credentials',
-            'registry_id': '',
-            'region': ''
-        }
-        self.creds_file = os.path.join(
-                            TPSettings().get_base_folder(),
-                            'gcp_credentials.yaml')
+        self.project_id = ""
+        self.registry_id = ""
+        self.region = ""
+        self.default_creds = {"title": "GCP IoT Credentials", "registry_id": "", "region": ""}
+        self.creds_file = os.path.join(TPSettings().get_base_folder(), "gcp_credentials.yaml")
         if not os.path.exists(self.creds_file):
-            Path(self.creds_file).write_text(
-                    yaml.dump(self.default_creds, sort_keys=False))
+            Path(self.creds_file).write_text(yaml.dump(self.default_creds, sort_keys=False))
 
-    def set_credentials(self, iot_manifest=None, data_view=None,
-                        credentials=None):
+    def set_credentials(self, iot_manifest=None, data_view=None, credentials=None):
         """
         Method logins into gcp portal via cli and
         set the credentials in azure cli
 
         Inputs:
               credentials    contain Registry ID and Region
         """
         # Set the project id
-        if (isinstance(iot_manifest, str) and os.path.exists(iot_manifest)
-           and iot_manifest.endswith('.json')):
+        if (
+            isinstance(iot_manifest, str)
+            and os.path.exists(iot_manifest)
+            and iot_manifest.endswith(".json")
+        ):
             with open(iot_manifest) as f:
-                self.project_id = json.load(f).get('project_id')
+                self.project_id = json.load(f).get("project_id")
         else:
-            raise ValueError('Check GCP iot-manifest file information')
+            raise ValueError("Check GCP iot-manifest file information")
 
         # set the environment variable
         os.environ["GOOGLE_APPLICATION_CREDENTIALS"] = iot_manifest
 
-        if (isinstance(data_view, str) and os.path.exists(data_view)
-           and data_view.endswith('.json')):
+        if isinstance(data_view, str) and os.path.exists(data_view) and data_view.endswith(".json"):
             self.data_view = data_view
         else:
-            raise ValueError('Check GCP data_view file information')
+            raise ValueError("Check GCP data_view file information")
 
         # set the registry id and region
         if not isinstance(credentials, dict):
-            raise ValueError('Unsupported User credentials type')
+            raise ValueError("Unsupported User credentials type")
 
-        self.registry_id = credentials.get('registry_id')
-        self.region = credentials.get('region')
+        self.registry_id = credentials.get("registry_id")
+        self.region = credentials.get("region")
 
     def register_device(self, secure_element_manifest):
-        """Method registers device with GCP
-        """
+        """Method registers device with GCP"""
         if not secure_element_manifest:
-            raise ValueError('Unsupported manifest format to process!')
+            raise ValueError("Unsupported manifest format to process!")
         try:
             client = iot_v1.DeviceManagerClient()
-            parent = client.registry_path(self.project_id, self.region,
-                                          self.registry_id)
+            parent = client.registry_path(self.project_id, self.region, self.registry_id)
 
             for device in secure_element_manifest:
-                print('Registering device with id {}...'.format(
-                            device.get('id')), end='')
+                print("Registering device with id {}...".format(device.get("id")), end="")
                 client.create_device(parent=parent, device=device)
-                print('OK')
+                print("OK")
 
         except AlreadyExists:
-            print('Device is registered already!!!')
+            print("Device is registered already!!!")
             pass
 
         except Exception as e:
-            print('     {}'.format(e))
+            print("     {}".format(e))
             raise
 
-    def register_from_manifest(self, device_manifest, device_manifest_ca,
-                               key_slot=0):
+    def register_from_manifest(self, device_manifest, device_manifest_ca, key_slot=0):
         """
         Method register device from given manifest
         Inputs:
               device_manifest     manifest contains certs and public keys
               device_manifest_ca  manifest signer key
               key_slot            slot where device private key present
 
             return true if device registered successfully else false
         """
         if device_manifest is None:
-            raise ValueError('Unsupported manifest format to process')
-        if os.path.exists(device_manifest) \
-                and device_manifest.endswith('.json'):
+            raise ValueError("Unsupported manifest format to process")
+        if os.path.exists(device_manifest) and device_manifest.endswith(".json"):
             with open(device_manifest) as json_data:
                 device_manifest = json.load(json_data)
 
         if not isinstance(device_manifest, list):
-            raise ValueError('Unsupport manifest format to process')
+            raise ValueError("Unsupport manifest format to process")
 
         manifest_ca = Cert()
         manifest_ca.set_certificate(device_manifest_ca)
         iterator = ManifestIterator(device_manifest)
-        print('Number of certificates: {}'.format(iterator.index))
+        print("Number of certificates: {}".format(iterator.index))
 
         while iterator.index != 0:
-            se = Manifest().decode_manifest(
-                iterator.__next__(), manifest_ca.certificate)
+            se = Manifest().decode_manifest(iterator.__next__(), manifest_ca.certificate)
             se_certs = Manifest().extract_public_data_pem(se)
-            slot = next((sub for sub in se_certs if sub.get(
-                'id') == str(key_slot)), None)
+            slot = next((sub for sub in se_certs if sub.get("id") == str(key_slot)), None)
 
             pubkey_format = dict()
-            if slot.get('certs'):
-                no_of_certs = len(slot.get('certs'))
-                pubkey_format.update({'format': 'ES256_X509_PEM'})
-                pubkey_format.update({'key': slot.get('certs')[no_of_certs-2]})
-            elif slot.get('pub_key'):
-                pubkey_format.update({'format': 'ES256_PEM'})
-                pubkey_format.update({'key': slot.get('pub_key')})
+            if slot.get("certs"):
+                no_of_certs = len(slot.get("certs"))
+                pubkey_format.update({"format": "ES256_X509_PEM"})
+                pubkey_format.update({"key": slot.get("certs")[no_of_certs - 2]})
+            elif slot.get("pub_key"):
+                pubkey_format.update({"format": "ES256_PEM"})
+                pubkey_format.update({"key": slot.get("pub_key")})
             else:
-                raise ValueError('Unknown manifest secure element object!')
+                raise ValueError("Unknown manifest secure element object!")
 
             # GCP manifest format which will be uploaded later
-            manifest_format = {
-                'id': '',
-                'credentials': [{
-                        'public_key': dict()
-                }]
-            }
+            manifest_format = {"id": "", "credentials": [{"public_key": dict()}]}
             se_manifest = []
-            manifest_format.update(
-                {'id': f'''d{se.get('uniqueId').upper()}'''})
-            manifest_format['credentials'][0]['public_key'] = pubkey_format
+            manifest_format.update({"id": f"""d{se.get('uniqueId').upper()}"""})
+            manifest_format["credentials"][0]["public_key"] = pubkey_format
             se_manifest.append(manifest_format)
             self.register_device(se_manifest)
 
     def execute_gcp_gui(self, qtUiFile):
         # os.environ["GOOGLE_APPLICATION_CREDENTIALS"] = self.data_view
         # with open(self.data_view) as f:
         #     self.project_id = json.load(f).get('project_id')
@@ -172,14 +155,16 @@
         # if app is None:
         #     app = QtWidgets.QApplication(sys.argv)
         # GCP_GUI(self.project_id, 'data-view', qtUiFile)
         # app.exec_()
         pass
 
 
+__all__ = ["GCPConnect"]
+
 # class GCP_GUI(QtWidgets.QMainWindow):
 #     """Basic Message Visualizer gui"""
 #     def __init__(self, project_id, subscription_id, qtUiFile):
 #         super(GCP_GUI, self).__init__(parent=None)
 #         self.qtUiFile = qtUiFile
 #         self.load_UI()
 
@@ -232,9 +217,9 @@
 #         self.add_data(sample_time.strftime("%H:%M:%S"), serialno, led_status)
 
 #         message.ack()
 
 
 # Standard boilerplate to call the main() function to begin
 # the program.
-if __name__ == '__main__':
+if __name__ == "__main__":
     pass
```

## tpds/flash_program/__init__.py

```diff
@@ -1,8 +1,8 @@
 """
     Trust Platform core package - flash_program module
 """
 
 from .flash_program import FlashProgram
 from .kit_connect import KitConnect
 
-__all__ = ['FlashProgram', 'KitConnect']
+__all__ = ["FlashProgram", "KitConnect"]
```

## tpds/flash_program/flash_program.py

```diff
@@ -15,24 +15,25 @@
 # KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 
 import os
-import time
 import platform
+import time
 from pathlib import Path
+
 from packaging.version import Version
 from pymcuprog.backend import Backend, SessionConfig
 from pymcuprog.toolconnection import ToolUsbHidConnection
 
 from tpds.tp_utils import run_subprocess_cmd
-from tpds.tp_utils.tp_settings import TPSettings
 from tpds.tp_utils.tp_client import tpdsAPI_get
+from tpds.tp_utils.tp_settings import TPSettings
 
 from .kit_connect import KitConnect
 
 
 class FlashProgram:
     """
     Class with methods which help with wrappers and
@@ -41,36 +42,34 @@
 
     def __init__(self, board_name="DM320118", board_info=None):
         self.board_name = board_name
         if board_info:
             self.board_info = board_info
         else:
             self.board_info = tpdsAPI_get(f"boards/get_details/{self.board_name}")
-        assert (
-            self.board_info
-        ), "Board Information cannot be None, Check board definitions."
+        assert self.board_info, "Board Information cannot be None, Check board definitions."
         self.kit = KitConnect(self.board_info)
         self.board_details = self.kit.get_board_details()
 
     def check_board_status(self):
-        if self.is_factory_programmed():
+        if self.kit.kit_iface.is_factory_programmed():
             board_status = "factory_programmed"
             if not self.is_kitparser_updated():
                 board_status = "outdated_factory_program"
         elif self.is_board_connected():
             board_status = "board_connected"
         else:
             board_status = "board_disconnected"
         return board_status
 
     def is_board_connected(self):
         return self.kit.is_board_connected()
 
     def is_factory_programmed(self):
-        return self.kit.kit_iface.is_factory_programmed()
+        return self.check_board_status() == "factory_programmed"
 
     def is_kitparser_updated(self):
         current_version = self.kit.kit_iface.get_kit_version()
         target_version = self.board_info.kit_parser_version
         return Version(current_version) >= Version(target_version)
 
     def load_hex_image(self, hexfile_path):
@@ -80,17 +79,15 @@
 
         Outputs:
               Returns true or error message
         """
         try:
             backend = Backend()
             backend.connect_to_tool(
-                ToolUsbHidConnection(
-                    serialnumber=self.board_details.get("serial_number")
-                )
+                ToolUsbHidConnection(serialnumber=self.board_details.get("serial_number"))
             )
             backend.start_session(
                 SessionConfig(self.board_details.get("debugger", {}).get("device"))
             )
             backend.erase()
             backend.write_hex_to_target(hexfile_path)
             if backend.verify_hex(hexfile_path):
@@ -125,22 +122,18 @@
         self.jar_loc = mplab_paths.get("jar_loc")
         self.java_loc = mplab_paths.get("java_loc")
 
         if not self.mplab_path:
             raise PermissionError("MPLAB Path is not set... Pls program manually")
 
         if self.jar_loc is None or self.java_loc is None:
-            raise FileNotFoundError(
-                "jar/java file(s) not found... Pls program manually"
-            )
+            raise FileNotFoundError("jar/java file(s) not found... Pls program manually")
 
         if not os.path.exists(hexfile_path):
-            raise FileNotFoundError(
-                f"{hexfile_path} is not found... Pls program manually"
-            )
+            raise FileNotFoundError(f"{hexfile_path} is not found... Pls program manually")
 
         subprocessout = self.__flash_micro(hexfile_path, addl_args)
         if subprocessout.returncode:
             raise ValueError(
                 "Programming failed with {} error code, Please rerun \
                     \nor program manually!".format(
                     subprocessout.returncode
```

## tpds/flash_program/kit_connect.py

```diff
@@ -15,150 +15,147 @@
 # KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 
 import platform
-import hid
 import re
-import serial
+
+import hid
 import libusb_package
-import usb.core
+import serial
 import usb.backend.libusb1
+import usb.core
 import usb.util
 from pykitinfo import pykitinfo
 from tpds.helper import log
 
 
-class KitConnect():
+class KitConnect:
     def __init__(self, board_info):
         self.board_info = board_info
-        if self.board_info.connection.interfaceType == 'hid':
+        if self.board_info.connection.interfaceType == "hid":
             self.kit_iface = KitConnectHid(board_info)
         else:
             self.kit_iface = KitConnectUART(board_info)
 
     def is_board_connected(self):
         for kit in pykitinfo.detect_all_kits():
-            if self.board_info.mcu_part_number == \
-                kit.get("debugger").get("device") or \
-                    self.board_info.kit_name == \
-                    kit.get('debugger', {}).get('kitname', ''):
+            if self.board_info.mcu_part_number == kit.get("debugger").get(
+                "device"
+            ) or self.board_info.kit_name == kit.get("debugger", {}).get("kitname", ""):
                 return True
         return False
 
     def get_kit_connected_COM(self):
         com_port = None
         kits = pykitinfo.detect_all_kits()
         for kit in kits:
-            if self.board_info.kit_name == \
-                    kit.get('debugger', {}).get('kitname', ''):
-                port = kit.get('debugger', {}).get('serial_port', None)
-                if port and platform.system() == 'Windows':
+            if self.board_info.kit_name == kit.get("debugger", {}).get("kitname", ""):
+                port = kit.get("debugger", {}).get("serial_port", None)
+                if port and platform.system() == "Windows":
                     com_port = int(port[3:])
                 else:
                     com_port = port
         return com_port
 
     def get_board_details(self):
         board_details = None
         for kit in pykitinfo.detect_all_kits():
-            if self.board_info.mcu_part_number == \
-                    kit.get("debugger").get("device") or \
-                    self.board_info.kit_name == \
-                    kit.get('debugger', {}).get('kitname', ''):
+            if self.board_info.mcu_part_number == kit.get("debugger").get(
+                "device"
+            ) or self.board_info.kit_name == kit.get("debugger", {}).get("kitname", ""):
                 board_details = kit
         return board_details
 
     def set_board_info(self, board_info):
         self.board_info = board_info
 
 
 class KitConnectHid(KitConnect):
     def __init__(self, board_info):
         self.set_board_info(board_info)
 
     def is_factory_programmed(self):
         for dev in hid.enumerate(
-                vendor_id=self.board_info.connection.vid,
-                product_id=self.board_info.kit_parser_pid):
-            if dev['product_string'] == self.board_info.product_string:
+            vendor_id=self.board_info.connection.vid, product_id=self.board_info.kit_parser_pid
+        ):
+            if dev["product_string"] == self.board_info.product_string:
                 return True
         return False
 
     def get_kit_version(self):
-        msg = 'b:f()\n'
-        if platform.system() == 'Windows':
-            msg = f'{msg:64}'
+        msg = "b:f()\n"
+        if platform.system() == "Windows":
+            msg = f"{msg:64}"
         try:
             response = self.__send_query_to_board(msg)
             version = re.findall("\\((.*?)\\)", response)[0]
-            kit_version = '.'.join(
-                a + b for a, b in zip(version[::2], version[1::2]))
+            kit_version = ".".join(a + b for a, b in zip(version[::2], version[1::2]))
         except BaseException as e:
             log(f"Version fetch has failed with error: {e}")
             kit_version = "0.0.0"
         return kit_version
 
     def __send_query_to_board(self, query):
-        libusb1_backend = usb.backend.libusb1.get_backend(
-            find_library=libusb_package.find_library)
+        libusb1_backend = usb.backend.libusb1.get_backend(find_library=libusb_package.find_library)
         dev = usb.core.find(
             idVendor=self.board_info.connection.vid,
             idProduct=self.board_info.kit_parser_pid,
             product=self.board_info.product_string,
-            backend=libusb1_backend)
-        assert dev, ((
-            f'{self.board_info.description} with PID: '
-            f'0x{self.board_info.kit_parser_pid:04X} is not connected. '
-            'Connect board and try again.'))
-
-        assert dev.write(1, query, 100) == (len(query) + 1), \
-            'USB Write is failed... Reset board and retry again'
-        response = ''.join([chr(x) for x in dev.read(0x81, len(query), 100)])
+            backend=libusb1_backend,
+        )
+        assert dev, (
+            f"{self.board_info.description} with PID: "
+            f"0x{self.board_info.kit_parser_pid:04X} is not connected. "
+            "Connect board and try again."
+        )
+
+        assert dev.write(1, query, 100) == (
+            len(query) + 1
+        ), "USB Write is failed... Reset board and retry again"
+        response = "".join([chr(x) for x in dev.read(0x81, len(query), 100)])
         log(f"Response from the board: {response}")
         return response
 
 
 class KitConnectUART(KitConnect):
     def __init__(self, board_info):
         self.set_board_info(board_info)
         self.com_port = self.get_kit_connected_COM()
         log(f"Kit Uart COM port: {self.com_port}")
-        assert self.com_port, \
-            'COM port is not detected... Check the connections and try again.'
+        assert self.com_port, "COM port is not detected... Check the connections and try again."
 
     def is_factory_programmed(self):
         is_programmed = False
         try:
-            is_programmed = self.__send_query_to_board(b'b:f()\n') is not None
+            is_programmed = self.__send_query_to_board(b"b:f()\n") is not None
         except BaseException as e:
-            log(f'{e}')
+            log(f"{e}")
         return is_programmed
 
     def get_kit_version(self):
         try:
-            response = self.__send_query_to_board(b'b:f()\n')
+            response = self.__send_query_to_board(b"b:f()\n")
             version = re.findall("\\((.*?)\\)", response)[0]
-            kit_version = '.'.join(
-                a + b for a, b in zip(version[::2], version[1::2]))
+            kit_version = ".".join(a + b for a, b in zip(version[::2], version[1::2]))
         except BaseException as e:
             log(f"Version fetch has failed with error: {e}")
             kit_version = "0.0.0"
         return kit_version
 
     def __send_query_to_board(self, query):
         response = None
-        with serial.Serial(f'COM{self.com_port}', 115200, timeout=5) as ser:
+        with serial.Serial(f"COM{self.com_port}", 115200, timeout=5) as ser:
             ser.write(query)
             response = ser.readline().decode()
             log(f"Response from the board: {response}")
         return response
 
 
 # Standard boilerplate to call the main() function to begin
 # the program.
-if __name__ == '__main__':
+if __name__ == "__main__":
     pass
 
-__all__ = ['KitConnect']
+__all__ = ["KitConnect"]
```

## tpds/manifest/__init__.py

```diff
@@ -1,6 +1,8 @@
 """
     Trust Platform core package - manifest module
 """
-from .manifest import *
-from .tflx_manifest import *
-from .tng_manifest import *
+from .manifest import Manifest, ManifestIterator
+from .tflx_manifest import TFLXTLSManifest
+from .tng_manifest import TNGTLSManifest
+
+__all__ = ["Manifest", "ManifestIterator", "TFLXTLSManifest", "TNGTLSManifest"]
```

## tpds/manifest/manifest.py

```diff
@@ -14,107 +14,103 @@
 # PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY
 # KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 
-import os
 import json
+import os
 import warnings
+
 with warnings.catch_warnings():
     # this will suppress all warnings in this block
-    warnings.filterwarnings('ignore', message='int_from_bytes is deprecated')
+    warnings.filterwarnings("ignore", message="int_from_bytes is deprecated")
     import jose
     import jose.jws
     from jose.utils import base64url_decode, base64url_encode
+
+from base64 import b64decode, urlsafe_b64encode
+from datetime import datetime, timedelta, timezone
+from pathlib import Path
+
 from cryptography import x509
 from cryptography.hazmat.backends import default_backend
 from cryptography.hazmat.primitives import hashes, serialization
-from cryptography.hazmat.primitives.asymmetric import ec, utils as crypto_utils
+from cryptography.hazmat.primitives.asymmetric import ec
+from cryptography.hazmat.primitives.asymmetric import utils as crypto_utils
 from cryptography.utils import int_to_bytes
-from base64 import b64decode, urlsafe_b64encode
-from datetime import datetime, timezone, timedelta
-from pathlib import Path
 
 # List out allowed verification algorithms for the JWS.
 # Only allows public-key based ones.
-verification_algorithms = [
-    'RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'ES512']
+verification_algorithms = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512"]
 
 
-class Manifest():
+class Manifest:
     def __init__(self):
         self.version = 1
-        self.model = ''
-        self.partNumber = ''
-        self.manufacturer = {
-            'organizationName': '',
-            'organizationalUnitName': ''}
-        self.provisioner = {
-            'organizationName': '',
-            'organizationalUnitName': ''}
-        self.distributor = {
-            'organizationName': '',
-            'organizationalUnitName': ''}
-        self.provisioningTimestamp = ''
-        self.uniqueId = ''
+        self.model = ""
+        self.partNumber = ""
+        self.manufacturer = {"organizationName": "", "organizationalUnitName": ""}
+        self.provisioner = {"organizationName": "", "organizationalUnitName": ""}
+        self.distributor = {"organizationName": "", "organizationalUnitName": ""}
+        self.provisioningTimestamp = ""
+        self.uniqueId = ""
         self.publicKeySet = dict()
 
     def set_provisioning_time(self, time):
         """
         Initialize the device provisioning time stamp
 
         Inputs:
               time             device certificate provisioned time
         """
-        self.provisioningTimestamp \
-            = time.strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + 'Z'
+        self.provisioningTimestamp = time.strftime("%Y-%m-%dT%H:%M:%S.%f")[:-3] + "Z"
 
     def set_unique_id(self, uniqueid):
         """
         Initialize the device unique id
 
         Inputs:
               uniqueid          device uniqueid which added into manifest
         """
         if isinstance(uniqueid, str):
             self.uniqueId = uniqueid
         elif isinstance(uniqueid, bytearray):
             self.uniqueId = uniqueid.hex()
 
-    def set_publicJWK(self, kid, kty='', crv='', x=None, y=None, x5c=None):
+    def set_publicJWK(self, kid, kty="", crv="", x=None, y=None, x5c=None):
         """
         Set JSON Web Keys (public keys and x509 certificates)
 
         Inputs:
               kid          key id or slot id of public/private key
               kty          key type
               crv          Algorithm curve type
               x            x component of public key
               y            y component of public key
               x5c          x509 certificates if any
         """
         publicJWK = dict()
-        publicJWK['kid'] = kid
-        if kty in ['EC', 'RSA', 'oct']:
-            publicJWK['kty'] = kty
-        if crv in ['P-256', 'P-384', 'P-521']:
-            publicJWK['crv'] = crv
+        publicJWK["kid"] = kid
+        if kty in ["EC", "RSA", "oct"]:
+            publicJWK["kty"] = kty
+        if crv in ["P-256", "P-384", "P-521"]:
+            publicJWK["crv"] = crv
         if x is not None:
-            publicJWK['x'] = x
+            publicJWK["x"] = x
         if y is not None:
-            publicJWK['y'] = y
+            publicJWK["y"] = y
         if isinstance(x5c, list):
-            publicJWK['x5c'] = x5c
+            publicJWK["x5c"] = x5c
 
-        if 'keys' not in self.publicKeySet:
-            self.publicKeySet['keys'] = []
+        if "keys" not in self.publicKeySet:
+            self.publicKeySet["keys"] = []
 
-        self.publicKeySet['keys'].append(publicJWK)
+        self.publicKeySet["keys"].append(publicJWK)
 
     def encode_manifest(self, ca_key_path=None, ca_cert_path=None):
         """
         Function generate secure signed element object which contains payload,
         protected, header and signature.
 
         Inputs:
@@ -134,46 +130,38 @@
             ca_cert_path = None
 
         ca_key_path, ca_key = self.__load_ca_key(ca_key_path)
         ca_cert_path, ca_cert = self.__load_ca_cert(ca_key, ca_cert_path)
 
         # Precompute the JWT header
         sse_protected_header = {
-            'typ': 'JWT',
-            'alg': 'ES256',
-            'kid': self.__jws_b64encode(
-                ca_cert.extensions.get_extension_for_class(
-                    x509.SubjectKeyIdentifier).value.digest),
-            'x5t#S256':
-                self.__jws_b64encode(ca_cert.fingerprint(hashes.SHA256()))
+            "typ": "JWT",
+            "alg": "ES256",
+            "kid": self.__jws_b64encode(
+                ca_cert.extensions.get_extension_for_class(x509.SubjectKeyIdentifier).value.digest
+            ),
+            "x5t#S256": self.__jws_b64encode(ca_cert.fingerprint(hashes.SHA256())),
         }
 
         se_object = self.get_manifest()
         signed_se = {
-            'payload': self.__jws_b64encode(json.dumps(
-                se_object).encode('ascii')),
-            'protected': self.__jws_b64encode(
-                json.dumps(sse_protected_header).encode('ascii')),
-            'header': {
-                'uniqueId': self.uniqueId
-            }
+            "payload": self.__jws_b64encode(json.dumps(se_object).encode("ascii")),
+            "protected": self.__jws_b64encode(json.dumps(sse_protected_header).encode("ascii")),
+            "header": {"uniqueId": self.uniqueId},
         }
 
         # Sign sse object
-        tbs = signed_se['protected'] + '.' + signed_se['payload']
-        signature = ca_key.sign(tbs.encode('ascii'), ec.ECDSA(hashes.SHA256()))
+        tbs = signed_se["protected"] + "." + signed_se["payload"]
+        signature = ca_key.sign(tbs.encode("ascii"), ec.ECDSA(hashes.SHA256()))
         r_int, s_int = crypto_utils.decode_dss_signature(signature)
-        signed_se['signature'] = self.__jws_b64encode(
-            int_to_bytes(r_int, 32) + int_to_bytes(s_int, 32))
+        signed_se["signature"] = self.__jws_b64encode(
+            int_to_bytes(r_int, 32) + int_to_bytes(s_int, 32)
+        )
 
-        return {
-            'signed_se': signed_se,
-            'ca_key_path': ca_key_path,
-            'ca_cert_path': ca_cert_path
-        }
+        return {"signed_se": signed_se, "ca_key_path": ca_key_path, "ca_cert_path": ca_cert_path}
 
     def decode_manifest(self, signed_se, ca_cert=None):
         """
         Function decode the SecureSignedElement Object by verifying the
         signature in it
 
         Inputs:
@@ -184,278 +172,291 @@
             se              contains secure element
         """
         # Load verification certificate
         if isinstance(ca_cert, x509.Certificate):
             verification_cert = ca_cert
         elif isinstance(ca_cert, str) and os.path.exists(ca_cert):
             cert_data = Path(ca_cert).read_bytes()
-            verification_cert = x509.load_pem_x509_certificate(
-                cert_data, default_backend())
+            verification_cert = x509.load_pem_x509_certificate(cert_data, default_backend())
         else:
             raise ValueError("Unknown manifest CA certificate format!")
 
         # Convert verification certificate public key to PEM format
-        verification_public_key_pem \
-            = verification_cert.public_key().public_bytes(
+        verification_public_key_pem = (
+            verification_cert.public_key()
+            .public_bytes(
                 encoding=serialization.Encoding.PEM,
-                format=serialization.PublicFormat.SubjectPublicKeyInfo).decode(
-                    'ascii')
+                format=serialization.PublicFormat.SubjectPublicKeyInfo,
+            )
+            .decode("ascii")
+        )
 
         # Get the base64url encoded subject key identifier for the v
         # verification cert
         ski_ext = verification_cert.extensions.get_extension_for_class(
-            extclass=x509.SubjectKeyIdentifier)
-        verification_cert_kid_b64 = base64url_encode(
-            ski_ext.value.digest).decode('ascii')
+            extclass=x509.SubjectKeyIdentifier
+        )
+        verification_cert_kid_b64 = base64url_encode(ski_ext.value.digest).decode("ascii")
 
         # Get the base64url encoded sha-256 thumbprint for the verification
         # cert
         verification_cert_x5t_s256_b64 = base64url_encode(
-            verification_cert.fingerprint(hashes.SHA256())).decode('ascii')
+            verification_cert.fingerprint(hashes.SHA256())
+        ).decode("ascii")
 
         # Decode the protected header
-        protected = json.loads(base64url_decode(
-            signed_se['protected'].encode('ascii')))
+        protected = json.loads(base64url_decode(signed_se["protected"].encode("ascii")))
 
-        if protected['kid'] != verification_cert_kid_b64:
-            print('kid does not match certificate value')
+        if protected["kid"] != verification_cert_kid_b64:
+            print("kid does not match certificate value")
             return {}
 
-        if protected['x5t#S256'] != verification_cert_x5t_s256_b64:
-            print('x5t#S256 does not match certificate value')
+        if protected["x5t#S256"] != verification_cert_x5t_s256_b64:
+            print("x5t#S256 does not match certificate value")
             return {}
 
         # Convert JWS to compact form as required by python-jose
-        jws_compact = '.'.join([
-            signed_se['protected'],
-            signed_se['payload'],
-            signed_se['signature']])
+        jws_compact = ".".join(
+            [signed_se["protected"], signed_se["payload"], signed_se["signature"]]
+        )
 
         # Verify and decode the payload. If verification fails an exception
         # will be raised.
         try:
             se_objects = jose.jws.verify(
                 token=jws_compact,
                 key=verification_public_key_pem,
-                algorithms=verification_algorithms)
+                algorithms=verification_algorithms,
+            )
         except Exception as e:
-            print('     {}'.format(e))
-            print('Invalid Signature in Signed SE')
+            print("     {}".format(e))
+            print("Invalid Signature in Signed SE")
             return {}
 
         se = json.loads(se_objects)
-        if se['uniqueId'] != signed_se['header']['uniqueId']:
+        if se["uniqueId"] != signed_se["header"]["uniqueId"]:
             print(
                 'uniqueId in header "{}" does not match version in payload "{}"\
-').format(signed_se['header']['uniqueId'], se['uniqueId'])
+'
+            ).format(signed_se["header"]["uniqueId"], se["uniqueId"])
             return {}
 
         return se
 
     def extract_public_data_pem(self, se_object):
-        '''
+        """
         Function extract the publickey JWK object from secure element and
         return it in pem format
         Inputs:
               se_object           contains secure element object
         Outputs:
               slots               contains public keys in pem format
-        '''
+        """
         try:
-            public_keys = se_object['publicKeySet']['keys']
+            public_keys = se_object["publicKeySet"]["keys"]
         except KeyError:
             public_keys = []
 
         slots = []
         for jwk in public_keys:
-            if jwk['kty'] not in ['EC', 'RSA', 'oct']:
-                print('Unsupported {}'.format(json.dumps({'kty': jwk['kty']})))
+            if jwk["kty"] not in ["EC", "RSA", "oct"]:
+                print("Unsupported {}".format(json.dumps({"kty": jwk["kty"]})))
                 continue
-            if jwk['crv'] not in ['P-256', 'P-384', 'P-521']:
-                print('Unsupported {}'.format(json.dumps({'crv': jwk['crv']})))
+            if jwk["crv"] not in ["P-256", "P-384", "P-521"]:
+                print("Unsupported {}".format(json.dumps({"crv": jwk["crv"]})))
                 continue
 
             slot = {}
-            slot.update({'id': jwk['kid']})
+            slot.update({"id": jwk["kid"]})
             public_key = ec.EllipticCurvePublicNumbers(
                 curve=ec.SECP256R1(),
-                x=int.from_bytes(base64url_decode(
-                    jwk['x'].encode('utf8')), byteorder='big', signed=False),
-                y=int.from_bytes(base64url_decode(
-                    jwk['y'].encode('utf8')), byteorder='big', signed=False)
+                x=int.from_bytes(
+                    base64url_decode(jwk["x"].encode("utf8")), byteorder="big", signed=False
+                ),
+                y=int.from_bytes(
+                    base64url_decode(jwk["y"].encode("utf8")), byteorder="big", signed=False
+                ),
             ).public_key(default_backend())
-            slot.update({'pub_key': public_key.public_bytes(
-                encoding=serialization.Encoding.PEM,
-                format=serialization.PublicFormat.SubjectPublicKeyInfo).decode(
-                    'ascii')})
+            slot.update(
+                {
+                    "pub_key": public_key.public_bytes(
+                        encoding=serialization.Encoding.PEM,
+                        format=serialization.PublicFormat.SubjectPublicKeyInfo,
+                    ).decode("ascii")
+                }
+            )
 
             # Decode any available certificates
             slot_certs = []
-            for cert_b64 in jwk.get('x5c', []):
+            for cert_b64 in jwk.get("x5c", []):
                 cert = x509.load_der_x509_certificate(
-                    data=b64decode(cert_b64), backend=default_backend())
+                    data=b64decode(cert_b64), backend=default_backend()
+                )
                 slot_certs.append(
-                    cert.public_bytes(
-                        encoding=serialization.Encoding.PEM).decode('ascii'))
-            slot.update({'certs': slot_certs})
+                    cert.public_bytes(encoding=serialization.Encoding.PEM).decode("ascii")
+                )
+            slot.update({"certs": slot_certs})
             slots.append(slot)
 
         return slots
 
     def get_manifest(self):
         return self.__dict__
 
     def __load_ca_cert(self, ca_key, ca_cert_path):
-        '''
+        """
         Function load manifest certificate extension and fingerprint from
         given cert path or will
         create a new manifest certificate and load it from the same
         Inputs:
               ca_cert_path       manifest signer cert path which contains cert
                                  extension and cert fingerprint
         Outputs:
               ca_cert_path       manifest signer cert path which contains cert
                                  extension and cert fingerprint
               ca_cert            contains manifest signer cert
-        '''
+        """
         if ca_cert_path is None:
             # Create root CA certificate
             builder = x509.CertificateBuilder()
             builder = builder.serial_number(self.__random_cert_sn(16))
 
-            name = x509.Name([
-                x509.NameAttribute(
-                    x509.oid.NameOID.ORGANIZATION_NAME,
-                    self.provisioner['organizationName']),
-                x509.NameAttribute(
-                    x509.oid.NameOID.COMMON_NAME,
-                    self.provisioner['organizationalUnitName'])])
+            name = x509.Name(
+                [
+                    x509.NameAttribute(
+                        x509.oid.NameOID.ORGANIZATION_NAME, self.provisioner["organizationName"]
+                    ),
+                    x509.NameAttribute(
+                        x509.oid.NameOID.COMMON_NAME, self.provisioner["organizationalUnitName"]
+                    ),
+                ]
+            )
             valid_date = datetime.utcnow().replace(tzinfo=timezone.utc)
 
             builder = builder.issuer_name(name)
             builder = builder.not_valid_before(valid_date)
-            builder = builder.not_valid_after(
-                valid_date + timedelta(days=365 * 25))
+            builder = builder.not_valid_after(valid_date + timedelta(days=365 * 25))
             builder = builder.subject_name(name)
             builder = builder.public_key(ca_key.public_key())
             builder = builder.add_extension(
-                x509.SubjectKeyIdentifier.from_public_key(ca_key.public_key()),
-                critical=False)
+                x509.SubjectKeyIdentifier.from_public_key(ca_key.public_key()), critical=False
+            )
             builder = builder.add_extension(
-                x509.BasicConstraints(ca=True, path_length=None),
-                critical=True)
+                x509.BasicConstraints(ca=True, path_length=None), critical=True
+            )
 
             # Self-sign certificate
             logger_cert = builder.sign(
-                private_key=ca_key,
-                algorithm=hashes.SHA256(),
-                backend=default_backend())
+                private_key=ca_key, algorithm=hashes.SHA256(), backend=default_backend()
+            )
 
             # Write CA certificate to file
-            ca_cert_path = Path('manifest_ca.crt')
-            with open(ca_cert_path, 'wb') as f:
-                f.write(logger_cert.public_bytes(
-                    encoding=serialization.Encoding.PEM))
+            ca_cert_path = Path("manifest_ca.crt")
+            with open(ca_cert_path, "wb") as f:
+                f.write(logger_cert.public_bytes(encoding=serialization.Encoding.PEM))
 
         cert_data = Path(ca_cert_path).read_bytes()
         ca_cert = x509.load_pem_x509_certificate(cert_data, default_backend())
 
         return ca_cert_path, ca_cert
 
     def __load_ca_key(self, ca_key_path):
-        '''
+        """
         Function create new ca key if given path is not found or load a key
         from existing path
         Inputs:
               ca_key_path       manifest signer key path which sign the
               secure element
         Outputs:
               ca_key            manifest signer key
               ca_key_path       manifest signer key path which sign the
                                 secure element
-        '''
+        """
         if ca_key_path is None:
-            ca_key_path = Path('manifest_ca.key')
+            ca_key_path = Path("manifest_ca.key")
             ca_key = ec.generate_private_key(
-                curve=ec.SECP256R1(),
-                backend=default_backend()).private_bytes(
-                    encoding=serialization.Encoding.PEM,
-                    format=serialization.PrivateFormat.PKCS8,
-                    encryption_algorithm=serialization.NoEncryption())
-            with open(str(ca_key_path), 'wb') as f:
+                curve=ec.SECP256R1(), backend=default_backend()
+            ).private_bytes(
+                encoding=serialization.Encoding.PEM,
+                format=serialization.PrivateFormat.PKCS8,
+                encryption_algorithm=serialization.NoEncryption(),
+            )
+            with open(str(ca_key_path), "wb") as f:
                 f.write(ca_key)
 
         ca_key_path = Path(ca_key_path)
-        assert ca_key_path.is_file(), 'File Not found'
-        with open(str(ca_key_path), 'rb') as f:
+        assert ca_key_path.is_file(), "File Not found"
+        with open(str(ca_key_path), "rb") as f:
             ca_key = serialization.load_pem_private_key(
-                data=f.read(),
-                password=None,
-                backend=default_backend())
+                data=f.read(), password=None, backend=default_backend()
+            )
 
         return ca_key_path, ca_key
 
     def __random_cert_sn(self, size):
-        '''Create a positive, non-trimmable serial number for X.509
-        certificates'''
+        """Create a positive, non-trimmable serial number for X.509
+        certificates"""
         raw_sn = bytearray(os.urandom(size))
         # Force MSB bit to 0 to ensure positive
         # integer
         raw_sn[0] = raw_sn[0] & 0x7F
         # Force next bit to 1 to ensure the
         # integer won't be trimmed in ASN.1 DER encoding
         raw_sn[0] = raw_sn[0] | 0x40
 
-        return int.from_bytes(raw_sn, byteorder='big', signed=False)
+        return int.from_bytes(raw_sn, byteorder="big", signed=False)
 
     def __jws_b64encode(self, source):
         """Simple helper function to remove base64 padding"""
-        return urlsafe_b64encode(source).decode('ascii').rstrip('=')
+        return urlsafe_b64encode(source).decode("ascii").rstrip("=")
 
     def write_signed_se_into_file(self, signed_se, filename):
         """
         Write signed manifest data (SecureSignedElement object) into given file
 
         Inputs:
                 signed_se           contains SignedSecureElement Object
                 filename            path to JSON file to dump the
                                     signedsecureelement object
         """
         if os.path.exists(filename):
-            with open(filename, 'rb') as f:
+            with open(filename, "rb") as f:
                 manifest_file = json.load(f)
 
             for secure_elem in manifest_file:
-                if secure_elem['header']['uniqueId'] == signed_se[
-                        'header']['uniqueId']:
+                if secure_elem["header"]["uniqueId"] == signed_se["header"]["uniqueId"]:
                     manifest_file.remove(secure_elem)
                     break
 
             manifest_file.append(signed_se)
-            file_manifest = json.dumps(manifest_file, indent=2).encode('ascii')
+            file_manifest = json.dumps(manifest_file, indent=2).encode("ascii")
         else:
-            file_manifest = json.dumps([signed_se], indent=2).encode('ascii')
+            file_manifest = json.dumps([signed_se], indent=2).encode("ascii")
 
-        with open(filename, 'wb') as f:
+        with open(filename, "wb") as f:
             f.write(file_manifest)
 
 
-class ManifestIterator():
+class ManifestIterator:
     """Iterator for a loaded manifest"""
+
     def __init__(self, manifest):
         self.manifest = manifest
         self.index = len(manifest)
 
     def __iter__(self):
         return self
 
     def __next__(self):
         if self.index == 0:
             raise StopIteration
         self.index = self.index - 1
         return self.manifest[self.index]
 
 
+__all__ = ["Manifest", "ManifestIterator"]
+
+
 # Standard boilerplate to call the main() function to begin
 # the program.
-if __name__ == '__main__':
+if __name__ == "__main__":
     pass
```

## tpds/manifest/tflx_manifest.py

```diff
@@ -15,81 +15,91 @@
 # KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 
 import base64
+
 import cryptoauthlib as cal
-from jose import utils
 from cryptography.hazmat.primitives import serialization
+from jose import utils
+
 from .manifest import Manifest
 
 
 class TFLXTLSManifest(Manifest):
     """Class that sets required certificates, keys and unique ID to TFLXTLS devices
 
     Args:
         Manifest (object): base class
     """
+
     def __init__(self):
         super().__init__()
-        self.model = 'ATECC608A'
-        self.partNumber = 'ATECC608A-TFLXTLS'
+        self.model = "ATECC608A"
+        self.partNumber = "ATECC608A-TFLXTLS"
         self.manufacturer = {
-            'organizationName': 'Microchip Technology Inc',
-            'organizationalUnitName': 'Secure Products Group'}
+            "organizationName": "Microchip Technology Inc",
+            "organizationalUnitName": "Secure Products Group",
+        }
         self.provisioner = {
-            'organizationName': 'Microchip Technology Inc',
-            'organizationalUnitName': 'Secure Products Group'}
+            "organizationName": "Microchip Technology Inc",
+            "organizationalUnitName": "Secure Products Group",
+        }
         self.distributor = {
-            'organizationName': 'Microchip Technology Inc',
-            'organizationalUnitName': 'Microchip Direct'}
+            "organizationName": "Microchip Technology Inc",
+            "organizationalUnitName": "Microchip Direct",
+        }
 
     def set_keys(self):
         """Method sets corresponding private keys and public keys to slots
         for TFLXTLS devices.
         """
         for ec_priv_key in [0, 1, 2, 3, 4]:
             public_key = bytearray()
-            assert cal.atcab_get_pubkey(ec_priv_key, public_key) \
-                == cal.Status.ATCA_SUCCESS, 'Reading Pub key failed'
-            x = utils.base64url_encode(public_key[0:32]).decode('ascii')
-            y = utils.base64url_encode(public_key[32:64]).decode('ascii')
-            self.set_publicJWK(str(ec_priv_key), 'EC', 'P-256', x, y, x5c=None)
+            assert (
+                cal.atcab_get_pubkey(ec_priv_key, public_key) == cal.Status.ATCA_SUCCESS
+            ), "Reading Pub key failed"
+            x = utils.base64url_encode(public_key[0:32]).decode("ascii")
+            y = utils.base64url_encode(public_key[32:64]).decode("ascii")
+            self.set_publicJWK(str(ec_priv_key), "EC", "P-256", x, y, x5c=None)
 
         for ec_pub_key in [13, 14, 15]:
             public_key = bytearray()
-            assert cal.atcab_read_pubkey(ec_pub_key, public_key) \
-                == cal.Status.ATCA_SUCCESS, 'Reading Pub key failed'
-            x = utils.base64url_encode(public_key[0:32]).decode('ascii')
-            y = utils.base64url_encode(public_key[32:64]).decode('ascii')
-            self.set_publicJWK(str(ec_pub_key), 'EC', 'P-256', x, y, x5c=None)
-
-    def set_certs(self, signer_cert=None, device_cert=None, kid=''):
-        """Methos that sets certificates to the device.
-        """
-        for key in self.publicKeySet['keys']:
-            if kid == key['kid']:
-                key['x5c'] = [
-                    base64.b64encode(device_cert.public_bytes(
-                        encoding=serialization.Encoding.DER)).decode('ascii'),
-                    base64.b64encode(signer_cert.public_bytes(
-                        encoding=serialization.Encoding.DER)).decode('ascii')
+            assert (
+                cal.atcab_read_pubkey(ec_pub_key, public_key) == cal.Status.ATCA_SUCCESS
+            ), "Reading Pub key failed"
+            x = utils.base64url_encode(public_key[0:32]).decode("ascii")
+            y = utils.base64url_encode(public_key[32:64]).decode("ascii")
+            self.set_publicJWK(str(ec_pub_key), "EC", "P-256", x, y, x5c=None)
+
+    def set_certs(self, signer_cert=None, device_cert=None, kid=""):
+        """Methos that sets certificates to the device."""
+        for key in self.publicKeySet["keys"]:
+            if kid == key["kid"]:
+                key["x5c"] = [
+                    base64.b64encode(
+                        device_cert.public_bytes(encoding=serialization.Encoding.DER)
+                    ).decode("ascii"),
+                    base64.b64encode(
+                        signer_cert.public_bytes(encoding=serialization.Encoding.DER)
+                    ).decode("ascii"),
                 ]
 
     def set_uniqueid(self):
-        """Method sets an uniqueid to the device.
-        """
+        """Method sets an uniqueid to the device."""
         ser_num = bytearray(9)
         assert cal.atcab_read_serial_number(ser_num) == cal.Status.ATCA_SUCCESS
         super().set_unique_id(ser_num)
 
     def load_manifest_uniqueid_and_keys(self):
         self.set_uniqueid()
         self.set_keys()
 
 
+__all__ = ["TFLXTLSManifest"]
+
 # Standard boilerplate to call the main() function to begin
 # the program.
-if __name__ == '__main__':
+if __name__ == "__main__":
     pass
```

## tpds/manifest/tng_manifest.py

```diff
@@ -15,74 +15,82 @@
 # KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 
 import base64
+
 import cryptoauthlib as cal
-from jose import utils
 from cryptography.hazmat.primitives import serialization
+from jose import utils
+
 from .manifest import Manifest
 
 
 class TNGTLSManifest(Manifest):
     """Class that sets required certificates, keys and unique ID to TNGTLS devices
 
     Args:
         Manifest (object): base class
     """
+
     def __init__(self):
         super().__init__()
-        self.model = 'ATECC608A'
-        self.partNumber = 'ATECC608A-TNGTLS'
+        self.model = "ATECC608A"
+        self.partNumber = "ATECC608A-TNGTLS"
         self.manufacturer = {
-            'organizationName': 'Microchip Technology Inc',
-            'organizationalUnitName': 'Secure Products Group'}
+            "organizationName": "Microchip Technology Inc",
+            "organizationalUnitName": "Secure Products Group",
+        }
         self.provisioner = {
-            'organizationName': 'Microchip Technology Inc',
-            'organizationalUnitName': 'Secure Products Group'}
+            "organizationName": "Microchip Technology Inc",
+            "organizationalUnitName": "Secure Products Group",
+        }
         self.distributor = {
-            'organizationName': 'Microchip Technology Inc',
-            'organizationalUnitName': 'Microchip Direct'}
+            "organizationName": "Microchip Technology Inc",
+            "organizationalUnitName": "Microchip Direct",
+        }
 
     def set_keys(self):
         """Method sets corresponding private keys and public keys to slots
         for devices.
         """
         for ec_priv_key in [0, 1, 2, 3, 4]:
             public_key = bytearray()
-            assert cal.atcab_get_pubkey(ec_priv_key, public_key) \
-                == cal.Status.ATCA_SUCCESS, 'Reading Pub key failed'
-            x = utils.base64url_encode(public_key[0:32]).decode('ascii')
-            y = utils.base64url_encode(public_key[32:64]).decode('ascii')
-            self.set_publicJWK(str(ec_priv_key), 'EC', 'P-256', x, y, x5c=None)
-
-    def set_certs(self, signer_cert=None, device_cert=None, kid=''):
-        """Methos that sets certificates to the device.
-        """
-        for key in self.publicKeySet['keys']:
-            if kid == key['kid']:
-                key['x5c'] = [
-                    base64.b64encode(device_cert.public_bytes(
-                        encoding=serialization.Encoding.DER)).decode('ascii'),
-                    base64.b64encode(signer_cert.public_bytes(
-                        encoding=serialization.Encoding.DER)).decode('ascii')
+            assert (
+                cal.atcab_get_pubkey(ec_priv_key, public_key) == cal.Status.ATCA_SUCCESS
+            ), "Reading Pub key failed"
+            x = utils.base64url_encode(public_key[0:32]).decode("ascii")
+            y = utils.base64url_encode(public_key[32:64]).decode("ascii")
+            self.set_publicJWK(str(ec_priv_key), "EC", "P-256", x, y, x5c=None)
+
+    def set_certs(self, signer_cert=None, device_cert=None, kid=""):
+        """Methos that sets certificates to the device."""
+        for key in self.publicKeySet["keys"]:
+            if kid == key["kid"]:
+                key["x5c"] = [
+                    base64.b64encode(
+                        device_cert.public_bytes(encoding=serialization.Encoding.DER)
+                    ).decode("ascii"),
+                    base64.b64encode(
+                        signer_cert.public_bytes(encoding=serialization.Encoding.DER)
+                    ).decode("ascii"),
                 ]
 
     def set_uniqueid(self):
-        """Method sets an uniqueid to the device.
-        """
+        """Method sets an uniqueid to the device."""
         ser_num = bytearray(9)
-        assert cal.atcab_read_serial_number(ser_num) \
-            == cal.Status.ATCA_SUCCESS
+        assert cal.atcab_read_serial_number(ser_num) == cal.Status.ATCA_SUCCESS
         super().set_unique_id(ser_num)
 
     def load_manifest_uniqueid_and_keys(self):
         self.set_uniqueid()
         self.set_keys()
 
 
+__all__ = ["TNGTLSManifest"]
+
 # Standard boilerplate to call the main() function to begin
 # the program.
-if __name__ == '__main__':
+if __name__ == "__main__":
     pass
```

## tpds/output_grabber/__init__.py

```diff
@@ -1,4 +1,6 @@
 """
     Trust Platform core package - output grabber module
 """
-from .library_output_grabber import *
+from .library_output_grabber import LibraryOutputGrabber
+
+__all__ = ["LibraryOutputGrabber"]
```

## tpds/output_grabber/library_output_grabber.py

```diff
@@ -15,18 +15,21 @@
 # KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 import os
 import threading
-class LibraryOutputGrabber():
+
+
+class LibraryOutputGrabber:
     """
     Class used to grab standard output or another stream.
     """
+
     def __init__(self, stream=None, threaded=False):
         self.origstream = stream
         self.threaded = threaded
         self.origstreamfd = self.origstream.fileno()
         self.capturedtext = ""
         self.pipe_out, self.pipe_in = os.pipe()
 
@@ -60,19 +63,20 @@
         Read the stream data (one byte at a time)
         and save the text in `capturedtext`.
         Exit when found the sequence "<<<<<"
         """
         count = 0
         while True:
             char = os.read(self.pipe_out, 1)
-            self.capturedtext += char.decode('utf-8')
-            if char == b'<':
+            self.capturedtext += char.decode("utf-8")
+            if char == b"<":
                 count += 1
                 if count == 5:
                     break
             else:
                 count = 0
 
+
 # Standard boilerplate to call the main() function to begin
 # the program.
-if __name__ == '__main__':
-    pass
+if __name__ == "__main__":
+    pass
```

## tpds/proto_provision/__init__.py

```diff
@@ -1,9 +1,28 @@
 """
     Trust Platform core package - proto provision module
 """
-from .ecc_provision import *
-from .tflxtls_provision import *
-from .ta100_provision import *
-from .ecc204_provision import *
-from .ta010_provision import *
-from .proto_provision import *
+from .ecc204_provision import ECC204Provision
+from .ecc_provision import ECCProvision
+from .proto_provision import ProtoProvisioning
+from .sha10x_provision import (
+    SHA10xProvision,
+    SHA104Provision,
+    SHA106Provision,
+    SHA105Provision,
+)
+from .ta010_provision import TA010Provision
+from .ta100_provision import TA100Provision
+from .tflxtls_provision import TFLXTLSProvision
+
+__all__ = [
+    "ECC204Provision",
+    "ECCProvision",
+    "ProtoProvisioning",
+    "SHA10xProvision",
+    "SHA104Provision",
+    "SHA106Provision",
+    "SHA105Provision",
+    "TA010Provision",
+    "TA100Provision",
+    "TFLXTLSProvision",
+]
```

## tpds/proto_provision/ecc204_provision.py

```diff
@@ -14,81 +14,86 @@
 # PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY
 # KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 
-from cryptography.hazmat.primitives.serialization import Encoding
 import cryptoauthlib as cal
+from cryptography.hazmat.primitives.serialization import Encoding
 
+from tpds.certs.cert_utils import is_signature_valid
 from tpds.certs.tflex_certs import TFLEXCerts
 from tpds.secure_element import ECC204
 from tpds.secure_element.constants import Constants
-from tpds.certs.cert_utils import is_signature_valid
 from tpds.tp_utils import calculate_wpc_digests
 
 
-class ECC204Provision():
-    def __init__(self, interface='i2c', address=0x33):
+class ECC204Provision:
+    def __init__(self, interface="i2c", address=0x33):
         self.element = ECC204(interface, address)
 
     def perform_genkey(self, slot):
         slot_public_key = bytearray(64)
         status = cal.atcab_genkey(slot, slot_public_key)
-        assert status == cal.Status.ATCA_SUCCESS, 'Genkey failed'
+        assert status == cal.Status.ATCA_SUCCESS, "Genkey failed"
         return slot_public_key
 
     def perform_slot_write(self, slot, data):
-        status = cal.atcab_write_bytes_zone(
-            Constants.ATCA_DATA_ZONE,
-            slot, 0, data, len(data))
-        assert status == cal.Status.ATCA_SUCCESS, 'Slot Write failed'
+        status = cal.atcab_write_bytes_zone(Constants.ATCA_DATA_ZONE, slot, 0, data, len(data))
+        assert status == cal.Status.ATCA_SUCCESS, "Slot Write failed"
 
     def provision_cert_slot(self, root_cert, signer_cert, device_cert):
-        certs = TFLEXCerts('ECC204')
+        certs = TFLEXCerts("ECC204")
         certs.set_tflex_certificates(root_cert, signer_cert, device_cert)
         template = certs.get_tflex_py_definitions()
-        assert cal.atcacert_write_cert(
-            template.get('signer'),
-            certs.signer.get_certificate_in_der(),
-            len(certs.signer.get_certificate_in_der())) \
-            == cal.Status.ATCA_SUCCESS, \
-            "Loading signer certificate into slot failed"
-        assert cal.atcacert_write_cert(
-            template.get('device'),
-            certs.device.get_certificate_in_der(),
-            len(certs.device.get_certificate_in_der())) \
-            == cal.Status.ATCA_SUCCESS, \
-            "Loading device certificate into slot failed"
+        assert (
+            cal.atcacert_write_cert(
+                template.get("signer"),
+                certs.signer.get_certificate_in_der(),
+                len(certs.signer.get_certificate_in_der()),
+            )
+            == cal.Status.ATCA_SUCCESS
+        ), "Loading signer certificate into slot failed"
+        assert (
+            cal.atcacert_write_cert(
+                template.get("device"),
+                certs.device.get_certificate_in_der(),
+                len(certs.device.get_certificate_in_der()),
+            )
+            == cal.Status.ATCA_SUCCESS
+        ), "Loading device certificate into slot failed"
 
     def provision_wpc_slots(self, root_cert, mfg_cert, puc_cert):
-        assert is_signature_valid(root_cert, root_cert.public_key()), \
-            'Root certificate signature verification failed'
-        assert is_signature_valid(mfg_cert, root_cert.public_key()), \
-            'MFG certificate signature verification failed'
-        assert is_signature_valid(puc_cert, mfg_cert.public_key()), \
-            'PUC certificate signature verification failed'
+        assert is_signature_valid(
+            root_cert, root_cert.public_key()
+        ), "Root certificate signature verification failed"
+        assert is_signature_valid(
+            mfg_cert, root_cert.public_key()
+        ), "MFG certificate signature verification failed"
+        assert is_signature_valid(
+            puc_cert, mfg_cert.public_key()
+        ), "PUC certificate signature verification failed"
 
         root_bytes = root_cert.public_bytes(encoding=Encoding.DER)
         mfg_bytes = mfg_cert.public_bytes(encoding=Encoding.DER)
         puc_bytes = puc_cert.public_bytes(encoding=Encoding.DER)
         wpc_digests = calculate_wpc_digests(root_bytes, mfg_bytes, puc_bytes)
 
         # Write Slot1 and Slot2 data to device
         # Adjust to Slot1 size (320)
-        puc_slot_data = puc_bytes + bytearray(b'\0' * (320 - len(puc_bytes)))
+        puc_slot_data = puc_bytes + bytearray(b"\0" * (320 - len(puc_bytes)))
         self.perform_slot_write(1, puc_slot_data)
-        self.perform_slot_write(2, wpc_digests.get('chain_digest'))
+        self.perform_slot_write(2, wpc_digests.get("chain_digest"))
 
         return {
-            'root_cert': root_bytes,
-            'root_digest': wpc_digests.get('root_digest'),
-            'mfg_cert': mfg_bytes,
-            'puc_cert': puc_bytes,
+            "root_cert": root_bytes,
+            "root_digest": wpc_digests.get("root_digest"),
+            "mfg_cert": mfg_bytes,
+            "puc_cert": puc_bytes,
         }
 
     def int_to_binary_linear(self, value):
-        '''
+        """
         wrapper function for converting decimal value into monotonic counter
-        '''
+        """
         return self.element.int_to_binary_linear(value)
```

## tpds/proto_provision/ecc_provision.py

```diff
@@ -3,56 +3,49 @@
 
 # Subject to your compliance with these terms, you may use Microchip software
 # and any derivatives exclusively with Microchip products. It is your
 # responsibility to comply with third party license terms applicable to your
 # use of third party software (including open source software) that may
 # accompany Microchip software.
 
+import cryptoauthlib as cal
+from tpds.helper import log
+
 # THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
 # EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
 # WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR
 # PURPOSE. IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
 # PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY
 # KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 import tpds.secure_element
 from tpds.secure_element.constants import Constants
-import cryptoauthlib as cal
-from tpds.helper import log
 
 
-class ECCProvision():
+class ECCProvision:
     def __init__(self, cfg=cal.cfg_ateccx08a_kithid_default()):
         self.element = tpds.secure_element.CAElement()
         self.element.connect(cfg)
 
     def perform_genkey(self, slot):
-        log(f'Performing Genkey for {slot}')
+        log(f"Performing Genkey for {slot}")
         slot_public_key = bytearray(64)
         status = cal.atcab_genkey(slot, slot_public_key)
-        assert status == cal.Status.ATCA_SUCCESS, 'Genkey failed'
+        assert status == cal.Status.ATCA_SUCCESS, "Genkey failed"
 
-    def perform_slot_write(
-                self, slot, data,
-                encryption_slot=None, encryption_data=None):
+    def perform_slot_write(self, slot, data, encryption_slot=None, encryption_data=None):
         if encryption_slot and encryption_data:
-            log((
-                f'Performing Slot Enc Write for {slot}'
-                f' with {encryption_slot}'))
-            status = cal.atcab_write_enc(
-                slot, 0, data,
-                encryption_data, encryption_slot)
+            log((f"Performing Slot Enc Write for {slot}" f" with {encryption_slot}"))
+            status = cal.atcab_write_enc(slot, 0, data, encryption_data, encryption_slot)
         else:
-            log(f'Performing Slot Write for {slot}')
-            status = cal.atcab_write_bytes_zone(
-                Constants.ATCA_DATA_ZONE,
-                slot, 0, data, len(data))
-        assert status == cal.Status.ATCA_SUCCESS, 'Slot Write failed'
+            log(f"Performing Slot Write for {slot}")
+            status = cal.atcab_write_bytes_zone(Constants.ATCA_DATA_ZONE, slot, 0, data, len(data))
+        assert status == cal.Status.ATCA_SUCCESS, "Slot Write failed"
 
 
 # Standard boilerplate to call the main() function to begin
 # the program.
-if __name__ == '__main__':
+if __name__ == "__main__":
     pass
```

## tpds/proto_provision/proto_provision.py

```diff
@@ -18,20 +18,20 @@
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 
 from tpds.proto_provision.tflxtls_provision import TFLXTLSProvision
 from tpds.proto_provision.tflxwpc_provision import TFLXWPCProvision
 
 
-class ProtoProvisioning():
+class ProtoProvisioning:
     def __new__(self, id, xml_file):
-        if 'tflxwpc' in id:
+        if "tflxwpc" in id:
             self = TFLXWPCProvision(xml_file)
         else:
             self = TFLXTLSProvision(xml_file)
         return self
 
 
 # Standard boilerplate to call the main() function to begin
 # the program.
-if __name__ == '__main__':
+if __name__ == "__main__":
     pass
```

## tpds/proto_provision/ta010_provision.py

```diff
@@ -15,13 +15,14 @@
 # KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 
 from tpds.secure_element import TA010
+
 from .ecc204_provision import ECC204Provision
 
 
 class TA010Provision(ECC204Provision):
     def __init__(self, interface="i2c", address=0x33):
         self.element = TA010(interface, address)
```

## tpds/proto_provision/ta100_provision.py

```diff
@@ -14,170 +14,180 @@
 # PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY
 # KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 import json
+
 from tpds.secure_element.ta_element import TAElement
+
 try:
     import cryptoauthlib_ta as cal
-except (ModuleNotFoundError, ImportError) as e:
+except (ModuleNotFoundError, ImportError):
     import cryptoauthlib as cal
-from tpds.tp_utils.tp_keys import TPSymmetricKey, TPAsymmetricKey
+
+from ctypes import byref, c_uint16
 from enum import Enum
-from ctypes import c_uint16, byref
+
+from tpds.tp_utils.tp_keys import TPAsymmetricKey, TPSymmetricKey
 
 
 class ClassType(Enum):
     public_key = 0
     private_key = 1
     symmetric_key = 2
     data = 3
     extracted_certificate = 4
     reserved = 5
     fast_crypto_key_group = 6
     crl = 7
 
 
 key_info = {
-    0: {'algorithm': 'ECC', 'size': 'secp256r1'},
-    1: {'algorithm': 'ECC', 'size': 'secp224r1'},
-    2: {'algorithm': 'ECC', 'size': 'secp384r1'},
-    4: {'algorithm': 'RSA', 'size': 1024},
-    5: {'algorithm': 'RSA', 'size': 2048},
-    6: {'algorithm': 'RSA', 'size': 3072},
-    8: {'algorithm': 'HMAC', 'size': 32},
-    9: {'algorithm': 'ECC', 'size': 'secp256k1'},
-    10: {'algorithm': 'ECC', 'size': 32},
-    12: {'algorithm': 'AES', 'size': 16}
+    0: {"algorithm": "ECC", "size": "secp256r1"},
+    1: {"algorithm": "ECC", "size": "secp224r1"},
+    2: {"algorithm": "ECC", "size": "secp384r1"},
+    4: {"algorithm": "RSA", "size": 1024},
+    5: {"algorithm": "RSA", "size": 2048},
+    6: {"algorithm": "RSA", "size": 3072},
+    8: {"algorithm": "HMAC", "size": 32},
+    9: {"algorithm": "ECC", "size": "secp256k1"},
+    10: {"algorithm": "ECC", "size": 32},
+    12: {"algorithm": "AES", "size": 16},
 }
 
 
-class TA100Provision():
+class TA100Provision:
     def __init__(self, cfg):
         self.element = TAElement()
         self.element.connect(cfg)
 
     def load_handles(self, handles):
         handles_status = list()
         for handle in handles:
             try:
-                handle_id = int(handle['handle'], 16)
+                handle_id = int(handle["handle"], 16)
                 handle_exist = self.element.is_handle_valid(handle_id)
                 if handle_exist:
                     if self.element.delete_handle(handle_id):
                         handle_exist = False
-                handle_status = ''
+                handle_status = ""
                 if not handle_exist:
                     attr_byte_buff = cal.ta_element_attributes_t.from_buffer(
-                        bytearray.fromhex(handle['attrib']))
-                    create_details = int(handle['details'], 16)
+                        bytearray.fromhex(handle["attrib"])
+                    )
+                    create_details = int(handle["details"], 16)
                     c_handle_out = c_uint16(0)
                     status = cal.get_cryptoauthlib().talib_create(
-                                                self.element.device, 0, create_details, handle_id,
-                                                byref(attr_byte_buff), byref(c_handle_out))
+                        self.element.device,
+                        0,
+                        create_details,
+                        handle_id,
+                        byref(attr_byte_buff),
+                        byref(c_handle_out),
+                    )
                     if not status:
                         data_bytes = self.get_key_from_handle(handle)
                         if data_bytes:
                             status = cal.talib_write_element(
-                                                cal.atcab_get_device(), handle_id,
-                                                len(data_bytes), data_bytes)
+                                cal.atcab_get_device(), handle_id, len(data_bytes), data_bytes
+                            )
                             if status != cal.Status.ATCA_SUCCESS:
-                                handle_status = f'Write element failed with 0x{status:02X} code'
+                                handle_status = f"Write element failed with 0x{status:02X} code"
                         else:
-                            handle_status = f'No data bytes to provision'
+                            handle_status = "No data bytes to provision"
                     else:
-                        handle_status = f'Creation failed with 0x{status:02X} code'
+                        handle_status = f"Creation failed with 0x{status:02X} code"
                 else:
-                    handle_status = 'Exists with no delete option'
+                    handle_status = "Exists with no delete option"
             except BaseException as e:
-                handle_status = f'{e}'
-            handles_status.append({'handle': f'{handle_id:02X}', 'status':handle_status})
+                handle_status = f"{e}"
+            handles_status.append({"handle": f"{handle_id:02X}", "status": handle_status})
         return handles_status
 
     def provision_device(self, json_obj):
-        ''' Provision the TA100
+        """Provision the TA100
         Steps
         1. Write the configuration memory, If configuration memory is not
                 locked.
         2. Read the previously created handles and delete - if delete_perm is
                 always
         3. Create & write the handles available in the JSON file, if key is
                 not available and source is HSM generate the keys internally
                 and write
-        '''
+        """
         self.ta_config = json.loads(json_obj)
         provision_info = dict()
         if self.ta_config:
-            if self.ta_config['TA100Attributes']['ConfigurationMemory']["attrib"]:
-                self.config_bytes = \
-                    self.ta_config['TA100Attributes']['ConfigurationMemory']["attrib"]
+            if self.ta_config["TA100Attributes"]["ConfigurationMemory"]["attrib"]:
+                self.config_bytes = self.ta_config["TA100Attributes"]["ConfigurationMemory"][
+                    "attrib"
+                ]
                 if self.element.is_config_zone_locked():
-                    provision_info.update(config_status='Skipping Configuration write as it is already locked')
+                    provision_info.update(
+                        config_status="Skipping Configuration write as it is already locked"
+                    )
                 else:
                     self.element.write_config_memory(self.config_bytes)
             else:
-                raise ('Configuration memory not available')
+                raise ("Configuration memory not available")
 
-            if self.ta_config['TA100Attributes']['HandleList']:
-                self.handles = self.ta_config['TA100Attributes']['HandleList']
+            if self.ta_config["TA100Attributes"]["HandleList"]:
+                self.handles = self.ta_config["TA100Attributes"]["HandleList"]
                 provision_info.update(handles_status=self.load_handles(self.handles))
             else:
-                raise ('Memory handles not created')
+                raise ("Memory handles not created")
         else:
-            raise('Empty File')
+            raise ("Empty File")
 
         return provision_info
 
     def get_key_from_handle(self, handle):
-        '''Parse attribute to get class and key_type
+        """Parse attribute to get class and key_type
         for key generation Symmetric/Asymmetric
-        '''
+        """
         data_bytes = None
         try:
-            if handle.get('source') == 'user':
-                data_bytes = bytearray.fromhex(handle.get('value'))
-            elif handle.get('source') == 'hsm':
+            if handle.get("source") == "user":
+                data_bytes = bytearray.fromhex(handle.get("value"))
+            elif handle.get("source") == "hsm":
                 attr_info = cal.ta_element_attributes_t.from_buffer(
-                    bytearray.fromhex(handle.get('attrib')))
-                data_bytes = self.get_key_bytes(
-                    attr_info.Class, attr_info.Key_Type)
-        except BaseException as e:
+                    bytearray.fromhex(handle.get("attrib"))
+                )
+                data_bytes = self.get_key_bytes(attr_info.Class, attr_info.Key_Type)
+        except BaseException:
             data_bytes = None
 
         return data_bytes
 
     def get_key_bytes(self, class_type, key_type):
         # HSM support only symmetric key and Private key generation
         key_bytes = None
         if class_type == ClassType.symmetric_key.value:
-            symmetric_key = TPSymmetricKey(
-                None, key_info.get(key_type).get('size'))
+            symmetric_key = TPSymmetricKey(None, key_info.get(key_type).get("size"))
             key_bytes = symmetric_key.get_bytes()
         elif class_type == ClassType.private_key.value:
-            key_algo = key_info.get(key_type).get('algorithm')
-            assert key_algo in ['ECC', 'RSA'], 'Unsupported Algorithm'
-            key = TPAsymmetricKey(
-                None, algo=key_algo,
-                size=key_info.get(key_type).get('size'))
+            key_algo = key_info.get(key_type).get("algorithm")
+            assert key_algo in ["ECC", "RSA"], "Unsupported Algorithm"
+            key = TPAsymmetricKey(None, algo=key_algo, size=key_info.get(key_type).get("size"))
             key_bytes = key.get_private_key_bytes()
         # elif class_type == ClassType.public_key.value:
         #     key_algo = key_info.get(key_type).get('algorithm')
         #     assert key_algo in ['ECC', 'RSA'], 'Unsupported Algorithm'
         #     key = TPAsymmetricKey(
         #         None, algo=key_algo,
         #         size=key_info.get(key_type).get('size'))
         #     key_bytes = key.public_key_bytes
         return key_bytes
 
 
 # Standard boilerplate to call the main() function to begin
 # the program.
-if __name__ == '__main__':
+if __name__ == "__main__":
     # cfg = cal.cfg_ateccx08a_kithid_default()
     # cfg.cfg.atcahid.dev_interface = int(cal.ATCAKitType.ATCA_KIT_SPI_IFACE)
     # cfg.cfg.atcahid.dev_identity = 0x0
     # cfg.devtype = 0x10
     # provision = TA100Provision(cfg)
     # print(provision.element.get_device_details())
     # json_obj = "{\"VersionAttributes\":{\"TaConfiguratorVersion\":\"2.0.2.0\",\"JsonVersion\":\"1.5.0\"},\"TA100Attributes\":{\"PackageOption\":\"_8PinSOIC\",\"IoType\":\"SPIInterface\",\"Lock\":{\"config\":true,\"setup\":true},\"Options\":{\"disable_aes\":false,\"force_fips\":false,\"bsd\":false,\"disable_rsa\":false},\"PullUps\":\"0xEF\",\"GroupNumber\":\"0x0000\",\"ConfigurationMemory\":{\"handle\":\"0xC000\",\"attrib\":\"000000000000000000000000000000002E00000000000100000000000000000000000000000000000000000000000000\"},\"HandleList\":[{\"name\":\"APP.PRI\",\"handle\":\"0x8000\",\"details\":\"0x0000\",\"attrib\":\"01FF040100004600\",\"source\":\"hsm\",\"value\":null},{\"name\":\"APP_HSM_AUTH_KEY\",\"handle\":\"0x8001\",\"details\":\"0x2000\",\"attrib\":\"42001800000B6500\",\"source\":\"user\",\"value\":\"b9e746b4264ea6dc58cda50d82fc2e8cf737e78227f0a43403a291833f5b768a\"},{\"name\":\"COMMON_KEY\",\"handle\":\"0x800b\",\"details\":\"0x0000\",\"attrib\":\"E2000E0000004510\",\"source\":\"user\",\"value\":\"b9e746b4264ea6dc58cda50d82fc2e8c\"},{\"name\":\"WLAN_KEY\",\"handle\":\"0x8008\",\"details\":\"0x0000\",\"attrib\":\"0320000009096500\",\"source\":\"user\",\"value\":\"0111111111111111111111111111111111111111111111111111111111111111\"},{\"name\":\"APP_HSM_TRNSPT_KEY\",\"handle\":\"0x8009\",\"details\":\"0x0000\",\"attrib\":\"E2001D00000B6500\",\"source\":\"user\",\"value\":\"b9e746b4264ea6dc58cda50d82fc2e8c\"},{\"name\":\"CA_ROOT_CLOUD.PUB\",\"handle\":\"0x800c\",\"details\":\"0x0000\",\"attrib\":\"00FF000000005500\",\"source\":\"user\",\"value\":\"b9e746b4264ea6dc58cda50d82fc2e8cf737e78227f0a43403a291833f5b768a52cf72794101ef673cbbef6381e8b545c1835231279814f7183763507a5fd117\"},{\"name\":\"APP_CERT\",\"handle\":\"0x800e\",\"details\":\"0x0000\",\"attrib\":\"030F000009005410\",\"source\":\"user\",\"value\":\"111111111111111111111111111111\"},{\"name\":\"SIGNER_CERT\",\"handle\":\"0x800f\",\"details\":\"0x0000\",\"attrib\":\"030E000009005410\",\"source\":\"user\",\"value\":\"1111111111111111111111111111\"},{\"name\":\"SIGNER.PUB\",\"handle\":\"0x800d\",\"details\":\"0x0000\",\"attrib\":\"0000000000005400\",\"source\":\"user\",\"value\":\"b9e746b4264ea6dc58cda50d82fc2e8cf737e78227f0a43403a291833f5b768a52cf72794101ef673cbbef6381e8b545c1835231279814f7183763507a5fd117\"}],\"DeviceUpdatePublicKey\":null}}"
```

## tpds/proto_provision/tflxtls_provision.py

```diff
@@ -3,279 +3,289 @@
 
 # Subject to your compliance with these terms, you may use Microchip software
 # and any derivatives exclusively with Microchip products. It is your
 # responsibility to comply with third party license terms applicable to your
 # use of third party software (including open source software) that may
 # accompany Microchip software.
 
+from datetime import datetime, timezone
+
+import cryptoauthlib as cal
+import lxml.etree as ET
+from cryptography import x509
+from cryptography.hazmat.primitives.asymmetric import ec
+
+from tpds.certs import Cert, TFLEXCerts
+from tpds.certs.cert_utils import (
+    get_backend,
+    get_device_public_key,
+    get_device_sn_number,
+    pubkey_cert_sn,
+)
+from tpds.certs.ext_builder import TimeFormat
+from tpds.secure_element.constants import Constants
+from tpds.tp_utils.tp_keys import TPAsymmetricKey
+
 # THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
 # EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
 # WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR
 # PURPOSE. IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
 # PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY
 # KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 from .ecc_provision import ECCProvision
-import cryptoauthlib as cal
-import lxml.etree as ET
-from tpds.certs import Cert, TFLEXCerts
-from tpds.certs.ext_builder import TimeFormat
-from tpds.certs.cert_utils import (
-    get_device_sn_number, get_device_public_key,
-    get_backend, pubkey_cert_sn)
-from tpds.secure_element.constants import Constants
-from cryptography import x509
-from cryptography.hazmat.primitives.asymmetric import ec
-from datetime import datetime, timezone
-from tpds.tp_utils.tp_keys import TPAsymmetricKey
 
 
 class TFLXTLSProvision(ECCProvision):
     def __init__(self, xml_file):
         self.root = ET.parse(xml_file).getroot()
 
-        if 'ECC' not in self.root.find('PartNumber').text:
-            raise ValueError('Unsupported Part Number in XML')
-        interface = self.root.find('Device').find(
-                                'ConfigurationZone').find('I2CEnable').text
-        address = self.root.find('Device').find(
-                                'ConfigurationZone').find('I2CAddress').text
+        if "ECC" not in self.root.find("PartNumber").text:
+            raise ValueError("Unsupported Part Number in XML")
+        interface = self.root.find("Device").find("ConfigurationZone").find("I2CEnable").text
+        address = self.root.find("Device").find("ConfigurationZone").find("I2CAddress").text
 
-        cfg=cal.cfg_ateccx08a_kithid_default()
-        if interface =='01':
+        cfg = cal.cfg_ateccx08a_kithid_default()
+        if interface == "01":
             cfg.cfg.atcahid.dev_interface = int(cal.ATCAKitType.ATCA_KIT_I2C_IFACE)
         else:
             cfg.cfg.atcahid.dev_interface = int(cal.ATCAKitType.ATCA_KIT_SWI_IFACE)
 
         cfg.cfg.atcahid.dev_identity = int(address, base=16)
         super().__init__(cfg)
 
         if not self.element.is_config_zone_locked():
-            raise ValueError('TFLXTLS cannot have unlocked config zone')
+            raise ValueError("TFLXTLS cannot have unlocked config zone")
         if not self.element.is_data_zone_locked():
-            raise ValueError('TFLXTLS cannot have unlocked data zone')
+            raise ValueError("TFLXTLS cannot have unlocked data zone")
 
     def provision_non_cert_slots(self):
-        self.data_zone = self.root.find('Device').find('DataZone')
-        slot_config = self.root.find('Device').find(
-                                'ConfigurationZone').find('SlotConfigurations')
+        self.data_zone = self.root.find("Device").find("DataZone")
+        slot_config = self.root.find("Device").find("ConfigurationZone").find("SlotConfigurations")
         self.slot_config = {}
-        for index, element in enumerate(slot_config.iter('SlotConfiguration')):
-            self.slot_config.update({index: element.text.replace(' ', '')})
-        self.slot_modes = [
-            'GenKey', 'Secret', 'Random', 'Public']
+        for index, element in enumerate(slot_config.iter("SlotConfiguration")):
+            self.slot_config.update({index: element.text.replace(" ", "")})
+        self.slot_modes = ["GenKey", "Secret", "Random", "Public"]
         for element in list(self.data_zone):
-            if element.attrib.get('Mode') == 'GenKey':
-                slot_index = int(element.attrib.get('Index'), base=16)
+            if element.attrib.get("Mode") == "GenKey":
+                slot_index = int(element.attrib.get("Index"), base=16)
                 slot_config = self.slot_config.get(slot_index)
-                if slot_config[2:3] == '2':
+                if slot_config[2:3] == "2":
                     self.perform_genkey(slot_index)
-            elif element.attrib.get('Mode') == 'Secret':
-                slot_index = int(element.attrib.get('Index'), base=16)
-                slot_data = bytearray.fromhex(element.find('Data').text)
+            elif element.attrib.get("Mode") == "Secret":
+                slot_index = int(element.attrib.get("Index"), base=16)
+                slot_data = bytearray.fromhex(element.find("Data").text)
                 slot_config = self.slot_config.get(slot_index)
                 encrypting_slot = encrypting_slot_data = None
-                if slot_config[2:3] == '4':
+                if slot_config[2:3] == "4":
                     encrypting_slot = int(slot_config[3:4], base=16)
                     encrypting_element = list(self.data_zone)[encrypting_slot]
-                    slot_data_attr = encrypting_element.find('Data')
-                    encrypting_slot_data = bytearray.fromhex(
-                                                slot_data_attr.text)
-                    if slot_data_attr.attrib.get('Size') == '36':
+                    slot_data_attr = encrypting_element.find("Data")
+                    encrypting_slot_data = bytearray.fromhex(slot_data_attr.text)
+                    if slot_data_attr.attrib.get("Size") == "36":
                         encrypting_slot_data = encrypting_slot_data[:32]
-                    elif slot_data_attr.attrib.get('Size') == '72':
+                    elif slot_data_attr.attrib.get("Size") == "72":
                         encrypting_slot_data = encrypting_slot_data[:64]
-                    self.perform_slot_write(
-                                encrypting_slot, encrypting_slot_data)
+                    self.perform_slot_write(encrypting_slot, encrypting_slot_data)
 
-                slot_data_attr = element.find('Data')
-                if slot_data_attr.attrib.get('Size') == '36':
+                slot_data_attr = element.find("Data")
+                if slot_data_attr.attrib.get("Size") == "36":
                     slot_data = slot_data[:32]
-                elif slot_data_attr.attrib.get('Size') == '72':
+                elif slot_data_attr.attrib.get("Size") == "72":
                     slot_data = slot_data[:64]
                 self.perform_slot_write(
-                                slot_index, slot_data,
-                                encrypting_slot, encrypting_slot_data)
-            elif element.attrib.get('Mode') == 'Random':
-                slot_index = element.attrib.get('Index')
-            elif element.attrib.get('Mode') == 'Public':
-                slot_index = int(element.attrib.get('Index'), base=16)
+                    slot_index, slot_data, encrypting_slot, encrypting_slot_data
+                )
+            elif element.attrib.get("Mode") == "Random":
+                slot_index = element.attrib.get("Index")
+            elif element.attrib.get("Mode") == "Public":
+                slot_index = int(element.attrib.get("Index"), base=16)
                 slot_config = self.slot_config.get(slot_index)
-                slot_data = bytearray.fromhex(element.find('Data').text)
+                slot_data = bytearray.fromhex(element.find("Data").text)
                 public_key_control_bytes = bytearray(4)
-                if slot_config[2:3] == '1':
-                    assert cal.atcab_read_zone(
-                        Constants.ATCA_DATA_ZONE, slot_index, 0, 0,
-                        public_key_control_bytes,
-                        len(public_key_control_bytes)) == cal.Status.ATCA_SUCCESS, \
-                        'Reading public key validation state - failed'
+                if slot_config[2:3] == "1":
+                    assert (
+                        cal.atcab_read_zone(
+                            Constants.ATCA_DATA_ZONE,
+                            slot_index,
+                            0,
+                            0,
+                            public_key_control_bytes,
+                            len(public_key_control_bytes),
+                        )
+                        == cal.Status.ATCA_SUCCESS
+                    ), "Reading public key validation state - failed"
                 if public_key_control_bytes[0] == 0x00:
                     self.perform_slot_write(slot_index, slot_data)
                 else:
-                    print('Validated Public key encountered, skipping the slot!')
+                    print("Validated Public key encountered, skipping the slot!")
 
     def provision_cert_slots(
-                    self, signer_ca=None, signer_ca_key=None,
-                    device_ca=None, device_ca_key=None):
+        self, signer_ca=None, signer_ca_key=None, device_ca=None, device_ca_key=None
+    ):
         signer_ca_key = TPAsymmetricKey(signer_ca_key)
         device_ca_key = TPAsymmetricKey(device_ca_key)
 
-        self.comp_certs = self.root.find('CompressedCerts')
-        signer_cert_element = self.comp_certs.find(
-                                '''CompressedCert[@ChainLevel='1']''')
-        signer_template = bytearray.fromhex(signer_cert_element.find(
-                                'TemplateData').text)
-        signer_template = x509.load_der_x509_certificate(
-                                    bytes(signer_template), get_backend())
-        validity = int(signer_cert_element.attrib.get('ValidYears'))
+        self.comp_certs = self.root.find("CompressedCerts")
+        signer_cert_element = self.comp_certs.find("""CompressedCert[@ChainLevel='1']""")
+        signer_template = bytearray.fromhex(signer_cert_element.find("TemplateData").text)
+        signer_template = x509.load_der_x509_certificate(bytes(signer_template), get_backend())
+        validity = int(signer_cert_element.attrib.get("ValidYears"))
 
         new_root = Cert()
         if signer_ca is not None:
             new_root.set_certificate(signer_ca)
         else:
-            new_root.builder = new_root.builder.subject_name(
-                    signer_template.issuer)
-            new_root.builder = new_root.builder.issuer_name(
-                    signer_template.issuer)
+            new_root.builder = new_root.builder.subject_name(signer_template.issuer)
+            new_root.builder = new_root.builder.issuer_name(signer_template.issuer)
             new_root.builder = new_root.builder.not_valid_before(
-                datetime.utcnow().replace(
-                    minute=0, second=0, microsecond=0, tzinfo=timezone.utc))
+                datetime.utcnow().replace(minute=0, second=0, microsecond=0, tzinfo=timezone.utc)
+            )
             new_root.builder = new_root.builder.not_valid_after(
                 new_root.builder._not_valid_before.replace(
-                    year=new_root.builder._not_valid_before.year + 40))
-            new_root.builder = new_root.builder.public_key(
-                signer_ca_key.get_public_key())
-            new_root.builder = new_root.builder.serial_number(
-                pubkey_cert_sn(16, new_root.builder))
+                    year=new_root.builder._not_valid_before.year + 40
+                )
+            )
+            new_root.builder = new_root.builder.public_key(signer_ca_key.get_public_key())
+            new_root.builder = new_root.builder.serial_number(pubkey_cert_sn(16, new_root.builder))
             new_root.builder = new_root.builder.add_extension(
-                x509.SubjectKeyIdentifier.from_public_key(
-                    signer_ca_key.get_public_key()),
-                critical=False)
+                x509.SubjectKeyIdentifier.from_public_key(signer_ca_key.get_public_key()),
+                critical=False,
+            )
             new_root.builder = new_root.builder.add_extension(
-                x509.AuthorityKeyIdentifier.from_issuer_public_key(
-                    signer_ca_key.get_public_key()),
-                critical=False)
+                x509.AuthorityKeyIdentifier.from_issuer_public_key(signer_ca_key.get_public_key()),
+                critical=False,
+            )
             new_root.builder = new_root.builder.add_extension(
-                x509.BasicConstraints(ca=True, path_length=None),
-                critical=True)
+                x509.BasicConstraints(ca=True, path_length=None), critical=True
+            )
             new_root.sign_builder(signer_ca_key.private_key)
 
         new_signer = Cert()
         if device_ca is not None:
             new_signer.set_certificate(device_ca)
         else:
-            new_signer.builder = new_signer.builder.subject_name(
-                    signer_template.subject)
-            new_signer.builder = new_signer.builder.issuer_name(
-                signer_template.issuer)
+            new_signer.builder = new_signer.builder.subject_name(signer_template.subject)
+            new_signer.builder = new_signer.builder.issuer_name(signer_template.issuer)
             new_signer.builder = new_signer.builder.not_valid_before(
-                datetime.utcnow().replace(
-                    minute=0, second=0, microsecond=0, tzinfo=timezone.utc))
-            if validity==0:
+                datetime.utcnow().replace(minute=0, second=0, microsecond=0, tzinfo=timezone.utc)
+            )
+            if validity == 0:
                 new_signer.builder = new_signer.builder.not_valid_after(
                     datetime(9999, 12, 31, 23, 59, 59, tzinfo=timezone.utc),
-                    format=TimeFormat.GENERALIZED_TIME)
+                    format=TimeFormat.GENERALIZED_TIME,
+                )
             else:
                 new_signer.builder = new_signer.builder.not_valid_after(
                     new_signer.builder._not_valid_before.replace(
-                        year=new_signer.builder._not_valid_before.year + validity),
-                        format=TimeFormat.GENERALIZED_TIME)
-            new_signer.builder = new_signer.builder.public_key(
-                device_ca_key.get_public_key())
+                        year=new_signer.builder._not_valid_before.year + validity
+                    ),
+                    format=TimeFormat.GENERALIZED_TIME,
+                )
+            new_signer.builder = new_signer.builder.public_key(device_ca_key.get_public_key())
             new_signer.builder = new_signer.builder.serial_number(
-                pubkey_cert_sn(16, new_signer.builder))
+                pubkey_cert_sn(16, new_signer.builder)
+            )
             for extn in signer_template.extensions:
-                if extn.oid._name == 'subjectKeyIdentifier':
+                if extn.oid._name == "subjectKeyIdentifier":
                     new_signer.builder = new_signer.builder.add_extension(
-                            x509.SubjectKeyIdentifier.from_public_key(
-                                device_ca_key.get_public_key()), extn.critical)
-                elif extn.oid._name == 'authorityKeyIdentifier':
+                        x509.SubjectKeyIdentifier.from_public_key(device_ca_key.get_public_key()),
+                        extn.critical,
+                    )
+                elif extn.oid._name == "authorityKeyIdentifier":
                     new_signer.builder = new_signer.builder.add_extension(
                         x509.AuthorityKeyIdentifier.from_issuer_subject_key_identifier(
                             new_root.certificate.extensions.get_extension_for_class(
-                                x509.SubjectKeyIdentifier).value), extn.critical)
+                                x509.SubjectKeyIdentifier
+                            ).value
+                        ),
+                        extn.critical,
+                    )
                 else:
-                    new_signer.builder = new_signer.builder.add_extension(
-                                                extn.value, extn.critical)
+                    new_signer.builder = new_signer.builder.add_extension(extn.value, extn.critical)
             new_signer.sign_builder(signer_ca_key.private_key)
 
-        device_cert_element = self.comp_certs.find(
-                                '''CompressedCert[@ChainLevel='0']''')
-        device_template = bytearray.fromhex(device_cert_element.find(
-                                'TemplateData').text)
-        device_template = x509.load_der_x509_certificate(
-                                    bytes(device_template), get_backend())
-        validity = int(device_cert_element.attrib.get('ValidYears'))
+        device_cert_element = self.comp_certs.find("""CompressedCert[@ChainLevel='0']""")
+        device_template = bytearray.fromhex(device_cert_element.find("TemplateData").text)
+        device_template = x509.load_der_x509_certificate(bytes(device_template), get_backend())
+        validity = int(device_cert_element.attrib.get("ValidYears"))
 
         updated_subject = device_template.subject
-        for element in device_cert_element.findall('Element'):
-            if element.attrib.get('Name') == 'SN03':
+        for element in device_cert_element.findall("Element"):
+            if element.attrib.get("Name") == "SN03":
                 subject_attr = []
                 for attr in device_template.subject:
                     if attr.oid == x509.oid.NameOID.COMMON_NAME:
                         prefix = device_template.subject.get_attributes_for_oid(
-                            x509.oid.NameOID.COMMON_NAME)[0].value[:-18]
+                            x509.oid.NameOID.COMMON_NAME
+                        )[0].value[:-18]
                         attr = x509.NameAttribute(
-                            x509.oid.NameOID.COMMON_NAME, get_device_sn_number(
-                                self.element.get_device_serial_number(), prefix))
+                            x509.oid.NameOID.COMMON_NAME,
+                            get_device_sn_number(self.element.get_device_serial_number(), prefix),
+                        )
                     subject_attr.append(attr)
                 updated_subject = x509.Name(subject_attr)
 
         device_pubkey = bytearray(64)
         status = cal.atcab_get_pubkey(0, device_pubkey)
-        assert status == cal.Status.ATCA_SUCCESS, 'atcab_get_pubkey failed'
+        assert status == cal.Status.ATCA_SUCCESS, "atcab_get_pubkey failed"
         device_pubkey = get_device_public_key(device_pubkey)
         device_pubkey = ec.EllipticCurvePublicNumbers(
-            x=int(device_pubkey[:64], 16),
-            y=int(device_pubkey[64:], 16),
-            curve=ec.SECP256R1()).public_key(get_backend())
+            x=int(device_pubkey[:64], 16), y=int(device_pubkey[64:], 16), curve=ec.SECP256R1()
+        ).public_key(get_backend())
 
         new_device = Cert()
-        new_device.builder = new_device.builder.issuer_name(
-            signer_template.subject)
+        new_device.builder = new_device.builder.issuer_name(signer_template.subject)
         new_device.builder = new_device.builder.not_valid_before(
-            datetime.utcnow().replace(
-                minute=0, second=0, microsecond=0, tzinfo=timezone.utc))
-        if validity==0:
+            datetime.utcnow().replace(minute=0, second=0, microsecond=0, tzinfo=timezone.utc)
+        )
+        if validity == 0:
             new_device.builder = new_device.builder.not_valid_after(
                 datetime(9999, 12, 31, 23, 59, 59, tzinfo=timezone.utc),
-                format=TimeFormat.GENERALIZED_TIME)
+                format=TimeFormat.GENERALIZED_TIME,
+            )
         else:
             new_device.builder = new_device.builder.not_valid_after(
                 new_device.builder._not_valid_before.replace(
-                    year=new_device.builder._not_valid_before.year + validity),
-                    format=TimeFormat.GENERALIZED_TIME)
+                    year=new_device.builder._not_valid_before.year + validity
+                ),
+                format=TimeFormat.GENERALIZED_TIME,
+            )
         new_device.builder = new_device.builder.subject_name(updated_subject)
         new_device.builder = new_device.builder.public_key(device_pubkey)
         new_device.builder = new_device.builder.serial_number(
-            pubkey_cert_sn(16, new_device.builder))
+            pubkey_cert_sn(16, new_device.builder)
+        )
         for extn in device_template.extensions:
-            if extn.oid._name == 'subjectKeyIdentifier':
+            if extn.oid._name == "subjectKeyIdentifier":
                 new_device.builder = new_device.builder.add_extension(
-                        x509.SubjectKeyIdentifier.from_public_key(
-                            device_pubkey), extn.critical)
-            elif extn.oid._name == 'authorityKeyIdentifier':
+                    x509.SubjectKeyIdentifier.from_public_key(device_pubkey), extn.critical
+                )
+            elif extn.oid._name == "authorityKeyIdentifier":
                 new_device.builder = new_device.builder.add_extension(
                     x509.AuthorityKeyIdentifier.from_issuer_subject_key_identifier(
                         new_signer.certificate.extensions.get_extension_for_class(
-                            x509.SubjectKeyIdentifier).value), extn.critical)
+                            x509.SubjectKeyIdentifier
+                        ).value
+                    ),
+                    extn.critical,
+                )
             else:
-                new_device.builder = new_device.builder.add_extension(
-                                            extn.value, extn.critical)
+                new_device.builder = new_device.builder.add_extension(extn.value, extn.critical)
         new_device.sign_builder(device_ca_key.private_key)
 
         # Verify new cert chain
         assert (
-            new_root.is_signature_valid(signer_ca_key.get_public_key()) and
-            new_signer.is_signature_valid(signer_ca_key.get_public_key()) and
-            new_device.is_signature_valid(device_ca_key.get_public_key())), \
-            'Certificate chain verification failed'
+            new_root.is_signature_valid(signer_ca_key.get_public_key())
+            and new_signer.is_signature_valid(signer_ca_key.get_public_key())
+            and new_device.is_signature_valid(device_ca_key.get_public_key())
+        ), "Certificate chain verification failed"
 
         # Store keys and certs to files
         # signer_ca_key.get_private_pem(Path('root.key'))
         # device_ca_key.get_private_pem(Path('signer.key'))
         # certs_txt = new_root.get_certificate_in_text()\
         #     + '\n\n' + new_signer.get_certificate_in_text()\
         #     + '\n\n' + new_device.get_certificate_in_text()
@@ -286,35 +296,40 @@
         #     new_signer.get_certificate_in_pem())
         # Path('device.crt').write_bytes(
         #     new_device.get_certificate_in_pem())
 
         # Write compressed certs to device
         certs = TFLEXCerts()
         certs.set_tflex_certificates(
-                        root_cert=new_root.certificate,
-                        signer_cert=new_signer.certificate,
-                        device_cert=new_device.certificate)
+            root_cert=new_root.certificate,
+            signer_cert=new_signer.certificate,
+            device_cert=new_device.certificate,
+        )
         template = certs.get_tflex_py_definitions()
-        assert cal.atcacert_write_cert(
-                template.get('signer'),
+        assert (
+            cal.atcacert_write_cert(
+                template.get("signer"),
                 certs.signer.get_certificate_in_der(),
-                len(certs.signer.get_certificate_in_der())) \
-            == cal.Status.ATCA_SUCCESS, \
-            "Loading signer certificate into slot failed"
-        assert cal.atcacert_write_cert(
-                template.get('device'),
+                len(certs.signer.get_certificate_in_der()),
+            )
+            == cal.Status.ATCA_SUCCESS
+        ), "Loading signer certificate into slot failed"
+        assert (
+            cal.atcacert_write_cert(
+                template.get("device"),
                 certs.device.get_certificate_in_der(),
-                len(certs.device.get_certificate_in_der())) \
-            == cal.Status.ATCA_SUCCESS, \
-            "Loading device certificate into slot failed"
+                len(certs.device.get_certificate_in_der()),
+            )
+            == cal.Status.ATCA_SUCCESS
+        ), "Loading device certificate into slot failed"
 
 
 # Standard boilerplate to call the main() function to begin
 # the program.
-if __name__ == '__main__':
+if __name__ == "__main__":
     # cfg = cal.cfg_ateccx08a_kithid_default()
     # cfg.cfg.atcahid.dev_interface = int(cal.ATCAKitType.ATCA_KIT_I2C_IFACE)
     # cfg.cfg.atcahid.dev_identity = 0x6C
     # provision = TFLXTLSProvision('sample_ecc.xml', cfg)
     # print(provision.element.get_device_details())
     # provision.provision_non_cert_slots()
     # provision.provision_cert_slots(
```

## tpds/proto_provision/tflxwpc_provision.py

```diff
@@ -18,224 +18,232 @@
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 
 # import os, sys
 # sys.path.append(os.path.normpath( os.path.join(os.getcwd(), *([".."] * 3), 'tpds_helper')))
 # sys.path.append(os.path.normpath( os.path.join(os.getcwd(), *([".."] * 3), 'tpds_core')))
 import struct
-from tpds.proto_provision.ecc_provision import ECCProvision
+from datetime import datetime, timezone
+
 import cryptoauthlib as cal
 import lxml.etree as ET
-from tpds.certs import Cert, WPCCertDef
-from tpds.certs.ext_builder import TimeFormat
-from tpds.certs.cert_utils import (
-                get_device_public_key, get_backend,
-                pubkey_cert_sn, random_cert_sn)
-from tpds.secure_element.constants import Constants
-from tpds.tp_utils.tp_keys import TPAsymmetricKey
-
 from cryptography import x509
+from cryptography.hazmat.backends import default_backend
+from cryptography.hazmat.primitives import hashes
 from cryptography.hazmat.primitives.asymmetric import ec
 from cryptography.hazmat.primitives.serialization import Encoding
-from cryptography.hazmat.primitives import hashes
-from cryptography.hazmat.backends import default_backend
 
-from datetime import datetime, timezone
+from tpds.certs import Cert, WPCCertDef
+from tpds.certs.cert_utils import get_backend, get_device_public_key, pubkey_cert_sn, random_cert_sn
+from tpds.certs.ext_builder import TimeFormat
+from tpds.proto_provision.ecc_provision import ECCProvision
+from tpds.secure_element.constants import Constants
+from tpds.tp_utils.tp_keys import TPAsymmetricKey
 
 
 class TFLXWPCProvision(ECCProvision):
     def __init__(self, xml_file):
         self.root = ET.parse(xml_file).getroot()
 
-        if 'ECC' not in self.root.find('PartNumber').text:
-            raise ValueError('Unsupported Part Number in XML')
-        interface = self.root.find('Device').find(
-                                'ConfigurationZone').find('I2CEnable').text
-        address = self.root.find('Device').find(
-                                'ConfigurationZone').find('I2CAddress').text
+        if "ECC" not in self.root.find("PartNumber").text:
+            raise ValueError("Unsupported Part Number in XML")
+        interface = self.root.find("Device").find("ConfigurationZone").find("I2CEnable").text
+        address = self.root.find("Device").find("ConfigurationZone").find("I2CAddress").text
 
-        cfg=cal.cfg_ateccx08a_kithid_default()
-        if interface =='01':
+        cfg = cal.cfg_ateccx08a_kithid_default()
+        if interface == "01":
             cfg.cfg.atcahid.dev_interface = int(cal.ATCAKitType.ATCA_KIT_I2C_IFACE)
         else:
             cfg.cfg.atcahid.dev_interface = int(cal.ATCAKitType.ATCA_KIT_SWI_IFACE)
 
         cfg.cfg.atcahid.dev_identity = int(address, base=16)
         super().__init__(cfg)
 
         if not self.element.is_config_zone_locked():
-            raise ValueError('TFLXWPC cannot have unlocked config zone')
+            raise ValueError("TFLXWPC cannot have unlocked config zone")
         if not self.element.is_data_zone_locked():
-            raise ValueError('TFLXWPC cannot have unlocked data zone')
+            raise ValueError("TFLXWPC cannot have unlocked data zone")
 
     def provision_non_cert_slots(self):
-        self.data_zone = self.root.find('Device').find('DataZone')
-        slot_config = self.root.find('Device').find(
-                                'ConfigurationZone').find('SlotConfigurations')
+        self.data_zone = self.root.find("Device").find("DataZone")
+        slot_config = self.root.find("Device").find("ConfigurationZone").find("SlotConfigurations")
         self.slot_config = {}
-        for index, element in enumerate(slot_config.iter('SlotConfiguration')):
-            self.slot_config.update({index: element.text.replace(' ', '')})
-        self.slot_modes = [
-            'GenKey', 'Secret', 'Random', 'Public']
+        for index, element in enumerate(slot_config.iter("SlotConfiguration")):
+            self.slot_config.update({index: element.text.replace(" ", "")})
+        self.slot_modes = ["GenKey", "Secret", "Random", "Public"]
         for element in list(self.data_zone):
-            if element.attrib.get('Mode') == 'GenKey':
-                slot_index = int(element.attrib.get('Index'), base=16)
+            if element.attrib.get("Mode") == "GenKey":
+                slot_index = int(element.attrib.get("Index"), base=16)
                 slot_config = self.slot_config.get(slot_index)
-                if slot_config[2:3] == '2':
+                if slot_config[2:3] == "2":
                     self.perform_genkey(slot_index)
-            elif element.attrib.get('Mode') == 'Secret':
-                slot_index = int(element.attrib.get('Index'), base=16)
-                slot_data = bytearray.fromhex(element.find('Data').text)
+            elif element.attrib.get("Mode") == "Secret":
+                slot_index = int(element.attrib.get("Index"), base=16)
+                slot_data = bytearray.fromhex(element.find("Data").text)
                 slot_config = self.slot_config.get(slot_index)
                 encrypting_slot = encrypting_slot_data = None
-                if slot_config[2:3] == '4':
+                if slot_config[2:3] == "4":
                     encrypting_slot = int(slot_config[3:4], base=16)
                     encrypting_element = list(self.data_zone)[encrypting_slot]
-                    slot_data_attr = encrypting_element.find('Data')
-                    encrypting_slot_data = bytearray.fromhex(
-                                                slot_data_attr.text)
-                    if slot_data_attr.attrib.get('Size') == '36':
+                    slot_data_attr = encrypting_element.find("Data")
+                    encrypting_slot_data = bytearray.fromhex(slot_data_attr.text)
+                    if slot_data_attr.attrib.get("Size") == "36":
                         encrypting_slot_data = encrypting_slot_data[:32]
-                    elif slot_data_attr.attrib.get('Size') == '72':
+                    elif slot_data_attr.attrib.get("Size") == "72":
                         encrypting_slot_data = encrypting_slot_data[:64]
-                    self.perform_slot_write(
-                                encrypting_slot, encrypting_slot_data)
+                    self.perform_slot_write(encrypting_slot, encrypting_slot_data)
 
-                slot_data_attr = element.find('Data')
-                if slot_data_attr.attrib.get('Size') == '36':
+                slot_data_attr = element.find("Data")
+                if slot_data_attr.attrib.get("Size") == "36":
                     slot_data = slot_data[:32]
-                elif slot_data_attr.attrib.get('Size') == '72':
+                elif slot_data_attr.attrib.get("Size") == "72":
                     slot_data = slot_data[:64]
                 self.perform_slot_write(
-                                slot_index, slot_data,
-                                encrypting_slot, encrypting_slot_data)
-            elif element.attrib.get('Mode') == 'Random':
-                slot_index = element.attrib.get('Index')
-            elif element.attrib.get('Mode') == 'Public':
-                slot_index = int(element.attrib.get('Index'), base=16)
+                    slot_index, slot_data, encrypting_slot, encrypting_slot_data
+                )
+            elif element.attrib.get("Mode") == "Random":
+                slot_index = element.attrib.get("Index")
+            elif element.attrib.get("Mode") == "Public":
+                slot_index = int(element.attrib.get("Index"), base=16)
                 slot_config = self.slot_config.get(slot_index)
-                slot_data = bytearray.fromhex(element.find('Data').text)
+                slot_data = bytearray.fromhex(element.find("Data").text)
                 public_key_control_bytes = bytearray(4)
-                if slot_config[2:3] == '1':
-                    assert cal.atcab_read_zone(
-                        Constants.ATCA_DATA_ZONE, slot_index, 0, 0,
-                        public_key_control_bytes,
-                        len(public_key_control_bytes)) == cal.Status.ATCA_SUCCESS, \
-                        'Reading public key validation state - failed'
+                if slot_config[2:3] == "1":
+                    assert (
+                        cal.atcab_read_zone(
+                            Constants.ATCA_DATA_ZONE,
+                            slot_index,
+                            0,
+                            0,
+                            public_key_control_bytes,
+                            len(public_key_control_bytes),
+                        )
+                        == cal.Status.ATCA_SUCCESS
+                    ), "Reading public key validation state - failed"
                 if public_key_control_bytes[0] == 0x00:
                     self.perform_slot_write(slot_index, slot_data)
                 else:
-                    print('Validated Public key encountered, skipping the slot!')
+                    print("Validated Public key encountered, skipping the slot!")
 
     def provision_cert_slots(
-                    self, signer_ca=None, signer_ca_key=None,
-                    device_ca=None, device_ca_key=None):
+        self, signer_ca=None, signer_ca_key=None, device_ca=None, device_ca_key=None
+    ):
         signer_ca_key = TPAsymmetricKey(signer_ca_key)
         device_ca_key = TPAsymmetricKey(device_ca_key)
 
-        self.comp_certs = self.root.find('CompressedCerts')
-        device_cert_element = self.comp_certs.find('''CompressedCert[@ChainLevel='0']''')
-        signer_cert_element = self.comp_certs.find('''CompressedCert[@ChainLevel='1']''')
-        single_signer_id = device_cert_element.attrib.get('SingleSignerID')
-        ptmc_seq = f'{single_signer_id[7:11]}-{single_signer_id[-2:]}'
-        for element in device_cert_element.findall('Element'):
-            if element.attrib.get('Name') == 'RSID':
-                rsid = element.attrib.get('CounterStart')
-        for element in signer_cert_element.findall('Element'):
-            if element.attrib.get('Name') == 'qiPolicy':
-                qi_policy_slot = int(''.join(filter(str.isdigit, element.attrib.get('DeviceLoc'))))
-                qi_policy_slot_offset = int(''.join(filter(str.isdigit, element.attrib.get('Offset'))))
-        qi_policy_bytes = bytearray.fromhex(
-                                        list(self.data_zone)[qi_policy_slot].find(
-                                            'Data').text)[qi_policy_slot_offset:qi_policy_slot_offset+4]
+        self.comp_certs = self.root.find("CompressedCerts")
+        device_cert_element = self.comp_certs.find("""CompressedCert[@ChainLevel='0']""")
+        signer_cert_element = self.comp_certs.find("""CompressedCert[@ChainLevel='1']""")
+        single_signer_id = device_cert_element.attrib.get("SingleSignerID")
+        ptmc_seq = f"{single_signer_id[7:11]}-{single_signer_id[-2:]}"
+        for element in device_cert_element.findall("Element"):
+            if element.attrib.get("Name") == "RSID":
+                rsid = element.attrib.get("CounterStart")
+        for element in signer_cert_element.findall("Element"):
+            if element.attrib.get("Name") == "qiPolicy":
+                qi_policy_slot = int("".join(filter(str.isdigit, element.attrib.get("DeviceLoc"))))
+                qi_policy_slot_offset = int(
+                    "".join(filter(str.isdigit, element.attrib.get("Offset")))
+                )
+        qi_policy_bytes = bytearray.fromhex(list(self.data_zone)[qi_policy_slot].find("Data").text)[
+            qi_policy_slot_offset : qi_policy_slot_offset + 4
+        ]
         device_template = Cert()
         device_template.set_certificate(
-                                x509.load_der_x509_certificate(
-                                        bytes.fromhex(device_cert_element.find('TemplateData').text),
-                                        backend=get_backend))
+            x509.load_der_x509_certificate(
+                bytes.fromhex(device_cert_element.find("TemplateData").text), backend=get_backend
+            )
+        )
 
         new_root = Cert()
         if signer_ca is not None:
             new_root.set_certificate(signer_ca)
         else:
             new_root.builder = new_root.builder.subject_name(
-                                        x509.Name([x509.NameAttribute(x509.oid.NameOID.COMMON_NAME, 'WPCCA1')]))
+                x509.Name([x509.NameAttribute(x509.oid.NameOID.COMMON_NAME, "WPCCA1")])
+            )
             new_root.builder = new_root.builder.issuer_name(
-                                        x509.Name([x509.NameAttribute(x509.oid.NameOID.COMMON_NAME, 'WPCCA1')]))
+                x509.Name([x509.NameAttribute(x509.oid.NameOID.COMMON_NAME, "WPCCA1")])
+            )
             new_root.builder = new_root.builder.not_valid_before(
-                                        datetime(2021, 3, 3, 16, 4, 1, tzinfo=timezone.utc))
+                datetime(2021, 3, 3, 16, 4, 1, tzinfo=timezone.utc)
+            )
             new_root.builder = new_root.builder.not_valid_after(
-                                        datetime(9999, 12, 31, 23, 59, 59, tzinfo=timezone.utc))
-            new_root.builder = new_root.builder.public_key(
-                                        signer_ca_key.get_public_key())
+                datetime(9999, 12, 31, 23, 59, 59, tzinfo=timezone.utc)
+            )
+            new_root.builder = new_root.builder.public_key(signer_ca_key.get_public_key())
             new_root.builder = new_root.builder.serial_number(random_cert_sn(8))
             new_root.builder = new_root.builder.add_extension(
-                                        x509.BasicConstraints(ca=True, path_length=None),
-                                        critical=True)
+                x509.BasicConstraints(ca=True, path_length=None), critical=True
+            )
             new_root.sign_builder(signer_ca_key.private_key)
 
         new_signer = Cert()
         if device_ca is not None:
             new_signer.set_certificate(device_ca)
         else:
             new_signer.builder = new_signer.builder.issuer_name(new_root.certificate.subject)
             new_signer.builder = new_signer.builder.subject_name(
-                                        x509.Name([x509.NameAttribute(x509.oid.NameOID.COMMON_NAME, ptmc_seq)]))
+                x509.Name([x509.NameAttribute(x509.oid.NameOID.COMMON_NAME, ptmc_seq)])
+            )
             new_signer.builder = new_signer.builder.not_valid_before(datetime.utcnow())
             new_signer.builder = new_signer.builder.not_valid_after(
-                                        datetime(9999, 12, 31, 23, 59, 59, tzinfo=timezone.utc),
-                                        format=TimeFormat.GENERALIZED_TIME)
-            new_signer.builder = new_signer.builder.public_key(
-                                        device_ca_key.get_public_key())
+                datetime(9999, 12, 31, 23, 59, 59, tzinfo=timezone.utc),
+                format=TimeFormat.GENERALIZED_TIME,
+            )
+            new_signer.builder = new_signer.builder.public_key(device_ca_key.get_public_key())
             new_signer.builder = new_signer.builder.serial_number(random_cert_sn(8))
             new_signer.builder = new_signer.builder.add_extension(
-                                        x509.BasicConstraints(ca=True, path_length=None),
-                                        critical=True)
+                x509.BasicConstraints(ca=True, path_length=None), critical=True
+            )
             wpc_qi_policy_extension_value = bytes([0x04, len(qi_policy_bytes)]) + qi_policy_bytes
             new_signer.builder = new_signer.builder.add_extension(
-                                    x509.UnrecognizedExtension(x509.ObjectIdentifier(
-                                        '2.23.148.1.1'), wpc_qi_policy_extension_value),
-                                    critical=True)
+                x509.UnrecognizedExtension(
+                    x509.ObjectIdentifier("2.23.148.1.1"), wpc_qi_policy_extension_value
+                ),
+                critical=True,
+            )
             new_signer.sign_builder(signer_ca_key.private_key)
 
         device_pubkey = bytearray(64)
         status = cal.atcab_get_pubkey(0, device_pubkey)
-        assert status == cal.Status.ATCA_SUCCESS, 'atcab_get_pubkey failed'
+        assert status == cal.Status.ATCA_SUCCESS, "atcab_get_pubkey failed"
         device_pubkey = get_device_public_key(device_pubkey)
         device_pubkey = ec.EllipticCurvePublicNumbers(
-                                    x=int(device_pubkey[:64], 16),
-                                    y=int(device_pubkey[64:], 16),
-                                    curve=ec.SECP256R1()).public_key(get_backend())
+            x=int(device_pubkey[:64], 16), y=int(device_pubkey[64:], 16), curve=ec.SECP256R1()
+        ).public_key(get_backend())
 
         new_device = Cert()
         new_device.builder = new_device.builder.issuer_name(new_signer.certificate.subject)
         new_device.builder = new_device.builder.not_valid_before(
-                                    datetime.utcnow().replace(tzinfo=timezone.utc, minute=0, second=0),
-                                    format=TimeFormat.GENERALIZED_TIME)
+            datetime.utcnow().replace(tzinfo=timezone.utc, minute=0, second=0),
+            format=TimeFormat.GENERALIZED_TIME,
+        )
         new_device.builder = new_device.builder.not_valid_after(
-                                    datetime(9999, 12, 31, 23, 59, 59, tzinfo=timezone.utc),
-                                    format=TimeFormat.GENERALIZED_TIME)
+            datetime(9999, 12, 31, 23, 59, 59, tzinfo=timezone.utc),
+            format=TimeFormat.GENERALIZED_TIME,
+        )
         new_device.builder = new_device.builder.subject_name(device_template.certificate.subject)
         new_device.builder = new_device.builder.public_key(device_pubkey)
         new_device.builder = new_device.builder.serial_number(pubkey_cert_sn(8, new_device.builder))
 
-        rsid_bytes = int(rsid, 16).to_bytes(9, byteorder='big', signed=False)
+        rsid_bytes = int(rsid, 16).to_bytes(9, byteorder="big", signed=False)
         rsid_extension_value = bytes([0x04, len(rsid_bytes)]) + rsid_bytes
         new_device.builder = new_device.builder.add_extension(
-                                    x509.UnrecognizedExtension(x509.ObjectIdentifier(
-                                        '2.23.148.1.2'), rsid_extension_value),
-                                    critical=True)
+            x509.UnrecognizedExtension(x509.ObjectIdentifier("2.23.148.1.2"), rsid_extension_value),
+            critical=True,
+        )
         new_device.sign_builder(device_ca_key.private_key)
 
         # Verify new cert chain
         assert (
-            new_root.is_signature_valid(signer_ca_key.get_public_key()) and
-            new_signer.is_signature_valid(signer_ca_key.get_public_key()) and
-            new_device.is_signature_valid(device_ca_key.get_public_key())), \
-            'Certificate chain verification failed'
+            new_root.is_signature_valid(signer_ca_key.get_public_key())
+            and new_signer.is_signature_valid(signer_ca_key.get_public_key())
+            and new_device.is_signature_valid(device_ca_key.get_public_key())
+        ), "Certificate chain verification failed"
 
         # Store keys and certs to files
         # signer_ca_key.get_private_pem(Path('root.key'))
         # device_ca_key.get_private_pem(Path('signer.key'))
         # certs_txt = new_root.get_certificate_in_text()\
         #     + '\n\n' + new_signer.get_certificate_in_text()\
         #     + '\n\n' + new_device.get_certificate_in_text()
@@ -249,58 +257,54 @@
         #     new_device.get_certificate_in_pem())
 
         root_bytes = new_root.certificate.public_bytes(encoding=Encoding.DER)
         mfg_bytes = new_signer.certificate.public_bytes(encoding=Encoding.DER)
         puc_bytes = new_device.certificate.public_bytes(encoding=Encoding.DER)
 
         # Setup hash engine for root cert digest
-        root_hash = hashes.Hash(
-            hashes.SHA256(),
-            backend=default_backend())
+        root_hash = hashes.Hash(hashes.SHA256(), backend=default_backend())
         root_hash.update(root_bytes)
         root_digest = root_hash.finalize()[:32]
 
-        length = 2 + len(root_digest) + \
-            len(mfg_bytes) + len(puc_bytes)
-        cert_chain = b''
-        cert_chain += struct.pack('>H', length)
+        length = 2 + len(root_digest) + len(mfg_bytes) + len(puc_bytes)
+        cert_chain = b""
+        cert_chain += struct.pack(">H", length)
         cert_chain += root_digest
         cert_chain += mfg_bytes
         cert_chain += puc_bytes
 
-        chain_hash = hashes.Hash(
-            hashes.SHA256(),
-            backend=default_backend())
+        chain_hash = hashes.Hash(hashes.SHA256(), backend=default_backend())
         chain_hash.update(cert_chain)
         chain_digest = chain_hash.finalize()[:32]
 
         # Write compressed certs to device
         crt_template = dict()
         cert_def = WPCCertDef()
         cert_def.set_certificate(new_signer.certificate, new_root.certificate, template_id=1)
-        crt_template.update({'signer': cert_def.get_py_definition()})
+        crt_template.update({"signer": cert_def.get_py_definition()})
         # cert_def.get_c_definition(True)
         cert_def = WPCCertDef()
         cert_def.set_certificate(new_device.certificate, new_signer.certificate, template_id=2)
-        crt_template.update({'device': cert_def.get_py_definition()})
+        crt_template.update({"device": cert_def.get_py_definition()})
         # cert_def.get_c_definition(True)
 
-        assert cal.atcacert_write_cert(
-            crt_template['signer'], mfg_bytes, len(mfg_bytes)) \
-            == cal.Status.ATCA_SUCCESS, \
-            "Loading MFG certificate into slot failed"
-        assert cal.atcacert_write_cert(
-            crt_template['device'], puc_bytes, len(puc_bytes)) \
-            == cal.Status.ATCA_SUCCESS, \
-            "Loading PUC certificate into slot failed"
-        assert cal.atcab_write_bytes_zone(
-            Constants.ATCA_DATA_ZONE, 3, 0,
-            chain_digest, len(chain_digest)) \
-            == cal.Status.ATCA_SUCCESS, \
-            "Loading Cert chain digest into slot failed"
+        assert (
+            cal.atcacert_write_cert(crt_template["signer"], mfg_bytes, len(mfg_bytes))
+            == cal.Status.ATCA_SUCCESS
+        ), "Loading MFG certificate into slot failed"
+        assert (
+            cal.atcacert_write_cert(crt_template["device"], puc_bytes, len(puc_bytes))
+            == cal.Status.ATCA_SUCCESS
+        ), "Loading PUC certificate into slot failed"
+        assert (
+            cal.atcab_write_bytes_zone(
+                Constants.ATCA_DATA_ZONE, 3, 0, chain_digest, len(chain_digest)
+            )
+            == cal.Status.ATCA_SUCCESS
+        ), "Loading Cert chain digest into slot failed"
 
         # print(f'Chain digest: {chain_digest.hex().upper()}')
         # read_data = [
         #     {'slot':3, 'size': 36},     {'slot':4, 'size': 36},     {'slot':5, 'size': 36},
         #     {'slot':9, 'size': 72},     {'slot':13, 'size': 72},     {'slot':14, 'size': 72},
         # ]
         # for slot_info in read_data:
@@ -313,13 +317,13 @@
         #         == cal.Status.ATCA_SUCCESS, \
         #         "Reading Chain digest from slot failed"
         #     print(f'Data from Slot{slot_id} with size {slot_size} is {buffer.hex().upper()}')
 
 
 # Standard boilerplate to call the main() function to begin
 # the program.
-if __name__ == '__main__':
-    test_prov = TFLXWPCProvision('ATECC608A-xxxxxx-T.xml')
+if __name__ == "__main__":
+    test_prov = TFLXWPCProvision("ATECC608A-xxxxxx-T.xml")
     print(test_prov.element.get_device_details())
     test_prov.provision_non_cert_slots()
     test_prov.provision_cert_slots()
     pass
```

## tpds/pubkey_validation/__init__.py

```diff
@@ -1,5 +1,7 @@
 """
     Trust Platform core package - pubkey_validation module
 """
-from .device_pubkey_validation import *
-from .pubkey_validation import *
+from .device_pubkey_validation import DevicePubkeyValidation
+from .pubkey_validation import PubKeyValidation
+
+__all__ = ["DevicePubkeyValidation", "PubKeyValidation"]
```

## tpds/pubkey_validation/device_pubkey_validation.py

```diff
@@ -15,19 +15,22 @@
 # KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 
 import os
+
 import cryptoauthlib as cal
 from cryptoauthlib.device import Atecc608Config
-from .pubkey_validation import PubKeyValidation
+
 import tpds.tp_utils
 
+from .pubkey_validation import PubKeyValidation
+
 
 class DevicePubkeyValidation(PubKeyValidation):
     def __init__(self, auth_pubkey_slot, pubkey_slot):
         super().__init__()
         self.__set_device_info(auth_pubkey_slot, pubkey_slot)
 
     def pubkey_invalidate(self, auth_key, public_key):
@@ -37,154 +40,168 @@
               auth_key          Authority private key to sign
                                 the pubkey digest
               public_key        public key to be invalidated
         outputs:
             is_invalidated      True if invalidated else False
         """
         self.authorize_public_key(auth_key, public_key, True)
-        assert cal.atcab_nonce(
-            self.nonce) == cal.Status.ATCA_SUCCESS, 'Loading Nonce failed'
+        assert cal.atcab_nonce(self.nonce) == cal.Status.ATCA_SUCCESS, "Loading Nonce failed"
 
-        assert cal.atcab_genkey_base(
-            0x10, self.device_info.get('pubkey_slot'),
-            other_data=b'\x00'*3) == cal.Status.ATCA_SUCCESS, \
-            'Genkey digest calculation on device failed'
+        assert (
+            cal.atcab_genkey_base(0x10, self.device_info.get("pubkey_slot"), other_data=b"\x00" * 3)
+            == cal.Status.ATCA_SUCCESS
+        ), "Genkey digest calculation on device failed"
 
         is_invalidated = cal.AtcaReference(False)
-        assert cal.atcab_verify_invalidate(
-            self.device_info.get('pubkey_slot'), self.signature,
-            self.sign_internal_other_data, is_invalidated) \
-            == cal.Status.ATCA_SUCCESS,\
-            'Slot verification for invalidate failed'
-
-        assert bool(is_invalidated.value), 'Verify Invalidate command is success, \
-            but invalidation failed'
+        assert (
+            cal.atcab_verify_invalidate(
+                self.device_info.get("pubkey_slot"),
+                self.signature,
+                self.sign_internal_other_data,
+                is_invalidated,
+            )
+            == cal.Status.ATCA_SUCCESS
+        ), "Slot verification for invalidate failed"
+
+        assert bool(
+            is_invalidated.value
+        ), "Verify Invalidate command is success, \
+            but invalidation failed"
 
     def pubkey_validate(self, auth_key, public_key):
         """
         Method validate the public key to use for the cryptographic function
         Inputs:
               auth_key        Authority validation private key
               public_key      public key to be validated
         Outputs:
               is_validated    True if validated else False
         """
         self.authorize_public_key(auth_key, public_key, False)
-        assert cal.atcab_nonce(self.nonce) == cal.Status.ATCA_SUCCESS, \
-            'Loading Nonce failed'
+        assert cal.atcab_nonce(self.nonce) == cal.Status.ATCA_SUCCESS, "Loading Nonce failed"
 
-        assert cal.atcab_genkey_base(
-            0x10, self.device_info.get('pubkey_slot'),
-            other_data=b'\x00'*3) == cal.Status.ATCA_SUCCESS, \
-            'Genkey digest calculation on device failed'
+        assert (
+            cal.atcab_genkey_base(0x10, self.device_info.get("pubkey_slot"), other_data=b"\x00" * 3)
+            == cal.Status.ATCA_SUCCESS
+        ), "Genkey digest calculation on device failed"
 
         is_validated = cal.AtcaReference(False)
-        assert cal.atcab_verify_validate(
-            self.device_info.get('pubkey_slot'), self.signature,
-            self.sign_internal_other_data, is_validated) \
-            == cal.Status.ATCA_SUCCESS, \
-            'Slot verification for validate failed'
-
-        assert bool(is_validated.value), 'Verify validate command is success, \
-            but validation failed'
+        assert (
+            cal.atcab_verify_validate(
+                self.device_info.get("pubkey_slot"),
+                self.signature,
+                self.sign_internal_other_data,
+                is_validated,
+            )
+            == cal.Status.ATCA_SUCCESS
+        ), "Slot verification for validate failed"
+
+        assert bool(
+            is_validated.value
+        ), "Verify validate command is success, \
+            but validation failed"
 
     def is_pubkey_validated(self):
         """
         Method check the public key validation state
         Inputs:
               pubkey_slot         public key slot
         Outputs:
               validation_state    True if public key is valid else False
         """
         public_key_control_bytes = bytearray(4)
-        assert cal.atcab_read_zone(
-            0x02, self.device_info.get('pubkey_slot'), 0, 0,
-            public_key_control_bytes,
-            len(public_key_control_bytes)) == cal.Status.ATCA_SUCCESS, \
-            'Reading public key validation state - failed'
+        assert (
+            cal.atcab_read_zone(
+                0x02,
+                self.device_info.get("pubkey_slot"),
+                0,
+                0,
+                public_key_control_bytes,
+                len(public_key_control_bytes),
+            )
+            == cal.Status.ATCA_SUCCESS
+        ), "Reading public key validation state - failed"
 
         return public_key_control_bytes[0] == 0x50
 
     def __set_device_info(self, auth_pubkey_slot, pubkey_slot):
         """
         Method set the device information to perform public key validation
         Input:
             auth_pubkey_slot          authority public key slot
             pubkey_slot               public key slot for (in)validation
         """
         device_config = bytearray()
-        assert cal.atcab_read_config_zone(device_config) \
-            == cal.Status.ATCA_SUCCESS,\
-            'Reading device configuration is failed'
+        assert (
+            cal.atcab_read_config_zone(device_config) == cal.Status.ATCA_SUCCESS
+        ), "Reading device configuration is failed"
 
         super().set_device_info(
-            Atecc608Config.from_buffer(device_config),
-            auth_pubkey_slot, pubkey_slot)
+            Atecc608Config.from_buffer(device_config), auth_pubkey_slot, pubkey_slot
+        )
 
-    def save_resources(self, auth_key, rotating_key, file='pubkey_rotation.h'):
+    def save_resources(self, auth_key, rotating_key, file="pubkey_rotation.h"):
         """Method saves the resource files.
 
         Input:
             auth_key                  Authority valid private key.
             rotating_key ([type]):    New rotating key
             file (str, optional):     File name to save the resources.
                                       Defaults to 'pubkey_rotation.h'.
         """
         auth_key = tpds.tp_utils.TPAsymmetricKey(auth_key)
         rotating_key = tpds.tp_utils.TPAsymmetricKey(rotating_key)
 
-        with open(file, 'w') as f:
+        with open(file, "w") as f:
             # Calculate invalidate signature and nonce to invalidate public key
             self.authorize_public_key(
-                auth_key.get_private_key(),
-                rotating_key.public_key_bytes, False)
+                auth_key.get_private_key(), rotating_key.public_key_bytes, False
+            )
 
-            f.write('#ifndef _PUBKEY_ROTATION_H\n')
-            f.write('#define _PUBKEY_ROTATION_H\n\n')
+            f.write("#ifndef _PUBKEY_ROTATION_H\n")
+            f.write("#define _PUBKEY_ROTATION_H\n\n")
             f.write('#include "cryptoauthlib.h"\n\n')
-            f.write('#ifdef __cplusplus\n')
+            f.write("#ifdef __cplusplus\n")
             f.write('extern "C" {\n')
-            f.write('#endif\n\n')
+            f.write("#endif\n\n")
 
-            f.write('uint8_t validated_nonce[] = {\n')
-            f.write(tpds.tp_utils.get_c_hex_bytes(self.pubkey_info.get(
-                'auth_nonce')) + '};\n\n')
-
-            f.write('uint8_t validated_signature[] = {\n')
-            f.write(tpds.tp_utils.get_c_hex_bytes(self.pubkey_info.get(
-                'auth_signature')) + '};\n\n')
+            f.write("uint8_t validated_nonce[] = {\n")
+            f.write(tpds.tp_utils.get_c_hex_bytes(self.pubkey_info.get("auth_nonce")) + "};\n\n")
+
+            f.write("uint8_t validated_signature[] = {\n")
+            f.write(
+                tpds.tp_utils.get_c_hex_bytes(self.pubkey_info.get("auth_signature")) + "};\n\n"
+            )
 
             # calculate digest and signature to verify new rotating public key
             message_digest = os.urandom(32)
-            signature = tpds.tp_utils.sign_on_host(
-                message_digest, rotating_key.get_private_key())
-            f.write('uint8_t rotating_digest[] = {\n')
-            f.write(tpds.tp_utils.get_c_hex_bytes(message_digest) + '};\n\n')
+            signature = tpds.tp_utils.sign_on_host(message_digest, rotating_key.get_private_key())
+            f.write("uint8_t rotating_digest[] = {\n")
+            f.write(tpds.tp_utils.get_c_hex_bytes(message_digest) + "};\n\n")
 
-            f.write('uint8_t rotating_signature[] = {\n')
-            f.write(tpds.tp_utils.get_c_hex_bytes(signature) + '};\n\n')
+            f.write("uint8_t rotating_signature[] = {\n")
+            f.write(tpds.tp_utils.get_c_hex_bytes(signature) + "};\n\n")
 
             # Calculate invalidate signature and nonce to invalidate public key
             self.authorize_public_key(
-                auth_key.get_private_key(),
-                rotating_key.public_key_bytes, True)
+                auth_key.get_private_key(), rotating_key.public_key_bytes, True
+            )
+
+            f.write("uint8_t invalidated_nonce[] = {\n")
+            f.write(tpds.tp_utils.get_c_hex_bytes(self.pubkey_info.get("auth_nonce")) + "};\n\n")
 
-            f.write('uint8_t invalidated_nonce[] = {\n')
-            f.write(tpds.tp_utils.get_c_hex_bytes(self.pubkey_info.get(
-                'auth_nonce')) + '};\n\n')
-
-            f.write('uint8_t invalidated_signature[] = {\n')
-            f.write(tpds.tp_utils.get_c_hex_bytes(self.pubkey_info.get(
-                'auth_signature')) + '};\n\n')
-
-            f.write('uint8_t public_key[] = {\n')
-            f.write(tpds.tp_utils.get_c_hex_bytes(self.pubkey_info.get(
-                'public_key')) + '};\n\n')
-
-            rotating_key_slot = self.device_info.get('pubkey_slot')
-            f.write(f'uint16_t rotating_pubkey_slot = {rotating_key_slot};\n')
-            auth_key_slot = self.device_info.get('auth_pubkey_slot')
-            f.write(f'uint16_t authority_pubkey_slot = {auth_key_slot};\n\n')
-            f.write('#ifdef __cplusplus\n')
-            f.write('}\n')
-            f.write('#endif\n')
-            f.write('#endif\n')
+            f.write("uint8_t invalidated_signature[] = {\n")
+            f.write(
+                tpds.tp_utils.get_c_hex_bytes(self.pubkey_info.get("auth_signature")) + "};\n\n"
+            )
+
+            f.write("uint8_t public_key[] = {\n")
+            f.write(tpds.tp_utils.get_c_hex_bytes(self.pubkey_info.get("public_key")) + "};\n\n")
+
+            rotating_key_slot = self.device_info.get("pubkey_slot")
+            f.write(f"uint16_t rotating_pubkey_slot = {rotating_key_slot};\n")
+            auth_key_slot = self.device_info.get("auth_pubkey_slot")
+            f.write(f"uint16_t authority_pubkey_slot = {auth_key_slot};\n\n")
+            f.write("#ifdef __cplusplus\n")
+            f.write("}\n")
+            f.write("#endif\n")
+            f.write("#endif\n")
```

## tpds/pubkey_validation/pubkey_validation.py

```diff
@@ -17,50 +17,57 @@
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 
 import os
 import struct
 from hashlib import sha256
+
 from cryptoauthlib.library import ctypes_to_bytes
+
 import tpds.tp_utils
 
 
-class PubKeyValidation():
+class PubKeyValidation:
     def __init__(self):
         pass
 
     def set_device_info(self, device_config, auth_pubkey_slot, pubkey_slot):
         """
         Method set the Tempkey flags, tempkey slot configuration and
         tempkey key configuration
         Inputs:
               device_config        device configuration
               auth_pubkey_slot     authority public key slot
               pubkey_slot          public key slot
         """
         self.device_info = dict()
-        self.device_info.update({'serial_num': ctypes_to_bytes(
-            device_config.SN03) + ctypes_to_bytes(device_config.SN48)})
-        self.device_info.update({'auth_pubkey_slot': auth_pubkey_slot})
-        self.device_info.update({'pubkey_slot': pubkey_slot})
-        self.device_info.update({'pubkey_slot_config': ctypes_to_bytes(
-            device_config.SlotConfig[pubkey_slot])})
-        self.device_info.update({'pubkey_key_config': ctypes_to_bytes(
-            device_config.KeyConfig[pubkey_slot])})
-        self.device_info.update({'pubkey_slot_lock':
-                                device_config.SlotLocked & (1 << pubkey_slot)})
+        self.device_info.update(
+            {
+                "serial_num": ctypes_to_bytes(device_config.SN03)
+                + ctypes_to_bytes(device_config.SN48)
+            }
+        )
+        self.device_info.update({"auth_pubkey_slot": auth_pubkey_slot})
+        self.device_info.update({"pubkey_slot": pubkey_slot})
+        self.device_info.update(
+            {"pubkey_slot_config": ctypes_to_bytes(device_config.SlotConfig[pubkey_slot])}
+        )
+        self.device_info.update(
+            {"pubkey_key_config": ctypes_to_bytes(device_config.KeyConfig[pubkey_slot])}
+        )
+        self.device_info.update({"pubkey_slot_lock": device_config.SlotLocked & (1 << pubkey_slot)})
 
         # Default values set
-        self.device_info.update({'sign_internal_mode': 0})
-        self.device_info.update({'include_full_sn': False})
-        self.device_info.update({'temp_key_source_flag': True})
-        self.device_info.update({'temp_key_gendig_data': False})
-        self.device_info.update({'temp_key_genkey_data': True})
-        self.device_info.update({'temp_key_no_mac': False})
+        self.device_info.update({"sign_internal_mode": 0})
+        self.device_info.update({"include_full_sn": False})
+        self.device_info.update({"temp_key_source_flag": True})
+        self.device_info.update({"temp_key_gendig_data": False})
+        self.device_info.update({"temp_key_genkey_data": True})
+        self.device_info.update({"temp_key_no_mac": False})
 
     def authorize_public_key(self, auth_key, public_key, pubkey_valid=False):
         """
         Method calculate public key digest and sign the same using authority
         private key
         Inputs:
              auth_key      Authority private key
@@ -76,76 +83,79 @@
         asym_key.set_public_key(public_key)
         self.public_key = asym_key.public_key_bytes
 
         self.__calc_nonce()
         self.__calc_genkey_digest()
         self.__calc_sign_internal_digest(pubkey_valid)
         self.signature = tpds.tp_utils.sign_on_host(
-            self.sign_internal_digest, asym_auth_key.get_private_key())
+            self.sign_internal_digest, asym_auth_key.get_private_key()
+        )
 
         self.pubkey_info = dict()
-        self.pubkey_info.update({'auth_nonce': self.nonce})
-        self.pubkey_info.update({'auth_signature': self.signature})
-        self.pubkey_info.update({'public_key': self.public_key})
+        self.pubkey_info.update({"auth_nonce": self.nonce})
+        self.pubkey_info.update({"auth_signature": self.signature})
+        self.pubkey_info.update({"public_key": self.public_key})
 
     def __calc_nonce(self):
         """
         Calculate host nonce
         """
         self.numin = os.urandom(32)
         self.nonce = self.numin
 
     def __calc_genkey_digest(self):
         """
         Calculate public key digest using genkey command
         """
-        msg = b''
-        msg += self.nonce   # value loaded to Tempkey
-        msg += b'\x40'      # GenKey Opcode
-        msg += b'\x00'*3    # other data
-        msg += self.device_info.get('serial_num')[8:9]
-        msg += self.device_info.get('serial_num')[0:2]
-        msg += b'\x00'*25
+        msg = b""
+        msg += self.nonce  # value loaded to Tempkey
+        msg += b"\x40"  # GenKey Opcode
+        msg += b"\x00" * 3  # other data
+        msg += self.device_info.get("serial_num")[8:9]
+        msg += self.device_info.get("serial_num")[0:2]
+        msg += b"\x00" * 25
         msg += self.public_key
         self.pubkey_digest = sha256(msg).digest()
 
     def __calc_sign_internal_digest(self, pubkey_valid=False):
         """
         Calculate sign internal message digest
         Inputs:
               pubkey_valid        True if public key valid else False
         """
-        msg = b''
+        msg = b""
         msg += self.pubkey_digest
-        msg += b'\x41'  # Sign Opcode
-        msg += struct.pack("B", self.device_info.get('sign_internal_mode'))
-        msg += struct.pack('<H', self.device_info.get('auth_pubkey_slot'))
-        msg += self.device_info.get('pubkey_slot_config')
-        msg += self.device_info.get('pubkey_key_config')
-
-        temp_key_flags = self.device_info.get('pubkey_slot')
-        temp_key_flags += (1 << 4) \
-            if self.device_info.get('temp_key_source_flag') else 0
-        temp_key_flags += (1 << 5) \
-            if self.device_info.get('temp_key_gendig_data') else 0
-        temp_key_flags += (1 << 6) \
-            if self.device_info.get('temp_key_genkey_data') else 0
-        temp_key_flags += (1 << 7) \
-            if self.device_info.get('temp_key_no_mac') else 0
-        msg += struct.pack('B', temp_key_flags)
-
-        msg += b'\x00'*2
-        msg += self.device_info.get('serial_num')[8:9]
-        msg += self.device_info.get('serial_num')[4:8] \
-            if self.device_info.get('include_full_sn') else b'\x00'*4
-        msg += self.device_info.get('serial_num')[0:2]
-        msg += self.device_info.get('serial_num')[2:4] \
-            if self.device_info.get('include_full_sn') else b'\x00'*2
-        msg += b'\x01' if self.device_info.get('pubkey_slot_lock') else b'\x00'
-        msg += b'\x01' if pubkey_valid else b'\x00'
-        msg += b'\x00'
+        msg += b"\x41"  # Sign Opcode
+        msg += struct.pack("B", self.device_info.get("sign_internal_mode"))
+        msg += struct.pack("<H", self.device_info.get("auth_pubkey_slot"))
+        msg += self.device_info.get("pubkey_slot_config")
+        msg += self.device_info.get("pubkey_key_config")
+
+        temp_key_flags = self.device_info.get("pubkey_slot")
+        temp_key_flags += (1 << 4) if self.device_info.get("temp_key_source_flag") else 0
+        temp_key_flags += (1 << 5) if self.device_info.get("temp_key_gendig_data") else 0
+        temp_key_flags += (1 << 6) if self.device_info.get("temp_key_genkey_data") else 0
+        temp_key_flags += (1 << 7) if self.device_info.get("temp_key_no_mac") else 0
+        msg += struct.pack("B", temp_key_flags)
+
+        msg += b"\x00" * 2
+        msg += self.device_info.get("serial_num")[8:9]
+        msg += (
+            self.device_info.get("serial_num")[4:8]
+            if self.device_info.get("include_full_sn")
+            else b"\x00" * 4
+        )
+        msg += self.device_info.get("serial_num")[0:2]
+        msg += (
+            self.device_info.get("serial_num")[2:4]
+            if self.device_info.get("include_full_sn")
+            else b"\x00" * 2
+        )
+        msg += b"\x01" if self.device_info.get("pubkey_slot_lock") else b"\x00"
+        msg += b"\x01" if pubkey_valid else b"\x00"
+        msg += b"\x00"
         other_data = bytearray()
         other_data.extend(msg[33:43])
         other_data.extend(msg[44:48])
         other_data.extend(msg[50:55])
         self.sign_internal_digest = sha256(msg).digest()
         self.sign_internal_other_data = other_data
```

## tpds/resource_generation/__init__.py

```diff
@@ -1,6 +1,8 @@
 """
     Trust Platform core package - resource_genrator module
 """
-from .resource_generation import *
-from .tflx_resource_generation import *
-from .tng_manifest_generation import *
+from .resource_generation import ResourceGeneration
+from .tflx_resource_generation import TFLXResources, TFLXSlotConfig
+from .tng_manifest_generation import TNGManifest
+
+__all__ = ["ResourceGeneration", "TFLXSlotConfig", "TFLXResources", "TNGManifest"]
```

## tpds/resource_generation/resource_generation.py

```diff
@@ -15,19 +15,20 @@
 # KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 
 import cryptoauthlib as cal
-from tpds.tp_utils import TPAsymmetricKey, TPSymmetricKey
+
 from tpds.secure_element.constants import Constants
+from tpds.tp_utils import TPAsymmetricKey, TPSymmetricKey
 
 
-class ResourceGeneration():
+class ResourceGeneration:
     def __init__(self):
         pass
 
     def generate_private_key(self, slot, public_key=None):
         """
         Method perform generate private key on device and get public key
         return ATCA_SUCCESS on success or error code
@@ -41,21 +42,21 @@
 
               Method create a .pem and .h file which contains public key
               e.g., slot_x_public_key.pem and slot_x_public_key.h
         """
         slot_public_key = bytearray(64)
         status = cal.atcab_genkey(slot, slot_public_key)
         if status == cal.Status.ATCA_SUCCESS:
-            public_key_title = 'slot_{}_ecc_public_key'.format(slot)
+            public_key_title = "slot_{}_ecc_public_key".format(slot)
             asym_key = TPAsymmetricKey()
             asym_key.set_public_key(slot_public_key)
             asym_key.get_public_c_hex(
-                        file='{}.h'.format(public_key_title),
-                        variable_name=public_key_title)
-            asym_key.get_public_pem('{}.pem'.format(public_key_title))
+                file="{}.h".format(public_key_title), variable_name=public_key_title
+            )
+            asym_key.get_public_pem("{}.pem".format(public_key_title))
 
             if isinstance(public_key, bytearray):
                 public_key[0:] = slot_public_key
             elif public_key:
                 asym_key.get_public_pem(public_key)
 
         return status
@@ -78,38 +79,38 @@
         public_key_control_bytes = bytearray(4)
         status = cal.atcab_read_zone(
             Constants.ATCA_DATA_ZONE,
             slot,
             0,
             0,
             public_key_control_bytes,
-            len(public_key_control_bytes))
+            len(public_key_control_bytes),
+        )
 
         if public_key_control_bytes[0] & 0x50:
-            print('Slot requires invalidation prior to write.')
+            print("Slot requires invalidation prior to write.")
             return status
         else:
             asym_key = TPAsymmetricKey()
             if public_key:
                 asym_key.set_public_key(public_key)
             else:
-                privkey_file = 'slot_{}_ecc_private_key'.format(slot) + '.pem'
+                privkey_file = "slot_{}_ecc_private_key".format(slot) + ".pem"
                 asym_key.get_private_pem(privkey_file)
 
             status = cal.atcab_write_pubkey(slot, asym_key.public_key_bytes)
             if status == cal.Status.ATCA_SUCCESS:
-                public_key_title = 'slot_{}_ecc_public_key'.format(slot)
+                public_key_title = "slot_{}_ecc_public_key".format(slot)
                 asym_key.get_public_c_hex(
-                                file='{}.h'.format(public_key_title),
-                                variable_name=public_key_title)
-                asym_key.get_public_pem('{}.pem'.format(public_key_title))
+                    file="{}.h".format(public_key_title), variable_name=public_key_title
+                )
+                asym_key.get_public_pem("{}.pem".format(public_key_title))
             return status
 
-    def load_secret_key(self, slot, secret_key=None, encryption_slot=None,
-                        encryption_key=None):
+    def load_secret_key(self, slot, secret_key=None, encryption_slot=None, encryption_key=None):
         """
         Method load a secret key into device and return it status
         Inputs:
               slot          slot number (secret key slot)
               secret_key    either .pem file or bytearray
                             which contains secret key in it
               encrypt_slot  slot number (encryption key slot)
@@ -123,34 +124,26 @@
         """
         sym_key = TPSymmetricKey(key=secret_key)
 
         if encryption_slot and encryption_key:
             sym_encryption_key = TPSymmetricKey(key=encryption_key)
 
             status = cal.atcab_write_enc(
-                slot,
-                0,
-                sym_key.key_bytes,
-                sym_encryption_key.key_bytes,
-                encryption_slot)
+                slot, 0, sym_key.key_bytes, sym_encryption_key.key_bytes, encryption_slot
+            )
         else:
             status = cal.atcab_write_bytes_zone(
-                Constants.ATCA_DATA_ZONE,
-                slot,
-                0,
-                sym_key.key_bytes,
-                len(sym_key.key_bytes))
+                Constants.ATCA_DATA_ZONE, slot, 0, sym_key.key_bytes, len(sym_key.key_bytes)
+            )
 
         if status == cal.Status.ATCA_SUCCESS:
-            slot_key_title = 'slot_{}_secret_key'.format(slot)
-            sym_key.get_c_hex(
-                        file='{}.h'.format(slot_key_title),
-                        variable_name=slot_key_title)
-            sym_key.get_pem('{}.pem'.format(slot_key_title))
+            slot_key_title = "slot_{}_secret_key".format(slot)
+            sym_key.get_c_hex(file="{}.h".format(slot_key_title), variable_name=slot_key_title)
+            sym_key.get_pem("{}.pem".format(slot_key_title))
 
         return status
 
 
 # Standard boilerplate to call the main() function to begin
 # the program.
-if __name__ == '__main__':
+if __name__ == "__main__":
     pass
```

## tpds/resource_generation/tflx_resource_generation.py

```diff
@@ -14,377 +14,407 @@
 # PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY
 # KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 
-import os
 import binascii
+import os
+from base64 import b16encode
+from dataclasses import dataclass
+from pathlib import Path
+
 import cryptoauthlib as cal
 from cryptography import x509
 from cryptography.hazmat.primitives import serialization
 from cryptography.hazmat.primitives.serialization import PublicFormat
-from base64 import b16encode
-from dataclasses import dataclass
-from pathlib import Path
-from tpds.tp_utils.tp_keys import TPAsymmetricKey
-from tpds.resource_generation import ResourceGeneration
-from tpds.pubkey_validation import DevicePubkeyValidation
+
 from tpds.certs.cert import Cert
+from tpds.certs.cert_utils import get_backend, get_cert_print_bytes, get_org_name
 from tpds.certs.certs_backup import CertsBackup
-from tpds.certs.cert_utils import get_org_name, get_cert_print_bytes, get_backend
 from tpds.certs.tflex_certs import TFLEXCerts
 from tpds.manifest.tflx_manifest import TFLXTLSManifest
+from tpds.pubkey_validation import DevicePubkeyValidation
+from tpds.resource_generation import ResourceGeneration
+from tpds.tp_utils.tp_keys import TPAsymmetricKey
 
 
 @dataclass(frozen=True)
-class TFLXSlotConfig():
+class TFLXSlotConfig:
     tflex_slot_config = {
         0: {
             "type": "private",
             "generate_resource": False,
-            "description": 'Permanent Private key, no generation is allowed'},
+            "description": "Permanent Private key, no generation is allowed",
+        },
         1: {
             "type": "private",
             "generate_resource": False,
-            "description": "Permanent Private key, no generation is allowed"},
+            "description": "Permanent Private key, no generation is allowed",
+        },
         2: {
             "type": "private",
             "generate_resource": True,
-            "description": "Private key and key is generated internally"},
+            "description": "Private key and key is generated internally",
+        },
         3: {
             "type": "private",
             "generate_resource": True,
-            "description": "Private key and key is generated internally"},
+            "description": "Private key and key is generated internally",
+        },
         4: {
             "type": "private",
             "generate_resource": True,
-            "description": "Private key and key is generated internally"},
+            "description": "Private key and key is generated internally",
+        },
         6: {
             "type": "secret",
             "generate_resource": True,
-            "description": "Secret key and key is generated and programmed"},
+            "description": "Secret key and key is generated and programmed",
+        },
         5: {
             "type": "secret",
             "generate_resource": True,
             "enc_key": int(6),
-            "description": "Secret key with writes using encrypted key"},
+            "description": "Secret key with writes using encrypted key",
+        },
         7: {
             "type": "secureboot digest",
             "generate_resource": False,
-            "description": "Secureboot digest and no key generation allowed"},
+            "description": "Secureboot digest and no key generation allowed",
+        },
         8: {
             "type": "reserved",
             "generate_resource": False,
-            "description": "Reserved and no key generation allowed"},
+            "description": "Reserved and no key generation allowed",
+        },
         9: {
             "type": "secret",
             "generate_resource": True,
-            "description": "Secret key and key is generated and programmed"},
+            "description": "Secret key and key is generated and programmed",
+        },
         10: {
             "type": "certificate",
             "generate_resource": False,
-            "description":
-                "Certificate slot and no key generation is allowed"},
+            "description": "Certificate slot and no key generation is allowed",
+        },
         11: {
             "type": "certificate",
             "generate_resource": False,
-            "description":
-                "Certificate slot and no key generation is allowed"},
+            "description": "Certificate slot and no key generation is allowed",
+        },
         12: {
             "type": "certificate",
             "generate_resource": False,
-            "description":
-                "Certificate slot and no key generation is allowed"},
+            "description": "Certificate slot and no key generation is allowed",
+        },
         13: {
             "type": "public",
             "generate_resource": True,
-            "description": "Public key and key is generated and programmed"},
+            "description": "Public key and key is generated and programmed",
+        },
         14: {
             "type": "public",
             "pubinvalid": True,
             "auth_key": 13,
             "generate_resource": True,
-            "description": "Public key and key is generated and programmed"},
+            "description": "Public key and key is generated and programmed",
+        },
         15: {
             "type": "public",
             "generate_resource": True,
-            "description": "Public key and key is generated and programmed"},
+            "description": "Public key and key is generated and programmed",
+        },
     }
 
 
 class TFLXResources(ResourceGeneration):
     """Class generates all the TrustFLEX resources.
 
     Args:
         ResourceGeneration: Base class.
     """
+
     def __init__(self):
         self.serial_number = bytearray()
-        assert cal.atcab_read_serial_number(
-            self.serial_number) == cal.Status.ATCA_SUCCESS, \
-            "Reading Serial number is failed"
+        assert (
+            cal.atcab_read_serial_number(self.serial_number) == cal.Status.ATCA_SUCCESS
+        ), "Reading Serial number is failed"
 
     def generate_all(self):
-        """Method to generate all the TrustFLEX resources.
-        """
-        for slot, tflex_slot_config \
-                in TFLXSlotConfig().tflex_slot_config.items():
-            if tflex_slot_config['generate_resource']:
-                if tflex_slot_config.get('type') == 'secret':
+        """Method to generate all the TrustFLEX resources."""
+        for slot, tflex_slot_config in TFLXSlotConfig().tflex_slot_config.items():
+            if tflex_slot_config["generate_resource"]:
+                if tflex_slot_config.get("type") == "secret":
                     # Check for encryption key if any
-                    enc_slot = tflex_slot_config.get('enc_key', None)
-                    enc_key = Path('slot_{}_secret_key.pem'.format(
-                        enc_slot)) if enc_slot else None
+                    enc_slot = tflex_slot_config.get("enc_key", None)
+                    enc_key = Path("slot_{}_secret_key.pem".format(enc_slot)) if enc_slot else None
 
                     # Get the file to retain
-                    secret_key = Path('slot_{}_secret_key.pem'.format(slot))
+                    secret_key = Path("slot_{}_secret_key.pem".format(slot))
 
-                    assert self.load_secret_key(
-                            slot, secret_key, enc_slot,
-                            enc_key) == cal.Status.ATCA_SUCCESS, \
-                        "Loading secret key into slot{} failed".format(slot)
-
-                elif tflex_slot_config.get('type') == 'private':
-                    assert self.generate_private_key(slot) \
-                        == cal.Status.ATCA_SUCCESS, \
-                        "Generating private key for slot{} failed".format(slot)
-
-                elif tflex_slot_config.get('type') == 'public':
-                    if 'pubinvalid' in tflex_slot_config:
-                        self.process_pubinvalid_slot(tflex_slot_config.get(
-                            'auth_key'), slot)
+                    assert (
+                        self.load_secret_key(slot, secret_key, enc_slot, enc_key)
+                        == cal.Status.ATCA_SUCCESS
+                    ), "Loading secret key into slot{} failed".format(slot)
+
+                elif tflex_slot_config.get("type") == "private":
+                    assert (
+                        self.generate_private_key(slot) == cal.Status.ATCA_SUCCESS
+                    ), "Generating private key for slot{} failed".format(slot)
+
+                elif tflex_slot_config.get("type") == "public":
+                    if "pubinvalid" in tflex_slot_config:
+                        self.process_pubinvalid_slot(tflex_slot_config.get("auth_key"), slot)
                     else:
                         # Get the file to retain
-                        public_key \
-                            = Path('slot_{}_ecc_public_key.pem'.format(slot))
+                        public_key = Path("slot_{}_ecc_public_key.pem".format(slot))
                         if not os.path.exists(public_key):
                             public_key = None
 
-                        assert self.load_public_key(
-                            slot, public_key) == cal.Status.ATCA_SUCCESS, \
-                            "Loading public key into slot{} failed"\
-                            .format(slot)
+                        assert (
+                            self.load_public_key(slot, public_key) == cal.Status.ATCA_SUCCESS
+                        ), "Loading public key into slot{} failed".format(slot)
 
-            print('Slot {}: {}'.format(slot, tflex_slot_config['description']))
+            print("Slot {}: {}".format(slot, tflex_slot_config["description"]))
 
     def process_pubinvalid_slot(self, auth_key_slot, pub_key_slot):
         """Method generates public key into corresponding slot.
 
         Args:
             auth_key_slot (int): Authority private key slot.
             pub_key_slot (int): Public key slot
         """
-        auth_key = Path('slot_{}_ecc_private_key.pem'.format(auth_key_slot))
+        auth_key = Path("slot_{}_ecc_private_key.pem".format(auth_key_slot))
         key_invalidation = DevicePubkeyValidation(auth_key_slot, pub_key_slot)
         if key_invalidation.is_pubkey_validated():
             # invalidate first if it is in validated state
             slot_pub_key = bytearray(64)
-            assert cal.atcab_read_pubkey(
-                pub_key_slot, slot_pub_key) == cal.Status.ATCA_SUCCESS, \
-                "Reading public key from slot {} failed".format(pub_key_slot)
+            assert (
+                cal.atcab_read_pubkey(pub_key_slot, slot_pub_key) == cal.Status.ATCA_SUCCESS
+            ), "Reading public key from slot {} failed".format(pub_key_slot)
             key_invalidation.pubkey_invalidate(auth_key, slot_pub_key)
 
         # Generate new rotating key pair
-        private_key = Path('slot_{}_ecc_private_key.pem'.format(pub_key_slot))
-        public_key = Path('slot_{}_ecc_public_key.pem'.format(pub_key_slot))
+        private_key = Path("slot_{}_ecc_private_key.pem".format(pub_key_slot))
+        public_key = Path("slot_{}_ecc_public_key.pem".format(pub_key_slot))
         asym_key = TPAsymmetricKey()
         asym_key.get_private_pem(private_key)
         asym_key.get_public_pem(public_key)
 
         # write key into slot
-        assert self.load_public_key(
-            pub_key_slot, public_key) == cal.Status.ATCA_SUCCESS, \
-            "Loading public key into slot{} failed".format(pub_key_slot)
+        assert (
+            self.load_public_key(pub_key_slot, public_key) == cal.Status.ATCA_SUCCESS
+        ), "Loading public key into slot{} failed".format(pub_key_slot)
 
         # Generate variables required for public key rotation embbeded project
         key_rotation = DevicePubkeyValidation(auth_key_slot, pub_key_slot)
-        pubkey_info_file = 'slot_{}_public_key_rotation.h'.format(pub_key_slot)
+        pubkey_info_file = "slot_{}_public_key_rotation.h".format(pub_key_slot)
         key_rotation.save_resources(auth_key, private_key, pubkey_info_file)
 
     def backup_mchp_certs(self, mchp_certs):
         """Check if the device contains MCHP certificates,
         and check if they are valid or not.
         """
         if mchp_certs is not None:
-            root = mchp_certs.get('root')
-            signer = mchp_certs.get('signer')
-            device = mchp_certs.get('device')
-
-            print('Verify cert chain...', end='')
-            is_chain_valid = \
-                root.is_signature_valid(
-                    root.certificate.public_key()) and \
-                signer.is_signature_valid(
-                    root.certificate.public_key()) and \
-                device.is_signature_valid(
-                    signer.certificate.public_key())
+            root = mchp_certs.get("root")
+            signer = mchp_certs.get("signer")
+            device = mchp_certs.get("device")
+
+            print("Verify cert chain...", end="")
+            is_chain_valid = (
+                root.is_signature_valid(root.certificate.public_key())
+                and signer.is_signature_valid(root.certificate.public_key())
+                and device.is_signature_valid(signer.certificate.public_key())
+            )
             if is_chain_valid:
-                print('Valid')
-                print('Device contain MCHP certificates')
-                print('Take MCHP certs backup...', end='')
+                print("Valid")
+                print("Device contain MCHP certificates")
+                print("Take MCHP certs backup...", end="")
                 backup_certs = CertsBackup()
                 backup_certs.store_to_file(mchp_certs, device_sn=self.serial_number)
-                print('OK')
+                print("OK")
             else:
-                print('Invalid')
+                print("Invalid")
         else:
-            print('Device doesn\'t contain MCHP certificates')
+            print("Device doesn't contain MCHP certificates")
 
     def restore_mchp_certs(self):
         """This method loads the root, signer and device certificates after checking,
         else shows an error in loading certificates.
         """
-        print('Restoring MCHP certificates...', end='')
+        print("Restoring MCHP certificates...", end="")
         mchp_certs = self.get_mchp_backup_certs()
         if mchp_certs:
             certs = TFLEXCerts()
             certs.set_tflex_certificates(
-                root_cert=mchp_certs.get('root'),
-                signer_cert=mchp_certs.get('signer'),
-                device_cert=mchp_certs.get('device'))
+                root_cert=mchp_certs.get("root"),
+                signer_cert=mchp_certs.get("signer"),
+                device_cert=mchp_certs.get("device"),
+            )
 
             # write signer and device cert into device
             template = certs.get_tflex_py_definitions()
-            assert cal.atcacert_write_cert(
-                    template.get('signer'),
+            assert (
+                cal.atcacert_write_cert(
+                    template.get("signer"),
                     certs.signer.get_certificate_in_der(),
-                    len(certs.signer.get_certificate_in_der())) \
-                == cal.Status.ATCA_SUCCESS, \
-                "Loading signer certificate into slot failed"
-            assert cal.atcacert_write_cert(
-                    template.get('device'),
+                    len(certs.signer.get_certificate_in_der()),
+                )
+                == cal.Status.ATCA_SUCCESS
+            ), "Loading signer certificate into slot failed"
+            assert (
+                cal.atcacert_write_cert(
+                    template.get("device"),
                     certs.device.get_certificate_in_der(),
-                    len(certs.device.get_certificate_in_der())) \
-                == cal.Status.ATCA_SUCCESS, \
-                "Loading device certificate into slot failed"
-            print('OK')
+                    len(certs.device.get_certificate_in_der()),
+                )
+                == cal.Status.ATCA_SUCCESS
+            ), "Loading device certificate into slot failed"
+            print("OK")
 
             # print the certificates
-            print(get_cert_print_bytes(
-                    certs.root.certificate.public_bytes(
-                        encoding=serialization.Encoding.PEM)))
-            print(get_cert_print_bytes(
-                    certs.signer.certificate.public_bytes(
-                        encoding=serialization.Encoding.PEM)))
-            print(get_cert_print_bytes(
-                    certs.device.certificate.public_bytes(
-                        encoding=serialization.Encoding.PEM)))
+            print(
+                get_cert_print_bytes(
+                    certs.root.certificate.public_bytes(encoding=serialization.Encoding.PEM)
+                )
+            )
+            print(
+                get_cert_print_bytes(
+                    certs.signer.certificate.public_bytes(encoding=serialization.Encoding.PEM)
+                )
+            )
+            print(
+                get_cert_print_bytes(
+                    certs.device.certificate.public_bytes(encoding=serialization.Encoding.PEM)
+                )
+            )
         else:
-            print('MCHP backup certs are not found')
+            print("MCHP backup certs are not found")
 
     def generate_custom_pki(self, org_name, prepend_sn=None):
         """Methos builds all the required certificates(i.e. root, signer, device).
 
         Args:
             org_name (str): Organization Namee
         """
         certs = TFLEXCerts()
-        root_crt_file = 'root_crt.crt'
-        root_key_file = 'root_key.key'
+        root_crt_file = "root_crt.crt"
+        root_key_file = "root_key.key"
         if os.path.exists(root_crt_file) and os.path.exists(root_key_file):
             root_crt = Cert()
             root_crt.set_certificate(root_crt_file)
             root_key = TPAsymmetricKey(root_key_file)
-            is_root_valid = root_crt.is_signature_valid(
-                root_key.get_public_key()) and get_org_name(
-                    root_crt.certificate.subject) == org_name
+            is_root_valid = (
+                root_crt.is_signature_valid(root_key.get_public_key())
+                and get_org_name(root_crt.certificate.subject) == org_name
+            )
         else:
             is_root_valid = False
 
         if is_root_valid:
             certs.set_tflex_certificates(root_cert=root_crt_file)
             certs.root.key.set_private_key(root_key_file)
         else:
             certs.build_root(org_name=org_name)
             certs.root.key.get_private_pem(root_key_file)
-            Path(root_crt_file).write_bytes(
-                certs.root.get_certificate_in_pem())
+            Path(root_crt_file).write_bytes(certs.root.get_certificate_in_pem())
 
-        signer_crt_file = 'signer_FFFF.crt'
-        signer_key_file = 'signer_FFFF.key'
-        if os.path.exists(signer_crt_file) \
-            and os.path.exists(signer_key_file) \
-                and is_root_valid:
+        signer_crt_file = "signer_FFFF.crt"
+        signer_key_file = "signer_FFFF.key"
+        if os.path.exists(signer_crt_file) and os.path.exists(signer_key_file) and is_root_valid:
             signer_crt = Cert()
             signer_crt.set_certificate(signer_crt_file)
             signer_key = TPAsymmetricKey(signer_key_file)
 
             crt_pubkey = signer_crt.certificate.public_key().public_bytes(
-                format=PublicFormat.SubjectPublicKeyInfo,
-                encoding=serialization.Encoding.DER)
-            signer_pubkey = signer_key.get_private_key().public_key(
-                ).public_bytes(
-                    format=PublicFormat.SubjectPublicKeyInfo,
-                    encoding=serialization.Encoding.DER)
-            is_signer_valid = (crt_pubkey == signer_pubkey) and \
-                (get_org_name(signer_crt.certificate.subject) ==
-                    get_org_name(root_crt.certificate.subject)) and \
-                (signer_crt.is_signature_valid(root_key.get_public_key()))
+                format=PublicFormat.SubjectPublicKeyInfo, encoding=serialization.Encoding.DER
+            )
+            signer_pubkey = (
+                signer_key.get_private_key()
+                .public_key()
+                .public_bytes(
+                    format=PublicFormat.SubjectPublicKeyInfo, encoding=serialization.Encoding.DER
+                )
+            )
+            is_signer_valid = (
+                (crt_pubkey == signer_pubkey)
+                and (
+                    get_org_name(signer_crt.certificate.subject)
+                    == get_org_name(root_crt.certificate.subject)
+                )
+                and (signer_crt.is_signature_valid(root_key.get_public_key()))
+            )
         else:
             is_signer_valid = False
 
         if is_signer_valid:
             certs.set_tflex_certificates(signer_cert=signer_crt_file)
             certs.signer.key.set_private_key(signer_key_file)
         else:
             certs.build_signer_csr(org_name=org_name)
             certs.build_signer()
             certs.signer.key.get_private_pem(signer_key_file)
-            Path(signer_crt_file).write_bytes(
-                certs.signer.get_certificate_in_pem())
+            Path(signer_crt_file).write_bytes(certs.signer.get_certificate_in_pem())
 
         # read serial number and device public key
         device_pubkey = bytearray()
-        assert cal.atcab_get_pubkey(0, device_pubkey) \
-            == cal.Status.ATCA_SUCCESS, \
-            "Reading device public key is failed"
-        device_crt_file = 'device_{}.crt'.format(
-            str(binascii.hexlify(self.serial_number), 'utf-8').upper())
+        assert (
+            cal.atcab_get_pubkey(0, device_pubkey) == cal.Status.ATCA_SUCCESS
+        ), "Reading device public key is failed"
+        device_crt_file = "device_{}.crt".format(
+            str(binascii.hexlify(self.serial_number), "utf-8").upper()
+        )
 
-        sn = ''
+        sn = ""
         if prepend_sn is not None:
-            sn = prepend_sn + '-' + b16encode(self.serial_number).decode('ascii')
+            sn = prepend_sn + "-" + b16encode(self.serial_number).decode("ascii")
         else:
             sn = self.serial_number
-        certs.build_device(
-            device_sn=sn,
-            device_public_key=device_pubkey,
-            org_name=org_name)
-        Path(device_crt_file).write_bytes(
-            certs.device.get_certificate_in_pem())
+        certs.build_device(device_sn=sn, device_public_key=device_pubkey, org_name=org_name)
+        Path(device_crt_file).write_bytes(certs.device.get_certificate_in_pem())
 
         # Validate and write the certificate chain
         if certs.is_certificate_chain_valid():
             crt_template = certs.get_tflex_py_definitions()
             certs.save_tflex_c_definitions()
-            assert cal.atcacert_write_cert(
-                        crt_template['signer'],
-                        certs.signer.get_certificate_in_der(),
-                        len(certs.signer.get_certificate_in_der())) \
-                == cal.Status.ATCA_SUCCESS, \
-                "Loading signer certificate into slot failed"
-            assert cal.atcacert_write_cert(
-                        crt_template['device'],
-                        certs.device.get_certificate_in_der(),
-                        len(certs.device.get_certificate_in_der())) \
-                == cal.Status.ATCA_SUCCESS, \
-                "Loading device certificate into slot failed"
+            assert (
+                cal.atcacert_write_cert(
+                    crt_template["signer"],
+                    certs.signer.get_certificate_in_der(),
+                    len(certs.signer.get_certificate_in_der()),
+                )
+                == cal.Status.ATCA_SUCCESS
+            ), "Loading signer certificate into slot failed"
+            assert (
+                cal.atcacert_write_cert(
+                    crt_template["device"],
+                    certs.device.get_certificate_in_der(),
+                    len(certs.device.get_certificate_in_der()),
+                )
+                == cal.Status.ATCA_SUCCESS
+            ), "Loading device certificate into slot failed"
 
             # print the certificates
-            print(get_cert_print_bytes(
-                    certs.root.certificate.public_bytes(
-                        encoding=serialization.Encoding.PEM)))
-            print(get_cert_print_bytes(
-                    certs.signer.certificate.public_bytes(
-                        encoding=serialization.Encoding.PEM)))
-            print(get_cert_print_bytes(
-                    certs.device.certificate.public_bytes(
-                        encoding=serialization.Encoding.PEM)))
+            print(
+                get_cert_print_bytes(
+                    certs.root.certificate.public_bytes(encoding=serialization.Encoding.PEM)
+                )
+            )
+            print(
+                get_cert_print_bytes(
+                    certs.signer.certificate.public_bytes(encoding=serialization.Encoding.PEM)
+                )
+            )
+            print(
+                get_cert_print_bytes(
+                    certs.device.certificate.public_bytes(encoding=serialization.Encoding.PEM)
+                )
+            )
 
     def get_mchp_backup_certs(self):
         """Method checks for the certificate files exists or not.
 
         Returns:
         """
         backup_certs = CertsBackup()
@@ -394,124 +424,117 @@
     def get_mchp_backup_file_names(self):
         """Method returns the certificates file names.
 
         Returns:
             dict: Dictionary containing the root, signer, device certificate
                   file names.
         """
-        root_crt_file = '{}_root.crt'.format(
-            str(binascii.hexlify(self.serial_number), 'utf-8').upper())
-        signer_crt_file = '{}_signer.crt'.format(
-            str(binascii.hexlify(self.serial_number), 'utf-8').upper())
-        device_crt_file = '{}_device.crt'.format(
-            str(binascii.hexlify(self.serial_number), 'utf-8').upper())
-
-        return {
-            'root': root_crt_file,
-            'signer': signer_crt_file,
-            'device': device_crt_file
-        }
+        root_crt_file = "{}_root.crt".format(
+            str(binascii.hexlify(self.serial_number), "utf-8").upper()
+        )
+        signer_crt_file = "{}_signer.crt".format(
+            str(binascii.hexlify(self.serial_number), "utf-8").upper()
+        )
+        device_crt_file = "{}_device.crt".format(
+            str(binascii.hexlify(self.serial_number), "utf-8").upper()
+        )
+
+        return {"root": root_crt_file, "signer": signer_crt_file, "device": device_crt_file}
 
     def get_mchp_certs_from_device(self):
         """
         Function check for MCHP certificate
         If found in device, take backup to system folder
         If found in system folder, restore certificate to device
 
         Inputs:
             restore     restore the MCHP certificate to device
         """
         try:
             root_cert_der_size = cal.AtcaReference(0)
-            assert cal.tng_atcacert_root_cert_size(
-                root_cert_der_size) == cal.Status.ATCA_SUCCESS
+            assert cal.tng_atcacert_root_cert_size(root_cert_der_size) == cal.Status.ATCA_SUCCESS
             root_cert_der = bytearray(root_cert_der_size.value)
-            assert cal.tng_atcacert_root_cert(
-                root_cert_der,
-                root_cert_der_size) == cal.Status.ATCA_SUCCESS
-            root_cert = x509.load_der_x509_certificate(bytes(root_cert_der),
-                                                       get_backend())
+            assert (
+                cal.tng_atcacert_root_cert(root_cert_der, root_cert_der_size)
+                == cal.Status.ATCA_SUCCESS
+            )
+            root_cert = x509.load_der_x509_certificate(bytes(root_cert_der), get_backend())
 
             signer_cert_der_size = cal.AtcaReference(0)
-            assert cal.tng_atcacert_max_signer_cert_size(
-                signer_cert_der_size) == cal.Status.ATCA_SUCCESS
+            assert (
+                cal.tng_atcacert_max_signer_cert_size(signer_cert_der_size)
+                == cal.Status.ATCA_SUCCESS
+            )
             signer_cert_der = bytearray(signer_cert_der_size.value)
-            assert cal.tng_atcacert_read_signer_cert(
-                signer_cert_der,
-                signer_cert_der_size) == cal.Status.ATCA_SUCCESS
-            signer_cert = x509.load_der_x509_certificate(bytes(signer_cert_der),
-                                                         get_backend())
+            assert (
+                cal.tng_atcacert_read_signer_cert(signer_cert_der, signer_cert_der_size)
+                == cal.Status.ATCA_SUCCESS
+            )
+            signer_cert = x509.load_der_x509_certificate(bytes(signer_cert_der), get_backend())
 
             device_cert_der_size = cal.AtcaReference(0)
-            assert cal.tng_atcacert_max_device_cert_size(
-                device_cert_der_size) == cal.Status.ATCA_SUCCESS
+            assert (
+                cal.tng_atcacert_max_device_cert_size(device_cert_der_size)
+                == cal.Status.ATCA_SUCCESS
+            )
             device_cert_der = bytearray(device_cert_der_size.value)
-            assert cal.tng_atcacert_read_device_cert(
-                device_cert_der,
-                device_cert_der_size) == cal.Status.ATCA_SUCCESS
-            device_cert = x509.load_der_x509_certificate(bytes(device_cert_der),
-                                                         get_backend())
+            assert (
+                cal.tng_atcacert_read_device_cert(device_cert_der, device_cert_der_size)
+                == cal.Status.ATCA_SUCCESS
+            )
+            device_cert = x509.load_der_x509_certificate(bytes(device_cert_der), get_backend())
 
             root = Cert()
             signer = Cert()
             device = Cert()
             root.set_certificate(root_cert)
             signer.set_certificate(signer_cert)
             device.set_certificate(device_cert)
 
-            return {
-                'root': root,
-                'signer': signer,
-                'device': device
-            }
+            return {"root": root, "signer": signer, "device": device}
 
         except Exception as err:
             print(err)
             return None
 
-    def generate_manifest(self, signer_cert, device_cert, file=''):
+    def generate_manifest(self, signer_cert, device_cert, file=""):
         """
         Method encode the trustflex manifest data and generate
         securesigned element by signing manifest data and
         store it in manifest file
 
         Args:
             signer_cert (str): path to signer certificate
             device_cert (str): path to device certificate
             file (str): manifest JSON filename
         """
         if not signer_cert and not device_cert:
-            raise ValueError(
-                    'Signer and device certificate is req to gen manifest')
+            raise ValueError("Signer and device certificate is req to gen manifest")
 
         signer = Cert()
         device = Cert()
         signer.set_certificate(signer_cert)
         device.set_certificate(device_cert)
 
         if not file:
-            file = 'TFLXTLS_devices_manifest.json'
+            file = "TFLXTLS_devices_manifest.json"
 
-        manifest_ca_key = 'manifest_ca.key'
-        manifest_ca_cert = 'manifest_ca.crt'
+        manifest_ca_key = "manifest_ca.key"
+        manifest_ca_cert = "manifest_ca.crt"
 
         manifest = TFLXTLSManifest()
         manifest.load_manifest_uniqueid_and_keys()
-        manifest.set_provisioning_time(
-                        device.certificate.not_valid_before)
-        manifest.set_certs(signer.certificate,
-                           device.certificate,
-                           kid='0')
-        if os.path.exists(manifest_ca_cert) \
-           and os.path.exists(manifest_ca_key):
-            signed_se = manifest.encode_manifest(manifest_ca_key,
-                                                 manifest_ca_cert)
+        manifest.set_provisioning_time(device.certificate.not_valid_before)
+        manifest.set_certs(signer.certificate, device.certificate, kid="0")
+        if os.path.exists(manifest_ca_cert) and os.path.exists(manifest_ca_key):
+            signed_se = manifest.encode_manifest(manifest_ca_key, manifest_ca_cert)
         else:
             signed_se = manifest.encode_manifest()
-        manifest.write_signed_se_into_file(signed_se.get('signed_se'),
-                                           file)
+        manifest.write_signed_se_into_file(signed_se.get("signed_se"), file)
+
 
+__all__ = ["TFLXSlotConfig", "TFLXResources"]
 
 # Standard boilerplate to call the main() function to begin
 # the program.
-if __name__ == '__main__':
+if __name__ == "__main__":
     pass
```

## tpds/resource_generation/tng_manifest_generation.py

```diff
@@ -15,114 +15,110 @@
 # KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 
 import os
+
 import cryptoauthlib as cal
 from cryptography import x509
-from tpds.certs.cert_utils import get_backend
+
 from tpds.certs.cert import Cert
+from tpds.certs.cert_utils import get_backend
 from tpds.manifest.tng_manifest import TNGTLSManifest
 
 
-class TNGManifest():
+class TNGManifest:
     def __init__(self):
         pass
 
-    def generate_manifest(self, file=''):
+    def generate_manifest(self, file=""):
         """
         Method encode the trustngo manifest data and generate
         securesigned element by signing manifest data and
         store it in manifest file
 
         Args:
             file (str): manifest JSON filename
         """
         tng_cert = self.__get_tng_certs_from_device()
         if not tng_cert:
-            raise ValueError(
-                    'Device doesn\'t contain correct certificates!!')
+            raise ValueError("Device doesn't contain correct certificates!!")
 
         if not file:
-            file = 'TNGTLS_devices_manifest.json'
+            file = "TNGTLS_devices_manifest.json"
 
-        manifest_ca_key = 'manifest_ca.key'
-        manifest_ca_cert = 'manifest_ca.crt'
+        manifest_ca_key = "manifest_ca.key"
+        manifest_ca_cert = "manifest_ca.crt"
 
         manifest = TNGTLSManifest()
         manifest.load_manifest_uniqueid_and_keys()
-        manifest.set_provisioning_time(
-                        tng_cert.get('device').certificate.not_valid_before)
-        manifest.set_certs(tng_cert.get('signer').certificate,
-                           tng_cert.get('device').certificate,
-                           kid='0')
-        if os.path.exists(manifest_ca_cert) \
-           and os.path.exists(manifest_ca_key):
-            signed_se = manifest.encode_manifest(manifest_ca_key,
-                                                 manifest_ca_cert)
+        manifest.set_provisioning_time(tng_cert.get("device").certificate.not_valid_before)
+        manifest.set_certs(
+            tng_cert.get("signer").certificate, tng_cert.get("device").certificate, kid="0"
+        )
+        if os.path.exists(manifest_ca_cert) and os.path.exists(manifest_ca_key):
+            signed_se = manifest.encode_manifest(manifest_ca_key, manifest_ca_cert)
         else:
             signed_se = manifest.encode_manifest()
-        manifest.write_signed_se_into_file(signed_se.get('signed_se'),
-                                           file)
+        manifest.write_signed_se_into_file(signed_se.get("signed_se"), file)
 
     def __get_tng_certs_from_device(self):
         """
         Function check for certificate present in device
 
         Return:
             return certificate read from device
         """
         try:
             root_cert_der_size = cal.AtcaReference(0)
-            assert cal.tng_atcacert_root_cert_size(
-                root_cert_der_size) == cal.Status.ATCA_SUCCESS
+            assert cal.tng_atcacert_root_cert_size(root_cert_der_size) == cal.Status.ATCA_SUCCESS
             root_cert_der = bytearray(root_cert_der_size.value)
-            assert cal.tng_atcacert_root_cert(
-                root_cert_der,
-                root_cert_der_size) == cal.Status.ATCA_SUCCESS
-            root_cert = x509.load_der_x509_certificate(bytes(root_cert_der),
-                                                       get_backend())
+            assert (
+                cal.tng_atcacert_root_cert(root_cert_der, root_cert_der_size)
+                == cal.Status.ATCA_SUCCESS
+            )
+            root_cert = x509.load_der_x509_certificate(bytes(root_cert_der), get_backend())
 
             signer_cert_der_size = cal.AtcaReference(0)
-            assert cal.tng_atcacert_max_signer_cert_size(
-                signer_cert_der_size) == cal.Status.ATCA_SUCCESS
+            assert (
+                cal.tng_atcacert_max_signer_cert_size(signer_cert_der_size)
+                == cal.Status.ATCA_SUCCESS
+            )
             signer_cert_der = bytearray(signer_cert_der_size.value)
-            assert cal.tng_atcacert_read_signer_cert(
-                signer_cert_der,
-                signer_cert_der_size) == cal.Status.ATCA_SUCCESS
-            signer_cert = x509.load_der_x509_certificate(bytes(signer_cert_der),
-                                                         get_backend())
+            assert (
+                cal.tng_atcacert_read_signer_cert(signer_cert_der, signer_cert_der_size)
+                == cal.Status.ATCA_SUCCESS
+            )
+            signer_cert = x509.load_der_x509_certificate(bytes(signer_cert_der), get_backend())
 
             device_cert_der_size = cal.AtcaReference(0)
-            assert cal.tng_atcacert_max_device_cert_size(
-                device_cert_der_size) == cal.Status.ATCA_SUCCESS
+            assert (
+                cal.tng_atcacert_max_device_cert_size(device_cert_der_size)
+                == cal.Status.ATCA_SUCCESS
+            )
             device_cert_der = bytearray(device_cert_der_size.value)
-            assert cal.tng_atcacert_read_device_cert(
-                device_cert_der,
-                device_cert_der_size) == cal.Status.ATCA_SUCCESS
-            device_cert = x509.load_der_x509_certificate(bytes(device_cert_der),
-                                                         get_backend())
+            assert (
+                cal.tng_atcacert_read_device_cert(device_cert_der, device_cert_der_size)
+                == cal.Status.ATCA_SUCCESS
+            )
+            device_cert = x509.load_der_x509_certificate(bytes(device_cert_der), get_backend())
 
             root = Cert()
             signer = Cert()
             device = Cert()
             root.set_certificate(root_cert)
             signer.set_certificate(signer_cert)
             device.set_certificate(device_cert)
 
-            return {
-                'root': root,
-                'signer': signer,
-                'device': device
-            }
+            return {"root": root, "signer": signer, "device": device}
 
         except Exception as err:
             print(err)
             return None
 
 
 # Standard boilerplate to call the main() function to begin
 # the program.
-if __name__ == '__main__':
+if __name__ == "__main__":
     pass
```

## tpds/secure_element/__init__.py

```diff
@@ -1,11 +1,27 @@
 """
     Trust Platform core package - secure_element module
 """
-from .ca_element import *
-from .constants import *
-from .ecc608a import *
-from .sha204a import *
-from .sha206a import *
-from .ta_element import *
-from .ecc204 import *
-from .ta010 import *
+from .ca_element import CAElement
+from .constants import Constants
+from .ecc204 import ECC204
+from .ecc608a import ECC608A, ECC608B
+from .sha10x import SHA104, SHA106, SHA105
+from .sha204a import SHA204A
+from .sha206a import SHA206A
+from .ta010 import TA010
+from .ta_element import TAElement
+
+__all__ = [
+    "CAElement",
+    "Constants",
+    "ECC204",
+    "ECC608A",
+    "ECC608B",
+    "SHA104",
+    "SHA106",
+    "SHA105",
+    "SHA204A",
+    "SHA206A",
+    "TA010",
+    "TAElement",
+]
```

## tpds/secure_element/ca_element.py

```diff
@@ -15,142 +15,137 @@
 # KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 
 import os
+
 import cryptoauthlib as cal
-from .constants import Constants
 from cryptography.hazmat.primitives.asymmetric import ec
-from tpds.certs.cert_utils import get_device_public_key, get_backend
 
+from tpds.certs.cert_utils import get_backend, get_device_public_key
 from tpds.flash_program import FlashProgram
 from tpds.tp_utils.tp_settings import TPSettings
 
+from .constants import Constants
+
 
-class CAElement():
+class CAElement:
     def __init__(self):
         pass
 
     def connect(self, cfg):
-
-        assert cal.atcab_init(cfg) \
-            == cal.Status.ATCA_SUCCESS, 'Can\'t connect to device'
+        assert cal.atcab_init(cfg) == cal.Status.ATCA_SUCCESS, "Can't connect to device"
 
     def get_device_revision(self):
-        '''
+        """
         Returns device revision from connected device
-        '''
+        """
         revision = bytearray(4)
-        assert cal.atcab_info(revision) \
-            == cal.Status.ATCA_SUCCESS, 'Reading Revision failed'
+        assert cal.atcab_info(revision) == cal.Status.ATCA_SUCCESS, "Reading Revision failed"
         return revision
 
     def get_device_serial_number(self):
-        '''
+        """
         Returns device serial number from connected device
-        '''
+        """
         serial_num = bytearray(9)
-        assert cal.atcab_read_serial_number(serial_num) \
-            == cal.Status.ATCA_SUCCESS, 'Reading Serial Number'
+        assert (
+            cal.atcab_read_serial_number(serial_num) == cal.Status.ATCA_SUCCESS
+        ), "Reading Serial Number"
         return serial_num
-    
+
     def get_monotonic_counter_value(self, counter_id):
         counter_value = cal.AtcaReference(0)
-        assert cal.atcab_counter_read(counter_id, counter_value) == cal.Status.ATCA_SUCCESS, \
-            f'failed to read the Monotonic counter value'
-        return counter_value 
+        assert (
+            cal.atcab_counter_read(counter_id, counter_value) == cal.Status.ATCA_SUCCESS
+        ), "failed to read the Monotonic counter value"
+        return counter_value
 
     def is_config_zone_locked(self):
         is_locked = cal.AtcaReference(False)
-        assert cal.atcab_is_locked(Constants.LOCK_ZONE_CONFIG, is_locked) \
-            == cal.Status.ATCA_SUCCESS, 'Reading lock status failed'
+        assert (
+            cal.atcab_is_locked(Constants.LOCK_ZONE_CONFIG, is_locked) == cal.Status.ATCA_SUCCESS
+        ), "Reading lock status failed"
         return bool(is_locked.value)
 
     def is_data_zone_locked(self):
         is_locked = cal.AtcaReference(False)
-        assert cal.atcab_is_locked(Constants.LOCK_ZONE_DATA, is_locked) \
-            == cal.Status.ATCA_SUCCESS, 'Reading lock status failed'
+        assert (
+            cal.atcab_is_locked(Constants.LOCK_ZONE_DATA, is_locked) == cal.Status.ATCA_SUCCESS
+        ), "Reading lock status failed"
         return bool(is_locked.value)
 
     def load_config_zone(self, config_data):
-        '''
+        """
         Loads configuration data to config zone
-        '''
-        assert self.is_config_zone_locked() == False, \
-            'Device config zone is already locked.'
+        """
+        assert self.is_config_zone_locked() is False, "Device config zone is already locked."
 
         # Write configuration
-        assert cal.atcab_write_bytes_zone(
-            Constants.ATCA_CONFIG_ZONE,
-            0,
-            16,
-            config_data,
-            len(config_data)) \
-            == cal.Status.ATCA_SUCCESS, 'Writing Config zone failed'
+        assert (
+            cal.atcab_write_bytes_zone(
+                Constants.ATCA_CONFIG_ZONE, 0, 16, config_data, len(config_data)
+            )
+            == cal.Status.ATCA_SUCCESS
+        ), "Writing Config zone failed"
 
         # Verify Config Zone
         config_qa = bytearray(len(config_data))
-        assert cal.atcab_read_bytes_zone(
-            Constants.ATCA_CONFIG_ZONE,
-            0,
-            16,
-            config_qa,
-            len(config_qa)) \
-            == cal.Status.ATCA_SUCCESS, 'Reading Config zone failed'
-
-        assert config_data \
-            == config_qa, 'Configuration read does not match'
-    
-    def connect_to_SE(self,boards):
-        print('Connecting to Secure Element: ')
-        assert boards, 'Prototyping board MUST be selected!'
-        assert boards.get_selected_board(), 'Select board to run an Usecase'
+        assert (
+            cal.atcab_read_bytes_zone(Constants.ATCA_CONFIG_ZONE, 0, 16, config_qa, len(config_qa))
+            == cal.Status.ATCA_SUCCESS
+        ), "Reading Config zone failed"
+
+        assert config_data == config_qa, "Configuration read does not match"
+
+    def connect_to_SE(self, boards):
+        print("Connecting to Secure Element: ")
+        assert boards, "Prototyping board MUST be selected!"
+        assert boards.get_selected_board(), "Select board to run an Usecase"
 
         kit_parser = FlashProgram()
         print(kit_parser.check_board_status())
-        assert kit_parser.is_board_connected(), 'Check the Kit parser board connections'
+        assert kit_parser.is_board_connected(), "Check the Kit parser board connections"
         factory_hex = boards.get_kit_hex()
 
         if not kit_parser.is_factory_programmed():
-            assert factory_hex, 'Factory hex is unavailable to program'
-            print('Programming factory hex...')
+            assert factory_hex, "Factory hex is unavailable to program"
+            print("Programming factory hex...")
             tp_settings = TPSettings()
             path = os.path.join(
-                tp_settings.get_tpds_core_path(),
-                'assets', 'Factory_Program.X',
-                factory_hex)
-            print(f'Programming {path} file')
+                tp_settings.get_tpds_core_path(), "assets", "Factory_Program.X", factory_hex
+            )
+            print(f"Programming {path} file")
             kit_parser.load_hex_image(path)
 
-        print('OK')
+        print("OK")
 
     def get_device_details(self):
-        '''
+        """
         Returns device basic information like Revision, Serial No,
         Config status etc..,
-        '''
+        """
         device_info = dict()
-        device_info['revision'] = self.get_device_revision().hex()
-        device_info['serial_number'] \
-            = self.get_device_serial_number().hex().upper()
-        device_info['lock_status'] \
-            = [self.is_config_zone_locked(), self.is_data_zone_locked()]
+        device_info["revision"] = self.get_device_revision().hex()
+        device_info["serial_number"] = self.get_device_serial_number().hex().upper()
+        device_info["lock_status"] = [self.is_config_zone_locked(), self.is_data_zone_locked()]
 
         return device_info
 
     def read_device_public_key(self, slot):
         device_pubkey = bytearray(64)
-        assert cal.atcab_get_pubkey(slot, device_pubkey) \
-            == cal.Status.ATCA_SUCCESS, 'Reading Public key is failed'
+        assert (
+            cal.atcab_get_pubkey(slot, device_pubkey) == cal.Status.ATCA_SUCCESS
+        ), "Reading Public key is failed"
         device_pubkey = get_device_public_key(device_pubkey)
         device_pubkey = ec.EllipticCurvePublicNumbers(
-                                x=int(device_pubkey[:64], 16),
-                                y=int(device_pubkey[64:], 16),
-                                curve=ec.SECP256R1()).public_key(get_backend())
+            x=int(device_pubkey[:64], 16), y=int(device_pubkey[64:], 16), curve=ec.SECP256R1()
+        ).public_key(get_backend())
         return device_pubkey
 
+
 # Standard boilerplate to call the main() function to begin
 # the program.
-if __name__ == '__main__':
+if __name__ == "__main__":
     pass
```

## tpds/secure_element/constants.py

```diff
@@ -15,15 +15,15 @@
 # KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 
 
-class Constants():
+class Constants:
     # List all Secure Element constants here
     ATCA_CONFIG_ZONE = 0x00
     ATCA_ZONE_OTP = 0x01
     ATCA_DATA_ZONE = 0x02
 
     LOCK_ZONE_CONFIG = 0x00
     LOCK_ZONE_DATA = 0x01
@@ -39,12 +39,11 @@
     # List all SHA206A constants here
 
     # List all ECC204A constants here
     ATCA_ECC204_ZONE_DATA = 0x00
     ATCA_ECC204_ZONE_CONFIG = 0x01
 
 
-
 # Standard boilerplate to call the main() function to begin
 # the program.
-if __name__ == '__main__':
+if __name__ == "__main__":
     pass
```

## tpds/secure_element/ecc204.py

```diff
@@ -15,109 +15,125 @@
 # KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 
 import struct
+from ctypes import byref, c_uint8, c_void_p, cast
+
 import cryptoauthlib as cal
+
 from .ca_element import CAElement
 from .constants import Constants
-from ctypes import cast, c_void_p, c_uint8, byref
 
 
 class ECC204(CAElement):
-    def __init__(self, interface='i2c', address=0x33):
+    def __init__(self, interface="i2c", address=0x33):
         self.cfg = cal.cfg_ateccx08a_kithid_default()
-        if interface == 'i2c':
-            self.cfg.cfg.atcahid.dev_interface \
-                = int(cal.ATCAKitType.ATCA_KIT_I2C_IFACE)
+        if interface == "i2c":
+            self.cfg.cfg.atcahid.dev_interface = int(cal.ATCAKitType.ATCA_KIT_I2C_IFACE)
             self.cfg.cfg.atcahid.dev_identity = address
         else:
-            self.cfg.cfg.atcahid.dev_interface \
-                = int(cal.ATCAKitType.ATCA_KIT_SWI_IFACE)
+            self.cfg.cfg.atcahid.dev_interface = int(cal.ATCAKitType.ATCA_KIT_SWI_IFACE)
             self.cfg.cfg.atcahid.dev_identity = address
 
-        self.cfg.devtype = cal.get_device_type_id('ECC204')
+        self.cfg.devtype = cal.get_device_type_id("ECC204")
 
         super().connect(self.cfg)
 
     def is_config_slot_locked(self, slot_number):
         _device = cast(cal.atcab_get_device(), c_void_p)
         is_locked = c_uint8()
-        assert cal.get_cryptoauthlib().calib_info_lock_status(
-            _device, (slot_number << 1) | Constants.ATCA_ECC204_ZONE_CONFIG,
-            byref(is_locked)) == cal.Status.ATCA_SUCCESS, \
-            'Reading Config Slot lock status is failed'
+        assert (
+            cal.get_cryptoauthlib().calib_info_lock_status(
+                _device, (slot_number << 1) | Constants.ATCA_ECC204_ZONE_CONFIG, byref(is_locked)
+            )
+            == cal.Status.ATCA_SUCCESS
+        ), "Reading Config Slot lock status is failed"
         return is_locked.value == 1
 
     def is_data_slot_locked(self, slot_number):
         _device = cast(cal.atcab_get_device(), c_void_p)
         is_locked = c_uint8()
-        assert cal.get_cryptoauthlib().calib_info_lock_status(
-            _device, (slot_number << 1) | Constants.ATCA_ECC204_ZONE_DATA,
-            byref(is_locked)) == cal.Status.ATCA_SUCCESS, \
-            'Reading Data Slot lock status is failed'
+        assert (
+            cal.get_cryptoauthlib().calib_info_lock_status(
+                _device, (slot_number << 1) | Constants.ATCA_ECC204_ZONE_DATA, byref(is_locked)
+            )
+            == cal.Status.ATCA_SUCCESS
+        ), "Reading Data Slot lock status is failed"
         return is_locked.value == 1
 
     def load_config_zone(self, config_data):
-        '''
+        """
         Loads configuration data to config zone
-        '''
-        assert self.is_config_zone_locked() is False, \
-            'Device config zone is already locked.'
+        """
+        assert self.is_config_zone_locked() is False, "Device config zone is already locked."
 
         # Write configuration
-        assert cal.atcab_write_config_zone(config_data) \
-            == cal.Status.ATCA_SUCCESS, 'Writing Config zone failed'
+        assert (
+            cal.atcab_write_config_zone(config_data) == cal.Status.ATCA_SUCCESS
+        ), "Writing Config zone failed"
 
         # Verify Config Zone
         config_qa = bytearray(len(config_data))
-        assert cal.atcab_read_config_zone(config_qa) \
-            == cal.Status.ATCA_SUCCESS, 'Reading Config zone failed'
+        assert (
+            cal.atcab_read_config_zone(config_qa) == cal.Status.ATCA_SUCCESS
+        ), "Reading Config zone failed"
 
-        assert config_data == config_qa, 'Configuration read does not match'
+        assert config_data == config_qa, "Configuration read does not match"
 
     def load_tflx_test_config(self, test_config):
-        assert len(test_config) == 64, 'Test Config is not of 64 bytes in size.'
+        assert len(test_config) == 64, "Test Config is not of 64 bytes in size."
         for subzone in [1, 2, 3]:
             if self.is_config_slot_locked(subzone) is False:
-                assert cal.get_cryptoauthlib().atcab_write_zone(
-                    Constants.ATCA_CONFIG_ZONE, subzone, 0, 0,
-                    test_config[(subzone * 16):((subzone + 1) * 16)], 16) == cal.Status.ATCA_SUCCESS, \
-                    f'Config Subzone{subzone} write is failed'
-        assert cal.atcab_lock_config_zone() == cal.Status.ATCA_SUCCESS, \
-            'Config zone lock has failed'
+                assert (
+                    cal.get_cryptoauthlib().atcab_write_zone(
+                        Constants.ATCA_CONFIG_ZONE,
+                        subzone,
+                        0,
+                        0,
+                        test_config[(subzone * 16) : ((subzone + 1) * 16)],
+                        16,
+                    )
+                    == cal.Status.ATCA_SUCCESS
+                ), f"Config Subzone{subzone} write is failed"
+        assert (
+            cal.atcab_lock_config_zone() == cal.Status.ATCA_SUCCESS
+        ), "Config zone lock has failed"
 
         if self.is_data_slot_locked(0) is False:
             public_key = bytearray(64)
-            assert cal.atcab_genkey(0, public_key) == cal.Status.ATCA_SUCCESS, \
-                'Slot0 key generation is failed'
-            assert cal.get_cryptoauthlib().atcab_lock_data_slot(0) == \
-                cal.Status.ATCA_SUCCESS, 'Data zone Slot0 lock is failed'
+            assert (
+                cal.atcab_genkey(0, public_key) == cal.Status.ATCA_SUCCESS
+            ), "Slot0 key generation is failed"
+            assert (
+                cal.get_cryptoauthlib().atcab_lock_data_slot(0) == cal.Status.ATCA_SUCCESS
+            ), "Data zone Slot0 lock is failed"
 
     def get_device_details(self):
-        '''
+        """
         Returns device basic information like Revision, Serial No,
         Config status etc..,
-        '''
+        """
         device_info = dict()
-        device_info['revision'] = self.get_device_revision().hex()
-        device_info['serial_number'] = self.get_device_serial_number().hex().upper()
-        device_info['lock_status'] = [
+        device_info["revision"] = self.get_device_revision().hex()
+        device_info["serial_number"] = self.get_device_serial_number().hex().upper()
+        device_info["lock_status"] = [
             tuple(self.is_config_slot_locked(i) for i in range(0, 4)),
-            tuple(self.is_data_slot_locked(i) for i in range(0, 4))]
+            tuple(self.is_data_slot_locked(i) for i in range(0, 4)),
+        ]
 
         return device_info
 
     def int_to_binary_linear(self, value):
-        '''
+        """
         convert decimal value into monotonic counter value
-        '''
-        l1 = list(struct.pack('>q', 0xffffffffffff >> (value % 96)))[2:]
-        b1 = list(struct.pack('>H', value // 96))
-        l2, b2 = [0xff, 0xff, 0xff, 0xff, 0xff, 0xff], [0x00, 0x00]
+        """
+        l1 = list(struct.pack(">q", 0xFFFFFFFFFFFF >> (value % 96)))[2:]
+        b1 = list(struct.pack(">H", value // 96))
+        l2, b2 = [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF], [0x00, 0x00]
         if value > 48:
-            l2 = list(struct.pack('>q', 0xffffffffffff >> ((value - 48) % 96)))[2:]
-            b2 = list(struct.pack('>H', (value - 48) // 96))
+            l2 = list(struct.pack(">q", 0xFFFFFFFFFFFF >> ((value - 48) % 96)))[2:]
+            b2 = list(struct.pack(">H", (value - 48) // 96))
         value = b1 + b2 + l1 + l2
         return value
```

## tpds/secure_element/ecc608a.py

```diff
@@ -17,147 +17,138 @@
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 
 import ctypes
 import struct
 from hashlib import sha256
+
 import cryptoauthlib as cal
+
 from .ca_element import CAElement
 from .constants import Constants
 
 
 class ECC608A(CAElement):
-    def __init__(self, interface='i2c', address=0xC0):
+    def __init__(self, interface="i2c", address=0xC0):
         self.cfg = cal.cfg_ateccx08a_kithid_default()
-        if interface == 'i2c':
-            self.cfg.cfg.atcahid.dev_interface \
-                = int(cal.ATCAKitType.ATCA_KIT_I2C_IFACE)
+        if interface == "i2c":
+            self.cfg.cfg.atcahid.dev_interface = int(cal.ATCAKitType.ATCA_KIT_I2C_IFACE)
             self.cfg.cfg.atcahid.dev_identity = address
         else:
-            self.cfg.cfg.atcahid.dev_interface \
-                = int(cal.ATCAKitType.ATCA_KIT_SWI_IFACE)
+            self.cfg.cfg.atcahid.dev_interface = int(cal.ATCAKitType.ATCA_KIT_SWI_IFACE)
             self.cfg.cfg.atcahid.dev_identity = 0
 
-        self.cfg.devtype = cal.get_device_type_id('ATECC608A')
+        self.cfg.devtype = cal.get_device_type_id("ATECC608A")
 
         super().connect(self.cfg)
 
-    def host_calc_mac_resp(self, symm_key, challenge, mode=0x41,
-                           slot=5):
-        '''
+    def host_calc_mac_resp(self, symm_key, challenge, mode=0x41, slot=5):
+        """
         Calculates mac on the host...
-        '''
+        """
         if not isinstance(symm_key, (bytearray, bytes)):
-            raise ValueError('Unknown symmetric key format!')
+            raise ValueError("Unknown symmetric key format!")
         if not isinstance(challenge, (bytearray, bytes)):
-            raise ValueError('Unknown tempkey or challenge format!')
+            raise ValueError("Unknown tempkey or challenge format!")
 
         ser_num = self.get_device_serial_number()
 
         is_sn_include = False
         if mode & 0x40:
             is_sn_include = True
 
-        response = b''
+        response = b""
         response += symm_key[0:32]
         response += challenge[0:32]
         response += struct.pack("B", Constants.ATCA_ECC608_MAC_OPCODE)
         response += struct.pack("B", mode)
-        response += struct.pack('<H', slot)
-        response += b'\x00'*11
+        response += struct.pack("<H", slot)
+        response += b"\x00" * 11
         response += ser_num[8:9]
-        response += ser_num[4:8] if is_sn_include else b'\x00'*4
+        response += ser_num[4:8] if is_sn_include else b"\x00" * 4
         response += ser_num[0:2]
-        response += ser_num[2:4] if is_sn_include else b'\x00'*2
+        response += ser_num[2:4] if is_sn_include else b"\x00" * 2
 
         response = sha256(response).digest()
 
-        return {
-            'challenge': challenge,
-            'response': response
-        }
+        return {"challenge": challenge, "response": response}
 
     def host_calc_nonce(self, num_in, rand_out, mode=0x00):
         """
         Calculate Host nonce
         """
         if not isinstance(num_in, (bytearray, bytes)):
-            raise ValueError('Unknown NumIn format!')
+            raise ValueError("Unknown NumIn format!")
         if not isinstance(rand_out, (bytearray, bytes)):
-            raise ValueError('Unknown Random number format!')
+            raise ValueError("Unknown Random number format!")
 
-        nonce = b''
+        nonce = b""
         nonce += rand_out[0:32]
         nonce += num_in[0:20]
         nonce += struct.pack("B", Constants.ATCA_ECC608_NONCE_OPCODE)
         nonce += struct.pack("B", mode)
-        nonce += b'\x00'
+        nonce += b"\x00"
 
         nonce = sha256(nonce).digest()
 
         return {
-            'num_in': num_in,
-            'rand_out': rand_out,
-            'nonce': nonce,
+            "num_in": num_in,
+            "rand_out": rand_out,
+            "nonce": nonce,
         }
 
     def get_device_mac_response(self, slot=5, challenge=0, mode=0x41):
-        '''
+        """
         Calculates mac on the device...
-        '''
+        """
         if not mode & 0x01:
             if challenge == 0:
-                raise ValueError('For given mode challenge is required!')
+                raise ValueError("For given mode challenge is required!")
 
         response = bytearray(32)
-        assert cal.atcab_mac(
-            mode,
-            slot,
-            challenge,
-            response) \
-            == cal.Status.ATCA_SUCCESS, "MAC Response generation failed"
+        assert (
+            cal.atcab_mac(mode, slot, challenge, response) == cal.Status.ATCA_SUCCESS
+        ), "MAC Response generation failed"
 
         return response
 
     def get_device_random_nonce(self, num_in):
-        '''
+        """
         Get random number from device for given num_in
-        '''
+        """
         rand_out = bytearray(32)
-        assert cal.atcab_nonce_rand(
-            num_in,
-            rand_out) \
-            == cal.Status.ATCA_SUCCESS, "Nonce generation failed"
+        assert (
+            cal.atcab_nonce_rand(num_in, rand_out) == cal.Status.ATCA_SUCCESS
+        ), "Nonce generation failed"
 
-        return {
-            'num_in': num_in,
-            'rand_out': rand_out
-        }
+        return {"num_in": num_in, "rand_out": rand_out}
 
 
 class ECC608B(CAElement):
-   def __init__(self, address, port):
+    def __init__(self, address, port):
         self.cfg = cal.ATCAIfaceCfg()
         self.cfg.iface_type = int(cal.ATCAIfaceType.ATCA_UART_IFACE)
         self.cfg.devtype = int(cal.ATCADeviceType.ATECC608B)
         self.cfg.wake_delay = 1500
         self.cfg.rx_retries = 10
 
         self.cfg.cfg.atcauart.dev_interface = int(cal.ATCAKitType.ATCA_KIT_I2C_IFACE)
         self.cfg.cfg.atcauart.dev_identity = address
         if isinstance(port, str):
-            self.cfg.cfg.cfg_data = ctypes.c_char_p(port.encode('ascii'))
+            self.cfg.cfg.cfg_data = ctypes.c_char_p(port.encode("ascii"))
         else:
             self.cfg.cfg.atcauart.port = port
         self.cfg.cfg.atcauart.baud = 115200
         self.cfg.cfg.atcauart.wordsize = 8
         self.cfg.cfg.atcauart.parity = 2
         self.cfg.cfg.atcauart.stopbits = 1
         self.port = port
         super().connect(self.cfg)
 
 
+__all__ = ["ECC608A", "ECC608B"]
+
 # Standard boilerplate to call the main() function to begin
 # the program.
-if __name__ == '__main__':
+if __name__ == "__main__":
     pass
```

## tpds/secure_element/sha204a.py

```diff
@@ -15,60 +15,56 @@
 # KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 
 import os
+
 import cryptoauthlib as cal
-from .ca_element import CAElement
-from .constants import Constants
 from cryptography.hazmat.backends import default_backend
 from cryptography.hazmat.primitives import hashes
 
+from .ca_element import CAElement
+from .constants import Constants
+
 
 class SHA204A(CAElement):
-    def __init__(self, interface='i2c', address=0xC8):
+    def __init__(self, interface="i2c", address=0xC8):
         self.cfg = cal.cfg_atsha20xa_kithid_default()
-        if interface == 'i2c':
-            self.cfg.cfg.atcahid.dev_interface \
-                = int(cal.ATCAKitType.ATCA_KIT_I2C_IFACE)
+        if interface == "i2c":
+            self.cfg.cfg.atcahid.dev_interface = int(cal.ATCAKitType.ATCA_KIT_I2C_IFACE)
             self.cfg.cfg.atcahid.dev_identity = address
         else:
-            self.cfg.cfg.atcahid.dev_interface \
-                = int(cal.ATCAKitType.ATCA_KIT_SWI_IFACE)
+            self.cfg.cfg.atcahid.dev_interface = int(cal.ATCAKitType.ATCA_KIT_SWI_IFACE)
             self.cfg.cfg.atcahid.dev_identity = address
 
-        self.cfg.devtype = cal.get_device_type_id('ATSHA204A')
+        self.cfg.devtype = cal.get_device_type_id("ATSHA204A")
 
         super().connect(self.cfg)
 
     def get_mac_response(self, slot, challenge=None):
-        '''
+        """
         Calculates mac on the device...
-        '''
+        """
         response = bytearray()
         if challenge is None:
             challenge = os.urandom(32)
 
-        assert cal.atcab_mac(
-            Constants.ATCA_SHA204A_MAC_MODE,
-            slot,
-            challenge,
-            response) \
-            == cal.Status.ATCA_SUCCESS, "Response generation failed"
-
-        return {
-            'challenge': challenge[0:32],
-            'response': response}
+        assert (
+            cal.atcab_mac(Constants.ATCA_SHA204A_MAC_MODE, slot, challenge, response)
+            == cal.Status.ATCA_SUCCESS
+        ), "Response generation failed"
+
+        return {"challenge": challenge[0:32], "response": response}
 
     def host_calc_mac_resp(self, slot, symm_key, challenge=None):
-        '''
+        """
         Calculates mac on the host...
-        '''
+        """
         response = bytearray()
         ser_num = self.get_device_serial_number()
 
         if challenge is None:
             challenge = os.urandom(32)
 
         response.extend(symm_key[0:32])  # symmetric key
@@ -83,16 +79,14 @@
         response.append(ser_num[0])
         response.append(ser_num[1])
         response.extend([0 for i in range(2)])
         digest = hashes.Hash(hashes.SHA256(), backend=default_backend())
         digest.update(bytes(response))
         response = digest.finalize()
 
-        return {
-            'challenge': challenge[0:32],
-            'response': response}
+        return {"challenge": challenge[0:32], "response": response}
 
 
 # Standard boilerplate to call the main() function to begin
 # the program.
-if __name__ == '__main__':
+if __name__ == "__main__":
     pass
```

## tpds/secure_element/sha206a.py

```diff
@@ -15,42 +15,40 @@
 # KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 
 import cryptoauthlib as cal
+
 from .sha204a import SHA204A
 
 
 class SHA206A(SHA204A):
-    def __init__(self, interface='swi', address=0x00):
+    def __init__(self, interface="swi", address=0x00):
         self.cfg = cal.cfg_atsha20xa_kithid_default()
         self.cfg.cfg.atcahid.dev_interface = int(cal.ATCAKitType.ATCA_KIT_SWI_IFACE)
         self.cfg.cfg.atcahid.dev_identity = 0
 
         # Should be using get_device_type_id('ATSHA206A')
         # but get_device_type_id yet
         self.cfg.devtype = 4
 
         super().connect(self.cfg)
 
     def get_use_counts(self):
         read_count = bytearray(20)
-        assert cal.atcab_read_bytes_zone(0, 0, 64, read_count, 20) \
-            == cal.Status.ATCA_SUCCESS, 'Reading UseFlags from device failed'
+        assert (
+            cal.atcab_read_bytes_zone(0, 0, 64, read_count, 20) == cal.Status.ATCA_SUCCESS
+        ), "Reading UseFlags from device failed"
+
+        dk_count = bin(read_count[2]).count("1")
+        pk_count = bin(int.from_bytes(read_count[4:], byteorder="big")).strip("0b").count("1")
+        consump_count = (pk_count * 8) - (8 - dk_count)
 
-        dk_count = bin(read_count[2]).count('1')
-        pk_count = bin(int.from_bytes(read_count[4:], byteorder="big"))\
-            .strip('0b').count('1')
-        consump_count = (pk_count*8)-(8-dk_count)
-
-        return {
-            'dk_useflag': dk_count,
-            'pk_useflag': pk_count,
-            'consump_count': consump_count}
+        return {"dk_useflag": dk_count, "pk_useflag": pk_count, "consump_count": consump_count}
 
 
 # Standard boilerplate to call the main() function to begin
 # the program.
-if __name__ == '__main__':
+if __name__ == "__main__":
     pass
```

## tpds/secure_element/ta010.py

```diff
@@ -14,17 +14,18 @@
 # PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY
 # KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 
-from .ecc204 import ECC204
 import cryptoauthlib as cal
 
+from .ecc204 import ECC204
+
 
 class TA010(ECC204):
     def __init__(self, interface="i2c", address=0x33):
         self.cfg = cal.cfg_ateccx08a_kithid_default()
         if interface == "i2c":
             self.cfg.cfg.atcahid.dev_interface = int(cal.ATCAKitType.ATCA_KIT_I2C_IFACE)
             self.cfg.cfg.atcahid.dev_identity = address
```

## tpds/secure_element/ta_element.py

```diff
@@ -15,156 +15,154 @@
 # KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 try:
     import cryptoauthlib_ta as cal
-except (ModuleNotFoundError, ImportError) as e:
+except (ModuleNotFoundError, ImportError):
     import cryptoauthlib as cal
-from ctypes import create_string_buffer, byref, c_bool
-from ctypes import cast, c_void_p, c_uint8, c_char_p
 
+from ctypes import byref, c_bool, c_char_p, c_uint8, c_void_p, cast, create_string_buffer
 
-class TAElement():
+
+class TAElement:
     def __init__(self):
         pass
 
     def connect(self, cfg):
-        '''
+        """
         Connects to ta using cfg provided
-        '''
-        assert cal.atcab_init(cfg) \
-            == cal.Status.ATCA_SUCCESS, 'Can\'t connect to device'
+        """
+        assert cal.atcab_init(cfg) == cal.Status.ATCA_SUCCESS, "Can't connect to device"
         self.device = cast(cal.atcab_get_device(), c_void_p)
 
     def get_device_revision(self):
-        '''
+        """
         Returns device revision from connected device
-        '''
+        """
         revision = create_string_buffer(4)
-        assert cal.talib_info_compat(self.device, revision) \
-            == cal.Status.ATCA_SUCCESS
+        assert cal.talib_info_compat(self.device, revision) == cal.Status.ATCA_SUCCESS
         return bytes(revision.raw)
 
     def get_device_serial_number(self):
-        '''
+        """
         Returns device serial number from connected device
-        '''
+        """
         c_serial_number = create_string_buffer(8)
-        assert cal.talib_info_serial_number(self.device, c_serial_number) \
-            == cal.Status.ATCA_SUCCESS
+        assert cal.talib_info_serial_number(self.device, c_serial_number) == cal.Status.ATCA_SUCCESS
         return bytes(c_serial_number.raw)
 
     def is_config_zone_locked(self):
-        '''
+        """
         Returns config memory lock status from connected device
-        '''
+        """
         is_locked = c_bool()
-        assert cal.talib_is_config_locked(self.device, byref(is_locked)) \
-            == cal.Status.ATCA_SUCCESS, 'Reading config lock status failed'
+        assert (
+            cal.talib_is_config_locked(self.device, byref(is_locked)) == cal.Status.ATCA_SUCCESS
+        ), "Reading config lock status failed"
         return bool(is_locked.value)
 
     def is_setup_locked(self):
-        '''
+        """
         Returns setup lock status from connected device
-        '''
+        """
         is_locked = c_bool()
-        assert cal.talib_is_setup_locked(self.device, byref(is_locked)) \
-            == cal.Status.ATCA_SUCCESS, 'Reading setup lock status failed'
+        assert (
+            cal.talib_is_setup_locked(self.device, byref(is_locked)) == cal.Status.ATCA_SUCCESS
+        ), "Reading setup lock status failed"
         return bool(is_locked.value)
 
     def is_handle_valid(self, target_handle):
-        '''
+        """
         Returns target_handle validity status from connected device
-        '''
+        """
         c_is_valid = c_uint8()
-        assert cal.get_cryptoauthlib().talib_is_handle_valid(
-            self.device, target_handle, cast(byref(c_is_valid), c_char_p)) \
-            == cal.Status.ATCA_SUCCESS, 'Reading handle validity failed'
+        assert (
+            cal.get_cryptoauthlib().talib_is_handle_valid(
+                self.device, target_handle, cast(byref(c_is_valid), c_char_p)
+            )
+            == cal.Status.ATCA_SUCCESS
+        ), "Reading handle validity failed"
         return bool(c_is_valid.value)
 
     def lock_setup(self):
-        '''Lock the setup
-        '''
-        assert cal.get_cryptoauthlib().talib_lock_setup(
-            self.device) == cal.Status.ATCA_SUCCESS, 'Locking setup failed'
+        """Lock the setup"""
+        assert (
+            cal.get_cryptoauthlib().talib_lock_setup(self.device) == cal.Status.ATCA_SUCCESS
+        ), "Locking setup failed"
 
     def get_handles_array(self):
-        '''
+        """
         Returns all handles present from connected device
-        '''
+        """
         handles = []
-        assert cal.talib_info_get_handles_array(self.device, handles) \
-            == cal.Status.ATCA_SUCCESS, 'Reading handle validity failed'
+        assert (
+            cal.talib_info_get_handles_array(self.device, handles) == cal.Status.ATCA_SUCCESS
+        ), "Reading handle validity failed"
         return handles
 
     def get_handle_info(self, target_handle):
-        '''
+        """
         Returns target_handle attributes info from connected device
-        '''
+        """
         handle_info = cal.ta_element_attributes_t()
-        assert cal.talib_info_get_handle_info(
-            self.device, target_handle, handle_info) \
-            == cal.Status.ATCA_SUCCESS, 'Reading handle info failed'
+        assert (
+            cal.talib_info_get_handle_info(self.device, target_handle, handle_info)
+            == cal.Status.ATCA_SUCCESS
+        ), "Reading handle info failed"
         return handle_info
 
     def get_device_details(self):
-        '''
+        """
         Returns device basic information like Revision, Serial No,
         Config status etc..,
-        '''
+        """
         device_info = dict()
-        device_info['revision'] = self.get_device_revision().hex()
-        device_info['serial_number'] \
-            = self.get_device_serial_number().hex().upper()
-        device_info['lock_status'] \
-            = [self.is_config_zone_locked(), self.is_setup_locked()]
-        device_info['handles'] = []
+        device_info["revision"] = self.get_device_revision().hex()
+        device_info["serial_number"] = self.get_device_serial_number().hex().upper()
+        device_info["lock_status"] = [self.is_config_zone_locked(), self.is_setup_locked()]
+        device_info["handles"] = []
         for handle in self.get_handles_array():
             handle_info = {}
-            handle_info.update({'handle': f'{handle:04X}'})
-            handle_info.update({
-                'validity':
-                'Valid' if self.is_handle_valid(handle) else 'Invalid'})
-            handle_info.update({
-                'attr':
-                bytes(self.get_handle_info(handle)).hex().upper()})
-            device_info['handles'].append(handle_info)
+            handle_info.update({"handle": f"{handle:04X}"})
+            handle_info.update({"validity": "Valid" if self.is_handle_valid(handle) else "Invalid"})
+            handle_info.update({"attr": bytes(self.get_handle_info(handle)).hex().upper()})
+            device_info["handles"].append(handle_info)
 
         return device_info
 
     def delete_handle(self, handle):
-        '''Delete the handle if read permission is set
-        '''
+        """Delete the handle if read permission is set"""
         # Read attribute info - delete permission
         attrib = cal.ta_element_attributes_t()
-        assert cal.talib_info_get_handle_info(
-            cal.atcab_get_device(), handle, attrib) \
-            == cal.Status.ATCA_SUCCESS, 'Fetching handle info failed'
+        assert (
+            cal.talib_info_get_handle_info(cal.atcab_get_device(), handle, attrib)
+            == cal.Status.ATCA_SUCCESS
+        ), "Fetching handle info failed"
 
         if attrib.Delete_Perm == 1:
-            assert cal.talib_delete_handle(
-                cal.atcab_get_device(), handle) \
-                == cal.Status.ATCA_SUCCESS, 'Handle deletion failed'
+            assert (
+                cal.talib_delete_handle(cal.atcab_get_device(), handle) == cal.Status.ATCA_SUCCESS
+            ), "Handle deletion failed"
             return True
 
         return False
 
     def write_config_memory(self, config_bytes):
-        '''Check configuration memory is locked.
+        """Check configuration memory is locked.
         before writing configuration data
-        '''
-        assert isinstance(config_bytes, str), \
-            'config_bytes should be bytearray'
+        """
+        assert isinstance(config_bytes, str), "config_bytes should be bytearray"
 
         if not self.is_config_zone_locked():
-            assert cal.atcab_write_config_zone(
-                bytearray.fromhex(config_bytes)) == \
-                cal.Status.ATCA_SUCCESS, 'Write config zone failed'
+            assert (
+                cal.atcab_write_config_zone(bytearray.fromhex(config_bytes))
+                == cal.Status.ATCA_SUCCESS
+            ), "Write config zone failed"
 
         # To read configuration memory, setup should be locked
         # if not self.is_setup_locked():
         #     self.lock_setup()
 
         # # Test code read after config write
         # ta_config_memory = bytearray(48)
@@ -176,15 +174,15 @@
 
         # assert bytearray.fromhex(config_bytes) == ta_config_memory[:48], \
         #     'Configuration read does not match'
 
 
 # Standard boilerplate to call the main() function to begin
 # the program.
-if __name__ == '__main__':
+if __name__ == "__main__":
     cfg = cal.cfg_ateccx08a_kithid_default()
     cfg.cfg.atcahid.dev_interface = int(cal.ATCAKitType.ATCA_KIT_I2C_IFACE)
     cfg.cfg.atcahid.dev_identity = 0x2E
     cfg.devtype = 0x10
 
     ta = TAElement()
     ta.connect(cfg)
```

## tpds/ta_attribute_parser/__init__.py

```diff
@@ -1,12 +1,66 @@
 """
     TA Configurator - Attribute Parser
 """
-from .attr_common import *
-from .attr_crl_property import *
-from .attr_data_property import *
-from .attr_extractedcert_property import *
-from .attr_fca_property import *
-from .attr_privkey_property import *
-from .attr_pubkey_property import *
-from .attr_symkey_property import *
-from .attributes import *
+from .attr_common import (
+    get_access_limit,
+    get_alg_mode,
+    get_bool,
+    get_delete_perm,
+    get_exportable,
+    get_handle_class,
+    get_key,
+    get_key_type,
+    get_lockable,
+    get_perm,
+    get_read_key,
+    get_read_perm,
+    get_reserved_58,
+    get_reserved_62,
+    get_usage_key,
+    get_usage_perm,
+    get_use_count,
+    get_write_key,
+    get_write_perm,
+    str_to_bin,
+)
+from .attr_crl_property import get_crl_properties
+from .attr_data_property import get_data_properties
+from .attr_extractedcert_property import get_extracted_properties
+from .attr_fca_property import get_fca_properties
+from .attr_privkey_property import get_private_properties
+from .attr_pubkey_property import get_public_properties
+from .attr_symkey_property import get_symmetric_properties
+from .attributes import attribute_info, decode_attribute, get_handle_property
+
+__all__ = [
+    "get_handle_class",
+    "get_key_type",
+    "get_alg_mode",
+    "get_bool",
+    "get_perm",
+    "get_usage_perm",
+    "get_read_perm",
+    "get_write_perm",
+    "get_delete_perm",
+    "get_key",
+    "get_usage_key",
+    "get_read_key",
+    "get_write_key",
+    "get_use_count",
+    "get_exportable",
+    "get_lockable",
+    "get_access_limit",
+    "get_reserved_58",
+    "get_reserved_62",
+    "str_to_bin",
+    "get_crl_properties",
+    "get_data_properties",
+    "get_extracted_properties",
+    "get_fca_properties",
+    "get_private_properties",
+    "get_public_properties",
+    "get_symmetric_properties",
+    "get_handle_property",
+    "decode_attribute",
+    "attribute_info",
+]
```

## tpds/ta_attribute_parser/attr_common.py

```diff
@@ -1,102 +1,153 @@
 import re
 
+
 def get_handle_class(value):
     class_details = {
-        0: 'Public Key',
-        1: 'Private Key',
-        2: 'Symmetric Key',
-        3: 'Data',
-        4: 'Extracted Certificate',
-        5: 'Reserved',
-        6: 'FCA Group',
-        7: 'CRL'
+        0: "Public Key",
+        1: "Private Key",
+        2: "Symmetric Key",
+        3: "Data",
+        4: "Extracted Certificate",
+        5: "Reserved",
+        6: "FCA Group",
+        7: "CRL",
     }
-    return class_details.get(value, 'Unknown')
+    return class_details.get(value, "Unknown")
+
 
 def get_key_type(value):
     key_type_details = {
-        0: 'ECC P256',
-        1: 'ECC P224',
-        2: 'ECC P384',
-        4: 'RSA 1024',
-        5: 'RSA 2048',
-        6: 'RSA 3072',
-        8: 'HMAC-SHA256',
-        9: 'SECP256K1',
-        10: 'Brainpool 256_R1',
-        12: 'AES-128'
+        0: "ECC P256",
+        1: "ECC P224",
+        2: "ECC P384",
+        4: "RSA 1024",
+        5: "RSA 2048",
+        6: "RSA 3072",
+        8: "HMAC-SHA256",
+        9: "SECP256K1",
+        10: "Brainpool 256_R1",
+        12: "AES-128",
     }
-    return key_type_details.get(value, 'Unknown')
+    return key_type_details.get(value, "Unknown")
 
-def get_alg_mode(value,d):
+
+def get_alg_mode(value, d):
     alg_mode_details = {
-        'ECC' :{0:"ECDSA",  1:"ECDH"},
-        'RSA' :{0:"SSA_1_5",1:"SSA_PSS"},
-        'AES' :{0:"CMAC",   1:"GCM"},
-        'HMAC':{0:"DIGEST", 1:"HMAC"}
+        "ECC": {0: "ECDSA", 1: "ECDH"},
+        "RSA": {0: "SSA_1_5", 1: "SSA_PSS"},
+        "AES": {0: "CMAC", 1: "GCM"},
+        "HMAC": {0: "DIGEST", 1: "HMAC"},
     }
-    key_str = re.split(r'\W+', d["key_type"])
-    ret_value = alg_mode_details.get(key_str[0],'Unknown')
-    if ret_value != 'Unknown':
-        return alg_mode_details[key_str[0]][int(value,2)]
+    key_str = re.split(r"\W+", d["key_type"])
+    ret_value = alg_mode_details.get(key_str[0], "Unknown")
+    if ret_value != "Unknown":
+        return alg_mode_details[key_str[0]][int(value, 2)]
     else:
         return ret_value
 
+
 def get_bool(value):
-    bool_details = {0:'Disabled', 1:'Enabled'}
-    return bool_details.get(value, 'Unknown')
+    bool_details = {0: "Disabled", 1: "Enabled"}
+    return bool_details.get(value, "Unknown")
+
 
 def get_perm(value):
     perm_details = {0: "Never", 1: "Always", 2: "Auth", 3: "Rights"}
-    return perm_details.get(value, 'Unknown')
+    return perm_details.get(value, "Unknown")
+
+
 def get_usage_perm(value):
     return get_perm(value)
+
+
 def get_read_perm(value):
     return get_perm(value)
+
+
 def get_write_perm(value):
     return get_perm(value)
+
+
 def get_delete_perm(value):
     return get_perm(value)
 
+
 def get_key(value):
     return hex(value)
+
+
 def get_usage_key(value):
     return get_key(value)
+
+
 def get_read_key(value):
     return get_key(value)
+
+
 def get_write_key(value):
     return get_key(value)
 
+
 def get_use_count(value):
-    use_count_details = {0: 'False', 1: 'Counter1', 2: 'Counter2', 3: 'Counter3'}
-    return use_count_details.get(value, 'Unknown')
+    use_count_details = {0: "False", 1: "Counter1", 2: "Counter2", 3: "Counter3"}
+    return use_count_details.get(value, "Unknown")
+
 
 def get_exportable(value):
-    exportable_details = {0: 'False', 1: 'True'}
-    return exportable_details.get(value, 'Unknown')
+    exportable_details = {0: "False", 1: "True"}
+    return exportable_details.get(value, "Unknown")
+
 
 def get_lockable(value):
-    lockable_details = {0: 'False', 1: 'True'}
-    return lockable_details.get(value, 'Unknown')
+    lockable_details = {0: "False", 1: "True"}
+    return lockable_details.get(value, "Unknown")
+
 
 def get_access_limit(value):
     access_limit_details = {0: "Always", 1: "Secure_Boot", 2: "One_Time_Clear", 3: "One_Time_Set"}
-    return access_limit_details.get(value, 'Unknown')
+    return access_limit_details.get(value, "Unknown")
+
 
 def get_reserved_58(value):
     pass
+
+
 def get_reserved_62(value):
     pass
 
 
 def str_to_bin(attr):
     """
     Convert 8 byte attribute string to bin string
     """
     attr_b = list(bytearray.fromhex(attr))
     bin_byte_l = []
     for byte in attr_b:
-        bin_byte_l.append(bin(byte).replace("0b","").zfill(8))
+        bin_byte_l.append(bin(byte).replace("0b", "").zfill(8))
     bin_byte_l.reverse()
-    attr_bin_value = ''.join([str(elem) for elem in bin_byte_l])
+    attr_bin_value = "".join([str(elem) for elem in bin_byte_l])
     return attr_bin_value
+
+
+__all__ = [
+    "get_handle_class",
+    "get_key_type",
+    "get_alg_mode",
+    "get_bool",
+    "get_perm",
+    "get_usage_perm",
+    "get_read_perm",
+    "get_write_perm",
+    "get_delete_perm",
+    "get_key",
+    "get_usage_key",
+    "get_read_key",
+    "get_write_key",
+    "get_use_count",
+    "get_exportable",
+    "get_lockable",
+    "get_access_limit",
+    "get_reserved_58",
+    "get_reserved_62",
+    "str_to_bin",
+]
```

## tpds/ta_attribute_parser/attr_crl_property.py

```diff
@@ -1,22 +1,22 @@
 def get_num_digest(value):
     return value
-    
+
+
 def get_crl_properties(value):
-    property_fields = {
-        'CRL': [
-            ('Num_Digests',8)
-            ]
-    }
-    #List to hold the crl property field with value
+    property_fields = {"CRL": [("Num_Digests", 8)]}
+    # List to hold the crl property field with value
     property_info_l = []
 
-    for field in property_fields['CRL']:
-        bits = value[-abs(field[1]):]
-        value = value[:-abs(field[1])]
-        property_field_value = int(bits,2)
+    for field in property_fields["CRL"]:
+        bits = value[-abs(field[1]) :]
+        value = value[: -abs(field[1])]
+        property_field_value = int(bits, 2)
         if field[0] == "Num_Digests":
-            t_d = {"Num_Digests":get_num_digest(property_field_value)}
-       
+            t_d = {"Num_Digests": get_num_digest(property_field_value)}
+
         property_info_l.append(t_d)
 
     return property_info_l
+
+
+__all__ = ["get_num_digest", "get_crl_properties"]
```

## tpds/ta_attribute_parser/attr_data_property.py

```diff
@@ -1,32 +1,31 @@
 from tpds.ta_attribute_parser import get_bool
 
+
 def get_size(value):
     return value
 
+
 def get_template(value):
     return get_bool(value)
 
+
 def get_data_properties(value):
-    property_fields = {
-        'Data': [
-            ('Size',12),
-            ('Template',1)
-            ]
-    }
-    #List to hold the data property field with value
+    property_fields = {"Data": [("Size", 12), ("Template", 1)]}
+    # List to hold the data property field with value
     property_info_l = []
 
-    for field in property_fields['Data']:
-        bits = value[-abs(field[1]):]
-        value = value[:-abs(field[1])]
-        property_field_value = int(bits,2)
+    for field in property_fields["Data"]:
+        bits = value[-abs(field[1]) :]
+        value = value[: -abs(field[1])]
+        property_field_value = int(bits, 2)
         if field[0] == "Size":
-            t_d = {"Size":get_size(property_field_value)}
+            t_d = {"Size": get_size(property_field_value)}
         elif field[0] == "Template":
-            t_d = {"Template":get_template(property_field_value)}
+            t_d = {"Template": get_template(property_field_value)}
 
         property_info_l.append(t_d)
 
     return property_info_l
 
-    
+
+__all__ = ["get_size", "get_template", "get_data_properties"]
```

## tpds/ta_attribute_parser/attr_extractedcert_property.py

```diff
@@ -1,55 +1,73 @@
 from tpds.ta_attribute_parser import get_bool
 
+
 def get_granted_rights(value):
     return value
 
+
 def get_secure_boot(value):
     return get_bool(value)
 
+
 def get_ca_ok(value):
     return get_bool(value)
 
+
 def get_ca_parent(value):
     return get_bool(value)
 
+
 def get_crl_sign(value):
     return get_bool(value)
 
+
 def get_special_only(value):
     return get_bool(value)
 
+
 def get_extracted_properties(value):
     property_fields = {
-        'Extracted Certificate': [
-            ('Granted_Rights',8),
-            ('Secure_Boot',1),
-            ('CA_OK',1),
-            ('CA_Parent',1),
-            ('CRL_Sign',1),
-            ('Special_Only',1)
-            ]
+        "Extracted Certificate": [
+            ("Granted_Rights", 8),
+            ("Secure_Boot", 1),
+            ("CA_OK", 1),
+            ("CA_Parent", 1),
+            ("CRL_Sign", 1),
+            ("Special_Only", 1),
+        ]
     }
 
-    #List to hold extracted property field with value----#
+    # List to hold extracted property field with value----#
     property_info_l = []
 
-    for field in property_fields['Extracted Certificate']:
-        bits = value[-abs(field[1]):]
-        value = value[:-abs(field[1])]
-        property_field_value = int(bits,2)
+    for field in property_fields["Extracted Certificate"]:
+        bits = value[-abs(field[1]) :]
+        value = value[: -abs(field[1])]
+        property_field_value = int(bits, 2)
         if field[0] == "Granted_Rights":
-            t_d = {"Granted_Rights":get_granted_rights(property_field_value)}
+            t_d = {"Granted_Rights": get_granted_rights(property_field_value)}
         elif field[0] == "Secure_Boot":
-            t_d = {"Secure_Boot":get_secure_boot(property_field_value)}
+            t_d = {"Secure_Boot": get_secure_boot(property_field_value)}
         elif field[0] == "CA_OK":
-            t_d = {"CA_OK":get_ca_ok(property_field_value)}
+            t_d = {"CA_OK": get_ca_ok(property_field_value)}
         elif field[0] == "CA_Parent":
-            t_d = {"CA_Parent":get_ca_parent(property_field_value)}
+            t_d = {"CA_Parent": get_ca_parent(property_field_value)}
         elif field[0] == "CRL_Sign":
-            t_d = {"CRL_Sign":get_crl_sign(property_field_value)}
+            t_d = {"CRL_Sign": get_crl_sign(property_field_value)}
         elif field[0] == "Special_Only":
-            t_d = {"Special_Only":get_special_only(property_field_value)}
+            t_d = {"Special_Only": get_special_only(property_field_value)}
 
         property_info_l.append(t_d)
 
     return property_info_l
+
+
+__all__ = [
+    "get_granted_rights",
+    "get_secure_boot",
+    "get_ca_ok",
+    "get_ca_parent",
+    "get_crl_sign",
+    "get_special_only",
+    "get_extracted_properties",
+]
```

## tpds/ta_attribute_parser/attr_fca_property.py

```diff
@@ -1,29 +1,31 @@
 from tpds.ta_attribute_parser import get_bool
+
+
 def get_num_key(value):
     return value
 
+
 def get_handles(value):
     return get_bool(value)
 
+
 def get_fca_properties(value):
-    property_fields = {
-        'Fast Crypto Key Group': [
-            ('Num_Keys',5),
-            ('Handles',1)
-        ]
-    }
-    #List to hold the Fca property field with value----#
+    property_fields = {"Fast Crypto Key Group": [("Num_Keys", 5), ("Handles", 1)]}
+    # List to hold the Fca property field with value----#
     property_info_l = []
 
-    for field in property_fields['Fast Crypto Key Group']:
-        bits = value[-abs(field[1]):]
-        value = value[:-abs(field[1])]
-        property_field_value = int(bits,2)
+    for field in property_fields["Fast Crypto Key Group"]:
+        bits = value[-abs(field[1]) :]
+        value = value[: -abs(field[1])]
+        property_field_value = int(bits, 2)
         if field[0] == "Num_Keys":
-            t_d = {"Num_Keys":get_num_key(property_field_value)}
+            t_d = {"Num_Keys": get_num_key(property_field_value)}
         elif field[0] == "Handles":
-            t_d = {"Handles":get_handles(property_field_value)}
+            t_d = {"Handles": get_handles(property_field_value)}
 
         property_info_l.append(t_d)
 
     return property_info_l
+
+
+__all__ = ["get_num_key", "get_handles", "get_fca_properties"]
```

## tpds/ta_attribute_parser/attr_privkey_property.py

```diff
@@ -1,50 +1,67 @@
 from tpds.ta_attribute_parser import get_bool
+
+
 def get_pub_key(value):
     return hex(0x8000 + value)
 
+
 def get_session(value):
     return get_bool(value)
 
+
 def get_key_gen(value):
     return get_bool(value)
 
+
 def get_sign_use(value):
     sign_use_details = {0: "None", 1: "All", 2: "Message_Only", 3: "Internal_Only"}
-    return sign_use_details.get(value, 'Unknown')
+    return sign_use_details.get(value, "Unknown")
+
 
 def get_agree_use(value):
     agree_use_details = {0: "None", 1: "Any_Target", 2: "RW_Never", 3: "Usage_Key"}
-    return agree_use_details.get(value, 'Unknown')
+    return agree_use_details.get(value, "Unknown")
+
 
 def get_private_properties(value):
     property_fields = {
-        'Private Key': [
-            ('Pub_Key'  ,8),
-            ('Session'  ,1),
-            ('Key_Gen'  ,1),
-            ('Sign_Use' ,2),
-            ('Agree_Use',2)
+        "Private Key": [
+            ("Pub_Key", 8),
+            ("Session", 1),
+            ("Key_Gen", 1),
+            ("Sign_Use", 2),
+            ("Agree_Use", 2),
         ]
     }
-    
-    #List to hold the private key property field with value
+
+    # List to hold the private key property field with value
     property_info_l = []
 
     for field in property_fields["Private Key"]:
-        bits = value[-abs(field[1]):]
-        value = value[:-abs(field[1])]
-        property_field_value = int(bits,2)
+        bits = value[-abs(field[1]) :]
+        value = value[: -abs(field[1])]
+        property_field_value = int(bits, 2)
         if field[0] == "Pub_Key":
-            t_d = {"Pub_Key":get_pub_key(property_field_value)}
+            t_d = {"Pub_Key": get_pub_key(property_field_value)}
         elif field[0] == "Session":
-            t_d = {"Session":get_session(property_field_value)}
+            t_d = {"Session": get_session(property_field_value)}
         elif field[0] == "Key_Gen":
-            t_d = {"Key_Gen":get_key_gen(property_field_value)}
-        elif  field[0] == "Sign_Use":
-            t_d = {"Sign_Use":get_sign_use(property_field_value)}
+            t_d = {"Key_Gen": get_key_gen(property_field_value)}
+        elif field[0] == "Sign_Use":
+            t_d = {"Sign_Use": get_sign_use(property_field_value)}
         elif field[0] == "Agree_Use":
-            t_d = {"Agree_Use":get_agree_use(property_field_value)}
+            t_d = {"Agree_Use": get_agree_use(property_field_value)}
 
         property_info_l.append(t_d)
 
     return property_info_l
+
+
+__all__ = [
+    "get_pub_key",
+    "get_session",
+    "get_key_gen",
+    "get_sign_use",
+    "get_agree_use",
+    "get_private_properties",
+]
```

## tpds/ta_attribute_parser/attr_pubkey_property.py

```diff
@@ -1,59 +1,74 @@
 from tpds.ta_attribute_parser import get_bool
 
+
 def get_path_length(value):
-    path_length_details = {255: 'Unrestricted'}
+    path_length_details = {255: "Unrestricted"}
     return path_length_details.get(value, value)
 
+
 def get_secure_boot(value):
     return get_bool(value)
 
+
 def get_crl_sign(value):
     return get_bool(value)
 
+
 def get_special_only(value):
     return get_bool(value)
 
+
 def get_root_str(value):
     root_str_details = {0: "False", 3: "True"}
-    return root_str_details.get(value, 'Unknown')
+    return root_str_details.get(value, "Unknown")
+
 
 def get_public_properties(value):
     property_fields = {
-        'Public Key': [
-            ('Path_Length',8),
-            ('Secure_Boot',1),
-            ('Root',2),
-            ('CRL_Sign',1),
-            ('Special_Only',1)
-            ],
+        "Public Key": [
+            ("Path_Length", 8),
+            ("Secure_Boot", 1),
+            ("Root", 2),
+            ("CRL_Sign", 1),
+            ("Special_Only", 1),
+        ],
     }
 
-    #List to hold the public key property field with value
+    # List to hold the public key property field with value
     property_info_l = []
 
-    #----field ex --> ('Path_Length',8)
-    for field in property_fields['Public Key']:
-        bits = value[-abs(field[1]):]
-        value = value[:-abs(field[1])]
-        property_field_value = int(bits,2)
+    # ----field ex --> ('Path_Length',8)
+    for field in property_fields["Public Key"]:
+        bits = value[-abs(field[1]) :]
+        value = value[: -abs(field[1])]
+        property_field_value = int(bits, 2)
         if field[0] == "Path_Length":
-            if (property_field_value == 255):
-                t_d = {"Path_Length":get_path_length(property_field_value)}
+            if property_field_value == 255:
+                t_d = {"Path_Length": get_path_length(property_field_value)}
             else:
-                t_d = {"Path_Length":get_path_length(property_field_value)}
+                t_d = {"Path_Length": get_path_length(property_field_value)}
         elif field[0] == "Secure_Boot":
-            t_d = {"Secure_Boot":get_secure_boot(property_field_value)}
+            t_d = {"Secure_Boot": get_secure_boot(property_field_value)}
 
         elif field[0] == "Root":
-            t_d = {"Root":get_root_str(property_field_value)}
+            t_d = {"Root": get_root_str(property_field_value)}
 
         elif field[0] == "CRL_Sign":
-            t_d = {"CRL_Sign":get_crl_sign(property_field_value)}
+            t_d = {"CRL_Sign": get_crl_sign(property_field_value)}
 
         elif field[0] == "Special_Only":
-            t_d = {"Special_Only":get_special_only(property_field_value)}
+            t_d = {"Special_Only": get_special_only(property_field_value)}
 
         property_info_l.append(t_d)
 
     return property_info_l
 
+
+__all__ = [
+    "get_path_length",
+    "get_secure_boot",
+    "get_crl_sign",
+    "get_special_only",
+    "get_root_str",
+    "get_public_properties",
+]
```

## tpds/ta_attribute_parser/attr_symkey_property.py

```diff
@@ -1,63 +1,108 @@
 from tpds.ta_attribute_parser import get_bool
 
+
 def get_granted_right(value):
     return value
 
+
 def get_sys_usage(value):
-    sym_usage_details = {
-        0:"MAC",
-        1:"ENC",
-        2:"ANY",
-        3:"KDF_SHA"
-    }
-    return sym_usage_details.get(value,'Unknown')
+    sym_usage_details = {0: "MAC", 1: "ENC", 2: "ANY", 3: "KDF_SHA"}
+    return sym_usage_details.get(value, "Unknown")
+
 
 def get_session_use(value):
-    
     session_use_details = {
-		0:{'Use_For_Auth':'Never', 'Encrypted_Session': 'NA',       'Session_Random_Nonce':'NA',	    'Use_For_Transfer':'No'  },
-		1:{'Use_For_Auth':'Either','Encrypted_Session':	'Optional',	'Session_Random_Nonce':'Optional' , 'Use_For_Transfer':'No'  },
-		2:{'Use_For_Auth':'Either','Encrypted_Session':	'Optional',	'Session_Random_Nonce':'Mandatory', 'Use_For_Transfer':'No'  },
-		3:{'Use_For_Auth':'Either','Encrypted_Session':	'Mandatory','Session_Random_Nonce':'Mandatory', 'Use_For_Transfer':'No'  },
-		4:{'Use_For_Auth':'Only',  'Encrypted_Session': 'Mandatory','Session_Random_Nonce':'Mandatory', 'Use_For_Transfer':'Only'},
-		5:{'Use_For_Auth':'Only',  'Encrypted_Session': 'Optional',	'Session_Random_Nonce':'Optional',	'Use_For_Transfer':'No'  },
-		6:{'Use_For_Auth':'Only',  'Encrypted_Session': 'Optional',	'Session_Random_Nonce':'Mandatory', 'Use_For_Transfer':	'No' },
-		7:{'Use_For_Auth':'Only',  'Encrypted_Session': 'Mandatory','Session_Random_Nonce':'Mandatory', 'Use_For_Transfer':	'No' }
-
+        0: {
+            "Use_For_Auth": "Never",
+            "Encrypted_Session": "NA",
+            "Session_Random_Nonce": "NA",
+            "Use_For_Transfer": "No",
+        },
+        1: {
+            "Use_For_Auth": "Either",
+            "Encrypted_Session": "Optional",
+            "Session_Random_Nonce": "Optional",
+            "Use_For_Transfer": "No",
+        },
+        2: {
+            "Use_For_Auth": "Either",
+            "Encrypted_Session": "Optional",
+            "Session_Random_Nonce": "Mandatory",
+            "Use_For_Transfer": "No",
+        },
+        3: {
+            "Use_For_Auth": "Either",
+            "Encrypted_Session": "Mandatory",
+            "Session_Random_Nonce": "Mandatory",
+            "Use_For_Transfer": "No",
+        },
+        4: {
+            "Use_For_Auth": "Only",
+            "Encrypted_Session": "Mandatory",
+            "Session_Random_Nonce": "Mandatory",
+            "Use_For_Transfer": "Only",
+        },
+        5: {
+            "Use_For_Auth": "Only",
+            "Encrypted_Session": "Optional",
+            "Session_Random_Nonce": "Optional",
+            "Use_For_Transfer": "No",
+        },
+        6: {
+            "Use_For_Auth": "Only",
+            "Encrypted_Session": "Optional",
+            "Session_Random_Nonce": "Mandatory",
+            "Use_For_Transfer": "No",
+        },
+        7: {
+            "Use_For_Auth": "Only",
+            "Encrypted_Session": "Mandatory",
+            "Session_Random_Nonce": "Mandatory",
+            "Use_For_Transfer": "No",
+        },
     }
 
-    return session_use_details.get(value,'Unknown')
+    return session_use_details.get(value, "Unknown")
+
 
 def get_key_group_ok(value):
-    return get_bool(value)   
+    return get_bool(value)
+
 
 def get_symmetric_properties(value):
     property_fields = {
-        'Symmetric Key': [
-            ('Granted_Rights',8),
-            ('Sym_Usage',2),
-            ('Session_Use',3),
-            ('Key_Group_OK',1)
-            ],
+        "Symmetric Key": [
+            ("Granted_Rights", 8),
+            ("Sym_Usage", 2),
+            ("Session_Use", 3),
+            ("Key_Group_OK", 1),
+        ],
     }
 
-    
-    #List to hold the symmetric key property field with value----#
+    # List to hold the symmetric key property field with value----#
     property_info_l = []
     for field in property_fields["Symmetric Key"]:
-        bits = value[-abs(field[1]):]
-        value = value[:-abs(field[1])]
-        property_field_value = int(bits,2)
+        bits = value[-abs(field[1]) :]
+        value = value[: -abs(field[1])]
+        property_field_value = int(bits, 2)
         if field[0] == "Granted_Rights":
-            t_d = {"Granted_Rights":get_granted_right(property_field_value)}
+            t_d = {"Granted_Rights": get_granted_right(property_field_value)}
         elif field[0] == "Sym_Usage":
-            t_d = {"Sym_Usage":get_sys_usage(property_field_value)}
+            t_d = {"Sym_Usage": get_sys_usage(property_field_value)}
         elif field[0] == "Session_Use":
-            t_d = {"Session_Use":get_session_use(property_field_value)}
-        elif  field[0] == "Key_Group_OK":
-            t_d = {"Sign_Use":get_key_group_ok(property_field_value)}
-        
+            t_d = {"Session_Use": get_session_use(property_field_value)}
+        elif field[0] == "Key_Group_OK":
+            t_d = {"Sign_Use": get_key_group_ok(property_field_value)}
 
         property_info_l.append(t_d)
 
     return property_info_l
+
+
+__all__ = [
+    "get_granted_right",
+    "get_sys_usage",
+    "get_session_use",
+    "get_key_group_ok",
+    "get_symmetric_properties",
+]
```

## tpds/ta_attribute_parser/attributes.py

```diff
@@ -1,104 +1,142 @@
-from tpds.ta_attribute_parser import *
 import re
 
+from .attr_common import (
+    str_to_bin,
+    get_handle_class,
+    get_key_type,
+    get_alg_mode,
+    get_usage_key,
+    get_write_key,
+    get_read_key,
+    get_usage_perm,
+    get_write_perm,
+    get_read_perm,
+    get_delete_perm,
+    get_use_count,
+    get_reserved_58,
+    get_exportable,
+    get_lockable,
+    get_access_limit,
+    get_reserved_62,
+)
+from .attr_crl_property import get_crl_properties
+from .attr_data_property import get_data_properties
+from .attr_extractedcert_property import get_extracted_properties
+from .attr_fca_property import get_fca_properties
+from .attr_privkey_property import get_private_properties
+from .attr_pubkey_property import get_public_properties
+from .attr_symkey_property import get_symmetric_properties
+
+
+_handle_property_map = {
+    "crl": get_crl_properties,
+    "data": get_data_properties,
+    "extracted": get_extracted_properties,
+    "fce": get_fca_properties,
+    "fca": get_fca_properties,
+    "private": get_private_properties,
+    "public": get_public_properties,
+    "symmetric": get_symmetric_properties,
+}
+
 
 def get_handle_property(value, d):
     """
     Function will invoke handle property api based on the handle class
     Ex :
     -->get_private_properties(value)
     -->get_public_properties(value)
     """
-    func = "get_" + d["handle_class"].split(" ")[0].lower() + "_properties (value)"
-    return {"Property": eval(func)}
+    func = _handle_property_map.get(d["handle_class"].split(" ")[0].lower(), None)
+    if func is not None:
+        return func(value)
+    else:
+        raise ValueError(f'Unable to part {d["handle_class"]} properties')
 
 
 def decode_attribute(attr):
     # Dict hold the decoded attribute informations
     attr_info = {}
     # handle_properties holds the bit length info of attribute fields
     # Don't remove reserved fields in below list
     handle_properties = [
-        ('handle_class', 3),
-        ('key_type', 4),
-        ('alg_mode', 1),
-        ('handle_property', 16),
-        ('usage_key', 8),
-        ('write_key', 8),
-        ('read_key', 8),
-        ('usage_perm', 2),
-        ('write_perm', 2),
-        ('read_perm', 2),
-        ('delete_perm', 2),
-        ('use_count', 2),
-        ('reserved_58', 1),
-        ('exportable', 1),
-        ('lockable', 1),
-        ('access_limit', 2),
-        ('reserved_62', 1)
+        ("handle_class", 3, get_handle_class),
+        ("key_type", 4, get_key_type),
+        ("alg_mode", 1, get_alg_mode),
+        ("handle_property", 16, get_handle_property),
+        ("usage_key", 8, get_usage_key),
+        ("write_key", 8, get_write_key),
+        ("read_key", 8, get_read_key),
+        ("usage_perm", 2, get_usage_perm),
+        ("write_perm", 2, get_write_perm),
+        ("read_perm", 2, get_read_perm),
+        ("delete_perm", 2, get_delete_perm),
+        ("use_count", 2, get_use_count),
+        ("reserved_58", 1, get_reserved_58),
+        ("exportable", 1, get_exportable),
+        ("lockable", 1, get_lockable),
+        ("access_limit", 2, get_access_limit),
+        ("reserved_62", 1, get_reserved_62),
     ]
 
-    name = 0
-    bit_length = 1
-
     attr_bin = str_to_bin(attr)
-    for field in handle_properties:
-        bits = attr_bin[-abs(field[bit_length]):]
-        attr_bin = attr_bin[:-abs(field[bit_length])]
+    for name, bitlen, func in handle_properties:
+        bits = attr_bin[-abs(bitlen) :]
+        attr_bin = attr_bin[: -abs(bitlen)]
         # Alg mode and handle_property function need key type info
-        if field[name] == "alg_mode" or field[name] == "handle_property":
-            value = bits
-            func = 'get_' + field[name] + '(value, attr_info)'
+        if name == "alg_mode" or name == "handle_property":
+            result = func(bits, attr_info)
         else:
-            value = int(bits, 2)
-            func = 'get_' + field[name] + '(value)'
-        attr_info.update({field[name]: eval(func)})
+            result = func(int(bits, 2))
+        attr_info.update({name: result})
 
     return attr_info
 
 
 def attribute_info(val):
     attr_info = decode_attribute(val)
-    key_property = re.sub(
-                        r'[\[{}\]\']', '',
-                        str(attr_info.get('handle_property')))
+    key_property = re.sub(r"[\[{}\]\']", "", str(attr_info.get("handle_property")))
     attr_list = []
     attr_list.append(
-                    f'{attr_info.get("handle_class")}, '
-                    f'{attr_info.get("key_type")}, '
-                    f'{attr_info.get("alg_mode")}, '
-                    f'Exportable:{attr_info.get("exportable")}, '
-                    f'Lockable:{attr_info.get("lockable")}, '
-                    f'Access limit:{attr_info.get("access_limit")}'
-                    )
+        f'{attr_info.get("handle_class")}, '
+        f'{attr_info.get("key_type")}, '
+        f'{attr_info.get("alg_mode")}, '
+        f'Exportable:{attr_info.get("exportable")}, '
+        f'Lockable:{attr_info.get("lockable")}, '
+        f'Access limit:{attr_info.get("access_limit")}'
+    )
     attr_list.append(
-                    f'Key Permission : '
-                    f' Usage:{attr_info.get("usage_perm")}, '
-                    f'Write:{attr_info.get("write_perm")}, '
-                    f' Read:{attr_info.get("read_perm")}, '
-                    f'Delete:{attr_info.get("delete_perm")}')
-    usage_key = ''
-    if attr_info.get("usage_perm") == 'Rights':
+        f"Key Permission : "
+        f' Usage:{attr_info.get("usage_perm")}, '
+        f'Write:{attr_info.get("write_perm")}, '
+        f' Read:{attr_info.get("read_perm")}, '
+        f'Delete:{attr_info.get("delete_perm")}'
+    )
+    usage_key = ""
+    if attr_info.get("usage_perm") == "Rights":
         usage_key = f'Usage Rights:{attr_info.get("usage_key")}, '
-    elif attr_info.get("usage_perm") == 'Auth':
+    elif attr_info.get("usage_perm") == "Auth":
         handle = hex(0x8000 | int(attr_info.get("usage_key"), base=16))
-        usage_key = f'Usage Auth Handle:{handle}, '
+        usage_key = f"Usage Auth Handle:{handle}, "
 
-    write_key = ''
-    if attr_info.get("write_perm") == 'Rights':
+    write_key = ""
+    if attr_info.get("write_perm") == "Rights":
         write_key = f'Write Rights:{attr_info.get("write_key")}, '
-    elif attr_info.get("write_perm") == 'Auth':
+    elif attr_info.get("write_perm") == "Auth":
         handle = hex(0x8000 | int(attr_info.get("write_key"), base=16))
-        write_key = f'Write Auth Handle:{handle}, '
+        write_key = f"Write Auth Handle:{handle}, "
 
-    read_key = ''
-    if attr_info.get("read_perm") == 'Rights':
+    read_key = ""
+    if attr_info.get("read_perm") == "Rights":
         read_key = f'Read Rights:{attr_info.get("read_key")}, '
-    elif attr_info.get("read_perm") == 'Auth':
+    elif attr_info.get("read_perm") == "Auth":
         handle = hex(0x8000 | int(attr_info.get("read_key"), base=16))
-        read_key = f'Read Auth Handle:{handle}, '
-    if usage_key != '' or read_key != '' or write_key != '':
-        attr_list.append('Key Handles : ' + usage_key+write_key+read_key)
-    attr_list.append(f'{key_property}')
+        read_key = f"Read Auth Handle:{handle}, "
+    if usage_key != "" or read_key != "" or write_key != "":
+        attr_list.append("Key Handles : " + usage_key + write_key + read_key)
+    attr_list.append(f"{key_property}")
+
+    return attr_list
+
 
-    return(attr_list)
+__all__ = ["get_handle_property", "decode_attribute", "attribute_info"]
```

## tpds/tp_utils/__init__.py

```diff
@@ -1,10 +1,49 @@
 """
     Trust Platform core package - tp_utils module
 """
-from .tp_keys import *
-from .tp_utils import *
-from .tp_print import *
-from .tp_client import *
-from .tp_settings import *
-from .tp_input_dialog import *
+from .tp_client import Client, Messages, tpdsAPI_get
+from .tp_input_dialog import (
+    OpenExplorerFolder,
+    TPInputDialog,
+    TPInputDropdown,
+    TPInputFileUpload,
+    TPInputTextBox,
+    TPMessageBox,
+)
+from .tp_keys import TPAsymmetricKey, TPSymmetricKey
+from .tp_print import print
+from .tp_settings import TPSettings
+from .tp_utils import (
+    add_to_zip_archive,
+    calculate_wpc_digests,
+    extract_zip_archive,
+    get_c_hex_bytes,
+    pretty_print_hex,
+    pretty_xml_hex_array,
+    run_subprocess_cmd,
+    sign_on_host,
+)
 
+__all__ = [
+    "Messages",
+    "Client",
+    "tpdsAPI_get",
+    "TPInputDialog",
+    "TPInputFileUpload",
+    "TPInputTextBox",
+    "TPInputDropdown",
+    "TPMessageBox",
+    "OpenExplorerFolder",
+    "TPSymmetricKey",
+    "TPAsymmetricKey",
+    "print",
+    "TPSettings",
+    "run_subprocess_cmd",
+    "pretty_print_hex",
+    "get_c_hex_bytes",
+    "pretty_xml_hex_array",
+    "sign_on_host",
+    "extract_zip_archive",
+    "add_to_zip_archive",
+    "calculate_wpc_digests",
+]
```

## tpds/tp_utils/tp_client.py

```diff
@@ -1,43 +1,41 @@
 import json
-import websocket
-import requests
 from types import SimpleNamespace
+
+import requests
+import websocket
 from tpds.app.vars import get_url_base
 
 
-class Messages():
+class Messages:
     op_codes = {
-            "loopback": 0,
-            "get_mplab_path": 1,
-            "open_notebook": 2,
-            "open_link": 3,
-            "file_upload": 11,
-            "text_box": 12,
-            "dropdown": 13,
-            "open_explorer": 14,
-            "messagebox": 18,
-            "symm_auth_inputs": 40,
-            "wpc_user_inputs": 41,
-            "provision_inputs": 50,
-        }
+        "loopback": 0,
+        "get_mplab_path": 1,
+        "open_notebook": 2,
+        "open_link": 3,
+        "file_upload": 11,
+        "text_box": 12,
+        "dropdown": 13,
+        "open_explorer": 14,
+        "messagebox": 18,
+        "symm_auth_inputs": 40,
+        "wpc_user_inputs": 41,
+        "sha10x_symm_auth_inputs": 42,
+        "provision_inputs": 50,
+    }
 
     # msg_schema = {"msg_id": "int", "parameters": ["string"]}
     def encode(self, op_code: str, args: list):
-        message = {
-            'msg_id': self.op_codes.get(op_code, 'loopback'),
-            'parameters': args}
+        message = {"msg_id": self.op_codes.get(op_code, "loopback"), "parameters": args}
         return json.dumps(message)
 
 
-class Client():
+class Client:
     def __init__(self, parent, recv_handler=None):
-        self.client = websocket.WebSocket(
-            on_error=self.error,
-            on_close=self.close)
+        self.client = websocket.WebSocket(on_error=self.error, on_close=self.close)
         self.client.connect("ws://127.0.0.1:1302/")
 
     def error(self, error_code):
         print("error code: {}".format(error_code))
         print(self.client.errorString())
 
     def close(self):
@@ -47,17 +45,15 @@
     def send_message(self, op_code, args: list):
         msg = Messages()
         message = msg.encode(op_code, args)
         self.client.send(message)
 
 
 def tpdsAPI_get(url_suffix):
-    response = requests.get(url=f'{get_url_base()}/{url_suffix}')
-    return json.loads(
-        response.content.decode('utf-8'),
-        object_hook=lambda d: SimpleNamespace(**d))
+    response = requests.get(url=f"{get_url_base()}/{url_suffix}")
+    return json.loads(response.content.decode("utf-8"), object_hook=lambda d: SimpleNamespace(**d))
 
 
-if __name__ == '__main__':
+if __name__ == "__main__":
     # Server must be running before this application starts sending
     # requests
     pass
```

## tpds/tp_utils/tp_input_dialog.py

```diff
@@ -15,94 +15,85 @@
 # KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 
 import json
+
 from .tp_client import Client
 
 
-class TPInputDialog():
+class TPInputDialog:
     def __init__(self, cb_msg_trigger, cb_msg_response):
         self.cb_msg_trigger = cb_msg_trigger
         self.cb_msg_received = cb_msg_response
 
     def invoke_dialog(self):
         self.client_c = Client(None)
         self.cb_msg_trigger()
         resp_msg = self.client_c.client.recv()
         self.client_c.client.close()
-        self.cb_msg_received(json.loads(resp_msg).get('response'))
+        self.cb_msg_received(json.loads(resp_msg).get("response"))
 
 
 class TPInputFileUpload(TPInputDialog):
-    def __init__(self, file_filter=None, dialog_title='UserInput', nav_dir=None):
+    def __init__(self, file_filter=None, dialog_title="UserInput", nav_dir=None):
         self.filter = file_filter
         self.dialog_title = dialog_title
         self.file_selection = None
         self.nav_dir = nav_dir
         super().__init__(self.file_upload, self.process_response)
 
     def file_upload(self):
-        self.client_c.send_message(
-                            'file_upload',
-                            [self.dialog_title, self.filter, self.nav_dir])
+        self.client_c.send_message("file_upload", [self.dialog_title, self.filter, self.nav_dir])
 
     def process_response(self, message):
         self.file_selection = message
 
 
 class TPInputTextBox(TPInputDialog):
-    def __init__(self, desc='Enter Here', dialog_title='UserInput'):
+    def __init__(self, desc="Enter Here", dialog_title="UserInput"):
         self.desc = desc
         self.dialog_title = dialog_title
         self.user_text = None
         super().__init__(self.text_box, self.process_response)
 
     def text_box(self):
-        self.client_c.send_message('text_box', [self.dialog_title, self.desc])
+        self.client_c.send_message("text_box", [self.dialog_title, self.desc])
 
     def process_response(self, message):
         self.user_text = message
 
 
 class TPInputDropdown(TPInputDialog):
-    def __init__(
-            self, item_list,
-            desc='Select your option', dialog_title='UserInput'):
+    def __init__(self, item_list, desc="Select your option", dialog_title="UserInput"):
         self.item_list = item_list
         self.desc = desc
         self.dialog_title = dialog_title
         self.user_option = None
         super().__init__(self.dropdown, self.process_response)
 
     def dropdown(self):
-        self.client_c.send_message(
-                            'dropdown',
-                            [self.dialog_title, self.item_list, self.desc])
+        self.client_c.send_message("dropdown", [self.dialog_title, self.item_list, self.desc])
 
     def process_response(self, message):
         self.user_option = message
 
 
 class TPMessageBox(TPInputDialog):
-    def __init__(
-            self, title='Select your option',
-            info='UserInput', option_list=['OK', 'Cancel']):
+    def __init__(self, title="Select your option", info="UserInput", option_list=["OK", "Cancel"]):
         self.title = title
         self.info = info
         self.option_list = option_list
-        self.user_select= None
+        self.user_select = None
         super().__init__(self.messagebox, self.process_response)
 
     def messagebox(self):
-        self.client_c.send_message(
-                            'messagebox',
-                            [self.title, self.info])
+        self.client_c.send_message("messagebox", [self.title, self.info])
 
     def process_response(self, message):
         self.user_select = message
 
 
 # class TPOpenLink(TPInputDialog):
 #     def __init__(
@@ -115,22 +106,31 @@
 #                             'open_link', [self.link])
 
 #     def process_response(self, message):
 #         pass
 
 
 class OpenExplorerFolder(TPInputDialog):
-    def __init__(self, path=''):
+    def __init__(self, path=""):
         self.path = path
         super().__init__(self.openexplorer, self.process_response)
 
     def openexplorer(self):
-        self.client_c.send_message('open_explorer', [self.path])
+        self.client_c.send_message("open_explorer", [self.path])
 
     def process_response(self, message):
         pass
 
 
+__all__ = [
+    "TPInputDialog",
+    "TPInputFileUpload",
+    "TPInputTextBox",
+    "TPInputDropdown",
+    "TPMessageBox",
+    "OpenExplorerFolder",
+]
+
 # Standard boilerplate to call the main() function to begin
 # the program.
-if __name__ == '__main__':
+if __name__ == "__main__":
     pass
```

## tpds/tp_utils/tp_keys.py

```diff
@@ -14,25 +14,26 @@
 # PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY
 # KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 
-import os
 import base64
+import os
+
 from cryptography.hazmat.backends import default_backend
-from cryptography.hazmat.primitives.asymmetric import ec
-from cryptography.hazmat.primitives.asymmetric import rsa
 from cryptography.hazmat.primitives import serialization
+from cryptography.hazmat.primitives.asymmetric import ec, rsa
 from pyasn1_modules import pem
+
 from .tp_utils import get_c_hex_bytes
 
 
-class TPSymmetricKey():
+class TPSymmetricKey:
     """This class creates a Symmetric Key and
     writes into a .pem file or bytearray.
     """
 
     def __init__(self, key=None, key_length=32):
         """Constructs required attributes
 
@@ -55,295 +56,286 @@
             ValueError: Value error is raised,
             when the format in the file is not correct or not as expected.
         """
         if isinstance(key, (bytearray, bytes)):
             self.key_bytes = key
         else:
             if key and os.path.exists(key):
-                with open(key, 'r') as f:
+                with open(key, "r") as f:
                     file_content = f.read()
 
-                if 'BEGIN SYMMETRIC KEY' in file_content:
+                if "BEGIN SYMMETRIC KEY" in file_content:
                     key_pem = pem.readPemFromFile(
                         open(key),
-                        startMarker='-----BEGIN SYMMETRIC KEY-----',
-                        endMarker='-----END SYMMETRIC KEY-----')
-                    self.key_bytes = b''
-                    self.key_bytes += (key_pem[17:((key_pem[14] - 2) + 17)])
+                        startMarker="-----BEGIN SYMMETRIC KEY-----",
+                        endMarker="-----END SYMMETRIC KEY-----",
+                    )
+                    self.key_bytes = b""
+                    self.key_bytes += key_pem[17 : ((key_pem[14] - 2) + 17)]
                 else:
-                    raise ValueError('found unknown format in {}'.format(key))
+                    raise ValueError("found unknown format in {}".format(key))
             else:
                 self.key_bytes = os.urandom(key_length)
 
-    def get_c_hex(self, file='', variable_name=''):
+    def get_c_hex(self, file="", variable_name=""):
         """Converts the input to hex bytes, writes to the file
-         and returns the hex bytes variable.
+        and returns the hex bytes variable.
         """
         c_hex_bytes = get_c_hex_bytes(self.key_bytes)
 
         if file:
-            with open(file, 'w') as f:
-                var_name = 'user_secret_key' \
-                    if variable_name == '' else variable_name
-                f.write(f'#ifndef _{var_name.upper()}_H\n')
-                f.write(f'#define _{var_name.upper()}\n\n')
+            with open(file, "w") as f:
+                var_name = "user_secret_key" if variable_name == "" else variable_name
+                f.write(f"#ifndef _{var_name.upper()}_H\n")
+                f.write(f"#define _{var_name.upper()}\n\n")
                 f.write('#include "cryptoauthlib.h"\n\n')
-                f.write('#ifdef __cplusplus\n')
+                f.write("#ifdef __cplusplus\n")
                 f.write('extern "C" {\n')
-                f.write('#endif\n\n')
-                f.write(f'uint8_t {var_name}[] = \n')
-                f.write('{\n'+f'{c_hex_bytes}'+'};\n\n')
-                f.write('#ifdef __cplusplus\n')
-                f.write('}\n')
-                f.write('#endif\n')
-                f.write('#endif\n')
+                f.write("#endif\n\n")
+                f.write(f"uint8_t {var_name}[] = \n")
+                f.write("{\n" + f"{c_hex_bytes}" + "};\n\n")
+                f.write("#ifdef __cplusplus\n")
+                f.write("}\n")
+                f.write("#endif\n")
+                f.write("#endif\n")
 
         return c_hex_bytes
 
-    def get_pem(self, file=''):
+    def get_pem(self, file=""):
         """Writes the symmetric key to the .pem file or into the bytearray.
 
         Args:
             file (str, optional): .pem file. Defaults to ''.
 
         Returns:
             bytearray: After inserting symmetric key.
         """
-        sym_key_der = bytearray.fromhex('304F300906072A8648CE4C030103')
+        sym_key_der = bytearray.fromhex("304F300906072A8648CE4C030103")
         sym_key_der += bytearray([(len(self.key_bytes) + 2), 0x00, 0x04])
         sym_key_der += self.key_bytes
         sym_key_der[1] = len(sym_key_der) - 2
 
-        sym_key_b64 = base64.b64encode(sym_key_der).decode('ascii')
+        sym_key_b64 = base64.b64encode(sym_key_der).decode("ascii")
         sym_key_pem = (
-            '-----BEGIN SYMMETRIC KEY-----\n'
-            + '\n'.join(sym_key_b64[i:i + 64] for i in range(
-                0, len(sym_key_b64), 64)) + '\n'
-            + '-----END SYMMETRIC KEY-----')
+            "-----BEGIN SYMMETRIC KEY-----\n"
+            + "\n".join(sym_key_b64[i : i + 64] for i in range(0, len(sym_key_b64), 64))
+            + "\n"
+            + "-----END SYMMETRIC KEY-----"
+        )
 
         if file:
-            with open(file, 'w') as f:
+            with open(file, "w") as f:
                 f.write(sym_key_pem)
 
         return sym_key_pem
 
     def get_bytes(self):
         return self.key_bytes
 
 
-class TPAsymmetricKey():
-    """Class generates an Asymmetric Key with Private and Public Key pair.
-    """
+class TPAsymmetricKey:
+    """Class generates an Asymmetric Key with Private and Public Key pair."""
 
-    def __init__(self, key='', **key_info):
+    def __init__(self, key="", **key_info):
         self.key_info = key_info
         self.set_private_key(key)
 
-    def set_private_key(self, key='', password=None):
+    def set_private_key(self, key="", password=None):
         """Method generates the private key.
 
         Args:
             key (str, optional): bytearray or .pem file. Defaults to ''.
 
         Raises:
             ValueError: ValueError is raised when expected format is
             not available.
         """
-        if isinstance(key, ec.EllipticCurvePrivateKey) or\
-                isinstance(key, rsa.RSAPrivateKey):
+        if isinstance(key, ec.EllipticCurvePrivateKey) or isinstance(key, rsa.RSAPrivateKey):
             self.private_key = key
 
         elif key and os.path.exists(key):
-            with open(key, 'r') as f:
+            with open(key, "r") as f:
                 file_content = f.read()
 
-            if 'BEGIN PRIVATE KEY' in file_content:
+            if "BEGIN PRIVATE KEY" in file_content:
                 self.private_key = serialization.load_pem_private_key(
-                    data=file_content.encode(),
-                    password=password,
-                    backend=default_backend())
+                    data=file_content.encode(), password=password, backend=default_backend()
+                )
             else:
-                raise ValueError('found unknown format in {}'.format(key))
+                raise ValueError("found unknown format in {}".format(key))
         else:
             # Generates key pair based on the algorithm argument
-            if self.key_info.get('algo') == 'RSA':
-                if self.key_info.get('size') == 1024 or \
-                        self.key_info.get('size') == 2048 or\
-                        self.key_info.get('size') == 3072:
+            if self.key_info.get("algo") == "RSA":
+                if (
+                    self.key_info.get("size") == 1024
+                    or self.key_info.get("size") == 2048
+                    or self.key_info.get("size") == 3072
+                ):
                     self.private_key = rsa.generate_private_key(
-                        public_exponent=65537,
-                        key_size=self.key_info.get('size'))
+                        public_exponent=65537, key_size=self.key_info.get("size")
+                    )
                 else:
                     raise ("Invalid RSA key size")
 
-            elif self.key_info.get('algo') == 'ECC':
-                if self.key_info.get('size') == 'secp256r1':
-                    self.private_key = ec.generate_private_key(
-                        ec.SECP256R1(),
-                        default_backend())
-                elif self.key_info.get('size') == 'secp224r1':
-                    self.private_key = ec.generate_private_key(
-                        ec.SECP224R1(),
-                        default_backend())
-                elif self.key_info.get('size') == 'secp384r1':
-                    self.private_key = ec.generate_private_key(
-                        ec.SECP384R1(),
-                        default_backend())
-                elif self.key_info.get('size') == 'secp256k1':
-                    self.private_key = ec.generate_private_key(
-                        ec.SECP256K1(),
-                        default_backend())
+            elif self.key_info.get("algo") == "ECC":
+                if self.key_info.get("size") == "secp256r1":
+                    self.private_key = ec.generate_private_key(ec.SECP256R1(), default_backend())
+                elif self.key_info.get("size") == "secp224r1":
+                    self.private_key = ec.generate_private_key(ec.SECP224R1(), default_backend())
+                elif self.key_info.get("size") == "secp384r1":
+                    self.private_key = ec.generate_private_key(ec.SECP384R1(), default_backend())
+                elif self.key_info.get("size") == "secp256k1":
+                    self.private_key = ec.generate_private_key(ec.SECP256K1(), default_backend())
                 else:
                     raise ("Invalid ECC Curve type")
 
             else:
-                '''Generate default keypair ECC-SECP256R1
-                '''
-                self.private_key = ec.generate_private_key(
-                    ec.SECP256R1(), default_backend())
+                """Generate default keypair ECC-SECP256R1"""
+                self.private_key = ec.generate_private_key(ec.SECP256R1(), default_backend())
 
-        if self.key_info.get('algo') == 'RSA':
+        if self.key_info.get("algo") == "RSA":
             public_key = self.private_key.public_key().public_numbers()
-            self.public_key_bytes = bytearray(public_key.n.to_bytes(
-                int(self.key_info.get('size')/8), 'big'))
+            self.public_key_bytes = bytearray(
+                public_key.n.to_bytes(int(self.key_info.get("size") / 8), "big")
+            )
         else:
-            self.public_key_bytes = self.private_key.public_key(
-                ).public_bytes(
-                    serialization.Encoding.X962,
-                    serialization.PublicFormat.UncompressedPoint)[1:]
+            self.public_key_bytes = self.private_key.public_key().public_bytes(
+                serialization.Encoding.X962, serialization.PublicFormat.UncompressedPoint
+            )[1:]
 
-    def set_public_key(self, key=''):
+    def set_public_key(self, key=""):
         """Method generates the public key.
 
         Args:
             key (str, optional): bytearray or .pem file. Defaults to ''.
 
         Raises:
             ValueError: ValueError is raised when expected format is not
             available.
         """
         if isinstance(key, (bytearray, bytes)):
             self.public_key_bytes = key
             self.private_key = None
         elif isinstance(key, ec.EllipticCurvePublicKey):
             self.public_key_bytes = key.public_bytes(
-                serialization.Encoding.X962,
-                serialization.PublicFormat.UncompressedPoint)[1:]
+                serialization.Encoding.X962, serialization.PublicFormat.UncompressedPoint
+            )[1:]
         elif key and os.path.exists(key):
-            with open(key, 'r') as f:
+            with open(key, "r") as f:
                 file_content = f.read()
 
-            if 'BEGIN PUBLIC KEY' in file_content:
+            if "BEGIN PUBLIC KEY" in file_content:
                 self.private_key = None
-                with open(key, 'rb') as f:
+                with open(key, "rb") as f:
                     public_key = serialization.load_pem_public_key(
-                        data=f.read(),
-                        backend=default_backend())
+                        data=f.read(), backend=default_backend()
+                    )
                     self.public_key_bytes = public_key.public_bytes(
-                        serialization.Encoding.X962,
-                        serialization.PublicFormat.UncompressedPoint)[1:]
+                        serialization.Encoding.X962, serialization.PublicFormat.UncompressedPoint
+                    )[1:]
             else:
-                raise ValueError('found unknown format in {}'.format(key))
+                raise ValueError("found unknown format in {}".format(key))
         else:
-            raise ValueError('key is not found in {}'.format(key))
+            raise ValueError("key is not found in {}".format(key))
 
     def get_private_key(self):
         return self.private_key
 
-    def get_private_pem(self, file=''):
+    def get_private_pem(self, file=""):
         if self.private_key is None:
-            raise ValueError('Private key is not available')
+            raise ValueError("Private key is not available")
 
         private_pem = self.private_key.private_bytes(
             encoding=serialization.Encoding.PEM,
             format=serialization.PrivateFormat.PKCS8,
-            encryption_algorithm=serialization.NoEncryption())
+            encryption_algorithm=serialization.NoEncryption(),
+        )
 
         if file:
-            with open(file, 'wb') as f:
+            with open(file, "wb") as f:
                 f.write(private_pem)
 
-        return str(private_pem, 'utf-8')
+        return str(private_pem, "utf-8")
 
-    def get_public_c_hex(self, file='', variable_name=''):
+    def get_public_c_hex(self, file="", variable_name=""):
         c_hex_bytes = get_c_hex_bytes(self.public_key_bytes)
 
         if file:
-            with open(file, 'w') as f:
-                var_name = 'user_public_key' \
-                    if variable_name == '' else variable_name
-                variable_declaration = 'uint8_t ' + str(var_name) + '[] = {\n'
+            with open(file, "w") as f:
+                var_name = "user_public_key" if variable_name == "" else variable_name
+                variable_declaration = "uint8_t " + str(var_name) + "[] = {\n"
                 f.write(variable_declaration)
                 f.write(c_hex_bytes)
-                f.write('};')
+                f.write("};")
 
         return c_hex_bytes
 
-    def get_public_pem(self, file=''):
-        public_key_der = bytearray.fromhex(
-            '3059301306072A8648CE3D020106082A8648CE3D03010703420004')
+    def get_public_pem(self, file=""):
+        public_key_der = bytearray.fromhex("3059301306072A8648CE3D020106082A8648CE3D03010703420004")
         public_key_der += self.public_key_bytes
-        public_key_b64 = base64.b64encode(public_key_der).decode('ascii')
+        public_key_b64 = base64.b64encode(public_key_der).decode("ascii")
         public_key_pem = (
-            '-----BEGIN PUBLIC KEY-----\n'
-            + '\n'.join(public_key_b64[i:i + 64] for i in range(
-                0, len(public_key_b64), 64)) + '\n'
-            + '-----END PUBLIC KEY-----'
+            "-----BEGIN PUBLIC KEY-----\n"
+            + "\n".join(public_key_b64[i : i + 64] for i in range(0, len(public_key_b64), 64))
+            + "\n"
+            + "-----END PUBLIC KEY-----"
         )
 
         if file:
-            with open(file, 'w') as f:
+            with open(file, "w") as f:
                 f.write(public_key_pem)
 
         return public_key_pem
 
     def get_public_key(self):
         if self.private_key:
             public_key = self.private_key.public_key()
         else:
             public_key = serialization.load_pem_public_key(
-                data=self.get_public_pem(),
-                backend=default_backend())
+                data=self.get_public_pem(), backend=default_backend()
+            )
 
         return public_key
 
     def get_public_key_bytes(self):
         return self.public_key_bytes
-            
 
     def get_private_key_bytes(self):
         ecc_key_size = {
-            'secp256r1': ec.SECP256R1.key_size,
-            'secp224r1': ec.SECP224R1.key_size,
-            'secp384r1': ec.SECP384R1.key_size,
-            'secp256k1': ec.SECP256K1.key_size
+            "secp256r1": ec.SECP256R1.key_size,
+            "secp224r1": ec.SECP224R1.key_size,
+            "secp384r1": ec.SECP384R1.key_size,
+            "secp256k1": ec.SECP256K1.key_size,
         }
 
         if self.private_key is None:
-            raise ValueError('Private key is not available')
+            raise ValueError("Private key is not available")
 
-        if self.key_info.get('algo') == 'RSA':
+        if self.key_info.get("algo") == "RSA":
             private = self.private_key.private_numbers()
-            private_key_p = bytearray(private.p.to_bytes(
-                int((self.key_info.get('size')/8)/2), 'big'))
-            private_key_q = bytearray(private.q.to_bytes(
-                int((self.key_info.get('size')/8)/2), 'big'))
+            private_key_p = bytearray(
+                private.p.to_bytes(int((self.key_info.get("size") / 8) / 2), "big")
+            )
+            private_key_q = bytearray(
+                private.q.to_bytes(int((self.key_info.get("size") / 8) / 2), "big")
+            )
             return private_key_p + private_key_q
 
-        elif self.key_info.get('algo') == 'ECC':
-            return bytearray(self.private_key.private_numbers().
-                             private_value.to_bytes(
-                             int(ecc_key_size.get(
-                                 self.key_info.get('size'))/8),
-                                 'big'))
+        elif self.key_info.get("algo") == "ECC":
+            return bytearray(
+                self.private_key.private_numbers().private_value.to_bytes(
+                    int(ecc_key_size.get(self.key_info.get("size")) / 8), "big"
+                )
+            )
 
         else:
-            return bytearray(self.private_key.private_numbers().
-                             private_value.to_bytes(
-                             int(ecc_key_size.get('secp256r1')/8),
-                             'big'))
+            return bytearray(
+                self.private_key.private_numbers().private_value.to_bytes(
+                    int(ecc_key_size.get("secp256r1") / 8), "big"
+                )
+            )
 
 
 # Standard boilerplate to call the main() function to begin
 # the program.
-if __name__ == '__main__':
+if __name__ == "__main__":
     pass
```

## tpds/tp_utils/tp_print.py

```diff
@@ -14,39 +14,39 @@
 # PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY
 # KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 
-import io
 import builtins
+import io
 
 
 def print(*args, **kwargs):
-    """A method that redirects the statements either onto terminal 
+    """A method that redirects the statements either onto terminal
     or onto the canvas based on the arguments provided.
 
-    If an attribute called canvas is passed to this function, 
+    If an attribute called canvas is passed to this function,
     prints to terminal and also to the canvas.
 
     Else prints only onto the terminal.
     """
-    canvas = kwargs.get('canvas', None)
-    if 'canvas' in kwargs:
-        kwargs.pop('canvas')
+    canvas = kwargs.get("canvas", None)
+    if "canvas" in kwargs:
+        kwargs.pop("canvas")
     if canvas:
         output = io.StringIO()
-        if kwargs.get('end') is not None:
+        if kwargs.get("end") is not None:
             builtins.print(*args, file=output, **kwargs)
         else:
-            builtins.print(*args, file=output, **kwargs, end='')
+            builtins.print(*args, file=output, **kwargs, end="")
         contents = output.getvalue()
         output.close()
         canvas.print_message(contents)
     builtins.print(*args, **kwargs)
 
 
 # Standard boilerplate to call the main() function to begin
 # the program.
-if __name__ == '__main__':
+if __name__ == "__main__":
     pass
```

## tpds/tp_utils/tp_settings.py

```diff
@@ -14,83 +14,75 @@
 # PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY
 # KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 import os
-from pathlib import Path
-import json
 import platform
+
 from tpds.settings import TrustPlatformSettings
 
 
-class TPSettings():
+class TPSettings:
     def __init__(self):
         self.__tp_settings = TrustPlatformSettings(log_enable=False)
 
     def get_mplab_paths(self):
         mplab_paths = {}
-        if (self.__tp_settings.settings.mplab_path is not None and os.path.exists(self.__tp_settings.settings.mplab_path)):
+        if self.__tp_settings.settings.mplab_path is not None and os.path.exists(
+            self.__tp_settings.settings.mplab_path
+        ):
             mplab_path = self.__tp_settings.settings.mplab_path
-            mplab_paths.update({'mplab_path': mplab_path})
-            jar_dir_path = os.path.join(
-                                mplab_path,
-                                "mplab_platform",
-                                "mplab_ipe")
-            java_dir_path = os.path.join(mplab_path, 'sys')
-            if platform.system().lower() == 'darwin':
-                jar_loc = self.__get_file_path('ipecmd.sh', jar_dir_path)
-                java_loc = self.__get_file_path('java', java_dir_path)
+            mplab_paths.update({"mplab_path": mplab_path})
+            jar_dir_path = os.path.join(mplab_path, "mplab_platform", "mplab_ipe")
+            java_dir_path = os.path.join(mplab_path, "sys")
+            if platform.system().lower() == "darwin":
+                jar_loc = self.__get_file_path("ipecmd.sh", jar_dir_path)
+                java_loc = self.__get_file_path("java", java_dir_path)
                 ide_path = self.__get_file_path(
-                                    'mplab_ide',
-                                    os.path.join(
-                                        mplab_path,
-                                        'mplab_platform', 'bin'))
-            elif platform.system().lower() == 'linux':
-                jar_loc = self.__get_file_path('ipecmd.jar', jar_dir_path)
-                java_loc = self.__get_file_path('java', java_dir_path)
+                    "mplab_ide", os.path.join(mplab_path, "mplab_platform", "bin")
+                )
+            elif platform.system().lower() == "linux":
+                jar_loc = self.__get_file_path("ipecmd.jar", jar_dir_path)
+                java_loc = self.__get_file_path("java", java_dir_path)
                 ide_path = self.__get_file_path(
-                                    'mplab_ide',
-                                    os.path.join(
-                                        mplab_path,
-                                        'mplab_platform', 'bin'))
+                    "mplab_ide", os.path.join(mplab_path, "mplab_platform", "bin")
+                )
             else:
-                jar_loc = self.__get_file_path('ipecmd.jar', jar_dir_path)
-                java_loc = self.__get_file_path('java.exe', java_dir_path)
+                jar_loc = self.__get_file_path("ipecmd.jar", jar_dir_path)
+                java_loc = self.__get_file_path("java.exe", java_dir_path)
                 ide_path = self.__get_file_path(
-                                    'mplab_ide64.exe',
-                                    os.path.join(
-                                        mplab_path,
-                                        'mplab_platform', 'bin'))
-            mplab_paths.update({'jar_loc': jar_loc})
-            mplab_paths.update({'java_loc': java_loc})
-            mplab_paths.update({'ide_path': ide_path})
+                    "mplab_ide64.exe", os.path.join(mplab_path, "mplab_platform", "bin")
+                )
+            mplab_paths.update({"jar_loc": jar_loc})
+            mplab_paths.update({"java_loc": java_loc})
+            mplab_paths.update({"ide_path": ide_path})
 
         return mplab_paths
 
     def get_tpds_core_path(self):
         return self.__tp_settings.settings.local_path
 
     def get_active_board(self):
         return self.__tp_settings.runtime_settings.active_board.lower()
 
     def get_base_folder(self):
         return self.__tp_settings.settings.home_path
 
     def __get_file_path(self, file_name, dir_path):
         file_loc = None
-        for (root, dirs, files) in os.walk(dir_path):
+        for root, dirs, files in os.walk(dir_path):
             if file_name in files:
                 if os.path.exists(os.path.join(root, file_name)):
                     file_loc = os.path.join(root, file_name)
 
         # if file_loc is None:
         #     raise FileNotFoundError("{} is not found".format(file_name))
 
         return file_loc
 
 
 # Standard boilerplate to call the main() function to begin
 # the program.
-if __name__ == '__main__':
+if __name__ == "__main__":
     pass
```

## tpds/tp_utils/tp_utils.py

```diff
@@ -17,19 +17,20 @@
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 
 import struct
 import subprocess
 from collections import namedtuple
+from zipfile import ZipFile
+
 import cryptography
-from cryptography.hazmat.primitives.asymmetric import ec, utils
 from cryptography.hazmat.primitives import hashes
+from cryptography.hazmat.primitives.asymmetric import ec, utils
 from cryptography.utils import int_to_bytes
-from zipfile import ZipFile
 
 
 def run_subprocess_cmd(cmd, sys_shell=False, sys_newlines=True):
     """
     Runs a command on ternimal/command prompt. Uses subprocess module.
 
     Inputs:
@@ -53,54 +54,51 @@
         subProcessOut = syshelper.run_subprocess_cmd(
             [sys.executable, "test.py", "-f", "sheet.csv"])
         print(subProcessOut.stdout)
         print(subProcessOut.stderr)
         print(subProcessOut.returncode)
     """
     proc = subprocess.Popen(
-            cmd,
-            stdout=subprocess.PIPE,
-            stderr=subprocess.PIPE,
-            universal_newlines=sys_newlines,
-            shell=sys_shell
+        cmd,
+        stdout=subprocess.PIPE,
+        stderr=subprocess.PIPE,
+        universal_newlines=sys_newlines,
+        shell=sys_shell,
     )
     stdout, stderr = proc.communicate()
-    subProcessOut = namedtuple(
-        "subProcessOut",
-        ['returncode', 'stdout', 'stderr'])
+    subProcessOut = namedtuple("subProcessOut", ["returncode", "stdout", "stderr"])
     return subProcessOut(proc.returncode, stdout, stderr)
 
 
-def pretty_print_hex(a, li=16, indent=''):
+def pretty_print_hex(a, li=16, indent=""):
     """
     Format a list/bytes/bytearray object into a formatted ascii hex string
     """
     lines = []
     a = bytearray(a)
     for x in range(0, len(a), li):
-        lines.append(indent + ' '.join([
-            '{:02X}'.format(y) for y in a[x:x+li]]))
-    return '\n'.join(lines)
+        lines.append(indent + " ".join(["{:02X}".format(y) for y in a[x : x + li]]))
+    return "\n".join(lines)
 
 
 def get_c_hex_bytes(value):
     """
     Convert the given input into hex bytes
     Inputs:
             value          value input which converted into hex bytes
     Outputs:
             hex_bytes      converted hex bytes
     """
-    hex_bytes = ''
+    hex_bytes = ""
     for x in range(0, len(value), 16):
-        hex_bytes += (''.join(['0x%02X, ' % y for y in value[x:x+16]]) + '\n')
+        hex_bytes += "".join(["0x%02X, " % y for y in value[x : x + 16]]) + "\n"
     return hex_bytes
 
 
-def pretty_xml_hex_array(data, indent='            ', bytes_per_line=32):
+def pretty_xml_hex_array(data, indent="            ", bytes_per_line=32):
     """
     Convert the data into print format for provisioning XML
 
     Args:
         data (str): original data to be formatted
         indent (str, optional): Indentation to add for alignment.
                         Defaults to '            '.
@@ -108,19 +106,18 @@
                         Defaults to 32.
 
     Returns:
         [str]: Formatted data to insert in XML
     """
     lines = []
     for i in range(0, len(data), bytes_per_line):
-        line_data = ''.join([f'{v}' for v in data[i:i+bytes_per_line]])
-        line_data = ' '.join(line_data[i:i+2] for i in range(
-            0, len(line_data), 2))
+        line_data = "".join([f"{v}" for v in data[i : i + bytes_per_line]])
+        line_data = " ".join(line_data[i : i + 2] for i in range(0, len(line_data), 2))
         lines.append(indent + line_data)
-    return '\n'.join(lines)
+    return "\n".join(lines)
 
 
 def sign_on_host(digest, private_key):
     """
     Sign the digest using private key
     Inputs:
           digest         digest to be signed
@@ -130,23 +127,22 @@
     """
     if len(digest) is not int(32):
         raise ValueError("Digest must be 32 bytes")
 
     if not isinstance(private_key, ec.EllipticCurvePrivateKey):
         raise ValueError("Invalid private key received")
 
-    signature = private_key.sign(digest, ec.ECDSA(
-        utils.Prehashed(hashes.SHA256())))
+    signature = private_key.sign(digest, ec.ECDSA(utils.Prehashed(hashes.SHA256())))
     (r, s) = utils.decode_dss_signature(signature)
     signature = int_to_bytes(r, 32) + int_to_bytes(s, 32)
 
     return signature
 
 
-def extract_zip_archive(zip_archive, dest_folder=''):
+def extract_zip_archive(zip_archive, dest_folder=""):
     """
     Extracts the files from zip_archive to store in dest_folder
 
     Args:
         zip_archive (Path): Zip file path to extract
         dest_folder (str, optional): Destination folder to save the files
                                         . Defaults to ''.
@@ -159,15 +155,15 @@
     """
     Adds files from list provided to zip_archive
 
     Args:
         zip_archive ([type]): Zip file path to add the files
         files (list, optional): list of files to add to Zip. Defaults to [].
     """
-    with ZipFile(zip_archive, 'w') as zf:
+    with ZipFile(zip_archive, "w") as zf:
         for file in files:
             zf.write(file)
 
 
 def calculate_wpc_digests(root_bytes, mfg_bytes, puc_bytes):
     """
     Calculates WPC Chain digest based on root, mfg and puc bytes
@@ -182,18 +178,27 @@
     hash_backend = cryptography.hazmat.backends.default_backend()
 
     root_hash = hashes.Hash(hashes.SHA256(), backend=hash_backend)
     root_hash.update(root_bytes)
     root_digest = root_hash.finalize()[:32]
 
     length = 2 + len(root_digest) + len(mfg_bytes) + len(puc_bytes)
-    cert_chain = b''
-    cert_chain += struct.pack('>H', length)
+    cert_chain = b""
+    cert_chain += struct.pack(">H", length)
     cert_chain += root_digest + mfg_bytes + puc_bytes
     chain_hash = hashes.Hash(hashes.SHA256(), backend=hash_backend)
     chain_hash.update(cert_chain)
     chain_digest = chain_hash.finalize()[:32]
 
-    return {
-        'root_digest': root_digest,
-        'chain_digest': chain_digest
-    }
+    return {"root_digest": root_digest, "chain_digest": chain_digest}
+
+
+__all__ = [
+    "run_subprocess_cmd",
+    "pretty_print_hex",
+    "get_c_hex_bytes",
+    "pretty_xml_hex_array",
+    "sign_on_host",
+    "extract_zip_archive",
+    "add_to_zip_archive",
+    "calculate_wpc_digests",
+]
```

## tpds/usecase_diagram/__init__.py

```diff
@@ -1,9 +1,25 @@
 """
     Trust Platform core package - usecase_diagram module
 """
-from .popup import *
-from .terminal import *
-from .canvas import *
-from .usecase_diagram import *
-from .menu_icons import *
-from .proto_boards import *
+from .canvas import CanvasFirmware, CanvasImage, CanvasLink, CanvasScript, CanvasTop, ErrorPopUp
+from .menu_icons import MenuIcons
+from .popup import CloseWindow, Popup
+from .proto_boards import ProtoBoard
+from .terminal import Terminal
+from .usecase_diagram import OpenDiagram, UsecaseDiagram
+
+__all__ = [
+    "CanvasTop",
+    "CanvasLink",
+    "CanvasImage",
+    "CanvasScript",
+    "CanvasFirmware",
+    "ErrorPopUp",
+    "MenuIcons",
+    "CloseWindow",
+    "Popup",
+    "ProtoBoard",
+    "Terminal",
+    "UsecaseDiagram",
+    "OpenDiagram",
+]
```

## tpds/usecase_diagram/canvas.py

```diff
@@ -1,20 +1,23 @@
 import os
 import shutil
-from pathlib import Path
+import subprocess
+import sys
 import traceback
+from pathlib import Path
+
 from ipywidgets import Image
-from .popup import Popup
-import sys
-import subprocess
 from pygments import formatters, highlight, lexers
+
 from tpds.tp_utils import Client
 
+from .popup import Popup
+
 
-class CanvasTop():
+class CanvasTop:
     """A class to hold buttons list and canvas layer for popup window.
 
     Buttons list includes image, link and script button areas,
     along with a special button to close popup window.
 
     """
 
@@ -24,16 +27,16 @@
         Args:
             canvas (canvas): The main canvas to interact with.
             layer (int): a canvas layer value for the popup window.
                         (Multicanvas has layers based on input)
         """
         self.t_canvas = canvas
         self.canvas = canvas[layer]
-        self.centerX = canvas.width/2
-        self.centerY = canvas.height/2
+        self.centerX = canvas.width / 2
+        self.centerY = canvas.height / 2
         self.click_list = list()
         self.close_list = list()
         self.canvas.on_mouse_down(self.on_click_check)
         if enable_coord:
             self.output = output
             self.canvas.on_mouse_move(self.on_mouse_move)
 
@@ -47,30 +50,26 @@
                         when mouse click event happens.
             y (int): y coordinate w.r.t the canvas is returned
                         when mouse click event happens.
         """
         if self.close_list[0].is_selected(x, y):
             self.close_list[0].render()
         else:
-            sel = [button for button in self.click_list if button.is_selected(
-                x, y)]
-            if (sel):
+            sel = [button for button in self.click_list if button.is_selected(x, y)]
+            if sel:
                 self.canvas.clear()
                 sel[0].render()
 
     def on_mouse_move(self, x, y):
         with self.output.log:
-            print(
-                f'Mouse Coordinates: {round(x):04d}:{round(y):04d}',
-                end='\r')
+            print(f"Mouse Coordinates: {round(x):04d}:{round(y):04d}", end="\r")
 
 
-class CanvasLink():
-    """Adds a link object on canvas.
-    """
+class CanvasLink:
+    """Adds a link object on canvas."""
 
     def __init__(self, x, y, width, height, link, canvas):
         """Constructs required attributes
 
         Args:
             x (int): x coordinate w.r.t canvas to place the link.
             y (int): y coordinate w.r.t canvas to place the link.
@@ -84,16 +83,15 @@
         self.width = width
         self.height = height
         self.link = link
         self.canvas = canvas
         self.canvas.on_client_ready(self.layout)
 
     def layout(self):
-        """Layout the button to distinguish as a link.
-        """
+        """Layout the button to distinguish as a link."""
         # self.canvas[1].stroke_style = 'blue'
         # self.canvas[1].shadow_offset_x = 0
         # self.canvas[1].shadow_offset_y = 0
         # self.canvas[1].shadow_blur = 0
         # self.canvas[1].begin_path()
         # self.canvas[1].line_width = 3
         # self.canvas[1].move_to(self.x, self.y+self.height)
@@ -107,33 +105,31 @@
         Args:
             x_in (int): x coordinate w.r.t mouse click event is returned.
             y_in (int): y coordinate w.r.t mouse click event is returned.
 
         Returns:
             bool: True if the link button is clicked, else False.
         """
-        return (
-            ((x_in > self.x) and (x_in < (self.x + self.width)))
-            and ((y_in > self.y) and (y_in < (self.y + self.height))))
+        return ((x_in > self.x) and (x_in < (self.x + self.width))) and (
+            (y_in > self.y) and (y_in < (self.y + self.height))
+        )
 
     def render(self):
-        """If a link object is clicked, respective URL is opened.
-        """
+        """If a link object is clicked, respective URL is opened."""
         self.client = Client(None)
         self.open_link()
         self.client.client.recv()
         self.client.client.close()
 
     def open_link(self):
-        self.client.send_message('open_link', [self.link])
+        self.client.send_message("open_link", [self.link])
 
 
-class CanvasImage():
-    """Adds an image object button on canvas.
-    """
+class CanvasImage:
+    """Adds an image object button on canvas."""
 
     def __init__(self, x, y, width, height, image, title, canvas):
         """Constructs required attributes.
 
         Args:
             x (int): x coordinate w.r.t canvas to place the image button.
             y (int): y coordinate w.r.t canvas to place the image button.
@@ -150,16 +146,15 @@
         self.image = image
         self.canvas = canvas
         self.popup = Popup(title, self.canvas[3])
         self.canvas.on_client_ready(self.layout)
         self.val = 20
 
     def layout(self):
-        """Layout of the image button.
-        """
+        """Layout of the image button."""
         # self.canvas[1].stroke_style = '#2bff00'
         # self.canvas[1].line_width = 3
         # self.canvas[1].line_join = 'round'
         # self.canvas[1].shadow_color = 'black'
         # self.canvas[1].shadow_offset_x = 1
         # self.canvas[1].shadow_offset_y = 1
         # self.canvas[1].shadow_blur = 1
@@ -189,31 +184,40 @@
         Args:
             x_in (int): x coordinate w.r.t mouse click event is returned.
             y_in (int): y coordinate w.r.t mouse click event is returned.
 
         Returns:
             bool: True if the image button is clicked, else False.
         """
-        return (
-            ((x_in > self.x) and (x_in < (self.x + self.width)))
-            and ((y_in > self.y) and (y_in < (self.y + self.height))))
+        return ((x_in > self.x) and (x_in < (self.x + self.width))) and (
+            (y_in > self.y) and (y_in < (self.y + self.height))
+        )
 
     def render(self):
-        """When clicked, the button's corresponding image is poped up.
-        """
+        """When clicked, the button's corresponding image is poped up."""
         self.popup.draw_image(self.image)
 
 
-class CanvasScript():
-    """Adds a script button on the canvas.
-    """
+class CanvasScript:
+    """Adds a script button on the canvas."""
 
     def __init__(
-            self, x, y, width, height, call_back, output, canvas,
-            canvas_top, prereq_scripts, index, working_dir=None):
+        self,
+        x,
+        y,
+        width,
+        height,
+        call_back,
+        output,
+        canvas,
+        canvas_top,
+        prereq_scripts,
+        index,
+        working_dir=None,
+    ):
         """Constructs required attributes.
 
         Args:
             x (int): x coordinate w.r.t canvas to place the script button.
             y (int): y coordinate w.r.t canvas to place the script button.
             width (int): Width of the button.
             height (int): Height of the button.
@@ -236,16 +240,15 @@
         self.prereq_scripts = prereq_scripts
         self.index = index
         self.exec_status = False
         self.canvas.on_client_ready(self.layout)
         self.working_dir = working_dir
 
     def layout(self):
-        """Layouting the script button.
-        """
+        """Layouting the script button."""
         # self.canvas[1].stroke_style = '#e40222'
         # self.canvas[1].line_width = 3
         # self.canvas[1].line_join = 'round'
         # self.canvas[1].shadow_color = 'black'
         # self.canvas[1].shadow_offset_x = 1
         # self.canvas[1].shadow_offset_y = 1
         # self.canvas[1].shadow_blur = 1
@@ -273,152 +276,151 @@
         Args:
             x_in (int): x coordinate w.r.t mouse click event is returned.
             y_in (int): y coordinate w.r.t mouse click event is returned.
 
         Returns:
             bool: True if the script button is clicked, else False.
         """
-        return (
-            ((x_in > self.x) and (x_in < (self.x + self.width)))
-            and ((y_in > self.y) and (y_in < (self.y + self.height))))
+        return ((x_in > self.x) and (x_in < (self.x + self.width))) and (
+            (y_in > self.y) and (y_in < (self.y + self.height))
+        )
 
     def prGreen(self, m):
         """Changes the print statement color to green.
 
         Args:
             m (str): Statement to apply the change.
         """
-        print("\033[1;32;47m{}\033[00m" .format(m))
+        print("\033[1;32;47m{}\033[00m".format(m))
 
     def prRed(self, m):
         """Changes the print statement color to red.
 
         Args:
             m (str): Statement to apply the change.
         """
-        print("\033[1;31;47m{}\033[00m" .format(m))
+        print("\033[1;31;47m{}\033[00m".format(m))
 
     def render(self):
         """When any script button is clicked,
         render method is invoked to call corresponding function.
         """
         with self.output.log:
-            self.popup = Popup(
-                'Step {} Execution Status'.format(str(self.index)),
-                self.canvas[3])
+            self.popup = Popup("Step {} Execution Status".format(str(self.index)), self.canvas[3])
             self.errorpopup = ErrorPopUp(self.popup)
-            script_list = [btn for btn in self.canv_top.click_list if (
-                (hasattr(btn, 'exec_status')))]
-            depend_list = [btn for btn in script_list if (
-                self in btn.prereq_scripts)]
+            script_list = [
+                btn for btn in self.canv_top.click_list if ((hasattr(btn, "exec_status")))
+            ]
+            depend_list = [btn for btn in script_list if (self in btn.prereq_scripts)]
             try:
-                is_allowed = all(
-                    [temp.exec_status for temp in self.prereq_scripts])
+                is_allowed = all([temp.exec_status for temp in self.prereq_scripts])
                 if is_allowed:
                     self.step_status_clear(self)
                     curr_dir = os.getcwd()
                     os.chdir(self.working_dir)
                     self.call_back(b=None)
                     os.chdir(curr_dir)
                     self.exec_status = True
                     # self.popup.print_message(
                     #     'Step Completed, Proceed to next step')
                     self.step_status_complete(self)
                     for script in depend_list:
                         self.clear_execution(script)
                     all_exec_status = [
-                        tot.exec_status for tot in script_list
-                        if (tot.exec_status is False)]
+                        tot.exec_status for tot in script_list if (tot.exec_status is False)
+                    ]
                     if not all_exec_status:
                         self.prGreen("Usecase Execution is Completed\n")
                         # self.popup.usecase_complete('done_icon.png')
                 else:
-                    str_val = f'Step{self.index} can\'t be executed before '
+                    str_val = f"Step{self.index} can't be executed before "
                     for script in self.prereq_scripts:
                         if not script.exec_status:
-                            str_val += 'Step'+str(script.index)+'\n'
+                            str_val += "Step" + str(script.index) + "\n"
                     self.errorpopup.traceback_print(str_val, footer=False)
             except Exception:
-                self.prRed(
-                    "\nError while executing Step-{}".format(str(self.index)))
+                self.prRed("\nError while executing Step-{}".format(str(self.index)))
                 # traceback.print_exc()
                 tb_text = "".join(traceback.format_exc())
 
                 lexer = lexers.get_lexer_by_name("pytb", stripall=True)
                 formatter = formatters.get_formatter_by_name("terminal256")
                 tb_colored = highlight(tb_text, lexer, formatter)
 
                 print(tb_colored)
                 exc_type, exc_value, exc_tb = sys.exc_info()
                 tb = traceback.TracebackException(exc_type, exc_value, exc_tb)
-                self.errorpopup.traceback_print(
-                    ''.join(tb.format_exception_only()))
+                self.errorpopup.traceback_print("".join(tb.format_exception_only()))
                 for script in depend_list:
                     self.clear_execution(script)
         os.chdir(curr_dir)
 
     def step_status_complete(self, current_script):
         """Changes the execution state of the script object after execution.
 
         Args:
             current_script (object): Script button object.
         """
-        self.prGreen(
-            'Executed Step-{} '.format(str(current_script.index))
-            + 'Successfully\n')
+        self.prGreen("Executed Step-{} ".format(str(current_script.index)) + "Successfully\n")
         curr_path = os.path.abspath(os.path.dirname(__file__))
-        px = current_script.x+5
+        px = current_script.x + 5
         py = current_script.y
         self.canvas[2].draw_image(
-            Image.from_file(os.path.join(
-                curr_path, 'done_icon.png')), px, py, 30, 30)
+            Image.from_file(os.path.join(curr_path, "done_icon.png")), px, py, 30, 30
+        )
         # self.canvas[2].stroke_style = '#4BB543'
         # self.canvas[2].line_width = 3
         # self.canvas[2].stroke_rect(
         #     current_script.x, current_script.y,
         #     current_script.width, current_script.height)
 
     def step_status_clear(self, current_script):
         """Clears the layout of the script button to default.
 
         Args:
             current_script (object): Script button object.
         """
         self.canvas[2].clear_rect(
-            current_script.x-2, current_script.y-2,
-            current_script.width+4, current_script.height+4)
+            current_script.x - 2,
+            current_script.y - 2,
+            current_script.width + 4,
+            current_script.height + 4,
+        )
 
     def clear_execution(self, current_script):
         """Clears the execution state to default when Reset button is clicked.
 
         Args:
             current_script (object): Script button object.
         """
-        px = current_script.x+current_script.width-30
+        px = current_script.x + current_script.width - 30
         py = current_script.y + 5
         self.canvas[2].clear_rect(px, py, 25, 25)
         self.canvas[2].clear_rect(
-            current_script.x-2, current_script.y-2,
-            current_script.width+4, current_script.height+4)
+            current_script.x - 2,
+            current_script.y - 2,
+            current_script.width + 4,
+            current_script.height + 4,
+        )
         current_script.exec_status = False
-        script_list = [btn for btn in self.canv_top.click_list if (
-            (hasattr(btn, 'exec_status')
-                and (current_script in btn.prereq_scripts)))]
+        script_list = [
+            btn
+            for btn in self.canv_top.click_list
+            if ((hasattr(btn, "exec_status") and (current_script in btn.prereq_scripts)))
+        ]
         for script in script_list:
             self.clear_execution(script)
 
 
-class CanvasFirmware():
-    """Adds a script button on the canvas.
-    """
+class CanvasFirmware:
+    """Adds a script button on the canvas."""
 
     def __init__(
-            self, x, y, canvas, canvas_top,
-            cb_project_path, mplab_ide_path=None,
-            working_dir=None):
+        self, x, y, canvas, canvas_top, cb_project_path, mplab_ide_path=None, working_dir=None
+    ):
         """Constructs required attributes.
 
         Args:
             x (int): x coordinate w.r.t canvas to place the script button.
             y (int): y coordinate w.r.t canvas to place the script button.
             canvas (canvas): canvas object
             canvas_top (canvas): canvas top class object
@@ -433,16 +435,15 @@
         self.cancas_top = canvas_top
         self.cb_project_path = cb_project_path
         self.mplab_ide_path = mplab_ide_path
         self.working_dir = working_dir
         self.canvas.on_client_ready(self.layout)
 
     def layout(self):
-        """Layouting the script button.
-        """
+        """Layouting the script button."""
         # curr_path = os.path.abspath(os.path.dirname(__file__))
         # self.canvas[1].draw_image(
         #     Image.from_file(os.path.join(curr_path, 'mplab.png')),
         #     self.x, self.y, self.width, self.height)
         self.canvas[1].shadow_offset_x = 0
         self.canvas[1].shadow_offset_y = 0
         self.canvas[1].shadow_blur = 0
@@ -453,140 +454,158 @@
         Args:
             x_in (int): x coordinate w.r.t mouse click event is returned.
             y_in (int): y coordinate w.r.t mouse click event is returned.
 
         Returns:
             bool: True if the script button is clicked, else False.
         """
-        return (
-            ((x_in > self.x) and (x_in < (self.x + self.width)))
-            and ((y_in > self.y) and (y_in < (self.y + self.height))))
+        return ((x_in > self.x) and (x_in < (self.x + self.width))) and (
+            (y_in > self.y) and (y_in < (self.y + self.height))
+        )
 
     def render(self):
         """When any script button is clicked,
         render method is invoked to call corresponding function.
         """
-        self.popup = Popup('Opening MPLABX', self.canvas[3])
+        self.popup = Popup("Opening MPLABX", self.canvas[3])
         self.epopup = ErrorPopUp(self.popup)
-        self.popup.canvas_layer.font = '28px serif'
-        self.popup.canvas_layer.text_align = 'start'
-        self.popup.canvas_layer.text_baseline = 'top'
-        self.popup.canvas_layer.fill_style = 'black'
+        self.popup.canvas_layer.font = "28px serif"
+        self.popup.canvas_layer.text_align = "start"
+        self.popup.canvas_layer.text_baseline = "top"
+        self.popup.canvas_layer.fill_style = "black"
 
         try:
-            assert self.mplab_ide_path is not None, \
-                'MPLAB X IDE path is not set in File -> Preferences -> MPLABX Path. \
-                    \nSet the path before clicking on MPLAB X Project'
-            assert self.cb_project_path() is not None, \
-                'Project Path is not available... Set Path in the Usecase'
-            assert self.working_dir is not None, \
-                'Working dir is not set... Set directory in the Usecase'
+            assert (
+                self.mplab_ide_path is not None
+            ), "MPLAB X IDE path is not set in File -> Preferences -> MPLABX Path. \
+                    \nSet the path before clicking on MPLAB X Project"
+            assert (
+                self.cb_project_path() is not None
+            ), "Project Path is not available... Set Path in the Usecase"
+            assert (
+                self.working_dir is not None
+            ), "Working dir is not set... Set directory in the Usecase"
 
             self.popup.get_layout(flag=True)
-            self.popup.canvas_layer.fill_style = 'black'
+            self.popup.canvas_layer.fill_style = "black"
             self.popup.canvas_layer.fill_text(
-                'Opening firmware... ensure all Usecase steps are',
-                self.popup.startx+20, self.popup.starty+20+35)
+                "Opening firmware... ensure all Usecase steps are",
+                self.popup.startx + 20,
+                self.popup.starty + 20 + 35,
+            )
             self.popup.canvas_layer.fill_text(
-                'executed at least once prior to loading firmware!',
-                self.popup.startx+20, self.popup.starty+20+35+40)
+                "executed at least once prior to loading firmware!",
+                self.popup.startx + 20,
+                self.popup.starty + 20 + 35 + 40,
+            )
             project_path = self.handle_working_dir_copy()
             subprocess.Popen(
                 [
                     self.mplab_ide_path,
-                    '--open',
+                    "--open",
                     project_path,
                 ]
             )
         except AssertionError as msg:
             self.epopup.traceback_print(str(msg), footer=False)
 
     def open_source_render(self):
-        self.popup = Popup('Caution', self.canvas[3])
+        self.popup = Popup("Caution", self.canvas[3])
         self.popup.get_layout(flag=False)
-        self.popup.canvas_layer.font = '28px serif'
-        self.popup.canvas_layer.text_align = 'start'
-        self.popup.canvas_layer.text_baseline = 'top'
-        self.popup.canvas_layer.fill_style = 'black'
+        self.popup.canvas_layer.font = "28px serif"
+        self.popup.canvas_layer.text_align = "start"
+        self.popup.canvas_layer.text_baseline = "top"
+        self.popup.canvas_layer.fill_style = "black"
         self.popup.canvas_layer.fill_text(
-            'Project Path is not available... Check Usecase settings',
-            self.popup.startx+20, self.popup.starty+20+35)
+            "Project Path is not available... Check Usecase settings",
+            self.popup.startx + 20,
+            self.popup.starty + 20 + 35,
+        )
 
     def handle_working_dir_copy(self, do_overwrite=False):
         if self.cb_project_path():
             do_copy = True
-            working_dir = os.path.join(self.working_dir, 'firmware')
+            working_dir = os.path.join(self.working_dir, "firmware")
             if os.path.exists(working_dir):
                 do_copy = False
 
             if do_copy or do_overwrite:
-                original_dir = self.cb_project_path().split('firmware')[
-                    0]+'firmware'
+                original_dir = self.cb_project_path().split("firmware")[0] + "firmware"
                 if os.path.exists(original_dir):
                     if os.path.exists(working_dir):
                         shutil.rmtree(working_dir)
-                    shutil.copytree(original_dir, working_dir,
-                                    dirs_exist_ok=True)
-                elif os.path.exists(original_dir + '.zip'):
-                    shutil.unpack_archive(original_dir + '.zip', working_dir)
+                    shutil.copytree(original_dir, working_dir, dirs_exist_ok=True)
+                elif os.path.exists(original_dir + ".zip"):
+                    shutil.unpack_archive(original_dir + ".zip", working_dir)
 
                 # Copy resources
                 original_dir = os.path.dirname(original_dir)
-                exclude_extn = ['.ipynb']
-                if do_overwrite is False and any(File.endswith(".h") for File in os.listdir(os.path.dirname(working_dir))):
-                    exclude_extn += ['.h', '.c']
-                files = [x for x in os.listdir(original_dir) if Path(
-                    os.path.join(original_dir, x)).is_file()]
-                files = [x for x in files if not x.endswith(
-                    tuple(exclude_extn))]
+                exclude_extn = [".ipynb"]
+                if do_overwrite is False and any(
+                    File.endswith(".h") for File in os.listdir(os.path.dirname(working_dir))
+                ):
+                    exclude_extn += [".h", ".c"]
+                files = [
+                    x
+                    for x in os.listdir(original_dir)
+                    if Path(os.path.join(original_dir, x)).is_file()
+                ]
+                files = [x for x in files if not x.endswith(tuple(exclude_extn))]
                 for fname in files:
-                    shutil.copy(os.path.join(original_dir, fname), os.path.join(
-                        os.path.dirname(working_dir), fname))
-
-            return os.path.join(os.path.dirname(working_dir), 'firmware' + 'firmware'.join(self.cb_project_path().split('firmware')[1:]))
+                    shutil.copy(
+                        os.path.join(original_dir, fname),
+                        os.path.join(os.path.dirname(working_dir), fname),
+                    )
+
+            return os.path.join(
+                os.path.dirname(working_dir),
+                "firmware" + "firmware".join(self.cb_project_path().split("firmware")[1:]),
+            )
 
     def get_c_src_folder(self):
         try:
-            assert self.cb_project_path() is not None, \
-                "This Usecase doesn't have firmware project..."
+            assert (
+                self.cb_project_path() is not None
+            ), "This Usecase doesn't have firmware project..."
             c_src_folder = None
             project_path = self.handle_working_dir_copy()
             c_src_folder, _ = os.path.split(project_path)
-            return os.path.join(c_src_folder, 'src')
+            return os.path.join(c_src_folder, "src")
         except BaseException as exp:
-            self.popup = Popup('Opening C Source Folder', self.canvas[3])
+            self.popup = Popup("Opening C Source Folder", self.canvas[3])
             self.epopup = ErrorPopUp(self.popup)
-            self.popup.canvas_layer.font = '28px serif'
-            self.popup.canvas_layer.text_align = 'start'
-            self.popup.canvas_layer.text_baseline = 'top'
-            self.popup.canvas_layer.fill_style = 'black'
+            self.popup.canvas_layer.font = "28px serif"
+            self.popup.canvas_layer.text_align = "start"
+            self.popup.canvas_layer.text_baseline = "top"
+            self.popup.canvas_layer.fill_style = "black"
             self.epopup.traceback_print(str(exp), footer=False)
 
 
-class ErrorPopUp():
+class ErrorPopUp:
     def __init__(self, popup):
         self.popup = popup
         self.val = None
 
     def traceback_print(self, s, footer=True):
-        """Redirects the traceback error message onto the popup window.
-        """
+        """Redirects the traceback error message onto the popup window."""
         self.val = s
         self.popup.canvas_layer.clear()
         self.popup.get_layout(flag=False)
-        if (footer):
+        if footer:
             self.popup.get_footer(flag=False)
-        self.popup.canvas_layer.font = '20px serif'
-        self.popup.canvas_layer.text_align = 'start'
-        self.popup.canvas_layer.text_baseline = 'top'
-        self.popup.canvas_layer.fill_style = 'black'
-        for i, si in enumerate(self.val.split('\n')):
-            if (i < 20):
+        self.popup.canvas_layer.font = "20px serif"
+        self.popup.canvas_layer.text_align = "start"
+        self.popup.canvas_layer.text_baseline = "top"
+        self.popup.canvas_layer.fill_style = "black"
+        for i, si in enumerate(self.val.split("\n")):
+            if i < 20:
                 self.popup.canvas_layer.fill_text(
-                    si[0:90],
-                    self.popup.startx+20, self.popup.starty+20+35 + 20*i)
+                    si[0:90], self.popup.startx + 20, self.popup.starty + 20 + 35 + 20 * i
+                )
+
 
+__all__ = ["CanvasTop", "CanvasLink", "CanvasImage", "CanvasScript", "CanvasFirmware", "ErrorPopUp"]
 
 # Standard boilerplate to call the main() function to begin
 # the program.
-if __name__ == '__main__':
+if __name__ == "__main__":
     pass
```

## tpds/usecase_diagram/menu_icons.py

```diff
@@ -1,92 +1,86 @@
-import os
-from ipywidgets import widgets, VBox, Layout, Box
 import warnings
+
 from IPython.display import HTML, display
-from tpds.tp_utils import tp_input_dialog
-from tpds.tp_utils import Client
+from ipywidgets import Box, Layout, VBox, widgets
+
+from tpds.tp_utils import Client, tp_input_dialog
+
 
+class MenuIcons:
+    """Adds RESET and HELP buttons to the Usecase Diagram"""
 
-class MenuIcons():
-    """Adds RESET and HELP buttons to the Usecase Diagram
-    """
     def __init__(self, canv_top, canvas, canvas_setup):
         """Constructs required attributes.
 
         Args:
             canv_top (object): Canvas_top object which includes list of buttons.
             canvas (object): Main canvas object
         """
         self.canv_top = canv_top
         self.canvas = canvas
         self.canvas_setup = canvas_setup
         self.help = widgets.Button(
-                            description="Usecase Help",
-                            tooltip='Open Usecase Help',
-                            style={'button_color': 'skyblue'},
-                            icon='fa-question-circle')
+            description="Usecase Help",
+            tooltip="Open Usecase Help",
+            style={"button_color": "skyblue"},
+            icon="fa-question-circle",
+        )
         self.usecase_help = None
         self.help.on_click(self.on_help_click)
 
         self.reset = widgets.Button(
-                            description="Reset",
-                            tooltip='Reset Transaction Diagram',
-                            style={'button_color': 'skyblue'},
-                            icon='fa-refresh')
+            description="Reset",
+            tooltip="Reset Transaction Diagram",
+            style={"button_color": "skyblue"},
+            icon="fa-refresh",
+        )
         self.reset.on_click(self.on_reset_click)
 
         self.learn = widgets.Button(
-                            description="Learn",
-                            tooltip='Play Usecase video',
-                            style={'button_color': 'skyblue'},
-                            icon='fa-info-circle')
+            description="Learn",
+            tooltip="Play Usecase video",
+            style={"button_color": "skyblue"},
+            icon="fa-info-circle",
+        )
         self.learn.on_click(self.on_learn_click)
 
         self.firmware_obj = None
         self.c_project = widgets.Button(
-                            description="MPLAB X Project",
-                            tooltip='Launch MPLAB X IDE Project',
-                            style={'button_color': 'skyblue'},
-                            icon='fa-hand-o-right')
+            description="MPLAB X Project",
+            tooltip="Launch MPLAB X IDE Project",
+            style={"button_color": "skyblue"},
+            icon="fa-hand-o-right",
+        )
         self.c_project.on_click(self.on_c_project_click)
 
         self.c_proj_folder = widgets.Button(
-                            description="C Source Folder",
-                            tooltip='Explore C Source files',
-                            style={'button_color': 'skyblue'},
-                            icon='fa-folder-open-o')
+            description="C Source Folder",
+            tooltip="Explore C Source files",
+            style={"button_color": "skyblue"},
+            icon="fa-folder-open-o",
+        )
         self.c_proj_folder.on_click(self.on_c_proj_folder_click)
 
-
         self.inner_box_layout = widgets.Layout(
-                            display='flex',
-                            flex_flow='row-reverse',
-                            overflow='hidden')
+            display="flex", flex_flow="row-reverse", overflow="hidden"
+        )
         self.outer_box_layout = widgets.Layout(
-                            display='flex',
-                            flex_flow='row-reverse',
-                            overflow='hidden',
-                            width='100%',
-                            height='35px')
+            display="flex", flex_flow="row-reverse", overflow="hidden", width="100%", height="35px"
+        )
 
         self.info_out = widgets.Output(
-                            layout=Layout(
-                                height='0px',
-                                overflow='hidden',
-                                margin='0px 0px 0px 50px'))
-        self.t_out = widgets.Output(
-                            layout=Layout(
-                                height='100%',
-                                overflow='hidden',
-                                margin='0px'))
+            layout=Layout(height="0px", overflow="hidden", margin="0px 0px 0px 50px")
+        )
+        self.t_out = widgets.Output(layout=Layout(height="100%", overflow="hidden", margin="0px"))
         self.box1 = widgets.HBox(
             children=[self.c_proj_folder, self.c_project, self.help, self.learn, self.reset],
-            layout=self.inner_box_layout)
-        self.box2 = widgets.HBox(
-            children=[self.box1], layout=self.outer_box_layout)
+            layout=self.inner_box_layout,
+        )
+        self.box2 = widgets.HBox(children=[self.box1], layout=self.outer_box_layout)
 
     def on_help_click(self, b):
         """Invoked when help button is clicked.
 
         Args:
             b (object): Corresponding ipywidget button object.
         """
@@ -104,71 +98,75 @@
         #                 allow="autoplay; encrypted-media" frameborder="1">
         #                 </iframe>"""))
         # else:
         #     self.__reset_menu_layout()
         if self.usecase_help:
             self.client = Client(None)
             if callable(self.usecase_help) and self.usecase_help():
-              self.open_usecase_help(self.usecase_help())
+                self.open_usecase_help(self.usecase_help())
             else:
-              self.open_usecase_help(self.usecase_help)
-            resp_msg = self.client.client.recv()
+                self.open_usecase_help(self.usecase_help)
+            self.client.client.recv()
             self.client.client.close()
 
-
     def open_usecase_help(self, path):
-        self.client.send_message('open_link', [path])
+        self.client.send_message("open_link", [path])
 
     def set_usecase_help(self, usecase_help):
         self.usecase_help = usecase_help
 
     def on_learn_click(self, b):
         """Invoked when help button is clicked.
 
         Args:
             b (object): Corresponding ipywidget button object.
         """
-        if self.learn.description != 'Close':
+        if self.learn.description != "Close":
             self.__reset_menu_layout()
-            self.learn.icon = 'fa-info-circle'
-            self.learn.style.button_color = '#FF605C'
-            self.learn.description = 'Close'
-            self.t_out.layout.height = '0px'
-            self.info_out.layout.height = '100%'
+            self.learn.icon = "fa-info-circle"
+            self.learn.style.button_color = "#FF605C"
+            self.learn.description = "Close"
+            self.t_out.layout.height = "0px"
+            self.info_out.layout.height = "100%"
             with warnings.catch_warnings():
                 # this will suppress all warnings in this block
-                warnings.filterwarnings('ignore', message='Consider using IPython.display.IFrame instead')
+                warnings.filterwarnings(
+                    "ignore", message="Consider using IPython.display.IFrame instead"
+                )
                 with self.info_out:
-                    display(HTML(
+                    display(
+                        HTML(
                             """<iframe width="100%" height="650"
                             src="https://www.youtube.com/embed/TdexOLD33bs?autoplay=1"
                             allow="autoplay; encrypted-media" frameborder="1">
-                            </iframe>"""))
+                            </iframe>"""
+                        )
+                    )
         else:
             self.__reset_menu_layout()
 
     def __reset_menu_layout(self):
-        self.help.icon = 'fa-question-circle'
-        self.help.style.button_color = 'skyblue'
-        self.help.description = 'Usecase Help'
-        self.learn.icon = 'fa-info-circle'
-        self.learn.style.button_color = 'skyblue'
-        self.learn.description = 'Learn'
+        self.help.icon = "fa-question-circle"
+        self.help.style.button_color = "skyblue"
+        self.help.description = "Usecase Help"
+        self.learn.icon = "fa-info-circle"
+        self.learn.style.button_color = "skyblue"
+        self.learn.description = "Learn"
         self.info_out.clear_output()
-        self.info_out.layout.height = '0%'
-        self.t_out.layout.height = '100%'
+        self.info_out.layout.height = "0%"
+        self.t_out.layout.height = "100%"
 
     def on_c_project_click(self, b):
         if self.firmware_obj:
             self.firmware_obj.render()
 
     def on_c_proj_folder_click(self, b):
         if self.firmware_obj:
             path = self.firmware_obj.get_c_src_folder()
-            assert path is not None, 'No Source folder available to open'
+            assert path is not None, "No Source folder available to open"
             c_project_files = tp_input_dialog.OpenExplorerFolder(path=path)
             c_project_files.invoke_dialog()
         else:
             self.firmware_obj.open_source_render()
 
     def set_firmware_obj(self, firmware_obj):
         self.firmware_obj = firmware_obj
@@ -179,27 +177,26 @@
         Clears the scripts execution status ti default.
         This reverts the usecase diagram to default.
 
         Args:
             b (object): corresponding ipywidgets button object.
         """
         self.canv_top.t_canvas[2].clear()
-        script_list = [btn for btn in self.canv_top.click_list if(
-                    (hasattr(btn, 'exec_status')))]
+        script_list = [btn for btn in self.canv_top.click_list if ((hasattr(btn, "exec_status")))]
         for script in script_list:
             script.exec_status = False
-        self.info_out.layout.height = '0px'
+        self.info_out.layout.height = "0px"
         self.info_out.clear_output()
-        self.t_out.layout.height = '100%'
-        self.help.icon = 'fa-question-circle'
-        self.help.style.button_color = 'skyblue'
-        self.help.description = 'Usecase Help'
-        self.learn.icon = 'fa-info-circle'
-        self.learn.style.button_color = 'skyblue'
-        self.learn.description = 'Learn'
+        self.t_out.layout.height = "100%"
+        self.help.icon = "fa-question-circle"
+        self.help.style.button_color = "skyblue"
+        self.help.description = "Usecase Help"
+        self.learn.icon = "fa-info-circle"
+        self.learn.style.button_color = "skyblue"
+        self.learn.description = "Learn"
         if self.firmware_obj:
             self.firmware_obj.handle_working_dir_copy(True)
 
     def return_layout(self):
         """Returns Layout along with Reset and Help buttons.
 
         Returns:
@@ -209,9 +206,9 @@
             display(Box([self.canvas]))
         return VBox([self.box2, self.t_out, self.info_out])
         # return self.canvas
 
 
 # Standard boilerplate to call the main() function to begin
 # the program.
-if __name__ == '__main__':
+if __name__ == "__main__":
     pass
```

## tpds/usecase_diagram/popup.py

```diff
@@ -1,14 +1,15 @@
-from ipywidgets import Image
 import os
 
+from ipywidgets import Image
+
+
+class CloseWindow:
+    """Adds a close button to the popup window."""
 
-class CloseWindow():
-    """Adds a close button to the popup window.
-    """
     def __init__(self, canvas_layer):
         """Constructs necessary attributes.
 
         Args:
             canvas_layer (main canvas layer): Layer to show close button.
                                                 Same as popup window layer.
         """
@@ -24,43 +25,42 @@
         Args:
             x_in (int): x coordinate w.r.t mouse click event is returned.
             y_in (int): y coordinate w.r.t mouse click event is returned.
 
         Returns:
             bool: True if the close button is clicked, else False.
         """
-        return (
-            ((x_in > self.x) and (x_in < (self.x + self.width)))
-            and ((y_in > self.y) and (y_in < (self.y + self.height))))
+        return ((x_in > self.x) and (x_in < (self.x + self.width))) and (
+            (y_in > self.y) and (y_in < (self.y + self.height))
+        )
 
     def layout(self):
-        """Draws a close button on canvas popup window.
-        """
-        self.canvas.fill_style = 'white'
+        """Draws a close button on canvas popup window."""
+        self.canvas.fill_style = "white"
         self.canvas.fill_rect(self.x, self.y, self.width, self.height)
-        self.canvas.stroke_style = 'black'
+        self.canvas.stroke_style = "black"
         self.canvas.line_width = 2
         self.canvas.begin_path()
-        self.canvas.move_to(self.x+5, self.y+5)
-        self.canvas.line_to(self.x+self.width-5, self.y+self.height-5)
-        self.canvas.move_to(self.x+self.width-5, self.y+5)
-        self.canvas.line_to(self.x+5, self.y+self.height-5)
+        self.canvas.move_to(self.x + 5, self.y + 5)
+        self.canvas.line_to(self.x + self.width - 5, self.y + self.height - 5)
+        self.canvas.move_to(self.x + self.width - 5, self.y + 5)
+        self.canvas.line_to(self.x + 5, self.y + self.height - 5)
         self.canvas.stroke()
 
     def render(self):
-        """Clears the layer when close button is clicked.
-        """
+        """Clears the layer when close button is clicked."""
         self.canvas.clear()
 
 
-class Popup():
+class Popup:
     """Opens a Popup window when image button or script button is clicked.
 
     The Output is shown on the Popup Window.
     """
+
     def __init__(self, title, canvas_layer):
         """Constructs necessary attributes
 
         Args:
             title (str): Title to the Popup window
             canvas_layer (main canvas layer): Layer to get Popup window.
         """
@@ -77,115 +77,115 @@
         """Gets the main layout when the buttons are clicked.
 
         Args:
             flag (bool, optional): False if there is an error while executing the clicked step.
                                     (e.g. When scripts are not being run in order)
                                     Defaults to True.
         """
-        self.canvas_layer.fill_style = '#FFFFFFCC'
-        self.canvas_layer.fill_rect(
-            0, 0, self.canvas_layer.width, self.canvas_layer.height)
-        if(flag):
-            self.canvas_layer.fill_style = '#4BB543'
+        self.canvas_layer.fill_style = "#FFFFFFCC"
+        self.canvas_layer.fill_rect(0, 0, self.canvas_layer.width, self.canvas_layer.height)
+        if flag:
+            self.canvas_layer.fill_style = "#4BB543"
         else:
-            self.canvas_layer.fill_style = '#e40222'
-        self.canvas_layer.fill_rect(
-                self.startx, self.starty,
-                self.endx, self.endy)
-        self.canvas_layer.fill_style = 'white'
-        self.canvas_layer.fill_rect(
-                self.startx+10, self.starty+35,
-                self.endx-(2*10), self.endy-(2*10)-35)
-        self.canvas_layer.font = '32px serif'
-        self.canvas_layer.text_align = 'start'
-        self.canvas_layer.text_baseline = 'top'
-        self.canvas_layer.fill_text(self.title, self.startx+10, self.starty)
+            self.canvas_layer.fill_style = "#e40222"
+        self.canvas_layer.fill_rect(self.startx, self.starty, self.endx, self.endy)
+        self.canvas_layer.fill_style = "white"
+        self.canvas_layer.fill_rect(
+            self.startx + 10, self.starty + 35, self.endx - (2 * 10), self.endy - (2 * 10) - 35
+        )
+        self.canvas_layer.font = "32px serif"
+        self.canvas_layer.text_align = "start"
+        self.canvas_layer.text_baseline = "top"
+        self.canvas_layer.fill_text(self.title, self.startx + 10, self.starty)
         self.close.layout()
 
     def get_footer(self, flag=True):
         """Adds a footer part to the main layout if necessary
 
         Args:
             flag (bool, optional): False: Image Output doesn't need any footer.
                                             Scripts point to terminal. So footer is needed.
                                             Defaults to True.
         """
-        if(flag):
-            self.canvas_layer.fill_style = '#4BB543'
+        if flag:
+            self.canvas_layer.fill_style = "#4BB543"
         else:
-            self.canvas_layer.fill_style = '#e40222'
-        self.canvas_layer.fill_rect(
-            self.startx, self.starty+self.endy, self.endx, 20)
-        self.canvas_layer.font = '24px serif'
-        self.canvas_layer.text_baseline = 'top'
-        self.canvas_layer.fill_style = 'white'
+            self.canvas_layer.fill_style = "#e40222"
+        self.canvas_layer.fill_rect(self.startx, self.starty + self.endy, self.endx, 20)
+        self.canvas_layer.font = "24px serif"
+        self.canvas_layer.text_baseline = "top"
+        self.canvas_layer.fill_style = "white"
         self.canvas_layer.fill_text(
             "Refer Terminal(on the right) for detailed log.",
-            self.startx+10, self.starty+self.endy-10)
+            self.startx + 10,
+            self.starty + self.endy - 10,
+        )
 
     def draw_image(self, image_file):
         """When image button is clicked, image is drawn on the popup window.
 
         Args:
             image_file (path str): Path to the image.
         """
         self.get_layout(flag=True)
         self.canvas_layer.draw_image(
             Image.from_file(image_file),
-            self.startx+10+35, self.starty+35,
-            self.endx-(2*10)-(2*35), self.endy-35-(2*10))
+            self.startx + 10 + 35,
+            self.starty + 35,
+            self.endx - (2 * 10) - (2 * 35),
+            self.endy - 35 - (2 * 10),
+        )
 
     def print_message(self, message):
         """When script button is clicked, required information is shown on popup.
 
         Args:
             message (str): Message to be shown on the popup.
         """
-        if(len(self.text_list) == 0):
+        if len(self.text_list) == 0:
             self.get_layout(flag=True)
             self.get_footer(flag=True)
 
-        if(len(self.text_list) == 10):
+        if len(self.text_list) == 10:
             self.text_list.pop(0)
         self.text_list.append(message)
-        self.canvas_layer.fill_style = 'white'
+        self.canvas_layer.fill_style = "white"
         self.canvas_layer.fill_rect(
-                self.startx+10, self.starty+10+35,
-                self.endx-(2*10), self.endy-(2*10)-35)
-        self.canvas_layer.font = '20px serif'
-        self.canvas_layer.text_align = 'start'
-        self.canvas_layer.text_baseline = 'top'
-        self.canvas_layer.fill_style = 'black'
+            self.startx + 10, self.starty + 10 + 35, self.endx - (2 * 10), self.endy - (2 * 10) - 35
+        )
+        self.canvas_layer.font = "20px serif"
+        self.canvas_layer.text_align = "start"
+        self.canvas_layer.text_baseline = "top"
+        self.canvas_layer.fill_style = "black"
         for i in range(len(self.text_list)):
             self.canvas_layer.fill_text(
-                        self.text_list[i][:90],
-                        self.startx+20, self.starty+20+35 + 20*i)
+                self.text_list[i][:90], self.startx + 20, self.starty + 20 + 35 + 20 * i
+            )
 
     def usecase_complete(self, img):
         """Called after the successful execution of use case.
 
         Helps the user to understand that the use case is successfully run.
 
         Args:
             img (path str): Successful Execution Image path.
         """
         curr_path = os.path.abspath(os.path.dirname(__file__))
-        self.canvas_layer.fill_style = 'white'
-        self.canvas_layer.fill_rect(
-            300, 200, 500, 150)
-        self.canvas_layer.stroke_style = '#4BB543'
+        self.canvas_layer.fill_style = "white"
+        self.canvas_layer.fill_rect(300, 200, 500, 150)
+        self.canvas_layer.stroke_style = "#4BB543"
         self.canvas_layer.line_width = 5
         self.canvas_layer.stroke_rect(300, 200, 500, 150)
-        self.canvas_layer.font = '48px serif'
-        self.canvas_layer.text_align = 'start'
-        self.canvas_layer.text_baseline = 'middle'
-        self.canvas_layer.fill_style = 'black'
-        self.canvas_layer.fill_text('Use Case Completed!!!', 320, 250)
+        self.canvas_layer.font = "48px serif"
+        self.canvas_layer.text_align = "start"
+        self.canvas_layer.text_baseline = "middle"
+        self.canvas_layer.fill_style = "black"
+        self.canvas_layer.fill_text("Use Case Completed!!!", 320, 250)
         self.canvas_layer.draw_image(
-            Image.from_file(os.path.join(
-                    curr_path, img)), 470, 280, 150, 150)
+            Image.from_file(os.path.join(curr_path, img)), 470, 280, 150, 150
+        )
 
 
 # Standard boilerplate to call the main() function to begin
 # the program.
-if __name__ == '__main__':
+if __name__ == "__main__":
     pass
```

## tpds/usecase_diagram/proto_boards.py

```diff
@@ -1,13 +1,14 @@
 import os
+
 from ipycanvas import MultiCanvas
 from ipywidgets import Image
 
 
-class ProtoBoard():
+class ProtoBoard:
     def __init__(self, img_size=200, max_width=1200):
         """This class handles proto boards addition to Usecase Notebook
 
         Args:
             img_size (int, optional):
                     [Board image dimension]. Defaults to 200.
             max_width (int, optional):
@@ -15,58 +16,57 @@
                     Defaults to 1200.
         """
         self.boards = []
         self.img_size = img_size
         self.max_width = max_width
         self.active_board = None
         curr_path = os.path.abspath(os.path.dirname(__file__))
-        self.select_img = Image.from_file(
-                                    os.path.join(curr_path, 'select.png'))
+        self.select_img = Image.from_file(os.path.join(curr_path, "select.png"))
 
     def add_board(
-            self, board_name, board_img,
-            board_kit_hex, board_firmware=None, board_help_docs=None):
+        self, board_name, board_img, board_kit_hex, board_firmware=None, board_help_docs=None
+    ):
         """This method adds a board to list of the boards to render
 
         Args:
             board_name ([type]): Title of the board
             board_img ([type]): Board image path
             board_kit_hex ([type]): Factory program hex path
             board_firmware ([type], optional):
                         C project (MPLAB) path. Defaults to None.
-            board_help_docs ([type], optional): help document path 
+            board_help_docs ([type], optional): help document path
         """
         board_info = {}
-        board_info.update({'name': board_name})
-        board_info.update({'img': Image.from_file(board_img)})
-        board_info.update({'kit_hex': board_kit_hex})
-        board_info.update({'firmware': board_firmware})
-        board_info.update({'help_docs': board_help_docs})
+        board_info.update({"name": board_name})
+        board_info.update({"img": Image.from_file(board_img)})
+        board_info.update({"kit_hex": board_kit_hex})
+        board_info.update({"firmware": board_firmware})
+        board_info.update({"help_docs": board_help_docs})
         self.boards.append(board_info)
 
     def render_boards(self, default_selection=None):
         """This method renders the boards on the canvas, It creates
-                layers to draw images, text and user clicks
+        layers to draw images, text and user clicks
         """
         width = height = 0
         for board in self.boards:
-            board.update({'x': width})
-            board.update({'y': height})
+            board.update({"x": width})
+            board.update({"y": height})
             width += self.img_size
             if width >= self.max_width:
                 width = 0
                 height += self.img_size
 
         if width:
             height += self.img_size
-        if len(self.boards) >= (self.max_width/self.img_size):
+        if len(self.boards) >= (self.max_width / self.img_size):
             width = self.max_width
 
         self.canvas = MultiCanvas(3, width=width, height=height)
-        self.canvas.layout.margin = '50px'
+        self.canvas.layout.margin = "50px"
         self.image_canvas = self.canvas[0]
         self.text_canvas = self.canvas[1]
         self.click_canvas = self.canvas[2]
         self.image_canvas.on_client_ready(self.draw_boards)
         self.click_canvas.on_mouse_down(self.handle_mouse_down)
         self.default_selection = default_selection
 
@@ -74,86 +74,79 @@
         """This callback method handles the Click action from User.
                 On selecting a valid board, it renders as selected.
 
         Args:
             x ([type]): x coordinate of the click
             y ([type]): y coordinate of the click
         """
-        image_index = int(((int(y/self.img_size))*(
-            self.max_width/self.img_size))+(int(x/self.img_size)))
+        image_index = int(
+            ((int(y / self.img_size)) * (self.max_width / self.img_size)) + (int(x / self.img_size))
+        )
         if image_index >= len(self.boards):
             return
         if self.active_board and (image_index == self.boards.index(self.active_board)):
             # Clear the current selection
-            self.image_canvas.fill_style = 'white'
+            self.image_canvas.fill_style = "white"
             self.image_canvas.fill_rect(
-                                self.active_board.get('x')+5,
-                                self.active_board.get('y')+170,
-                                50, 50)
+                self.active_board.get("x") + 5, self.active_board.get("y") + 170, 50, 50
+            )
             self.active_board = None
         else:
             self.__select_board(image_index)
 
     def draw_boards(self):
-        """This method draws the board images and texts
-        """
+        """This method draws the board images and texts"""
         for board in self.boards:
-            self.image_canvas.draw_image(
-                                board.get('img'),
-                                board.get('x'), board.get('y'))
-            self.text_canvas.stroke_style = 'red'
+            self.image_canvas.draw_image(board.get("img"), board.get("x"), board.get("y"))
+            self.text_canvas.stroke_style = "red"
             self.text_canvas.stroke_rect(
-                                board.get('x'), board.get('y'),
-                                self.img_size, self.img_size)
-            self.text_canvas.font = '16px serif'
-            self.text_canvas.fill_text(
-                                    board.get('name'),
-                                    board.get('x')+1, board.get('y')+20)
+                board.get("x"), board.get("y"), self.img_size, self.img_size
+            )
+            self.text_canvas.font = "16px serif"
+            self.text_canvas.fill_text(board.get("name"), board.get("x") + 1, board.get("y") + 20)
         # 0 is valid selection
         if self.default_selection is not None:
             self.__select_board(self.default_selection)
 
     def __select_board(self, index):
         if index >= len(self.boards):
             return
         if self.active_board:
             # Clear the current selection
-            self.image_canvas.fill_style = 'white'
+            self.image_canvas.fill_style = "white"
             self.image_canvas.fill_rect(
-                                self.active_board.get('x')+5,
-                                self.active_board.get('y')+170,
-                                50, 50)
+                self.active_board.get("x") + 5, self.active_board.get("y") + 170, 50, 50
+            )
 
         # Set the new selection and draw the new selection
         self.active_board = self.boards[index]
         self.image_canvas.draw_image(
-                            self.select_img,
-                            self.active_board.get('x')+5,
-                            self.active_board.get('y')+170)
+            self.select_img, self.active_board.get("x") + 5, self.active_board.get("y") + 170
+        )
 
     def get_firmware_project(self):
         """Access method to get C project path
 
         Returns:
             [str]: Project path
         """
         project_path = None
         if self.active_board is not None:
-            project_path = self.active_board.get('firmware')
+            project_path = self.active_board.get("firmware")
         return project_path
 
     def get_kit_hex(self):
         """Access method to get factory hex file
 
         Returns:
             [str]: Factory hex file path
         """
         hex_path = None
         if self.active_board is not None:
-            hex_path = self.active_board.get('kit_hex')
+            hex_path = self.active_board.get("kit_hex")
         return hex_path
 
     def get_selected_board(self):
         """Access method to get selected board
 
         Returns:
             dict/None: Dictionary of selected board details
@@ -163,10 +156,10 @@
     def get_help_docs(self):
         """Access method to get help document file
 
         Returns:
             [str]: help document file path
         """
         if self.active_board is not None:
-            return self.active_board.get('help_docs')
-        
-        return self.boards[0].get('help_docs')
+            return self.active_board.get("help_docs")
+
+        return self.boards[0].get("help_docs")
```

## tpds/usecase_diagram/terminal.py

```diff
@@ -1,48 +1,49 @@
-from ipywidgets import widgets, Layout, VBox, HBox
+from ipywidgets import HBox, Layout, VBox, widgets
 
 
-class Terminal():
+class Terminal:
     """For the detailed output from scripts,
     Terminal is created beside the Transaction Digram.
     """
+
     def __init__(self):
-        """Constructs necessary attributes
-        """
+        """Constructs necessary attributes"""
         self.clear = widgets.Button(
-                            description="Clear Output",
-                            tooltip='clear log output',
-                            style={'button_color': 'skyblue'},
-                            width='50%')
+            description="Clear Output",
+            tooltip="clear log output",
+            style={"button_color": "skyblue"},
+            width="50%",
+        )
         self.clear.on_click(self.on_clear_click)
 
         self.terminal = widgets.Button(
-                            description="Hide Terminal",
-                            style={'button_color': 'skyblue'},
-                            width='50%',
-                            icon='fa-eye-slash')
+            description="Hide Terminal",
+            style={"button_color": "skyblue"},
+            width="50%",
+            icon="fa-eye-slash",
+        )
         self.terminal.on_click(self.on_terminal_click)
 
-        self.log = widgets.Output(layout=widgets.Layout(
-                            width='320px',
-                            height='480px',
-                            overflow='hidden scroll',
-                            border='2px solid black'))
+        self.log = widgets.Output(
+            layout=widgets.Layout(
+                width="320px", height="480px", overflow="hidden scroll", border="2px solid black"
+            )
+        )
 
         self.inner_box_layout = Layout(
-                            display='flex',
-                            flex_flow='column',
-                            align_items='stretch',
-                            width='100%')
+            display="flex", flex_flow="column", align_items="stretch", width="100%"
+        )
         self.outer_box_layout = Layout(
-                            display='flex',
-                            flex_flow='column',
-                            align_items='stretch',
-                            width='96%',
-                            margin='0px 0px 0px 10px')
+            display="flex",
+            flex_flow="column",
+            align_items="stretch",
+            width="96%",
+            margin="0px 0px 0px 10px",
+        )
 
     def on_clear_click(self, b):
         """Clear the terminal output when clear button is clicked.
 
         Args:
             b (ipywidgets button object): button associated to this function.
         """
@@ -50,33 +51,37 @@
 
     def on_terminal_click(self, b):
         """Show/ Hide the terminal window.
 
         Args:
             b (ipywidgets button object): button associated to this function.
         """
-        if self.inner_box_layout.width == '0%':
-            self.inner_box_layout.width = '100%'
-            self.log.layout.border = '2px solid black'
-            self.terminal.description = 'Hide Terminal'
-            self.terminal.icon = 'fa-eye-slash'
+        if self.inner_box_layout.width == "0%":
+            self.inner_box_layout.width = "100%"
+            self.log.layout.border = "2px solid black"
+            self.terminal.description = "Hide Terminal"
+            self.terminal.icon = "fa-eye-slash"
         else:
-            self.inner_box_layout.width = '0%'
-            self.log.layout.border = '0px'
-            self.terminal.description = 'Show Terminal'
-            self.terminal.icon = 'fa-eye'
+            self.inner_box_layout.width = "0%"
+            self.log.layout.border = "0px"
+            self.terminal.description = "Show Terminal"
+            self.terminal.icon = "fa-eye"
 
     def get_layout(self):
         """Layout of the terminal
 
         Returns:
             Box Layout: Return the layout of the terminal
         """
         return VBox(
-            [HBox([self.clear], layout=Layout(display='flex', justify_content= 'flex-end'))
-            , self.log], layout=Layout(margin='0px 0px 0px 10px'))
+            [
+                HBox([self.clear], layout=Layout(display="flex", justify_content="flex-end")),
+                self.log,
+            ],
+            layout=Layout(margin="0px 0px 0px 10px"),
+        )
 
 
 # Standard boilerplate to call the main() function to begin
 # the program.
-if __name__ == '__main__':
+if __name__ == "__main__":
     pass
```

## tpds/usecase_diagram/usecase_diagram.py

```diff
@@ -1,54 +1,47 @@
-from ipywidgets import VBox, HBox, widgets, Layout
 from ipycanvas import MultiCanvas
-from .canvas import CanvasTop, CanvasImage, CanvasLink
-from .canvas import CanvasScript, CanvasFirmware
+from ipywidgets import HBox, Image, Layout, VBox, widgets
+
+from .canvas import CanvasFirmware, CanvasImage, CanvasLink, CanvasScript, CanvasTop
+from .menu_icons import MenuIcons
 from .popup import CloseWindow
 from .terminal import Terminal
-from .menu_icons import MenuIcons
-from ipywidgets import Image
 
 
-class UsecaseDiagram():
+class UsecaseDiagram:
     """A class to build canvas object in Notebook"""
 
-    def __init__(
-                self, td_image,
-                width=1120, height=480, enable_coord=False, working_dir=None):
+    def __init__(self, td_image, width=1120, height=480, enable_coord=False, working_dir=None):
         """Constructs necessary attributes.
 
         Args:
             td_image (image path): Image to place on the canvas bottom layer.
             width (int, optional): Width of the image. Defaults to 1150.
             height (int, optional): Height of the image. Defaults to 750.
         """
         self.width = width
         self.height = height
         self.canvas = MultiCanvas(4, width=self.width, height=self.height)
-        self.canvas.layout.width = '100%'
-        self.canvas.layout.height = '100%'
-        self.canvas.layout.margin = '0px 0px 0px 50px'
+        self.canvas.layout.width = "100%"
+        self.canvas.layout.height = "100%"
+        self.canvas.layout.margin = "0px 0px 0px 50px"
         self.td_image_b = Image.from_file(td_image)
         self.canvas.on_client_ready(self.perform_drawings)
 
         if enable_coord:
             self.output = Terminal()
             self.output_layout = self.output.get_layout()
-            self.canvas_top = CanvasTop(
-                                    self.canvas, 3,
-                                    enable_coord, self.output)
+            self.canvas_top = CanvasTop(self.canvas, 3, enable_coord, self.output)
         else:
             self.output_layout = None
             self.canvas_top = CanvasTop(self.canvas, 3)
 
         self.cls_b = CloseWindow(self.canvas[3])
         self.canvas_top.close_list.append(self.cls_b)
-        self.menu = MenuIcons(
-                        self.canvas_top, self.canvas,
-                        None)
+        self.menu = MenuIcons(self.canvas_top, self.canvas, None)
         self.script_index = 0
         self.working_dir = working_dir
 
     def add_image(self, x, y, width, height, image, title):
         """Adds a button on canvas to open an image.
         When clicked within the button area, it pops up specified image window.
 
@@ -56,32 +49,30 @@
             x (int): x coordinate w.r.t canvas to place the button.
             y (int): y coordinate w.r.t canvas to place the button.
             width (int): Width of the button.
             height (int): Height of the button.
             image (image path): Image to display when button area is clicked.
             title (str): Title of the popup window.
         """
-        canvas_image = CanvasImage(
-            x, y, width, height, image, title, self.canvas)
+        canvas_image = CanvasImage(x, y, width, height, image, title, self.canvas)
         self.canvas_top.click_list.append(canvas_image)
 
     def add_link(self, x, y, width, height, link):
         """Adds an area on to canvas to open any page.
 
         When clicked within the area, it directs to the given url.
 
         Args:
             x (int): x coordinate w.r.t canvas to place the link.
             y (int): y coordinate w.r.t canvas to place the link.
             width (int): Width of the link area.
             height (int): Height of the link area.
             link (url): URL to be redirected when clicked.
         """
-        canvas_link = CanvasLink(
-            x, y, width, height, link, self.canvas)
+        canvas_link = CanvasLink(x, y, width, height, link, self.canvas)
         self.canvas_top.click_list.append(canvas_link)
 
     def add_script(self, x, y, width, height, call_back, prereq_scripts=[], script_index=None):
         """[summary]
 
         Args:
             x (int): x coordinate w.r.t canvas to place the image button.
@@ -93,65 +84,65 @@
         """
         if self.output_layout is None:
             self.output = Terminal()
             self.output_layout = self.output.get_layout()
         self.script_index += 1
         script_index = script_index or self.script_index
         canvas_script = CanvasScript(
-            x, y, width, height, call_back, self.output, self.canvas,
-            self.canvas_top, prereq_scripts, script_index, self.working_dir)
+            x,
+            y,
+            width,
+            height,
+            call_back,
+            self.output,
+            self.canvas,
+            self.canvas_top,
+            prereq_scripts,
+            script_index,
+            self.working_dir,
+        )
         self.canvas_top.click_list.append(canvas_script)
-        return (canvas_script)
+        return canvas_script
 
     def add_firmware(self, cb_project_path, mplab_ide_path=None):
         canvas_firmware = CanvasFirmware(
-                            0, 0, self.canvas, self.canvas_top,
-                            cb_project_path, mplab_ide_path, self.working_dir)
+            0, 0, self.canvas, self.canvas_top, cb_project_path, mplab_ide_path, self.working_dir
+        )
         self.menu.set_firmware_obj(canvas_firmware)
 
     def add_usecase_help(self, usecase_help):
         self.menu.set_usecase_help(usecase_help)
 
     def perform_drawings(self):
-        """This method draws the given image on the bottom layer of the canvas.
-        """
+        """This method draws the given image on the bottom layer of the canvas."""
         self.canvas[0].draw_image(self.td_image_b, 0, 0, self.width, self.height)
 
     def display_canvas(self):
-        """Displays the Usecase Diagram.
-        """
+        """Displays the Usecase Diagram."""
         v_list = VBox([self.menu.return_layout()])
         h_list = [HBox([v_list, self.output_layout])]
         return VBox(h_list)
 
 
-class OpenDiagram():
-    """Shows/ Hides the Usecase diagram.
-    """
+class OpenDiagram:
+    """Shows/ Hides the Usecase diagram."""
+
     def __init__(self, menu, h_list):
         self.menu = menu
         self.list_items = h_list
-        self.res_out = widgets.Output(
-                                layout=Layout(
-                                            height='100%',
-                                            overflow='hidden',
-                                            margin='0px'))
-        self.left = widgets.Output(
-                                layout=Layout(
-                                            height='100%',
-                                            overflow='hidden',
-                                            margin='0px'))
+        self.res_out = widgets.Output(layout=Layout(height="100%", overflow="hidden", margin="0px"))
+        self.left = widgets.Output(layout=Layout(height="100%", overflow="hidden", margin="0px"))
 
     def depend_layout(self):
         """layout of the entire Usecase diagram division.
 
         Returns:
             Box layout: Return the Box Layout.
         """
         box = VBox(self.list_items)
         return box
 
 
 # Standard boilerplate to call the main() function to begin
 # the program.
-if __name__ == '__main__':
+if __name__ == "__main__":
     pass
```

## tpds/xml_handler/__init__.py

```diff
@@ -1,9 +1,22 @@
 """
     Trust Plaform core package - xml_handler module
 """
-from .caencryption import *
-from .ciphers import *
-from .ecc_xml_encryption import *
-from .tflxtls_xml_updates import *
-from .tflxwpc_xml_updates import *
-from .xml_processing import *
+from .caencryption import CAEncryption
+from .ciphers import Cipher_AES, Cipher_RSA, Ciphers, Hash_Sha256
+from .ecc_xml_encryption import ECCXMLEncryption
+from .tflxtls_xml_updates import TFLXTLSXMLUpdates
+from .tflxwpc_xml_updates import TFLXWPCXMLUpdates
+from .xml_processing import XMLProcessingRegistry
+
+__all__ = [
+    "CAEncryption",
+    "Hash_Sha256",
+    "Cipher_AES",
+    "Cipher_RSA",
+    "Ciphers",
+    "ECCXMLEncryption",
+    "TFLXTLSXMLUpdates",
+    "TFLXWPCXMLUpdates",
+    "XMLProcessingRegistry",
+    "XMLProcessing",
+]
```

## tpds/xml_handler/caencryption.py

```diff
@@ -14,16 +14,17 @@
 # PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY
 # KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 
-class CAEncryption():
+
+class CAEncryption:
     def __init__(self):
         pass
 
 
 # Standard boilerplate to call the main() function to begin
 # the program.
-if __name__ == '__main__':
+if __name__ == "__main__":
     pass
```

## tpds/xml_handler/ciphers.py

```diff
@@ -16,25 +16,26 @@
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 
 import os
 import re
-from cryptography.hazmat.backends import default_backend
-import cryptography.hazmat.primitives.padding as aes_padding
-from cryptography.hazmat.primitives import serialization, hashes
-from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
-from cryptography.hazmat.primitives.asymmetric import rsa, padding
 from base64 import b64decode
-from xml.dom import minidom
 from pathlib import Path
+from xml.dom import minidom
 
+import cryptography.hazmat.primitives.padding as aes_padding
+from cryptography.hazmat.backends import default_backend
+from cryptography.hazmat.primitives import hashes, serialization
+from cryptography.hazmat.primitives.asymmetric import padding, rsa
+from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
 
-class Hash_Sha256():
+
+class Hash_Sha256:
     def __init__(self):
         self.sha256_init()
 
     def sha256_init(self):
         self.sha256 = hashes.Hash(hashes.SHA256(), backend=default_backend())
 
     def sha256_update(self, data):
@@ -42,114 +43,110 @@
 
     def sha256_hash(self, data=None):
         if data is not None:
             self.sha256.update(data)
         return self.sha256.finalize()
 
 
-class Cipher_AES():
+class Cipher_AES:
     def __init__(self, aes_key=None, aes_iv=None):
         self.aes_key = aes_key or os.urandom(32)
         # print(f'AES Key: {self.aes_key.hex()}\n{list(self.aes_key)}')
         self.aes_iv = aes_iv or os.urandom(16)
         # print(f'AES IV: {self.aes_iv.hex()}\n{list(self.aes_iv)}')
         self.cipher = Cipher(
-            algorithms.AES(self.aes_key),
-            modes.CBC(self.aes_iv),
-            backend=default_backend())
+            algorithms.AES(self.aes_key), modes.CBC(self.aes_iv), backend=default_backend()
+        )
 
     def encrypt(self, plain_text):
         plain_text = plain_text.hex().encode()
-        cipher_text = bytearray(len(plain_text)*2)
+        cipher_text = bytearray(len(plain_text) * 2)
         padder = aes_padding.PKCS7(algorithms.AES.block_size).padder()
         # print(f'Plain text: {plain_text.hex()}')
         padded_data = padder.update(plain_text) + padder.finalize()
         encryptor = self.cipher.encryptor()
-        len_encrypted = encryptor.update_into(
-                            padded_data,
-                            cipher_text)
+        len_encrypted = encryptor.update_into(padded_data, cipher_text)
         encryptor.finalize()
         # print(f'Cipher text: {cipher_text[:len_encrypted].hex()}')
         return cipher_text[:len_encrypted]
 
     def decrypt(self, cipher_text):
-        plain_text = bytearray(len(cipher_text)+len(self.aes_iv))
+        plain_text = bytearray(len(cipher_text) + len(self.aes_iv))
         decryptor = self.cipher.decryptor()
         len_decrypted = decryptor.update_into(cipher_text, plain_text)
         decryptor.finalize()
         return plain_text[:len_decrypted]
 
     def get_key_iv(self):
-        return self.aes_key+self.aes_iv
+        return self.aes_key + self.aes_iv
 
 
-class Cipher_RSA():
-    def __init__(self, rsa_key_xml_file=''):
+class Cipher_RSA:
+    def __init__(self, rsa_key_xml_file=""):
         self.rsa_public_key = self.__get_public_key(rsa_key_xml_file)
 
     def encrypt(self, message):
         # print(f'RSA Input: {message.hex()}')
-        ciphertext = self.rsa_public_key.encrypt(
-            message,
-            padding.PKCS1v15())
+        ciphertext = self.rsa_public_key.encrypt(message, padding.PKCS1v15())
         # print(f'RSA Output: {ciphertext.hex()}')
         return ciphertext
 
     def __get_public_key(self, file_publickey_xml):
         if os.path.isfile(Path(file_publickey_xml)):
-            with open(file_publickey_xml, 'r') as pkFile:
+            with open(file_publickey_xml, "r") as pkFile:
                 xmlPublicKey = pkFile.read()
             xmlPublicKey = re.sub(".*?xmlversion.*\n?", "", xmlPublicKey)
             rsaKeyValue = minidom.parseString(xmlPublicKey)
-            modulus = self.__getLong(
-                rsaKeyValue.getElementsByTagName('Modulus')[0].childNodes)
-            exponent = self.__getLong(
-                rsaKeyValue.getElementsByTagName('Exponent')[0].childNodes)
-            rsa_publicKey = rsa.RSAPublicNumbers(
-                exponent, modulus).public_key(default_backend())
-            public_key_file = os.path.splitext(file_publickey_xml)[0] + '.key'
+            modulus = self.__getLong(rsaKeyValue.getElementsByTagName("Modulus")[0].childNodes)
+            exponent = self.__getLong(rsaKeyValue.getElementsByTagName("Exponent")[0].childNodes)
+            rsa_publicKey = rsa.RSAPublicNumbers(exponent, modulus).public_key(default_backend())
+            # public_key_file = os.path.splitext(file_publickey_xml)[0] + ".key"
         else:
-            private_key_file = 'Generated_RSA_Private.key'
-            public_key_file = 'Generated_RSA_Public.key'
+            private_key_file = "Generated_RSA_Private.key"
+            # public_key_file = "Generated_RSA_Public.key"
             rsa_private_key = rsa.generate_private_key(
-                public_exponent=65537,
-                key_size=2048,
-                backend=default_backend())
-            with open(private_key_file, 'wb') as key_file:
-                key_file.write(rsa_private_key.private_bytes(
-                    encoding=serialization.Encoding.PEM,
-                    format=serialization.PrivateFormat.TraditionalOpenSSL,
-                    encryption_algorithm=serialization.NoEncryption()))
+                public_exponent=65537, key_size=2048, backend=default_backend()
+            )
+            with open(private_key_file, "wb") as key_file:
+                key_file.write(
+                    rsa_private_key.private_bytes(
+                        encoding=serialization.Encoding.PEM,
+                        format=serialization.PrivateFormat.TraditionalOpenSSL,
+                        encryption_algorithm=serialization.NoEncryption(),
+                    )
+                )
             rsa_publicKey = rsa_private_key.public_key()
 
         # with open(public_key_file, 'wb') as key_file:
         #     key_file.write(rsa_publicKey.public_bytes(
         #         encoding=serialization.Encoding.PEM,
         #         format=serialization.PublicFormat.SubjectPublicKeyInfo))
         return rsa_publicKey
 
     def __getLong(self, nodelist):
         rc = []
         for node in nodelist:
             if node.nodeType == node.TEXT_NODE:
                 rc.append(node.data)
-        string = ''.join(rc)
-        return int.from_bytes(b64decode(string), byteorder='big')
+        string = "".join(rc)
+        return int.from_bytes(b64decode(string), byteorder="big")
 
 
 class Ciphers(Cipher_AES, Cipher_RSA, Hash_Sha256):
-    def __init__(self, rsa_key_xml_file='', aes_key=None, aes_iv=None):
+    def __init__(self, rsa_key_xml_file="", aes_key=None, aes_iv=None):
         Cipher_AES.__init__(self, aes_key, aes_iv)
         Cipher_RSA.__init__(self, rsa_key_xml_file)
         Hash_Sha256.__init__(self)
 
     def encrypt_slot(self, slot_data):
         return Cipher_AES.encrypt(self, slot_data)
 
     def encrypt_aes_key_iv(self):
         return Cipher_RSA.encrypt(self, self.get_key_iv())
 
 
+__all__ = ["Hash_Sha256", "Cipher_AES", "Cipher_RSA", "Ciphers"]
+
 # Standard boilerplate to call the main() function to begin
 # the program.
-if __name__ == '__main__':
+if __name__ == "__main__":
     pass
```

## tpds/xml_handler/ecc_xml_encryption.py

```diff
@@ -14,139 +14,128 @@
 # PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY
 # KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 
+from os.path import splitext
 from shutil import copyfile
+
 import lxml.etree as ElementTree
-from os.path import splitext
-from .ciphers import Ciphers
+
 from tpds.tp_utils.tp_utils import pretty_xml_hex_array
 
+from .ciphers import Ciphers
+
 
-class ECCXMLEncryption():
-    def __init__(self, xml_file, rsa_key_xml, xml_out_file=''):
+class ECCXMLEncryption:
+    def __init__(self, xml_file, rsa_key_xml, xml_out_file=""):
         self.file = xml_out_file
-        if self.file == '':
-            self.file = splitext(xml_file)[0]+'.ENC.xml'
+        if self.file == "":
+            self.file = splitext(xml_file)[0] + ".ENC.xml"
         self.rsa_key_xml = rsa_key_xml
         copyfile(xml_file, self.file)
         self.tree = ElementTree.parse(self.file)
         self.root = self.tree.getroot()
         # self.secure_element = self.root.tag
         # self.xml_version = self.root.find('XMLVersion').text
         # self.part_number = self.root.find('PartNumber').text
-        self.config_zone = self.root.find('Device').find('ConfigurationZone')
-        self.sn01 = self.config_zone.find('SN01')
-        self.sn8 = self.config_zone.find('SN8')
-        self.data_zone = self.root.find('Device').find('DataZone')
-        self.otp_zone = self.root.find('Device').find('OTPZone')
-        self.certs = self.root.find('CompressedCerts')
+        self.config_zone = self.root.find("Device").find("ConfigurationZone")
+        self.sn01 = self.config_zone.find("SN01")
+        self.sn8 = self.config_zone.find("SN8")
+        self.data_zone = self.root.find("Device").find("DataZone")
+        self.otp_zone = self.root.find("Device").find("OTPZone")
+        self.certs = self.root.find("CompressedCerts")
         self.qa_data_zone_info = []
 
     def get_slots_to_encrypt_by_mode(self):
-        self.encrypt_modes = [
-            'Derived', 'Secret', 'PrivWrite', 'HKDF-Expand-SHA256']
+        self.encrypt_modes = ["Derived", "Secret", "PrivWrite", "HKDF-Expand-SHA256"]
         slots_to_encrypt_by_mode = dict()
         for encrypt_modes in list(self.encrypt_modes):
             search_string = "[@Mode='{}']".format(encrypt_modes)
             slots_to_encrypt_by_mode[encrypt_modes] = []
             for element in list(self.data_zone):
                 slot_element = element.findall(search_string)
                 if slot_element:
-                    slots_to_encrypt_by_mode[
-                        encrypt_modes].append(slot_element)
+                    slots_to_encrypt_by_mode[encrypt_modes].append(slot_element)
 
         return slots_to_encrypt_by_mode
 
     def encrypt_device_slot(self, by_mode):
         for slot in list(by_mode):
-            slot_data = slot[0].find('Data')
-            slot_data.tag = 'EncryptedData'
+            slot_data = slot[0].find("Data")
+            slot_data.tag = "EncryptedData"
             slot_info = dict(slot[0].items())
 
-            slot_info_modes = [
-                x for x in self.encrypt_modes if x != 'PrivWrite']
-            if slot_info['Mode'] in slot_info_modes:
-                self.qa_data_zone_info.append({
-                    'Index': slot_info['Index'],
-                    'Key': slot_data.text})
+            slot_info_modes = [x for x in self.encrypt_modes if x != "PrivWrite"]
+            if slot_info["Mode"] in slot_info_modes:
+                self.qa_data_zone_info.append({"Index": slot_info["Index"], "Key": slot_data.text})
             data = self.cipher.encrypt_slot(bytes.fromhex(slot_data.text))
             data = pretty_xml_hex_array(str(data.hex().upper()))
-            slot_data.text = f'\n{data}'
+            slot_data.text = f"\n{data}"
 
     def add_QA_tag(self):
         qa = None
-        if self.qa_data_zone_info or self.otp_zone.get('Mode') == 'Secret':
-            qa = ElementTree.Element('QA')
-            challenge = ElementTree.SubElement(qa, 'Challenge')
-            data = pretty_xml_hex_array(
-                str(bytes(range(0, 32)).hex().upper()), bytes_per_line=64)
-            challenge.text = f'\n{data}'
+        if self.qa_data_zone_info or self.otp_zone.get("Mode") == "Secret":
+            qa = ElementTree.Element("QA")
+            challenge = ElementTree.SubElement(qa, "Challenge")
+            data = pretty_xml_hex_array(str(bytes(range(0, 32)).hex().upper()), bytes_per_line=64)
+            challenge.text = f"\n{data}"
 
         if self.qa_data_zone_info:
-            data_zone = ElementTree.SubElement(qa, 'DataZone')
-            data_zone.set('Size', str(len(self.qa_data_zone_info)))
+            data_zone = ElementTree.SubElement(qa, "DataZone")
+            data_zone.set("Size", str(len(self.qa_data_zone_info)))
             for info in self.qa_data_zone_info:
-                data_response = ElementTree.SubElement(data_zone, 'Response')
-                data_response.set('Index', str(info['Index']))
+                data_response = ElementTree.SubElement(data_zone, "Response")
+                data_response.set("Index", str(info["Index"]))
                 data = self.__generate_slot_response(
-                        bytes.fromhex(challenge.text), int(info['Index']),
-                        bytes.fromhex(info['Key']))
-                data = pretty_xml_hex_array(
-                                str(data.hex().upper()), bytes_per_line=64)
-                data_response.text = f'\n{data}'
+                    bytes.fromhex(challenge.text), int(info["Index"]), bytes.fromhex(info["Key"])
+                )
+                data = pretty_xml_hex_array(str(data.hex().upper()), bytes_per_line=64)
+                data_response.text = f"\n{data}"
                 self.__generate_otp_response(bytes.fromhex(challenge.text))
 
-        if self.otp_zone.get('Mode') == 'Secret':
-            otp_zone = ElementTree.SubElement(qa, 'OTPZone')
-            otp_response = ElementTree.SubElement(otp_zone, 'Response')
-            data = self.__generate_otp_response(bytes.fromhex(
-                    self.otp_zone.find('Data').text))
+        if self.otp_zone.get("Mode") == "Secret":
+            otp_zone = ElementTree.SubElement(qa, "OTPZone")
+            otp_response = ElementTree.SubElement(otp_zone, "Response")
+            data = self.__generate_otp_response(bytes.fromhex(self.otp_zone.find("Data").text))
             data = pretty_xml_hex_array(str(data.hex().upper()))
-            otp_response.text = f'\n{data}'
+            otp_response.text = f"\n{data}"
 
         if qa is not None:
             self.root.append(qa)
 
     def add_AESKey_tag(self):
-        self.aes_key = ElementTree.Element('AESKey')
-        data = pretty_xml_hex_array(str(
-            self.cipher.encrypt_aes_key_iv().hex().upper()))
-        self.aes_key.text = f'\n{data}'
+        self.aes_key = ElementTree.Element("AESKey")
+        data = pretty_xml_hex_array(str(self.cipher.encrypt_aes_key_iv().hex().upper()))
+        self.aes_key.text = f"\n{data}"
         self.root.append(self.aes_key)
 
     def add_Digest_tag(self):
         # calculate digest of encrypted file without digest tag
         # calculate digest of secret bytes
         # append the Digest tag to final XML
         file_name = self.file
-        self.tree.write(file_name, xml_declaration=True, encoding='UTF-8')
+        self.tree.write(file_name, xml_declaration=True, encoding="UTF-8")
 
         parser = ElementTree.XMLParser(remove_blank_text=True)
         xml_doc = ElementTree.parse(file_name, parser)
-        xml_doc.write(
-            file_name, pretty_print=True,
-            xml_declaration=True, encoding='UTF-8')
+        xml_doc.write(file_name, pretty_print=True, xml_declaration=True, encoding="UTF-8")
 
-        with open(file_name, 'rb') as f:
+        with open(file_name, "rb") as f:
             data = f.read()
         self.cipher.sha256_init()
         self.cipher.sha256_update(data)
 
-        digest = ElementTree.Element('Digest')
-        data = pretty_xml_hex_array(str(
-            self.cipher.sha256_hash().hex().upper()))
-        digest.text = f'\n{data}'
+        digest = ElementTree.Element("Digest")
+        data = pretty_xml_hex_array(str(self.cipher.sha256_hash().hex().upper()))
+        digest.text = f"\n{data}"
         xml_doc.getroot().append(digest)
-        xml_doc.write(
-            file_name, pretty_print=True,
-            xml_declaration=True, encoding='UTF-8')
+        xml_doc.write(file_name, pretty_print=True, xml_declaration=True, encoding="UTF-8")
 
     def perform_encryption(self):
         self.cipher = Ciphers(self.rsa_key_xml)
         slots_to_encrypt_by_mode = self.get_slots_to_encrypt_by_mode()
         for by_mode in slots_to_encrypt_by_mode.values():
             self.encrypt_device_slot(by_mode)
         self.add_QA_tag()
@@ -190,18 +179,18 @@
 
         self.cipher.sha256_init()
         self.cipher.sha256_update(data)
 
         return self.cipher.sha256_hash()
 
     def __pretty_print_hex(self, a):
-        return ''.join(['%02X ' % y for y in a])
+        return "".join(["%02X " % y for y in a])
 
 
 # Standard boilerplate to call the main() function to begin
 # the program.
-if __name__ == '__main__':
+if __name__ == "__main__":
     # xml_enc = ECCXMLEncryption(
     #                 'xml_handler/ATECC608B-MAHAA-T_0309170608.xml',
     #                 'xml_handler/test_RSA_Key.xml')
     # xml_enc.perform_encryption()
     pass
```

## tpds/xml_handler/tflxtls_xml_updates.py

```diff
@@ -14,268 +14,259 @@
 # PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY
 # KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 
-import os
 import json
+import os
 from pathlib import Path
+
 import lxml.etree as ElementTree
-from tpds.certs.tflex_certs import TFLEXCerts
-from tpds.certs.create_cert_defs import CertDef
 from cryptography.hazmat.primitives import serialization
+
+from tpds.certs.create_cert_defs import CertDef
+from tpds.certs.tflex_certs import TFLEXCerts
 from tpds.tp_utils.tp_utils import pretty_xml_hex_array
 
 
-class TFLXTLSXMLUpdates():
-    def __init__(self, base_xml='ECC608B_TFLXTLS.xml'):
+class TFLXTLSXMLUpdates:
+    def __init__(self, base_xml="ECC608B_TFLXTLS.xml"):
         curr_path = os.path.abspath(os.path.dirname(__file__))
         self.tree = ElementTree.parse(os.path.join(curr_path, base_xml))
         self.root = self.tree.getroot()
-        self.config_zone = self.root.find('Device').find('ConfigurationZone')
-        self.data_zone = self.root.find('Device').find('DataZone')
-        self.comp_certs = self.root.find('CompressedCerts')
-        self.cert_slots = {
-            'device_crt': 10,
-            'signer_crt': 12
-        }
+        self.config_zone = self.root.find("Device").find("ConfigurationZone")
+        self.data_zone = self.root.find("Device").find("DataZone")
+        self.comp_certs = self.root.find("CompressedCerts")
+        self.cert_slots = {"device_crt": 10, "signer_crt": 12}
 
     def update_with_user_data(self, user_data):
         self.user_data = json.loads(user_data)
-        self.root.find('PartNumber').text = self.user_data.get('part_number')
-        if 'ECC608A' in self.user_data.get('part_number'):
-            self.root.tag = 'ATECC608A'
-        self.config_zone.find('SN8').text = self.user_data.get('man_id')
-        if self.user_data.get('interface') == 'swi':
-            self.config_zone.find('I2CEnable').text = '00'
-            self.config_zone.find('I2CAddress').text = '03'
+        self.root.find("PartNumber").text = self.user_data.get("part_number")
+        if "ECC608A" in self.user_data.get("part_number"):
+            self.root.tag = "ATECC608A"
+        self.config_zone.find("SN8").text = self.user_data.get("man_id")
+        if self.user_data.get("interface") == "swi":
+            self.config_zone.find("I2CEnable").text = "00"
+            self.config_zone.find("I2CAddress").text = "03"
 
         self.__process_slot_config()
         self.__process_slot_data()
         self.__process_certs_data()
         self.__process_otp_data()
         # self.dump(self.root)
 
     def __process_slot_config(self):
-        if self.user_data.get('sboot_latch') == 'enabled':
-            key_config = self.config_zone.find(
-                "KeyConfigurations/KeyConfiguration[@Index='0']")
-            key_config.text = key_config.text[:3]+'1'+key_config.text[4:]
-            secure_boot = self.config_zone.find('SecureBoot')
-            secure_boot.text = secure_boot.text[:1]+'B'+secure_boot.text[2:]
-
-        slot_locked = [slot.get('slot_id') for slot in self.user_data.get(
-            'slot_info') if slot.get('slot_lock') == 'enabled']
+        if self.user_data.get("sboot_latch") == "enabled":
+            key_config = self.config_zone.find("KeyConfigurations/KeyConfiguration[@Index='0']")
+            key_config.text = key_config.text[:3] + "1" + key_config.text[4:]
+            secure_boot = self.config_zone.find("SecureBoot")
+            secure_boot.text = secure_boot.text[:1] + "B" + secure_boot.text[2:]
+
+        slot_locked = [
+            slot.get("slot_id")
+            for slot in self.user_data.get("slot_info")
+            if slot.get("slot_lock") == "enabled"
+        ]
         for slot in slot_locked:
             slot_config = self.config_zone.find(
-                f"SlotConfigurations/SlotConfiguration[@Index='{slot:X}']")
-            slot_config.text = slot_config.text[:3]+'8'+slot_config.text[4:]
+                f"SlotConfigurations/SlotConfiguration[@Index='{slot:X}']"
+            )
+            slot_config.text = slot_config.text[:3] + "8" + slot_config.text[4:]
 
     def __process_slot_data(self):
         public_key_slots = [13, 14, 15]
-        slots_with_data = [slot.get('slot_id') for slot in self.user_data.get(
-            'slot_info') if slot.get('data') is not None]
+        slots_with_data = [
+            slot.get("slot_id")
+            for slot in self.user_data.get("slot_info")
+            if slot.get("data") is not None
+        ]
 
         for slot in slots_with_data:
-            slot_details = self.user_data.get('slot_info')[slot]
+            slot_details = self.user_data.get("slot_info")[slot]
             slot_element = self.data_zone.find(f"Slot[@Index='{slot:X}']")
-            if slot_details.get('slot_type') == 'secret':
-                slot_element.set('Mode', 'Secret')
-                slot_data_element = ElementTree.SubElement(
-                    slot_element, 'Data')
+            if slot_details.get("slot_type") == "secret":
+                slot_element.set("Mode", "Secret")
+                slot_data_element = ElementTree.SubElement(slot_element, "Data")
                 if slot == 9:
-                    slot_data_element.set('Size', "72")
+                    slot_data_element.set("Size", "72")
                     data = pretty_xml_hex_array(
-                        self.user_data.get('slot_info')[slot].get(
-                            'data')+'0000000000000000')
+                        self.user_data.get("slot_info")[slot].get("data") + "0000000000000000"
+                    )
                 else:
-                    slot_data_element.set('Size', "36")
+                    slot_data_element.set("Size", "36")
                     data = pretty_xml_hex_array(
-                        self.user_data.get('slot_info')[slot].get(
-                            'data')+'00000000')
-                slot_data_element.text = f'\n{data}'
+                        self.user_data.get("slot_info")[slot].get("data") + "00000000"
+                    )
+                slot_data_element.text = f"\n{data}"
                 slot_element.append(slot_data_element)
-            elif slot_details.get('slot_type') == 'public':
-                slot_data = self.user_data.get('slot_info')[slot].get('data')
+            elif slot_details.get("slot_type") == "public":
+                slot_data = self.user_data.get("slot_info")[slot].get("data")
                 if slot in public_key_slots:
-                    slot_data = f'00000000{slot_data[:64]}00000000{slot_data[-64:]}'
+                    slot_data = f"00000000{slot_data[:64]}00000000{slot_data[-64:]}"
                 data = pretty_xml_hex_array(slot_data)
-                slot_element.find('Data').text = f'\n{data}'
-            elif slot_details.get('slot_type') == 'general':
-                slot_data = self.user_data.get('slot_info')[slot].get('data')
+                slot_element.find("Data").text = f"\n{data}"
+            elif slot_details.get("slot_type") == "general":
+                slot_data = self.user_data.get("slot_info")[slot].get("data")
                 data = pretty_xml_hex_array(slot_data)
-                slot_element.find('Data').text = f'\n{data}'
+                slot_element.find("Data").text = f"\n{data}"
 
     def __process_certs_data(self):
-        slot10_data = self.user_data.get('slot_info')[
-            self.cert_slots.get('device_crt')]
-        slot12_data = self.user_data.get('slot_info')[
-            self.cert_slots.get('signer_crt')]
+        slot10_data = self.user_data.get("slot_info")[self.cert_slots.get("device_crt")]
+        slot12_data = self.user_data.get("slot_info")[self.cert_slots.get("signer_crt")]
 
         self.tflex_certs = TFLEXCerts()
-        if slot12_data.get('cert_type') == 'MCHPCert':
+        if slot12_data.get("cert_type") == "MCHPCert":
             self.tflex_certs.build_root()
             self.tflex_certs.build_signer_csr()
             self.tflex_certs.build_signer()
             self.tflex_certs.build_device()
         else:
             self.tflex_certs.build_root(
-                org_name=slot12_data.get('signer_ca_org'),
-                common_name=slot12_data.get('signer_ca_cn'),
-                validity=int(slot12_data.get('cert_expiry_years')),
-                user_pub_key=bytes(slot12_data.get('signer_ca_pubkey'), 'ascii'))
+                org_name=slot12_data.get("signer_ca_org"),
+                common_name=slot12_data.get("signer_ca_cn"),
+                validity=int(slot12_data.get("cert_expiry_years")),
+                user_pub_key=bytes(slot12_data.get("signer_ca_pubkey"), "ascii"),
+            )
             self.tflex_certs.build_signer_csr(
-                org_name=slot12_data.get('cert_org'),
-                common_name=slot12_data.get('cert_cn'),
-                signer_id='FFFF')
-            self.tflex_certs.build_signer(
-                validity=int(slot12_data.get('cert_expiry_years')))
+                org_name=slot12_data.get("cert_org"),
+                common_name=slot12_data.get("cert_cn"),
+                signer_id="FFFF",
+            )
+            self.tflex_certs.build_signer(validity=int(slot12_data.get("cert_expiry_years")))
             self.tflex_certs.build_device(
-                device_sn=slot10_data.get('cert_cn'),
-                org_name=slot10_data.get('cert_org'),
-                validity=int(slot10_data.get('cert_expiry_years')))
-
-        certs_txt = self.tflex_certs.root.get_certificate_in_text()\
-            + '\n\n' + self.tflex_certs.signer.get_certificate_in_text()\
-            + '\n\n' + self.tflex_certs.device.get_certificate_in_text()
-        Path('custom_certs.txt').write_text(certs_txt)
-        Path('root.crt').write_bytes(
-            self.tflex_certs.root.get_certificate_in_pem())
-        Path('signer.crt').write_bytes(
-            self.tflex_certs.signer.get_certificate_in_pem())
-        Path('device.crt').write_bytes(
-            self.tflex_certs.device.get_certificate_in_pem())
+                device_sn=slot10_data.get("cert_cn"),
+                org_name=slot10_data.get("cert_org"),
+                validity=int(slot10_data.get("cert_expiry_years")),
+            )
+
+        certs_txt = (
+            self.tflex_certs.root.get_certificate_in_text()
+            + "\n\n"
+            + self.tflex_certs.signer.get_certificate_in_text()
+            + "\n\n"
+            + self.tflex_certs.device.get_certificate_in_text()
+        )
+        Path("custom_certs.txt").write_text(certs_txt)
+        Path("root.crt").write_bytes(self.tflex_certs.root.get_certificate_in_pem())
+        Path("signer.crt").write_bytes(self.tflex_certs.signer.get_certificate_in_pem())
+        Path("device.crt").write_bytes(self.tflex_certs.device.get_certificate_in_pem())
 
         self.__process_signer_cert(self.tflex_certs)
         self.__process_device_cert(self.tflex_certs)
 
     def __process_signer_cert(self, certs):
         cert_def = CertDef()
-        cert_def.set_certificate(
-            certs.signer.certificate, certs.root.certificate, 1)
+        cert_def.set_certificate(certs.signer.certificate, certs.root.certificate, 1)
         params = cert_def.get_cert_params()
 
-        signer_comp_cert = self.comp_certs.find(
-            "CompressedCert[@ChainLevel='1']")
-        signer_comp_cert.set('TemplateID', str(params.get('template_id')))
-        signer_comp_cert.set('ChainID', str(params.get('chain_id')))
-        signer_comp_cert.set('TbsSize', str(params.get(
-            'tbs_cert_loc').get('count')))
-        signer_comp_cert.set('TbsLoc', str(params.get(
-            'tbs_cert_loc').get('offset')))
-        signer_comp_cert.set('ValidYears', str(params.get('expire_years')))
-        if self.user_data.get('single_signer'):
-            signer_comp_cert.set(
-                "SingleSignerID", self.user_data.get('single_signer'))
+        signer_comp_cert = self.comp_certs.find("CompressedCert[@ChainLevel='1']")
+        signer_comp_cert.set("TemplateID", str(params.get("template_id")))
+        signer_comp_cert.set("ChainID", str(params.get("chain_id")))
+        signer_comp_cert.set("TbsSize", str(params.get("tbs_cert_loc").get("count")))
+        signer_comp_cert.set("TbsLoc", str(params.get("tbs_cert_loc").get("offset")))
+        signer_comp_cert.set("ValidYears", str(params.get("expire_years")))
+        if self.user_data.get("single_signer"):
+            signer_comp_cert.set("SingleSignerID", self.user_data.get("single_signer"))
 
         std_cert_elements = [
-            'SubjectPublicKey', 'Signature', 'IssueDate', 'ExpireDate',
-            'SignerID', 'SerialNumber', 'AuthorityKeyId', 'SubjectKeyId'
+            "SubjectPublicKey",
+            "Signature",
+            "IssueDate",
+            "ExpireDate",
+            "SignerID",
+            "SerialNumber",
+            "AuthorityKeyId",
+            "SubjectKeyId",
         ]
         for elem in std_cert_elements:
-            element = params.get('std_cert_elements')[
-                std_cert_elements.index(elem)]
+            element = params.get("std_cert_elements")[std_cert_elements.index(elem)]
             search_for = f"Element[@Name='{elem}']"
-            signer_comp_cert.find(search_for).set(
-                'DataLoc', str(element.get('offset')))
-            signer_comp_cert.find(search_for).set(
-                'NumBytes', str(element.get('count')))
-
-        template_data = cert_def.cert.public_bytes(
-            encoding=serialization.Encoding.DER)
-        signer_comp_cert.find('TemplateData').set(
-            'Size', str(len(template_data)))
+            signer_comp_cert.find(search_for).set("DataLoc", str(element.get("offset")))
+            signer_comp_cert.find(search_for).set("NumBytes", str(element.get("count")))
+
+        template_data = cert_def.cert.public_bytes(encoding=serialization.Encoding.DER)
+        signer_comp_cert.find("TemplateData").set("Size", str(len(template_data)))
         data = pretty_xml_hex_array(template_data.hex().upper())
-        signer_comp_cert.find('TemplateData').text = f'\n{data}'
+        signer_comp_cert.find("TemplateData").text = f"\n{data}"
 
-        slot12_data = self.user_data.get('slot_info')[
-            self.cert_slots.get('signer_crt')]
-        if slot12_data.get('cert_type') != 'MCHPCert':
-            data = pretty_xml_hex_array(slot12_data.get('signer_ca_pubkey'))
-            signer_comp_cert.find('CAPublicKey').text = f'\n{data}'
+        slot12_data = self.user_data.get("slot_info")[self.cert_slots.get("signer_crt")]
+        if slot12_data.get("cert_type") != "MCHPCert":
+            data = pretty_xml_hex_array(slot12_data.get("signer_ca_pubkey"))
+            signer_comp_cert.find("CAPublicKey").text = f"\n{data}"
         cert_def.get_c_definition(True)
 
     def __process_device_cert(self, certs):
         cert_def = CertDef()
-        cert_def.set_certificate(
-            certs.device.certificate, certs.signer.certificate, 3)
+        cert_def.set_certificate(certs.device.certificate, certs.signer.certificate, 3)
         params = cert_def.get_cert_params()
 
-        device_comp_cert = self.comp_certs.find(
-            "CompressedCert[@ChainLevel='0']")
-        device_comp_cert.set('TemplateID', str(params.get('template_id')))
-        device_comp_cert.set('ChainID', str(params.get('chain_id')))
-        device_comp_cert.set('TbsSize', str(params.get(
-            'tbs_cert_loc').get('count')))
-        device_comp_cert.set('TbsLoc', str(params.get(
-            'tbs_cert_loc').get('offset')))
-        device_comp_cert.set('ValidYears', str(params.get('expire_years')))
-        if self.user_data.get('single_signer'):
-            device_comp_cert.set(
-                "SingleSignerID", self.user_data.get('single_signer'))
+        device_comp_cert = self.comp_certs.find("CompressedCert[@ChainLevel='0']")
+        device_comp_cert.set("TemplateID", str(params.get("template_id")))
+        device_comp_cert.set("ChainID", str(params.get("chain_id")))
+        device_comp_cert.set("TbsSize", str(params.get("tbs_cert_loc").get("count")))
+        device_comp_cert.set("TbsLoc", str(params.get("tbs_cert_loc").get("offset")))
+        device_comp_cert.set("ValidYears", str(params.get("expire_years")))
+        if self.user_data.get("single_signer"):
+            device_comp_cert.set("SingleSignerID", self.user_data.get("single_signer"))
 
         std_cert_elements = [
-            'SubjectPublicKey', 'Signature', 'IssueDate', 'ExpireDate',
-            'SignerID', 'SerialNumber', 'AuthorityKeyId', 'SubjectKeyId'
+            "SubjectPublicKey",
+            "Signature",
+            "IssueDate",
+            "ExpireDate",
+            "SignerID",
+            "SerialNumber",
+            "AuthorityKeyId",
+            "SubjectKeyId",
         ]
         for elem in std_cert_elements:
-            element = params.get('std_cert_elements')[
-                std_cert_elements.index(elem)]
+            element = params.get("std_cert_elements")[std_cert_elements.index(elem)]
             search_for = f"Element[@Name='{elem}']"
-            device_comp_cert.find(search_for).set(
-                'DataLoc', str(element.get('offset')))
-            device_comp_cert.find(search_for).set(
-                'NumBytes', str(element.get('count')))
-
-        slot10_data = self.user_data.get('slot_info')[
-            self.cert_slots.get('device_crt')]
-        if (slot10_data.get('cert_type') != 'MCHPCert') and \
-                ('0123030405060708EE' not in slot10_data.get('cert_cn')):
-            device_comp_cert.remove(device_comp_cert.find(
-                "Element[@Name='SN03']"))
-            device_comp_cert.remove(device_comp_cert.find(
-                "Element[@Name='SN48']"))
+            device_comp_cert.find(search_for).set("DataLoc", str(element.get("offset")))
+            device_comp_cert.find(search_for).set("NumBytes", str(element.get("count")))
+
+        slot10_data = self.user_data.get("slot_info")[self.cert_slots.get("device_crt")]
+        if (slot10_data.get("cert_type") != "MCHPCert") and (
+            "0123030405060708EE" not in slot10_data.get("cert_cn")
+        ):
+            device_comp_cert.remove(device_comp_cert.find("Element[@Name='SN03']"))
+            device_comp_cert.remove(device_comp_cert.find("Element[@Name='SN48']"))
         else:
-            SN_elements = ['SN03', 'SN48']
+            SN_elements = ["SN03", "SN48"]
             cert_elements = cert_def.get_cert_elements()
             for element in cert_elements:
-                if element.get('id') in SN_elements:
-                    sn_data = cert_elements[SN_elements.index(
-                        element.get('id'))].get('cert_loc')
+                if element.get("id") in SN_elements:
+                    sn_data = cert_elements[SN_elements.index(element.get("id"))].get("cert_loc")
                     search_for = f"Element[@Name='{element.get('id')}']"
-                    device_comp_cert.find(search_for).set(
-                        'DataLoc', str(sn_data.get('offset')))
-                    device_comp_cert.find(search_for).set(
-                        'NumBytes', str(sn_data.get('count')))
-
-        template_data = cert_def.cert.public_bytes(
-            encoding=serialization.Encoding.DER)
-        device_comp_cert.find('TemplateData').set(
-            'Size', str(len(template_data)))
+                    device_comp_cert.find(search_for).set("DataLoc", str(sn_data.get("offset")))
+                    device_comp_cert.find(search_for).set("NumBytes", str(sn_data.get("count")))
+
+        template_data = cert_def.cert.public_bytes(encoding=serialization.Encoding.DER)
+        device_comp_cert.find("TemplateData").set("Size", str(len(template_data)))
         data = pretty_xml_hex_array(template_data.hex().upper())
-        device_comp_cert.find('TemplateData').text = f'\n{data}'
+        device_comp_cert.find("TemplateData").text = f"\n{data}"
         cert_def.get_c_definition(True)
 
     def __process_otp_data(self):
-        otp_element = self.root.find('Device').find('OTPZone')
-        data = pretty_xml_hex_array(self.user_data.get('otp_zone'))
-        otp_element.find('Data').text = f'\n{data}'
+        otp_element = self.root.find("Device").find("OTPZone")
+        data = pretty_xml_hex_array(self.user_data.get("otp_zone"))
+        otp_element.find("Data").text = f"\n{data}"
 
     def save_root(self, dest_xml):
         tree = ElementTree.ElementTree(self.root)
-        tree.write(dest_xml, xml_declaration=True, encoding='UTF-8')
+        tree.write(dest_xml, xml_declaration=True, encoding="UTF-8")
 
     def dump(self, element):
         print(ElementTree.dump(element))
 
 
 # Standard boilerplate to call the main() function to begin
 # the program.
-if __name__ == '__main__':
+if __name__ == "__main__":
     config_string = ' \
-    {\"base_xml\":\"ECC608B_TFLXTLS.xml\",\"xml_type\":\"proto_xml\",\"interface\":\"i2c\",\"slot_info\":[{\"slot_id\":0,\"slot_type\":\"private\",\"key_load_config\":\"noLoad\",\"slot_lock\":null},{\"slot_id\":1,\"slot_type\":\"private\",\"key_load_config\":\"noLoad\",\"slot_lock\":null},{\"slot_id\":2,\"slot_type\":\"private\",\"key_load_config\":\"noLoad\",\"slot_lock\":\"disabled\"},{\"slot_id\":3,\"slot_type\":\"private\",\"key_load_config\":\"noLoad\",\"slot_lock\":\"disabled\"},{\"slot_id\":4,\"slot_type\":\"private\",\"key_load_config\":\"noLoad\",\"slot_lock\":\"disabled\"},{\"slot_id\":5,\"slot_type\":\"secret\",\"key_load_config\":\"load\",\"slot_lock\":\"disabled\",\"data\":null},{\"slot_id\":6,\"slot_type\":\"secret\",\"key_load_config\":\"load\",\"slot_lock\":\"disabled\",\"data\":null},{\"slot_id\":7,\"slot_type\":\"general\",\"key_load_config\":\"noLoad\",\"slot_lock\":null},{\"slot_id\":8,\"slot_type\":\"general\",\"key_load_config\":\"load\",\"slot_lock\":\"disabled\",\"data\":null},{\"slot_id\":9,\"slot_type\":\"secret\",\"key_load_config\":\"load\",\"slot_lock\":null,\"data\":null},{\"slot_id\":10,\"slot_type\":\"cert\",\"key_load_config\":\"cert\",\"slot_lock\":null,\"cert_type\":\"custCert\",\"cert_org\":\"dev org name\",\"cert_cn\":\"sn0123030405060708EE\",\"cert_expiry_years\":\"10\"},{\"slot_id\":11,\"slot_type\":\"cert\",\"key_load_config\":\"noLoad\",\"slot_lock\":null},{\"slot_id\":12,\"slot_type\":\"cert\",\"key_load_config\":\"cert\",\"slot_lock\":null,\"cert_type\":\"custCert\",\"cert_org\":\"signer org\",\"cert_cn\":\"signer cn\",\"cert_expiry_years\":\"10\",\"signer_ca_org\":\"root org\",\"signer_ca_cn\":\"root cn\",\"signer_ca_pubkey\":\"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111\"},{\"slot_id\":13,\"slot_type\":\"public\",\"key_load_config\":\"load\",\"slot_lock\":\"disabled\",\"data\":null},{\"slot_id\":14,\"slot_type\":\"public\",\"key_load_config\":\"load\",\"slot_lock\":null,\"data\":null},{\"slot_id\":15,\"slot_type\":\"public\",\"key_load_config\":\"load\",\"slot_lock\":\"disabled\",\"data\":null}],\"sboot_latch\":\"disabled\",\"man_id\":\"01\",\"part_number\":\"ATECC608B-MAHAA-T\",\"otp_zone\":\"77644E78416A61650000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"}'
+    {"base_xml":"ECC608B_TFLXTLS.xml","xml_type":"proto_xml","interface":"i2c","slot_info":[{"slot_id":0,"slot_type":"private","key_load_config":"noLoad","slot_lock":null},{"slot_id":1,"slot_type":"private","key_load_config":"noLoad","slot_lock":null},{"slot_id":2,"slot_type":"private","key_load_config":"noLoad","slot_lock":"disabled"},{"slot_id":3,"slot_type":"private","key_load_config":"noLoad","slot_lock":"disabled"},{"slot_id":4,"slot_type":"private","key_load_config":"noLoad","slot_lock":"disabled"},{"slot_id":5,"slot_type":"secret","key_load_config":"load","slot_lock":"disabled","data":null},{"slot_id":6,"slot_type":"secret","key_load_config":"load","slot_lock":"disabled","data":null},{"slot_id":7,"slot_type":"general","key_load_config":"noLoad","slot_lock":null},{"slot_id":8,"slot_type":"general","key_load_config":"load","slot_lock":"disabled","data":null},{"slot_id":9,"slot_type":"secret","key_load_config":"load","slot_lock":null,"data":null},{"slot_id":10,"slot_type":"cert","key_load_config":"cert","slot_lock":null,"cert_type":"custCert","cert_org":"dev org name","cert_cn":"sn0123030405060708EE","cert_expiry_years":"10"},{"slot_id":11,"slot_type":"cert","key_load_config":"noLoad","slot_lock":null},{"slot_id":12,"slot_type":"cert","key_load_config":"cert","slot_lock":null,"cert_type":"custCert","cert_org":"signer org","cert_cn":"signer cn","cert_expiry_years":"10","signer_ca_org":"root org","signer_ca_cn":"root cn","signer_ca_pubkey":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"},{"slot_id":13,"slot_type":"public","key_load_config":"load","slot_lock":"disabled","data":null},{"slot_id":14,"slot_type":"public","key_load_config":"load","slot_lock":null,"data":null},{"slot_id":15,"slot_type":"public","key_load_config":"load","slot_lock":"disabled","data":null}],"sboot_latch":"disabled","man_id":"01","part_number":"ATECC608B-MAHAA-T","otp_zone":"77644E78416A61650000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}'
     xml = TFLXTLSXMLUpdates()
     xml.update_with_user_data(config_string)
-    part_number = json.loads(config_string).get('part_number')
-    xml.save_root(f'{part_number}.xml')
+    part_number = json.loads(config_string).get("part_number")
+    xml.save_root(f"{part_number}.xml")
```

## tpds/xml_handler/tflxwpc_xml_updates.py

```diff
@@ -14,315 +14,311 @@
 # PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY
 # KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 
-import os
 # import sys
 # sys.path.append(os.path.normpath( os.path.join(os.getcwd(), *([".."] * 3), 'tpds_helper')))
 # sys.path.append(os.path.normpath( os.path.join(os.getcwd(), *([".."] * 3), 'tpds_core')))
 import json
+import os
+from datetime import datetime, timezone
 from pathlib import Path
+
 import lxml.etree as ElementTree
-from tpds.certs import Cert
-from tpds.certs.ext_builder import TimeFormat
-from tpds.certs.cert_utils import (
-            pubkey_cert_sn, get_device_public_key, get_backend)
-from tpds.certs.tflex_certs import TFLEXCerts
-from tpds.certs.create_cert_defs import CertDef
 from cryptography import x509
 from cryptography.hazmat.primitives import serialization
 from cryptography.hazmat.primitives.asymmetric import ec
-from tpds.tp_utils.tp_utils import pretty_xml_hex_array
+
+from tpds.certs import Cert
+from tpds.certs.cert_utils import get_backend, get_device_public_key, pubkey_cert_sn
+from tpds.certs.create_cert_defs import CertDef
+from tpds.certs.ext_builder import TimeFormat
+from tpds.certs.tflex_certs import TFLEXCerts
 from tpds.tp_utils.tp_keys import TPAsymmetricKey
-from datetime import datetime, timezone
+from tpds.tp_utils.tp_utils import pretty_xml_hex_array
 
 
-class TFLXWPCXMLUpdates():
-    def __init__(self, base_xml='ECC608A-MAH-TFLXWPC.xml'):
+class TFLXWPCXMLUpdates:
+    def __init__(self, base_xml="ECC608A-MAH-TFLXWPC.xml"):
         curr_path = os.path.abspath(os.path.dirname(__file__))
         self.tree = ElementTree.parse(os.path.join(curr_path, base_xml))
         self.root = self.tree.getroot()
-        self.config_zone = self.root.find('Device').find('ConfigurationZone')
-        self.data_zone = self.root.find('Device').find('DataZone')
-        self.comp_certs = self.root.find('CompressedCerts')
-        self.cert_slots = {
-            'device_crt': 10,
-            'signer_crt': 12
-        }
+        self.config_zone = self.root.find("Device").find("ConfigurationZone")
+        self.data_zone = self.root.find("Device").find("DataZone")
+        self.comp_certs = self.root.find("CompressedCerts")
+        self.cert_slots = {"device_crt": 10, "signer_crt": 12}
 
     def update_with_user_data(self, user_data):
         self.user_data = json.loads(user_data)
-        self.root.find('PartNumber').text = self.user_data.get('part_number')
-        if 'ECC608A' in self.user_data.get('part_number'):
-            self.root.tag = 'ATECC608A'
-        self.config_zone.find('SN8').text = self.user_data.get('man_id')
-        if self.user_data.get('interface') == 'swi':
-            self.config_zone.find('I2CEnable').text = '00'
-            self.config_zone.find('I2CAddress').text = '03'
+        self.root.find("PartNumber").text = self.user_data.get("part_number")
+        if "ECC608A" in self.user_data.get("part_number"):
+            self.root.tag = "ATECC608A"
+        self.config_zone.find("SN8").text = self.user_data.get("man_id")
+        if self.user_data.get("interface") == "swi":
+            self.config_zone.find("I2CEnable").text = "00"
+            self.config_zone.find("I2CAddress").text = "03"
 
         self.__process_slot_config()
         self.__process_slot_data()
         self.__process_otp_data()
         self.__process_wpc_certs_data()
         # self.__process_tls_certs_data()
         # self.dump(self.root)
 
     def __process_slot_config(self):
-        if self.user_data.get('sboot_latch') == 'enabled':
+        if self.user_data.get("sboot_latch") == "enabled":
             for slot in [0, 1, 2]:
                 key_config = self.config_zone.find(
-                    f'''KeyConfigurations/KeyConfiguration[@Index='{slot:X}']''')
-                key_config.text = key_config.text[:3]+'1'+key_config.text[4:]
-            secure_boot = self.config_zone.find('SecureBoot')
-            secure_boot.text = secure_boot.text[:1]+'B'+secure_boot.text[2:]
-
-        slot_locked = [slot.get('slot_id') for slot in self.user_data.get(
-            'slot_info') if slot.get('slot_lock') == 'enabled']
+                    f"""KeyConfigurations/KeyConfiguration[@Index='{slot:X}']"""
+                )
+                key_config.text = key_config.text[:3] + "1" + key_config.text[4:]
+            secure_boot = self.config_zone.find("SecureBoot")
+            secure_boot.text = secure_boot.text[:1] + "B" + secure_boot.text[2:]
+
+        slot_locked = [
+            slot.get("slot_id")
+            for slot in self.user_data.get("slot_info")
+            if slot.get("slot_lock") == "enabled"
+        ]
         for slot in slot_locked:
             slot_config = self.config_zone.find(
-                f"SlotConfigurations/SlotConfiguration[@Index='{slot:X}']")
-            slot_config.text = slot_config.text[:3]+'8'+slot_config.text[4:]
+                f"SlotConfigurations/SlotConfiguration[@Index='{slot:X}']"
+            )
+            slot_config.text = slot_config.text[:3] + "8" + slot_config.text[4:]
 
     def __process_slot_data(self):
         mfg_ca_slot = 4
         slot_element = self.data_zone.find(f"Slot[@Index='{mfg_ca_slot:X}']")
-        ptmc_seq_id = self.user_data.get('ptmc')+'-'+ self.user_data.get('ca_seq_id')
-        data = '00'*10 + '3230' + '00'*13 + ptmc_seq_id.encode().hex().upper() + \
-            '00'*3 + '01'
-        slot_element.find('Data').text = f'\n{pretty_xml_hex_array(data)}'
+        ptmc_seq_id = self.user_data.get("ptmc") + "-" + self.user_data.get("ca_seq_id")
+        data = "00" * 10 + "3230" + "00" * 13 + ptmc_seq_id.encode().hex().upper() + "00" * 3 + "01"
+        slot_element.find("Data").text = f"\n{pretty_xml_hex_array(data)}"
 
         public_key_slots = [15]
-        slots_with_data = [slot.get('slot_id') for slot in self.user_data.get(
-            'slot_info') if slot.get('data') is not None]
+        slots_with_data = [
+            slot.get("slot_id")
+            for slot in self.user_data.get("slot_info")
+            if slot.get("data") is not None
+        ]
         for slot in slots_with_data:
-            slot_details = self.user_data.get('slot_info')[slot]
+            slot_details = self.user_data.get("slot_info")[slot]
             slot_element = self.data_zone.find(f"Slot[@Index='{slot:X}']")
-            if slot_details.get('slot_type') == 'secret':
-                slot_element.set('Mode', 'Secret')
-                slot_data_element = ElementTree.SubElement(
-                                                    slot_element, 'Data')
-                slot_data_element.set('Size', "36")
+            if slot_details.get("slot_type") == "secret":
+                slot_element.set("Mode", "Secret")
+                slot_data_element = ElementTree.SubElement(slot_element, "Data")
+                slot_data_element.set("Size", "36")
                 data = pretty_xml_hex_array(
-                    self.user_data.get('slot_info')[slot].get('data')+'00000000')
-                slot_data_element.text = f'\n{data}'
+                    self.user_data.get("slot_info")[slot].get("data") + "00000000"
+                )
+                slot_data_element.text = f"\n{data}"
                 slot_element.append(slot_data_element)
-            elif slot_details.get('slot_type') == 'public':
-                slot_data = self.user_data.get('slot_info')[slot].get('data')
+            elif slot_details.get("slot_type") == "public":
+                slot_data = self.user_data.get("slot_info")[slot].get("data")
                 if slot in public_key_slots:
-                    slot_data = f'00000000{slot_data[:64]}00000000{slot_data[-64:]}'
+                    slot_data = f"00000000{slot_data[:64]}00000000{slot_data[-64:]}"
                 data = pretty_xml_hex_array(slot_data)
-                slot_element.find('Data').text = f'\n{data}'
+                slot_element.find("Data").text = f"\n{data}"
 
     def __process_otp_data(self):
-        otp_element = self.root.find('Device').find('OTPZone')
-        data = pretty_xml_hex_array(self.user_data.get('otp_zone'))
-        otp_element.find('Data').text = f'\n{data}'
+        otp_element = self.root.find("Device").find("OTPZone")
+        data = pretty_xml_hex_array(self.user_data.get("otp_zone"))
+        otp_element.find("Data").text = f"\n{data}"
 
     def __process_wpc_certs_data(self):
-        ptmc = self.user_data.get('ptmc')
-        ca_seq_id = self.user_data.get('ca_seq_id')
-        qi_id = self.user_data.get('qi_id')
-        rsid = f'{os.urandom(4).hex().upper().zfill(16)}'
+        ptmc = self.user_data.get("ptmc")
+        ca_seq_id = self.user_data.get("ca_seq_id")
+        qi_id = self.user_data.get("qi_id")
+        rsid = f"{os.urandom(4).hex().upper().zfill(16)}"
         mfg_comp_cert = self.comp_certs.find("CompressedCert[@ChainLevel='1']")
-        mfg_comp_cert.set('SingleSignerID', f'WPC_CA_{ptmc}_{ca_seq_id.zfill(4)}')
+        mfg_comp_cert.set("SingleSignerID", f"WPC_CA_{ptmc}_{ca_seq_id.zfill(4)}")
         puc_comp_cert = self.comp_certs.find("CompressedCert[@ChainLevel='0']")
-        puc_comp_cert.set('SingleSignerID', f'WPC_CA_{ptmc}_{ca_seq_id.zfill(4)}')
-        puc_comp_cert.find("Element[@Name='RSID']").set('CounterStart', rsid)
+        puc_comp_cert.set("SingleSignerID", f"WPC_CA_{ptmc}_{ca_seq_id.zfill(4)}")
+        puc_comp_cert.find("Element[@Name='RSID']").set("CounterStart", rsid)
 
         # Build device certificate template data
         device_ca_key = TPAsymmetricKey()
         device_pubkey = get_device_public_key(None)
         device_pubkey = ec.EllipticCurvePublicNumbers(
-            x=int(device_pubkey[:64], 16),
-            y=int(device_pubkey[64:], 16),
-            curve=ec.SECP256R1()).public_key(get_backend())
+            x=int(device_pubkey[:64], 16), y=int(device_pubkey[64:], 16), curve=ec.SECP256R1()
+        ).public_key(get_backend())
 
         new_device = Cert()
         new_device.builder = new_device.builder.issuer_name(
-                                    x509.Name([
-                                        x509.NameAttribute(x509.oid.NameOID.COMMON_NAME,f'{ptmc}-{ca_seq_id}')]))
+            x509.Name([x509.NameAttribute(x509.oid.NameOID.COMMON_NAME, f"{ptmc}-{ca_seq_id}")])
+        )
         new_device.builder = new_device.builder.not_valid_before(
-                                    datetime.utcnow().replace(tzinfo=timezone.utc, minute=0, second=0),
-                                    format=TimeFormat.GENERALIZED_TIME)
+            datetime.utcnow().replace(tzinfo=timezone.utc, minute=0, second=0),
+            format=TimeFormat.GENERALIZED_TIME,
+        )
         new_device.builder = new_device.builder.not_valid_after(
-                                    datetime(9999, 12, 31, 23, 59, 59, tzinfo=timezone.utc),
-                                    format=TimeFormat.GENERALIZED_TIME)
+            datetime(9999, 12, 31, 23, 59, 59, tzinfo=timezone.utc),
+            format=TimeFormat.GENERALIZED_TIME,
+        )
         new_device.builder = new_device.builder.subject_name(
-                                        x509.Name([x509.NameAttribute(x509.oid.NameOID.COMMON_NAME, f'{qi_id}')]))
+            x509.Name([x509.NameAttribute(x509.oid.NameOID.COMMON_NAME, f"{qi_id}")])
+        )
         new_device.builder = new_device.builder.public_key(device_pubkey)
         new_device.builder = new_device.builder.serial_number(pubkey_cert_sn(8, new_device.builder))
 
-        rsid_bytes = int(rsid, 16).to_bytes(9, byteorder='big', signed=False)
+        rsid_bytes = int(rsid, 16).to_bytes(9, byteorder="big", signed=False)
         rsid_extension_value = bytes([0x04, len(rsid_bytes)]) + rsid_bytes
         new_device.builder = new_device.builder.add_extension(
-            x509.UnrecognizedExtension(x509.ObjectIdentifier(
-                '2.23.148.1.2'), rsid_extension_value),
-            critical=True)
+            x509.UnrecognizedExtension(x509.ObjectIdentifier("2.23.148.1.2"), rsid_extension_value),
+            critical=True,
+        )
         new_device.sign_builder(device_ca_key.private_key)
         template_data = new_device.certificate.public_bytes(encoding=serialization.Encoding.DER)
-        puc_comp_cert.find('TemplateData').set('Size', str(len(template_data)))
+        puc_comp_cert.find("TemplateData").set("Size", str(len(template_data)))
         data = pretty_xml_hex_array(template_data.hex().upper())
-        puc_comp_cert.find('TemplateData').text = f'\n{data}'
+        puc_comp_cert.find("TemplateData").text = f"\n{data}"
 
     def __process_tls_certs_data(self):
-        slot10_data = self.user_data.get('slot_info')[
-            self.cert_slots.get('device_crt')]
-        slot12_data = self.user_data.get('slot_info')[
-            self.cert_slots.get('signer_crt')]
+        slot10_data = self.user_data.get("slot_info")[self.cert_slots.get("device_crt")]
+        slot12_data = self.user_data.get("slot_info")[self.cert_slots.get("signer_crt")]
 
         self.tflex_certs = TFLEXCerts()
-        if slot12_data.get('cert_type') == 'MCHPCert':
+        if slot12_data.get("cert_type") == "MCHPCert":
             self.tflex_certs.build_root()
             self.tflex_certs.build_signer_csr()
             self.tflex_certs.build_signer()
             self.tflex_certs.build_device()
         else:
             self.tflex_certs.build_root(
-                org_name=slot12_data.get('signer_ca_org'),
-                common_name=slot12_data.get('signer_ca_cn'),
-                validity=int(slot12_data.get('cert_expiry_years')),
-                user_pub_key=bytes(slot12_data.get('signer_ca_pubkey'), 'ascii'))
+                org_name=slot12_data.get("signer_ca_org"),
+                common_name=slot12_data.get("signer_ca_cn"),
+                validity=int(slot12_data.get("cert_expiry_years")),
+                user_pub_key=bytes(slot12_data.get("signer_ca_pubkey"), "ascii"),
+            )
             self.tflex_certs.build_signer_csr(
-                org_name=slot12_data.get('cert_org'),
-                common_name=slot12_data.get('cert_cn'),
-                signer_id='FFFF')
-            self.tflex_certs.build_signer(
-                validity=int(slot12_data.get('cert_expiry_years')))
+                org_name=slot12_data.get("cert_org"),
+                common_name=slot12_data.get("cert_cn"),
+                signer_id="FFFF",
+            )
+            self.tflex_certs.build_signer(validity=int(slot12_data.get("cert_expiry_years")))
             self.tflex_certs.build_device(
-                device_sn=slot10_data.get('cert_cn'),
-                org_name=slot10_data.get('cert_org'),
-                validity=int(slot10_data.get('cert_expiry_years')))
-
-        certs_txt = self.tflex_certs.root.get_certificate_in_text()\
-            + '\n\n' + self.tflex_certs.signer.get_certificate_in_text()\
-            + '\n\n' + self.tflex_certs.device.get_certificate_in_text()
-        Path('custom_certs.txt').write_text(certs_txt)
-        Path('root.crt').write_bytes(
-            self.tflex_certs.root.get_certificate_in_pem())
-        Path('signer.crt').write_bytes(
-            self.tflex_certs.signer.get_certificate_in_pem())
-        Path('device.crt').write_bytes(
-            self.tflex_certs.device.get_certificate_in_pem())
+                device_sn=slot10_data.get("cert_cn"),
+                org_name=slot10_data.get("cert_org"),
+                validity=int(slot10_data.get("cert_expiry_years")),
+            )
+
+        certs_txt = (
+            self.tflex_certs.root.get_certificate_in_text()
+            + "\n\n"
+            + self.tflex_certs.signer.get_certificate_in_text()
+            + "\n\n"
+            + self.tflex_certs.device.get_certificate_in_text()
+        )
+        Path("custom_certs.txt").write_text(certs_txt)
+        Path("root.crt").write_bytes(self.tflex_certs.root.get_certificate_in_pem())
+        Path("signer.crt").write_bytes(self.tflex_certs.signer.get_certificate_in_pem())
+        Path("device.crt").write_bytes(self.tflex_certs.device.get_certificate_in_pem())
 
         self.__process_signer_cert(self.tflex_certs)
         self.__process_device_cert(self.tflex_certs)
 
     def __process_signer_cert(self, certs):
         cert_def = CertDef()
-        cert_def.set_certificate(
-            certs.signer.certificate, certs.root.certificate, 1)
+        cert_def.set_certificate(certs.signer.certificate, certs.root.certificate, 1)
         params = cert_def.get_cert_params()
 
-        signer_comp_cert = self.comp_certs.find(
-                            "CompressedCert[@ChainLevel='1']")
-        signer_comp_cert.set('TemplateID', str(params.get('template_id')))
-        signer_comp_cert.set('ChainID', str(params.get('chain_id')))
-        signer_comp_cert.set('TbsSize', str(params.get(
-                            'tbs_cert_loc').get('count')))
-        signer_comp_cert.set('TbsLoc', str(params.get(
-                            'tbs_cert_loc').get('offset')))
-        signer_comp_cert.set('ValidYears', str(params.get('expire_years')))
+        signer_comp_cert = self.comp_certs.find("CompressedCert[@ChainLevel='1']")
+        signer_comp_cert.set("TemplateID", str(params.get("template_id")))
+        signer_comp_cert.set("ChainID", str(params.get("chain_id")))
+        signer_comp_cert.set("TbsSize", str(params.get("tbs_cert_loc").get("count")))
+        signer_comp_cert.set("TbsLoc", str(params.get("tbs_cert_loc").get("offset")))
+        signer_comp_cert.set("ValidYears", str(params.get("expire_years")))
 
         std_cert_elements = [
-            'SubjectPublicKey', 'Signature', 'IssueDate', 'ExpireDate',
-            'SignerID', 'SerialNumber', 'AuthorityKeyId', 'SubjectKeyId'
+            "SubjectPublicKey",
+            "Signature",
+            "IssueDate",
+            "ExpireDate",
+            "SignerID",
+            "SerialNumber",
+            "AuthorityKeyId",
+            "SubjectKeyId",
         ]
         for elem in std_cert_elements:
-            element = params.get('std_cert_elements')[
-                std_cert_elements.index(elem)]
+            element = params.get("std_cert_elements")[std_cert_elements.index(elem)]
             search_for = f"Element[@Name='{elem}']"
-            signer_comp_cert.find(search_for).set(
-                            'DataLoc', str(element.get('offset')))
-            signer_comp_cert.find(search_for).set(
-                            'NumBytes', str(element.get('count')))
-
-        template_data = cert_def.cert.public_bytes(
-                            encoding=serialization.Encoding.DER)
-        signer_comp_cert.find('TemplateData').set(
-                            'Size', str(len(template_data)))
+            signer_comp_cert.find(search_for).set("DataLoc", str(element.get("offset")))
+            signer_comp_cert.find(search_for).set("NumBytes", str(element.get("count")))
+
+        template_data = cert_def.cert.public_bytes(encoding=serialization.Encoding.DER)
+        signer_comp_cert.find("TemplateData").set("Size", str(len(template_data)))
         data = pretty_xml_hex_array(template_data.hex().upper())
-        signer_comp_cert.find('TemplateData').text = f'\n{data}'
+        signer_comp_cert.find("TemplateData").text = f"\n{data}"
 
-        slot12_data = self.user_data.get('slot_info')[
-                            self.cert_slots.get('signer_crt')]
-        if slot12_data.get('cert_type') != 'MCHPCert':
-            data = pretty_xml_hex_array(slot12_data.get('signer_ca_pubkey'))
-            signer_comp_cert.find('CAPublicKey').text = f'\n{data}'
+        slot12_data = self.user_data.get("slot_info")[self.cert_slots.get("signer_crt")]
+        if slot12_data.get("cert_type") != "MCHPCert":
+            data = pretty_xml_hex_array(slot12_data.get("signer_ca_pubkey"))
+            signer_comp_cert.find("CAPublicKey").text = f"\n{data}"
         cert_def.get_c_definition(True)
 
     def __process_device_cert(self, certs):
         cert_def = CertDef()
-        cert_def.set_certificate(
-            certs.device.certificate, certs.signer.certificate, 3)
+        cert_def.set_certificate(certs.device.certificate, certs.signer.certificate, 3)
         params = cert_def.get_cert_params()
 
-        device_comp_cert = self.comp_certs.find(
-                            "CompressedCert[@ChainLevel='0']")
-        device_comp_cert.set('TemplateID', str(params.get('template_id')))
-        device_comp_cert.set('ChainID', str(params.get('chain_id')))
-        device_comp_cert.set('TbsSize', str(params.get(
-                            'tbs_cert_loc').get('count')))
-        device_comp_cert.set('TbsLoc', str(params.get(
-                            'tbs_cert_loc').get('offset')))
-        device_comp_cert.set('ValidYears', str(params.get('expire_years')))
+        device_comp_cert = self.comp_certs.find("CompressedCert[@ChainLevel='0']")
+        device_comp_cert.set("TemplateID", str(params.get("template_id")))
+        device_comp_cert.set("ChainID", str(params.get("chain_id")))
+        device_comp_cert.set("TbsSize", str(params.get("tbs_cert_loc").get("count")))
+        device_comp_cert.set("TbsLoc", str(params.get("tbs_cert_loc").get("offset")))
+        device_comp_cert.set("ValidYears", str(params.get("expire_years")))
 
         std_cert_elements = [
-            'SubjectPublicKey', 'Signature', 'IssueDate', 'ExpireDate',
-            'SignerID', 'SerialNumber', 'AuthorityKeyId', 'SubjectKeyId'
+            "SubjectPublicKey",
+            "Signature",
+            "IssueDate",
+            "ExpireDate",
+            "SignerID",
+            "SerialNumber",
+            "AuthorityKeyId",
+            "SubjectKeyId",
         ]
         for elem in std_cert_elements:
-            element = params.get('std_cert_elements')[
-                std_cert_elements.index(elem)]
+            element = params.get("std_cert_elements")[std_cert_elements.index(elem)]
             search_for = f"Element[@Name='{elem}']"
-            device_comp_cert.find(search_for).set(
-                                'DataLoc', str(element.get('offset')))
-            device_comp_cert.find(search_for).set(
-                                'NumBytes', str(element.get('count')))
-
-        slot10_data = self.user_data.get('slot_info')[
-                                self.cert_slots.get('device_crt')]
-        if (slot10_data.get('cert_type') != 'MCHPCert') and \
-        ('0123030405060708EE' not in slot10_data.get('cert_cn')):
-            device_comp_cert.remove(device_comp_cert.find(
-                                "Element[@Name='SN03']"))
-            device_comp_cert.remove(device_comp_cert.find(
-                                "Element[@Name='SN48']"))
+            device_comp_cert.find(search_for).set("DataLoc", str(element.get("offset")))
+            device_comp_cert.find(search_for).set("NumBytes", str(element.get("count")))
+
+        slot10_data = self.user_data.get("slot_info")[self.cert_slots.get("device_crt")]
+        if (slot10_data.get("cert_type") != "MCHPCert") and (
+            "0123030405060708EE" not in slot10_data.get("cert_cn")
+        ):
+            device_comp_cert.remove(device_comp_cert.find("Element[@Name='SN03']"))
+            device_comp_cert.remove(device_comp_cert.find("Element[@Name='SN48']"))
         else:
-            SN_elements = ['SN03', 'SN48']
+            SN_elements = ["SN03", "SN48"]
             cert_elements = cert_def.get_cert_elements()
             for element in cert_elements:
-                if element.get('id') in SN_elements:
-                    sn_data = cert_elements[SN_elements.index(
-                                element.get('id'))].get('cert_loc')
+                if element.get("id") in SN_elements:
+                    sn_data = cert_elements[SN_elements.index(element.get("id"))].get("cert_loc")
                     search_for = f"Element[@Name='{element.get('id')}']"
-                    device_comp_cert.find(search_for).set(
-                                'DataLoc', str(sn_data.get('offset')))
-                    device_comp_cert.find(search_for).set(
-                                'NumBytes', str(sn_data.get('count')))
-
-        template_data = cert_def.cert.public_bytes(
-                                encoding=serialization.Encoding.DER)
-        device_comp_cert.find('TemplateData').set(
-                                'Size', str(len(template_data)))
+                    device_comp_cert.find(search_for).set("DataLoc", str(sn_data.get("offset")))
+                    device_comp_cert.find(search_for).set("NumBytes", str(sn_data.get("count")))
+
+        template_data = cert_def.cert.public_bytes(encoding=serialization.Encoding.DER)
+        device_comp_cert.find("TemplateData").set("Size", str(len(template_data)))
         data = pretty_xml_hex_array(template_data.hex().upper())
-        device_comp_cert.find('TemplateData').text = f'\n{data}'
+        device_comp_cert.find("TemplateData").text = f"\n{data}"
         cert_def.get_c_definition(True)
 
     def save_root(self, dest_xml):
         tree = ElementTree.ElementTree(self.root)
-        tree.write(dest_xml, xml_declaration=True, encoding='UTF-8')
+        tree.write(dest_xml, xml_declaration=True, encoding="UTF-8")
 
     def dump(self, element):
         print(ElementTree.dump(element))
 
 
 # Standard boilerplate to call the main() function to begin
 # the program.
-if __name__ == '__main__':
+if __name__ == "__main__":
     config_string = ' \
     {"base_xml":"ECC608A-MAH-TFLXWPC.xml","xml_type":"proto_xml","interface":"i2c","slot_info":[{"slot_id":0,"slot_type":"private","key_load_config":"noLoad","slot_lock":null},{"slot_id":1,"slot_type":"private","key_load_config":"noLoad","slot_lock":null},{"slot_id":2,"slot_type":"private","key_load_config":"noLoad","slot_lock":null},{"slot_id":3,"slot_type":"general","key_load_config":"noLoad","slot_lock":"disabled"},{"slot_id":4,"slot_type":"general","key_load_config":"noLoad","slot_lock":null},{"slot_id":5,"slot_type":"general","key_load_config":"noLoad","slot_lock":null},{"slot_id":6,"slot_type":"secret","key_load_config":"load","slot_lock":"disabled","data":null},{"slot_id":7,"slot_type":"general","key_load_config":"noLoad","slot_lock":null},{"slot_id":8,"slot_type":"general","key_load_config":"noLoad","slot_lock":"disabled"},{"slot_id":9,"slot_type":"general","key_load_config":"noLoad","slot_lock":null},{"slot_id":10,"slot_type":"cert","key_load_config":"noLoad","slot_lock":null},{"slot_id":11,"slot_type":"cert","key_load_config":"noLoad","slot_lock":null},{"slot_id":12,"slot_type":"cert","key_load_config":"noLoad","slot_lock":null},{"slot_id":13,"slot_type":"general","key_load_config":"noLoad","slot_lock":null},{"slot_id":14,"slot_type":"general","key_load_config":"noLoad","slot_lock":null},{"slot_id":15,"slot_type":"public","key_load_config":"load","slot_lock":"disabled","data":null}],"sboot_latch":"enabled","man_id":"01","part_number":"ATECC608A-xxxxxx-T","otp_zone":"601B1E853B13C7750000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "ptmc":"004E", "qi_id":"11430", "ca_seq_id":"10"}'
-    xml = TFLXWPCXMLUpdates(json.loads(config_string).get('base_xml'))
+    xml = TFLXWPCXMLUpdates(json.loads(config_string).get("base_xml"))
     xml.update_with_user_data(config_string)
-    xml.save_root(f'''{json.loads(config_string).get('part_number')}.xml''')
+    xml.save_root(f"""{json.loads(config_string).get('part_number')}.xml""")
```

## tpds/xml_handler/xml_processing.py

```diff
@@ -15,43 +15,46 @@
 # KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
 # HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
 # FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
 # ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 # THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 
 from __future__ import annotations
+
 from typing import Any
+
 from tpds.xml_handler.tflxtls_xml_updates import TFLXTLSXMLUpdates
 from tpds.xml_handler.tflxwpc_xml_updates import TFLXWPCXMLUpdates
 
 
-class XMLProcessingRegistry():
+class XMLProcessingRegistry:
     __shared_state: dict[str, Any] = {}
 
     def __new__(cls, **kwargs: str) -> Any:
         # Only ever allow one global instance of the usecase collector
         instance = super().__new__(cls)
         instance.__dict__ = cls.__shared_state
         return instance
 
     def __init__(self) -> None:
-        if '_registry' not in self.__dict__.keys():
+        if "_registry" not in self.__dict__.keys():
             self._registry = {
-                'ECC608B_TFLXTLS.xml': TFLXTLSXMLUpdates('ECC608B_TFLXTLS.xml'),
-                'PIC32CMLS60_ECC608.xml': TFLXTLSXMLUpdates('PIC32CMLS60_ECC608.xml'),
-                'ECC608A-MAH-TFLXWPC.xml': TFLXWPCXMLUpdates('ECC608A-MAH-TFLXWPC.xml')
+                "ECC608B_TFLXTLS.xml": TFLXTLSXMLUpdates("ECC608B_TFLXTLS.xml"),
+                "PIC32CMLS60_ECC608.xml": TFLXTLSXMLUpdates("PIC32CMLS60_ECC608.xml"),
+                "ECC608A-MAH-TFLXWPC.xml": TFLXWPCXMLUpdates("ECC608A-MAH-TFLXWPC.xml"),
             }
 
     def add_handler(self, name: str, handler: Any) -> None:
         self._registry[name] = handler
 
     def get_handler(self, name: str, default: Any = None) -> Any:
         return self._registry.get(name, default)
 
 
-class XMLProcessing():
-    def __new__(cls, base_xml='ECC608B_TFLXTLS.xml'):
+class XMLProcessing:
+    def __new__(cls, base_xml="ECC608B_TFLXTLS.xml"):
         if base_xml is None:
-            base_xml = 'ECC608B_TFLXTLS.xml'
+            base_xml = "ECC608B_TFLXTLS.xml"
         return XMLProcessingRegistry().get_handler(base_xml, cls)
 
-__all__ = ['XMLProcessing', 'XMLProcessingRegistry']
+
+__all__ = ["XMLProcessing", "XMLProcessingRegistry"]
```

## tpds/xml_handler/encrypt/__init__.py

```diff
@@ -1,5 +1,7 @@
 """
     Trust Plaform Provisioning package - Encryption module
 """
-from .ciphers import *
-from .encrypt import *
+from .ciphers import CipherAESCBC, CipherAESGCM, CipherRSA
+from .encrypt import GenerateEncryptedXml
+
+__all__ = ["CipherAESGCM", "CipherAESCBC", "CipherRSA", "GenerateEncryptedXml"]
```

## tpds/xml_handler/encrypt/ciphers.py

```diff
@@ -1,33 +1,33 @@
 import os
+import struct
+from pathlib import Path
+
 from cryptography.hazmat.backends import default_backend
-from cryptography.hazmat.primitives import serialization, hashes
+from cryptography.hazmat.primitives import hashes, serialization
+from cryptography.hazmat.primitives.asymmetric import padding, rsa
 from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
-from cryptography.hazmat.primitives.asymmetric import rsa, padding
-from pathlib import Path
-import struct
 
 
 # AES-GCM 256 bit encryption & decryption methods
-class CipherAESGCM():
+class CipherAESGCM:
     def __init__(self, aes_key=None):
         self.aes_key = aes_key or bytes(os.urandom(32))
 
     """
     Perform an AES-GCM encryption with random iv generated internally.
     Args:
         plaintext           Plaintext to be encrypted in bytes
     Returns:
         ciphertext, tag, iv
     """
 
     def encrypt(self, plain_text):
         iv = bytes(os.urandom(12))
-        cipher = Cipher(algorithms.AES(self.aes_key),
-                        modes.GCM(iv), backend=default_backend())
+        cipher = Cipher(algorithms.AES(self.aes_key), modes.GCM(iv), backend=default_backend())
 
         encryptor = cipher.encryptor()
         cipher_text = encryptor.update(plain_text) + encryptor.finalize()
         return cipher_text, encryptor.tag, iv
 
     """
     Perform an AES-GCM decryption operation.
@@ -36,43 +36,43 @@
         iv                    12 byte Initialization vector used in encryption
         tag                   16 byte Tag
     Returns:
         plaintext
     """
 
     def decrypt(self, cipher_text, iv, tag):
-        cipher = Cipher(algorithms.AES(self.aes_key),
-                        modes.GCM(iv, tag),
-                        backend=default_backend())
+        cipher = Cipher(algorithms.AES(self.aes_key), modes.GCM(iv, tag), backend=default_backend())
         decryptor = cipher.decryptor()
         plain_text = decryptor.update(cipher_text) + decryptor.finalize()
         return plain_text
 
     def get_key_bytes(self):
         return self.aes_key
 
+
 # AES-GCM 256 bit encryption & decryption methods
 
 
-class CipherAESCBC():
+class CipherAESCBC:
     def __init__(self, aes_key=None, aes_iv=None):
         self.aes_key = aes_key or bytes(os.urandom(32))
         self.aes_iv = aes_iv or bytes(os.urandom(16))
 
     """
     Perform an AES-GCM encryption with random iv generated internally.
     Args:
         plaintext           Plaintext to be encrypted in bytes
     Returns:
         ciphertext, tag, iv
     """
 
     def encrypt(self, plain_text):
-        cipher = Cipher(algorithms.AES(self.aes_key), modes.CBC(
-            self.aes_iv), backend=default_backend())
+        cipher = Cipher(
+            algorithms.AES(self.aes_key), modes.CBC(self.aes_iv), backend=default_backend()
+        )
 
         encryptor = cipher.encryptor()
         cipher_text = encryptor.update(plain_text) + encryptor.finalize()
         return cipher_text, self.aes_iv
 
     """
     Perform an AES-GCM decryption operation.
@@ -81,28 +81,29 @@
         iv                    12 byte Initialization vector used in encryption
         tag                   16 byte Tag
     Returns:
         plaintext
     """
 
     def decrypt(self, cipher_text):
-        cipher = Cipher(algorithms.AES(self.aes_key),
-                        modes.CBC(self.aes_iv),
-                        backend=default_backend())
+        cipher = Cipher(
+            algorithms.AES(self.aes_key), modes.CBC(self.aes_iv), backend=default_backend()
+        )
         decryptor = cipher.decryptor()
         plain_text = decryptor.update(cipher_text) + decryptor.finalize()
         return plain_text
 
 
 # RSA2048 bit encryption methods
-class CipherRSA():
+class CipherRSA:
     def __init__(self, rsa_key_file=None):
-        if (rsa_key_file is None):
+        if rsa_key_file is None:
             self.private_key = rsa.generate_private_key(
-                public_exponent=65537, key_size=4096, backend=default_backend())
+                public_exponent=65537, key_size=4096, backend=default_backend()
+            )
             self.rsa_public_key = self.private_key.public_key()
         else:
             self.rsa_public_key = self.__get_public_key(rsa_key_file)
 
     """
     Perform an RSA encryption.
     Args:
@@ -110,74 +111,95 @@
     Returns:
         ciphertext
     """
 
     def encrypt(self, message):
         ciphertext = self.rsa_public_key.encrypt(
             message,
-            padding.OAEP(mgf=padding.MGF1(algorithm=hashes.SHA256()), algorithm=hashes.SHA256(), label=None))
+            padding.OAEP(
+                mgf=padding.MGF1(algorithm=hashes.SHA256()), algorithm=hashes.SHA256(), label=None
+            ),
+        )
         return ciphertext
 
     def decrypt(self, ciphertext):
         plaintext = self.private_key.decrypt(
             ciphertext,
-            padding.OAEP(mgf=padding.MGF1(algorithm=hashes.SHA256()), algorithm=hashes.SHA256(), label=None))
+            padding.OAEP(
+                mgf=padding.MGF1(algorithm=hashes.SHA256()), algorithm=hashes.SHA256(), label=None
+            ),
+        )
         return plaintext
 
     def encrypt_dten(self, message):
-
         aes_gcm = CipherAESGCM()
 
         cipher_text, tag, iv = aes_gcm.encrypt(message)
 
         wrapped_key = self.rsa_public_key.encrypt(
             aes_gcm.aes_key,
-            padding.OAEP(mgf=padding.MGF1(algorithm=hashes.SHA256()), algorithm=hashes.SHA256(), label=None))
-
-        wrapped_key_len = struct.pack('>L', len(wrapped_key))
-        iv_len = struct.pack('>L', len(iv))
-        cipher_text_len = struct.pack('>L', len(cipher_text))
-        tag_len = struct.pack('>L', len(tag))
+            padding.OAEP(
+                mgf=padding.MGF1(algorithm=hashes.SHA256()), algorithm=hashes.SHA256(), label=None
+            ),
+        )
 
-        return (wrapped_key_len + wrapped_key + iv_len + iv + cipher_text_len + cipher_text + tag_len + tag)
+        wrapped_key_len = struct.pack(">L", len(wrapped_key))
+        iv_len = struct.pack(">L", len(iv))
+        cipher_text_len = struct.pack(">L", len(cipher_text))
+        tag_len = struct.pack(">L", len(tag))
+
+        return (
+            wrapped_key_len
+            + wrapped_key
+            + iv_len
+            + iv
+            + cipher_text_len
+            + cipher_text
+            + tag_len
+            + tag
+        )
 
     def __get_public_key(self, rsa_public_key):
-
         if os.path.isfile(Path(rsa_public_key)):
-            with open(rsa_public_key, 'rb') as pkFile:
+            with open(rsa_public_key, "rb") as pkFile:
                 public_pem_data = pkFile.read()
             rsa_publicKey = serialization.load_pem_public_key(
-                public_pem_data, backend=default_backend())
+                public_pem_data, backend=default_backend()
+            )
         elif isinstance(rsa_public_key, str):
             modulus = int(rsa_public_key, 16)
             exponent = 65537
-            rsa_publicKey = rsa.RSAPublicNumbers(
-                exponent, modulus).public_key(default_backend())
+            rsa_publicKey = rsa.RSAPublicNumbers(exponent, modulus).public_key(default_backend())
         else:
             raise ValueError("Invalid RSA key format")
 
         return rsa_publicKey
 
     def export_rsa_keys(self, file=None):
         private_pem = self.private_key.private_bytes(
             encoding=serialization.Encoding.PEM,
             format=serialization.PrivateFormat.PKCS8,
-            encryption_algorithm=serialization.NoEncryption()
+            encryption_algorithm=serialization.NoEncryption(),
         )
         if file:
             with open(file + "_private.pem", "wb") as key_file:
                 key_file.write(private_pem)
         return private_pem
 
     def export_rsa_public_key(self, file=None):
         public_key = self.private_key.public_key()
         pem = public_key.public_bytes(
             encoding=serialization.Encoding.PEM,
-            format=serialization.PublicFormat.SubjectPublicKeyInfo
+            format=serialization.PublicFormat.SubjectPublicKeyInfo,
         )
         if file:
             with open(file + "_public.pem", "wb") as key_file:
                 key_file.write(pem)
 
     def get_key_bytes(self):
-        return self.rsa_public_key.public_bytes(encoding=serialization.Encoding.DER,
-                                                format=serialization.PublicFormat.SubjectPublicKeyInfo)
+        return self.rsa_public_key.public_bytes(
+            encoding=serialization.Encoding.DER,
+            format=serialization.PublicFormat.SubjectPublicKeyInfo,
+        )
+
+
+__all__ = ["CipherAESGCM", "CipherAESCBC", "CipherRSA"]
```

## tpds/xml_handler/encrypt/encrypt.py

```diff
@@ -1,385 +1,384 @@
 from argparse import ArgumentParser
 from base64 import b64decode, b64encode
 from pathlib import Path
+
+from cryptography.hazmat.primitives import serialization
+from cryptography.hazmat.primitives.asymmetric import ec, rsa
 from lxml import etree
+
 from .ciphers import CipherAESGCM, CipherRSA
-from cryptography.hazmat.primitives import serialization
-from cryptography.hazmat.primitives.asymmetric import rsa, ec
 
 
-class GenerateEncryptedXml():
-    '''
+class GenerateEncryptedXml:
+    """
     This class takes the xml file with random secret unencrypted and
     generate the new xml file with random secret encrypted
-    '''
+    """
 
     def __init__(self, input_file, encryption_key_file) -> None:
         self.input_file = input_file
-        self.tree = etree.parse(
-            self.input_file, etree.XMLParser(remove_blank_text=True))
+        self.tree = etree.parse(self.input_file, etree.XMLParser(remove_blank_text=True))
         self.root = self.tree.getroot()
         self.aes = CipherAESGCM()
         self.rsa = CipherRSA(encryption_key_file)
         self.aes_key = self.aes.get_key_bytes()
-        self.wrap_key_name = 'WrapKey1'
+        self.wrap_key_name = "WrapKey1"
         # print(f'Generated AES Key - {self.aes_key.hex()}')
 
     def convert_bytes_to_encrypted_data(self, secret: bytes) -> bytes:
-        '''
+        """
         Function convert the random secret to encrypted data
         Args - random secret
         Return - encrypted secret
-        '''
+        """
         cipher_text, tag, iv = self.aes.encrypt(secret)
         # -- Format the encrypted data - iv_len, iv, cipher_len, cipher, tag_len, tag
 
         encrypted_data = bytes()
-        encrypted_data += len(iv).to_bytes(length=4, byteorder='big')
+        encrypted_data += len(iv).to_bytes(length=4, byteorder="big")
         encrypted_data += iv
-        encrypted_data += len(cipher_text).to_bytes(length=4, byteorder='big')
+        encrypted_data += len(cipher_text).to_bytes(length=4, byteorder="big")
         encrypted_data += cipher_text
-        encrypted_data += len(tag).to_bytes(length=4, byteorder='big')
+        encrypted_data += len(tag).to_bytes(length=4, byteorder="big")
         encrypted_data += tag
 
         return encrypted_data
 
     def encode_encrypted_attribute(self, is_encrypted: bool) -> str:
-        if self.root.nsmap[None] == 'https://www.microchip.com/schema/TA100_Config_1.0':
+        if self.root.nsmap[None] == "https://www.microchip.com/schema/TA100_Config_1.0":
             # This early config used lower case boolean names for just this attribute, which was inconsistent with
             # other fields
-            return 'true' if is_encrypted else 'false'
+            return "true" if is_encrypted else "false"
         else:
             # Later configs fixed this inconsistency and used capitalized boolean names
-            return 'True' if is_encrypted else 'False'
+            return "True" if is_encrypted else "False"
 
     def encrypt_bytes(self, secret_element: etree.Element):
         if sum(1 for _ in secret_element.iter()) > 1:
             raise ValueError(
-                'Secret element has more than one node, which is not supported. Embedded comment?')
-        if secret_element.attrib['algorithm'] != 'AES256_GCM':
-            raise ValueError(
-                f'Unsupported algorithm "{secret_element.attrib["algorithm"]}".')
+                "Secret element has more than one node, which is not supported. Embedded comment?"
+            )
+        if secret_element.attrib["algorithm"] != "AES256_GCM":
+            raise ValueError(f'Unsupported algorithm "{secret_element.attrib["algorithm"]}".')
         # There were some changes around the style of the encrypted attribute (false and False).
-        if secret_element.attrib['encrypted'].lower() != 'false':
+        if secret_element.attrib["encrypted"].lower() != "false":
             raise ValueError(
-                f'Unexpected encrypted attribute "{secret_element.attrib["encrypted"]}". Should be false.')
+                f'Unexpected encrypted attribute "{secret_element.attrib["encrypted"]}". Should be false.'
+            )
 
-        if secret_element.attrib['encoding'] == 'Hex':
+        if secret_element.attrib["encoding"] == "Hex":
             data = bytes.fromhex(secret_element.text)
-        elif secret_element.attrib['encoding'] == 'Base64':
+        elif secret_element.attrib["encoding"] == "Base64":
             data = b64decode(secret_element.text)
         else:
-            raise ValueError(
-                f'Unsupported encoding "{secret_element.attrib["encoding"]}".')
+            raise ValueError(f'Unsupported encoding "{secret_element.attrib["encoding"]}".')
         encrypted_data = self.convert_bytes_to_encrypted_data(data)
-        if secret_element.attrib['encoding'] == 'Hex':
+        if secret_element.attrib["encoding"] == "Hex":
             encoded_encrypted_data = encrypted_data.hex()
-        elif secret_element.attrib['encoding'] == 'Base64':
+        elif secret_element.attrib["encoding"] == "Base64":
             encoded_encrypted_data = b64encode(encrypted_data)
         else:
-            raise ValueError(
-                f'Unsupported encoding "{secret_element.attrib["encoding"]}".')
+            raise ValueError(f'Unsupported encoding "{secret_element.attrib["encoding"]}".')
 
-        secret_element.attrib['encrypted'] = self.encode_encrypted_attribute(
-            True)
-        secret_element.attrib['key_name'] = self.wrap_key_name
+        secret_element.attrib["encrypted"] = self.encode_encrypted_attribute(True)
+        secret_element.attrib["key_name"] = self.wrap_key_name
         self.set_indent_element_text(
-            element=secret_element, data=self.format_data(data=encoded_encrypted_data))
+            element=secret_element, data=self.format_data(data=encoded_encrypted_data)
+        )
 
     def encrypt_rsa_public_key(self, secret_element: etree.Element):
         if sum(1 for _ in secret_element.iter()) > 1:
             raise ValueError(
-                'Secret element has more than one node, which is not supported. Embedded comment?')
-        if secret_element.attrib['algorithm'] != 'AES256_GCM':
-            raise ValueError(
-                f'Unsupported algorithm "{secret_element.attrib["algorithm"]}".')
-        if secret_element.attrib['encrypted'] != 'false':
+                "Secret element has more than one node, which is not supported. Embedded comment?"
+            )
+        if secret_element.attrib["algorithm"] != "AES256_GCM":
+            raise ValueError(f'Unsupported algorithm "{secret_element.attrib["algorithm"]}".')
+        if secret_element.attrib["encrypted"] != "false":
             raise ValueError(
-                f'Unexpected encrypted attribute "{secret_element.attrib["encrypted"]}". Should be false.')
+                f'Unexpected encrypted attribute "{secret_element.attrib["encrypted"]}". Should be false.'
+            )
 
-        if secret_element.attrib['encoding'] == 'Hex':
-            if secret_element.attrib['format'] != 'TA100_Write':
-                raise ValueError((
-                    f'Unexpected format attribute "{secret_element.attrib["format"]}"'
-                    f' for "{secret_element.attrib["encoding"]}" encoding. Expected TA100_Write.'
-                ))
+        if secret_element.attrib["encoding"] == "Hex":
+            if secret_element.attrib["format"] != "TA100_Write":
+                raise ValueError(
+                    (
+                        f'Unexpected format attribute "{secret_element.attrib["format"]}"'
+                        f' for "{secret_element.attrib["encoding"]}" encoding. Expected TA100_Write.'
+                    )
+                )
             data = bytes.fromhex(secret_element.text)
-        elif secret_element.attrib['encoding'] == 'Base64':
-            if secret_element.attrib['format'] != 'TA100_Write':
-                raise ValueError((
-                    f'Unexpected format attribute "{secret_element.attrib["format"]}"'
-                    f' for "{secret_element.attrib["encoding"]}" encoding. Expected TA100_Write.'
-                ))
+        elif secret_element.attrib["encoding"] == "Base64":
+            if secret_element.attrib["format"] != "TA100_Write":
+                raise ValueError(
+                    (
+                        f'Unexpected format attribute "{secret_element.attrib["format"]}"'
+                        f' for "{secret_element.attrib["encoding"]}" encoding. Expected TA100_Write.'
+                    )
+                )
             data = b64decode(secret_element.text)
-        elif secret_element.attrib['encoding'] == 'PEM':
-            if secret_element.attrib['format'] != 'Subject_Public_Key_Info':
-                raise ValueError((
-                    f'Unexpected format attribute "{secret_element.attrib["format"]}"'
-                    f' for "{secret_element.attrib["encoding"]}" encoding. Expected Subject_Public_Key_Info.'
-                ))
-            public_key = serialization.load_pem_public_key(
-                secret_element.text.encode('utf8'))
-            if not isinstance(public_key, rsa.RSAPublicKey):
+        elif secret_element.attrib["encoding"] == "PEM":
+            if secret_element.attrib["format"] != "Subject_Public_Key_Info":
                 raise ValueError(
-                    'Subject_Public_Key_Info is not for an RSA public key.')
+                    (
+                        f'Unexpected format attribute "{secret_element.attrib["format"]}"'
+                        f' for "{secret_element.attrib["encoding"]}" encoding. Expected Subject_Public_Key_Info.'
+                    )
+                )
+            public_key = serialization.load_pem_public_key(secret_element.text.encode("utf8"))
+            if not isinstance(public_key, rsa.RSAPublicKey):
+                raise ValueError("Subject_Public_Key_Info is not for an RSA public key.")
             # Convert the public key to TA100_Write format (only one support right now)
             # TA100_Write format omits the exponent, since it must be 65537 in most cases (3072 can also use 3, but
             # that's also not supported yet). Make sure the exponent is expected.
             if public_key.public_numbers().e != 65537:
-                raise ValueError((
-                    f'RSA public key has unsupported exponent {public_key.public_numbers().e}.'
-                    f' Must be 65537 for TA100.'
-                ))
-            data = public_key.public_numbers().n.to_bytes(
-                public_key.key_size/8, byteorder='big')
+                raise ValueError(
+                    (
+                        f"RSA public key has unsupported exponent {public_key.public_numbers().e}."
+                        f" Must be 65537 for TA100."
+                    )
+                )
+            data = public_key.public_numbers().n.to_bytes(public_key.key_size / 8, byteorder="big")
         else:
-            raise ValueError(
-                f'Unsupported encoding "{secret_element.attrib["encoding"]}".')
+            raise ValueError(f'Unsupported encoding "{secret_element.attrib["encoding"]}".')
 
         encrypted_data = self.convert_bytes_to_encrypted_data(data)
 
-        secret_element.attrib['encoding'] = 'Hex'
-        secret_element.attrib['encrypted'] = self.encode_encrypted_attribute(
-            True)
-        secret_element.attrib['key_name'] = self.wrap_key_name
+        secret_element.attrib["encoding"] = "Hex"
+        secret_element.attrib["encrypted"] = self.encode_encrypted_attribute(True)
+        secret_element.attrib["key_name"] = self.wrap_key_name
 
         self.set_indent_element_text(
-            element=secret_element, data=self.format_data(data=encrypted_data.hex()))
+            element=secret_element, data=self.format_data(data=encrypted_data.hex())
+        )
 
     def encrypt_rsa_private_key(self, secret_element: etree.Element):
-        if secret_element.attrib['algorithm'] != 'AES256_GCM':
-            raise ValueError(
-                f'Unsupported algorithm "{secret_element.attrib["algorithm"]}".')
-        if secret_element.attrib['encrypted'] != 'false':
+        if secret_element.attrib["algorithm"] != "AES256_GCM":
+            raise ValueError(f'Unsupported algorithm "{secret_element.attrib["algorithm"]}".')
+        if secret_element.attrib["encrypted"] != "false":
             raise ValueError(
-                f'Unexpected encrypted attribute "{secret_element.attrib["encrypted"]}". Should be false.')
+                f'Unexpected encrypted attribute "{secret_element.attrib["encrypted"]}". Should be false.'
+            )
 
-        if secret_element.attrib['format'] != 'TA100_Write':
+        if secret_element.attrib["format"] != "TA100_Write":
             raise ValueError(
                 f'Unexpected format attribute "{secret_element.attrib["format"]}". Only expected TA100_Write.'
             )
-        if secret_element.attrib['encoding'] == 'Hex':
+        if secret_element.attrib["encoding"] == "Hex":
             data = bytes.fromhex(secret_element.text)
-        elif secret_element.attrib['encoding'] == 'Base64':
+        elif secret_element.attrib["encoding"] == "Base64":
             data = b64decode(secret_element.text)
         else:
-            raise ValueError(
-                f'Unhandled encoding {secret_element.attrib["encoding"]}.')
+            raise ValueError(f'Unhandled encoding {secret_element.attrib["encoding"]}.')
 
         encrypted_data = self.convert_bytes_to_encrypted_data(data)
 
-        secret_element.attrib['encoding'] = 'Hex'
-        secret_element.attrib['encrypted'] = self.encode_encrypted_attribute(
-            True)
-        secret_element.attrib['key_name'] = self.wrap_key_name
+        secret_element.attrib["encoding"] = "Hex"
+        secret_element.attrib["encrypted"] = self.encode_encrypted_attribute(True)
+        secret_element.attrib["key_name"] = self.wrap_key_name
 
         self.set_indent_element_text(
-            element=secret_element, data=self.format_data(data=encrypted_data.hex()))
+            element=secret_element, data=self.format_data(data=encrypted_data.hex())
+        )
 
     def encrypt_ecc_public_key(self, secret_element: etree.Element):
         if sum(1 for _ in secret_element.iter()) > 1:
             raise ValueError(
-                'Secret element has more than one node, which is not supported. Embedded comment?')
-        if secret_element.attrib['algorithm'] != 'AES256_GCM':
-            raise ValueError(
-                f'Unsupported algorithm "{secret_element.attrib["algorithm"]}".')
-        if secret_element.attrib['encrypted'] != 'false':
+                "Secret element has more than one node, which is not supported. Embedded comment?"
+            )
+        if secret_element.attrib["algorithm"] != "AES256_GCM":
+            raise ValueError(f'Unsupported algorithm "{secret_element.attrib["algorithm"]}".')
+        if secret_element.attrib["encrypted"] != "false":
             raise ValueError(
-                f'Unexpected encrypted attribute "{secret_element.attrib["encrypted"]}". Should be false.')
+                f'Unexpected encrypted attribute "{secret_element.attrib["encrypted"]}". Should be false.'
+            )
 
-        if secret_element.attrib['encoding'] == 'Hex':
-            if secret_element.attrib['format'] != 'TA100_Write':
-                raise ValueError((
-                    f'Unexpected format attribute "{secret_element.attrib["format"]}"'
-                    f' for "{secret_element.attrib["encoding"]}" encoding. Expected TA100_Write.'
-                ))
+        if secret_element.attrib["encoding"] == "Hex":
+            if secret_element.attrib["format"] != "TA100_Write":
+                raise ValueError(
+                    (
+                        f'Unexpected format attribute "{secret_element.attrib["format"]}"'
+                        f' for "{secret_element.attrib["encoding"]}" encoding. Expected TA100_Write.'
+                    )
+                )
             data = bytes.fromhex(secret_element.text)
-        elif secret_element.attrib['encoding'] == 'Base64':
-            if secret_element.attrib['format'] != 'TA100_Write':
-                raise ValueError((
-                    f'Unexpected format attribute "{secret_element.attrib["format"]}"'
-                    f' for "{secret_element.attrib["encoding"]}" encoding. Expected TA100_Write.'
-                ))
+        elif secret_element.attrib["encoding"] == "Base64":
+            if secret_element.attrib["format"] != "TA100_Write":
+                raise ValueError(
+                    (
+                        f'Unexpected format attribute "{secret_element.attrib["format"]}"'
+                        f' for "{secret_element.attrib["encoding"]}" encoding. Expected TA100_Write.'
+                    )
+                )
             data = b64decode(secret_element.text)
-        elif secret_element.attrib['encoding'] == 'PEM':
-            if secret_element.attrib['format'] != 'Subject_Public_Key_Info':
-                raise ValueError((
-                    f'Unexpected format attribute "{secret_element.attrib["format"]}"'
-                    f' for "{secret_element.attrib["encoding"]}" encoding. Expected Subject_Public_Key_Info.'
-                ))
-            public_key = serialization.load_pem_public_key(
-                secret_element.text.encode('utf8'))
-            if not isinstance(public_key, ec.EllipticCurvePublicKey):
+        elif secret_element.attrib["encoding"] == "PEM":
+            if secret_element.attrib["format"] != "Subject_Public_Key_Info":
                 raise ValueError(
-                    'Subject_Public_Key_Info is not for an ECC public key.')
+                    (
+                        f'Unexpected format attribute "{secret_element.attrib["format"]}"'
+                        f' for "{secret_element.attrib["encoding"]}" encoding. Expected Subject_Public_Key_Info.'
+                    )
+                )
+            public_key = serialization.load_pem_public_key(secret_element.text.encode("utf8"))
+            if not isinstance(public_key, ec.EllipticCurvePublicKey):
+                raise ValueError("Subject_Public_Key_Info is not for an ECC public key.")
             # Convert the public key to TA100_Write format (only one supported right now)
             data = public_key.public_bytes(
                 encoding=serialization.Encoding.X962,
-                format=serialization.PublicFormat.UncompressedPoint
+                format=serialization.PublicFormat.UncompressedPoint,
             )[1:]
         else:
-            raise ValueError(
-                f'Unsupported encoding "{secret_element.attrib["encoding"]}".')
+            raise ValueError(f'Unsupported encoding "{secret_element.attrib["encoding"]}".')
 
         encrypted_data = self.convert_bytes_to_encrypted_data(data)
 
-        secret_element.attrib['encoding'] = 'Hex'
-        secret_element.attrib['encrypted'] = self.encode_encrypted_attribute(
-            True)
-        secret_element.attrib['key_name'] = self.wrap_key_name
+        secret_element.attrib["encoding"] = "Hex"
+        secret_element.attrib["encrypted"] = self.encode_encrypted_attribute(True)
+        secret_element.attrib["key_name"] = self.wrap_key_name
 
         self.set_indent_element_text(
-            element=secret_element, data=self.format_data(data=encrypted_data.hex()))
+            element=secret_element, data=self.format_data(data=encrypted_data.hex())
+        )
 
     def encrypt_ecc_private_key(self, secret_element: etree.Element):
-        if secret_element.attrib['algorithm'] != 'AES256_GCM':
-            raise ValueError(
-                f'Unsupported algorithm "{secret_element.attrib["algorithm"]}".')
-        if secret_element.attrib['encrypted'] != 'false':
+        if secret_element.attrib["algorithm"] != "AES256_GCM":
+            raise ValueError(f'Unsupported algorithm "{secret_element.attrib["algorithm"]}".')
+        if secret_element.attrib["encrypted"] != "false":
             raise ValueError(
-                f'Unexpected encrypted attribute "{secret_element.attrib["encrypted"]}". Should be false.')
+                f'Unexpected encrypted attribute "{secret_element.attrib["encrypted"]}". Should be false.'
+            )
 
-        if secret_element.attrib['encoding'] == 'Hex':
+        if secret_element.attrib["encoding"] == "Hex":
             data = bytes.fromhex(secret_element.text)
-        elif secret_element.attrib['encoding'] == 'Base64':
+        elif secret_element.attrib["encoding"] == "Base64":
             data = b64decode(secret_element.text)
         else:
-            raise ValueError(
-                f'Unhandled encoding {secret_element.attrib["encoding"]}.')
+            raise ValueError(f'Unhandled encoding {secret_element.attrib["encoding"]}.')
 
-        if secret_element.attrib['format'] == 'PKCS8':
+        if secret_element.attrib["format"] == "PKCS8":
             # Assume data is unencrypted PKCS#8 in DER encoding
-            private_key = serialization.load_der_private_key(
-                data=data, password=None)
+            private_key = serialization.load_der_private_key(data=data, password=None)
             if not isinstance(private_key, ec.EllipticCurvePrivateKey):
-                raise ValueError('Private key is not ECC')
+                raise ValueError("Private key is not ECC")
 
             # We need to convert PKCS#8 private keys to TA100_Write format as that's the only encrypted private key
             # format supported right now.
 
             # Calculate number of bytes required to hold the private key value.
             # The +7 rounds the count up when the bit size isn't a multiple of 8 (e.g. 521)
             byte_count = (private_key.key_size + 7) // 8
 
             # TA100_Write ECC private key format is the private key value in big-endian format
             data = private_key.private_numbers().private_value.to_bytes(
-                byte_count, byteorder='big', signed=False)
-            secret_element.attrib['format'] = 'TA100_Write'
-        elif secret_element.attrib['format'] != 'TA100_Write':
+                byte_count, byteorder="big", signed=False
+            )
+            secret_element.attrib["format"] = "TA100_Write"
+        elif secret_element.attrib["format"] != "TA100_Write":
             raise ValueError(
                 f'Unexpected format attribute "{secret_element.attrib["format"]}". Only expected TA100_Write.'
             )
 
         encrypted_data = self.convert_bytes_to_encrypted_data(data)
 
-        secret_element.attrib['encoding'] = 'Hex'
-        secret_element.attrib['encrypted'] = self.encode_encrypted_attribute(
-            True)
-        secret_element.attrib['key_name'] = self.wrap_key_name
+        secret_element.attrib["encoding"] = "Hex"
+        secret_element.attrib["encrypted"] = self.encode_encrypted_attribute(True)
+        secret_element.attrib["key_name"] = self.wrap_key_name
 
         self.set_indent_element_text(
-            element=secret_element, data=self.format_data(data=encrypted_data.hex()))
+            element=secret_element, data=self.format_data(data=encrypted_data.hex())
+        )
 
     def parse_datasource_section(self):
-        '''
+        """
         Function iterate over datasource section and find the secret element.
-        '''
-        for secret_element in self.tree.findall('//Secret', namespaces=self.root.nsmap):
-            ns = f'{{{secret_element.nsmap[None]}}}'
-            if secret_element.getparent().tag == f'{ns}Static_Bytes':
+        """
+        for secret_element in self.tree.findall("//Secret", namespaces=self.root.nsmap):
+            ns = f"{{{secret_element.nsmap[None]}}}"
+            if secret_element.getparent().tag == f"{ns}Static_Bytes":
                 self.encrypt_bytes(secret_element=secret_element)
-            elif secret_element.getparent().tag == f'{ns}Static_RSA_Public_Key':
+            elif secret_element.getparent().tag == f"{ns}Static_RSA_Public_Key":
                 self.encrypt_rsa_public_key(secret_element=secret_element)
-            elif secret_element.getparent().tag == f'{ns}Static_RSA_Private_Key':
+            elif secret_element.getparent().tag == f"{ns}Static_RSA_Private_Key":
                 self.encrypt_rsa_private_key(secret_element=secret_element)
-            elif secret_element.getparent().tag == f'{ns}Static_ECC_Public_Key':
+            elif secret_element.getparent().tag == f"{ns}Static_ECC_Public_Key":
                 self.encrypt_ecc_public_key(secret_element=secret_element)
-            elif secret_element.getparent().tag == f'{ns}Static_ECC_Private_Key':
+            elif secret_element.getparent().tag == f"{ns}Static_ECC_Private_Key":
                 self.encrypt_ecc_private_key(secret_element=secret_element)
             else:
-                raise ValueError(
-                    f'Secret {secret_element.getparent().tag} is not supported.')
+                raise ValueError(f"Secret {secret_element.getparent().tag} is not supported.")
 
     def generate(self) -> bytes:
-        '''
+        """
         Function create new xml file with updated content
-        '''
-        return etree.tostring(self.tree, pretty_print=True, xml_declaration=True, encoding='UTF-8')
+        """
+        return etree.tostring(self.tree, pretty_print=True, xml_declaration=True, encoding="UTF-8")
 
     @staticmethod
-    def set_indent_element_text(element: etree.Element, data: str, indent: str = '  ') -> None:
+    def set_indent_element_text(element: etree.Element, data: str, indent: str = "  ") -> None:
         level = 1
         parent = element.getparent()
         while parent is not None:
             level += 1
             parent = parent.getparent()
-        data_indent = indent*level
+        data_indent = indent * level
 
-        element.text = '\n' + data_indent + \
-            data.replace('\n', f'\n{data_indent}') + '\n' + indent*(level-1)
+        element.text = (
+            "\n"
+            + data_indent
+            + data.replace("\n", f"\n{data_indent}")
+            + "\n"
+            + indent * (level - 1)
+        )
 
     @staticmethod
     def format_data(data: str, split_len: int = 64) -> str:
-        return '\n'.join(data[i:i+split_len] for i in range(0, len(data), split_len))
+        return "\n".join(data[i : i + split_len] for i in range(0, len(data), split_len))
 
     def add_wrapped_key(self):
-        '''
+        """
         Function encrypt the aes key with encryption key
-        '''
+        """
 
         encrypted_aes_key = self.rsa.encrypt(self.aes_key)
         # print(f'Wrapped AES Key - {self.format_data(encrypted_aes_key.hex())}')
 
-        data_sources_element = self.root.find(
-            'Data_Sources', namespaces=self.root.nsmap)
-        wrapped_key_element = etree.SubElement(
-            data_sources_element, 'Wrapped_Key')
-
-        etree.SubElement(wrapped_key_element, 'Name').text = self.wrap_key_name
-
-        key_element = etree.SubElement(wrapped_key_element, 'Key')
-        key_element.attrib['algorithm'] = 'RSA_OAEP_SHA256'
-        key_element.attrib['encoding'] = 'Hex'
+        data_sources_element = self.root.find("Data_Sources", namespaces=self.root.nsmap)
+        wrapped_key_element = etree.SubElement(data_sources_element, "Wrapped_Key")
+
+        etree.SubElement(wrapped_key_element, "Name").text = self.wrap_key_name
+
+        key_element = etree.SubElement(wrapped_key_element, "Key")
+        key_element.attrib["algorithm"] = "RSA_OAEP_SHA256"
+        key_element.attrib["encoding"] = "Hex"
         self.set_indent_element_text(
-            element=key_element,
-            data=self.format_data(encrypted_aes_key.hex())
+            element=key_element, data=self.format_data(encrypted_aes_key.hex())
         )
 
-        wrapping_public_key_element = etree.SubElement(
-            wrapped_key_element, 'Wrapping_Public_Key')
-        wrapping_public_key_element.attrib['encoding'] = 'PEM'
-        wrapping_public_key_element.attrib['format'] = 'Subject_Public_Key_Info'
+        wrapping_public_key_element = etree.SubElement(wrapped_key_element, "Wrapping_Public_Key")
+        wrapping_public_key_element.attrib["encoding"] = "PEM"
+        wrapping_public_key_element.attrib["format"] = "Subject_Public_Key_Info"
         self.set_indent_element_text(
             element=wrapping_public_key_element,
             data=self.rsa.rsa_public_key.public_bytes(
                 encoding=serialization.Encoding.PEM,
-                format=serialization.PublicFormat.SubjectPublicKeyInfo
-            ).decode('utf8')
+                format=serialization.PublicFormat.SubjectPublicKeyInfo,
+            ).decode("utf8"),
         )
 
 
 if __name__ == "__main__":
-    parser = ArgumentParser(
-        description='Encrypts static secret data in a TA100 config file.')
+    parser = ArgumentParser(description="Encrypts static secret data in a TA100 config file.")
     parser.add_argument(
-        '--in',
-        help='Path to unencrypted TA100 config file with plain-text secrets.',
-        required=True
+        "--in", help="Path to unencrypted TA100 config file with plain-text secrets.", required=True
     )
     parser.add_argument(
-        '--out',
-        help='Encrypted TA100 config file wil be saved to this path.',
-        required=True
+        "--out", help="Encrypted TA100 config file wil be saved to this path.", required=True
     )
     parser.add_argument(
-        '--key',
-        help='Path to the public key to wrap/encrypt the secret data with.',
-        required=True
+        "--key", help="Path to the public key to wrap/encrypt the secret data with.", required=True
     )
     args = vars(parser.parse_args())
 
-    xml = GenerateEncryptedXml(
-        input_file=args['in'], encryption_key_file=args['key'])
+    xml = GenerateEncryptedXml(input_file=args["in"], encryption_key_file=args["key"])
     xml.parse_datasource_section()
     xml.add_wrapped_key()
-    Path(args['out']).write_bytes(xml.generate())
+    Path(args["out"]).write_bytes(xml.generate())
```

## Comparing `tpds_helper-2.3.6.dist-info/LICENSE` & `tpds_helper-2.3.7.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `tpds_helper-2.3.6.dist-info/RECORD` & `tpds_helper-2.3.7.dist-info/RECORD`

 * *Files 26% similar despite different names*

```diff
@@ -1,101 +1,104 @@
-tpds/__init__.py,sha256=jv2YF__bseklT3OWEzlqJ5qE24c4aWd5F4r0TTjOrWQ,65
-tpds/certs/__init__.py,sha256=kqb5hsEt-9_RswpnE9pAOqYiI4rB_WkL9TetCBqBx3Y,308
+tpds/__init__.py,sha256=ED6jHcYiuYpr_0vjGz0zx2lrrmJT9sDJCzIljoDfmlM,65
+tpds/certs/__init__.py,sha256=P7MhPND3J-7S_NYDgYSdGMXrixvX9waCX9nImuvM8FU,1460
 tpds/certs/cert.py,sha256=wXNJkl-2-GfnVA_enZndULJfEjfS336rw525DBMHKvM,67
-tpds/certs/cert_utils.py,sha256=gg_1wS8HPZplaD9vL7HQHM0VF90LH_Ej4D-Dm3W6VMk,1640
-tpds/certs/certs_backup.py,sha256=LiIC5_wFPD8llw719doK7dMq3ozkc6rjHAItlLQ5kB4,3434
-tpds/certs/create_cert_defs.py,sha256=9kTXnUvvg8jBLZJ_icoTfLkI8lYq5F4hWrVPW94EKJA,22405
-tpds/certs/ext_builder.py,sha256=-_V3CYyERJAl1iYBWldPdtQ92y3lU5rk3pMsUpTu7xc,131
-tpds/certs/sign_csr.py,sha256=RkbooiGECf4BZv07EYMshLH_VEc0H-a7NIEqs9FvObk,81
-tpds/certs/sign_csr.zip,sha256=MJj2NgEF3U08gsDWb-KJxV0dhyDka81SZsPjNgwDfjQ,1643
-tpds/certs/tflex_certs.py,sha256=Ih8WciMxwvANo8VMZoedTyjd2jKWh7BeYQNqLRK8dkc,15887
-tpds/certs/timefix_backend.py,sha256=TZkf2fg4Eo0-4VVAsNiKnqCl5dpAqj4Sm_xIe8JgBC0,109
-tpds/certs/wpc_cert_def.py,sha256=jVJNTKc4vHV_BBPcnUQl1REmuHVKb57PxSuPLtCf9Ms,23117
-tpds/certs/x509_find_elements.py,sha256=IuVjdN_apxTzFiIN6rqMro2bCscoEVk9p4r5n0rySGk,7238
+tpds/certs/cert_utils.py,sha256=VwTHmbleQET4ZGeOZFxpcaH03bqYBM0pF-X5CqqWvhY,2108
+tpds/certs/certs_backup.py,sha256=SyoxkEYq2n66Ibnv8UXYaWM8WDsh1Z9Lmot7dlO9Jhk,3518
+tpds/certs/create_cert_defs.py,sha256=7xRX7elMipDHKCJAhaplApS1mJ7qgFlSe9kJi7-azNo,21764
+tpds/certs/ext_builder.py,sha256=8_YBReb4QCfA8KUdBDCq1iLONec9KC9NwgDvvpSX0II,157
+tpds/certs/sign_csr.py,sha256=nYTObfo1vub9klroVNYeUB5thk07KbxUcGGjMylrbgg,105
+tpds/certs/sign_csr.zip,sha256=6mL6Zi3sxh2jtF2BDdI6fe9AzCIvc3JRg2VKjZp9eqM,1642
+tpds/certs/tflex_certs.py,sha256=EKBAo6eGFXa3RabsPVi46J9CPG2yiNhi2L03G5Ox6P0,15728
+tpds/certs/timefix_backend.py,sha256=JNehqJZD6sUfUBitCAIK5Lol3CsUrG91dtvTakU1vKc,140
+tpds/certs/wpc_cert_def.py,sha256=sLQtBRCQbmS4ItnK3KoqJ7zC48arR8_z1P_gVq183uo,22358
+tpds/certs/x509_find_elements.py,sha256=7HvtHMbsis-yGKz96Ro3QRk80PxGiT4hFfvpHt7cy7o,6995
 tpds/certs/sign_csr/readme.md,sha256=rBTzuHRUn0M0e9WS2tzpj9129mWYCzdn7MBRms9HgX4,1312
 tpds/certs/sign_csr/requirements.txt,sha256=3foeLa3LceixJShaQP1sbppt5gsJnEpwEUiur-HUtP8,22
-tpds/certs/sign_csr/sign_csr.py,sha256=pe-ef-ktqFmDEG1fE99ZM9G5K0QO5Kp0nLOA9y6h2XU,1266
-tpds/cloud_connect/__init__.py,sha256=3x7bgB1WpSNoZpjuQ-rzEnYryGtiIaR4FkFPmC0stQQ,271
-tpds/cloud_connect/aws_connect.py,sha256=fIn7YIwLwux6c0WiyXF9J7wzB6-jkRMwz02swlle6lk,21672
-tpds/cloud_connect/azureRTOS_connect.py,sha256=8KOOhxxvddN7v4PmvKO26somrpNc1k8EWYyjQW7PG1k,15839
-tpds/cloud_connect/azure_connect.py,sha256=yJCPzZzxw-WKHsbh9vIoPx5zWixyGoyf7AROvaJT_u0,20014
-tpds/cloud_connect/cloud_connect.py,sha256=4YqcDeZ7Eqv9wvN9w3moJO1i6NNHJuZyNr3O06Ek-yw,1364
-tpds/cloud_connect/gcp_connect.py,sha256=RPYtEGJEOsoDj8VggzS9bkIK_W4Dhz7yPKx8uvEJlfE,9654
-tpds/flash_program/__init__.py,sha256=SvO4jCQ0RbY5T_kR3g_Ee2HhGw4K6FGiH6hvSgX0WIo,182
-tpds/flash_program/flash_program.py,sha256=IlPp4qMyetjCwBHojblj9muQOqeDu8a-u8HiKbNEVuE,7827
-tpds/flash_program/kit_connect.py,sha256=VV9BEnBPuBXWtaF8EP2tct9BWB07Kkn69SBOAlTrlgY,6246
-tpds/manifest/__init__.py,sha256=Xca4Nte1nFTNC9U6F0-q8L8ae2m8GGGmOQCsEVnO70o,139
-tpds/manifest/manifest.py,sha256=N76rBYUTZWmC3PK5sB1Lr8rsB90oeSvcrRlUbkLOwwQ,17832
-tpds/manifest/tflx_manifest.py,sha256=kDbfwTaw5_iRHs9-83O-1F0TTp-uRnJR1cRlUTjdXFg,4131
-tpds/manifest/tng_manifest.py,sha256=6zy8EMmF0VIfNij-WxlzJm7NU1HHudfpZsA__Ob8fxM,3694
-tpds/output_grabber/__init__.py,sha256=XXszOFlzUddpk_Bv1pVKYkZBlTZ-jpITSxmipBO_AwI,101
-tpds/output_grabber/library_output_grabber.py,sha256=i7MmD4xSrWb8kBOB9nRpYoOcLeLDyINeYlavlJAX-GU,2927
-tpds/proto_provision/__init__.py,sha256=8NuU7PoUAdNP70_9rigd8J2l_dN4Q9AyE-xzhgOXbuE,252
-tpds/proto_provision/ecc204_provision.py,sha256=2hAYgDOZe9ZwdZJHorK9lccIcIK80D3iEYfs3oXbZzE,4344
-tpds/proto_provision/ecc_provision.py,sha256=xz01XJDXVU8gXIMLVWtqA_yC21EBk9IFMAp56z1NdeM,2544
-tpds/proto_provision/proto_provision.py,sha256=JRoa9_Jaa_cJD_WV0pKAiSllW5CBgQkWs-H7aopzlDE,1660
-tpds/proto_provision/ta010_provision.py,sha256=xvhCehXiYjT-3AEcf46e3Ipm6AaJQW_qLJiUpNa6oDo,1420
-tpds/proto_provision/ta100_provision.py,sha256=EKpTtWtJ2ceoghyE8AmD6z3xBnCkVDx2XRl08r8MpF0,10387
-tpds/proto_provision/tflxtls_provision.py,sha256=QQqC_ipkc_NI-U2H7mzF4RUP8e0XFQtXYwf8UZ174bc,17044
-tpds/proto_provision/tflxwpc_provision.py,sha256=3oE8SSuljfbHPPOzrHuewSPH36-TjET1loBGvtmxrAU,17370
-tpds/pubkey_validation/__init__.py,sha256=THBL2_btwbi_ZSycvi2ETX3Hh2W4WRVdMfUwelE_Wks,140
-tpds/pubkey_validation/device_pubkey_validation.py,sha256=bAYnM8zRF7oYKTrQbH_NmjAknJk4-o8ModKbz-cdGhQ,8318
-tpds/pubkey_validation/pubkey_validation.py,sha256=mBYMpwRCTNGeXVhFrUFAICwF-rIohVfmzIL_ccZ-zp0,6594
-tpds/resource_generation/__init__.py,sha256=PaVa11VToUy8OzlPUObitu29XjAQTyK6TX4axzSnj1M,181
-tpds/resource_generation/resource_generation.py,sha256=bEGN4RnnDk0J55uA0OoB_-RfDcqaPcIuLd713cqm51U,6477
-tpds/resource_generation/tflx_resource_generation.py,sha256=0F9qTE82K_k8LKw3mh84LBFPTwGRZ6w4YG_L2ocB0xk,21893
-tpds/resource_generation/tng_manifest_generation.py,sha256=MrYeK-eJjDIru6N0s6B-KNYj2Eq9PNkwp7K-wKIitx8,5235
-tpds/secure_element/__init__.py,sha256=0A8RkODllVNKsljR1KwADzxdrs1udpgeibhU2z9Gp3A,252
-tpds/secure_element/ca_element.py,sha256=_kza7H4cpqARc4IWGz7ZZ31IDHvzwnU1ILX49WeLFG0,6062
-tpds/secure_element/constants.py,sha256=-oZQh97TaZoSMtvkhfuwRtxG1pM1aeAARHoQwDMVlM4,1865
-tpds/secure_element/ecc204.py,sha256=0U9OAEMpy4syTWsiRcBGpy4ZT5KESspXzz45dFVh9OM,5558
-tpds/secure_element/ecc608a.py,sha256=kV51Yfy4igJfyiU5PI0OaNl-lEGe43NmXgjwQwcFUu4,5699
-tpds/secure_element/sha204a.py,sha256=U-4zO4mDNC_BVyF7tp48TvZ8ZWfhxgn00u4V9WcNYaw,3691
-tpds/secure_element/sha206a.py,sha256=USzd0M9FhBtDEOHJISF5harYXRTbRJUr22yWCb79mMU,2343
-tpds/secure_element/ta010.py,sha256=ZYLSZYH2Fd_TbQKHTJboqne7-sfLl5shRZ3sSDFUVWc,1808
-tpds/secure_element/ta_element.py,sha256=Z726ddPGARpqU_2j-Nzx-GXpJ4DOjWMMAe4Ht2DgJ8U,7316
-tpds/ta_attribute_parser/__init__.py,sha256=TQ0-10fYsWS4QVe_atzgxUsD2ef3MqEyBccjrcZVY3o,351
-tpds/ta_attribute_parser/attr_common.py,sha256=SlEqGE5nvjW6uvmefB_tegPG2WjMJM2IaOPwIIhHFA4,2799
-tpds/ta_attribute_parser/attr_crl_property.py,sha256=fiU3D2n2tA8R1QYoce3NJ_qtLrvxEbrv4Az9PcSN5zQ,591
-tpds/ta_attribute_parser/attr_data_property.py,sha256=DdJh4eweFxQ_-br1JaDYrBZ0iz6fBilWieufle7oPB4,788
-tpds/ta_attribute_parser/attr_extractedcert_property.py,sha256=EXjyZaVx4saP1VYRuyga0AHPGCqtGgeKlA0xzq_ecnQ,1639
-tpds/ta_attribute_parser/attr_fca_property.py,sha256=lXqNbBMYY8XtmmX2EpwXUzSSz3K9Xgc0_ednjbFakvo,827
-tpds/ta_attribute_parser/attr_privkey_property.py,sha256=93U4rPwLichK7mwkYFAwip5dSndNEJRgknMAGusPAGA,1605
-tpds/ta_attribute_parser/attr_pubkey_property.py,sha256=HiMTU_Kt88Tu5yyMKEgA1aTsfcg5IQJqmCBnFKCrYqU,1752
-tpds/ta_attribute_parser/attr_symkey_property.py,sha256=bf2shJsZPe2OTu05quFQpIwYZx-wjiPZz0EnkzosEOw,2485
-tpds/ta_attribute_parser/attributes.py,sha256=JJThhquDGO3u_QY9YKAfm-ygPhtR8bgTI_VIYzl8h98,3730
-tpds/tp_utils/__init__.py,sha256=1HHysPaW83DKiqe_vcM8mgpFHWgl5T1LcZ2S1e1_zx0,213
-tpds/tp_utils/tp_client.py,sha256=OimFIzJl3qvNeJqeWUXYv8s1fIQ8fBxugxpdlrihvUM,1730
-tpds/tp_utils/tp_input_dialog.py,sha256=_bXouWAEynZt36Qtixlw2YZTjLIpk2OBGAEXD9beq8A,4670
-tpds/tp_utils/tp_keys.py,sha256=nWHw9v77AfnMyfI1rvkId-sNh_TJGqQvaGtNv_2GkGI,13581
-tpds/tp_utils/tp_print.py,sha256=F3t8o6SsfhpM13jvFBHpN70_H6FKg7HycQrZQq3RCrg,2099
-tpds/tp_utils/tp_settings.py,sha256=EWSv1vpXd2klkkmj1FhrX8q7L3TNhpld4kBRkFMf5G8,4340
-tpds/tp_utils/tp_utils.py,sha256=YNAuj9VBMvN7r3ACFKJAO4bb-EOw5JNi4_GV0S_CHQg,6954
-tpds/usecase_diagram/__init__.py,sha256=I6P8tSEp4xKOIO0MTlDXyw-t-YVrwCyrgT-wMo97FRk,216
-tpds/usecase_diagram/canvas.py,sha256=qoltIZjfTfxA8ayJmekIftnLGcws-jwiqENX5fVI1RQ,22932
+tpds/certs/sign_csr/sign_csr.py,sha256=pLRX6D877AJW93GWOQaywGaGE-JLxROi0JwD5ZWuhYs,1265
+tpds/cloud_connect/__init__.py,sha256=juFr24IpBqGuorx3TKUPncUc9qzZuQj4Ki1qlQCHeAg,804
+tpds/cloud_connect/aws_connect.py,sha256=AALFUj6cGJ_YhIl-IOJXH4LIhUrddVXegWwNO1NW_yY,21146
+tpds/cloud_connect/azureRTOS_connect.py,sha256=TQNeRvkgShwor1GbEzg4ctdCaW9nwCtvN6P89KHFHiU,9004
+tpds/cloud_connect/azure_connect.py,sha256=1GzwJt-Gji-pb3YlsSp1hTU3CxrBGlHZ2Ce55WDe5j4,16174
+tpds/cloud_connect/azure_sdk.py,sha256=wPRJZmZegW4tmJ6iXKcXFrUPJvoV0iBZ0yvuu9QCOQI,16733
+tpds/cloud_connect/cloud_connect.py,sha256=PS7gEhNMaoW0O8z4zeegMc2V63fztKRwo3mE9ztGqH8,1390
+tpds/cloud_connect/gcp_connect.py,sha256=Wq8UOOztJ54MvFagBqweKHqieRYgTwlQNEw4F2kFnMo,9280
+tpds/flash_program/__init__.py,sha256=XdqY2y_CZLDTc26q-8U3urmyomggN826T1Ic-aBitQc,182
+tpds/flash_program/flash_program.py,sha256=4BsuvPMGD3W6OzXPBzhvCfc7yqAPey-WcVS7EttGPuQ,7727
+tpds/flash_program/kit_connect.py,sha256=ea5TgW0f5bX6fQbCflVDr-G3fxKFUSXsCq6mUUc5VPg,6108
+tpds/manifest/__init__.py,sha256=7Jrk0edTDQUtHTM_WMY5QKv7CksipL_ZOnunqDVipMs,272
+tpds/manifest/manifest.py,sha256=_WHMlvloU0mmD9vLwHnudEV1w4oiAS_UPqJ6Wr6EVMs,17816
+tpds/manifest/tflx_manifest.py,sha256=uZP1pCDs5Rk7qZiJHCEAEFB5117aFi5JiL8hfcr4aBg,4248
+tpds/manifest/tng_manifest.py,sha256=X-NaqWWV8WXcFYnmUIAR07nEsE9k8PL2dG1_Vyx_09Q,3782
+tpds/output_grabber/__init__.py,sha256=KoG_foeYRcYGoi8ZUPFIivjRaiIMXCXFs5erIqGKBxc,157
+tpds/output_grabber/library_output_grabber.py,sha256=KK8bCTScIKGZcGmoMpXTwuZEAOw4JY3yi6eOLkYH-xY,2930
+tpds/proto_provision/__init__.py,sha256=neoUQyQyzCT5hxL6YVcwASy3FTPr4I7fLvKCJE5P0xE,695
+tpds/proto_provision/ecc204_provision.py,sha256=8ZKBZ2mI_yaGAENkTpgEw_hd6LSmegPY2RwnDlcFyV4,4409
+tpds/proto_provision/ecc_provision.py,sha256=h-wEsawX6rHuap4-QVagCcChaB9P4PGEwqeVJAzyJRM,2411
+tpds/proto_provision/proto_provision.py,sha256=iZstprAfBma0Iy2zFYsI1RvJy5bV7uzx7LjpmdVYilo,1658
+tpds/proto_provision/sha10x_provision.py,sha256=WfEWNN9RjIEgtEeqlgwggZZU2osZilzFtwwuFZfap7s,2761
+tpds/proto_provision/ta010_provision.py,sha256=zT_5yVd4aWX4p_yLe3W6A8y6bIwuinnu0AnGvOf9cZA,1421
+tpds/proto_provision/ta100_provision.py,sha256=l2nty-eANpurLY6jo-Fd-0PDQJB9kYyb9ZSRQSwwb0E,10444
+tpds/proto_provision/tflxtls_provision.py,sha256=mvjkNsRaXOLLM3qPU2w4N9OQSUFy51r-niG1SykoQpQ,16866
+tpds/proto_provision/tflxwpc_provision.py,sha256=PIn2hsksx9UNw4fy-gH_u2yuuUpj9iimLlA00pUEtu0,16564
+tpds/pubkey_validation/__init__.py,sha256=07twpt6eiwRREzWIcekNBpmb9PYT6Jbst905umC-fTw,234
+tpds/pubkey_validation/device_pubkey_validation.py,sha256=gC6R1st8nSt-T1PqZq3bJTm-Krf-jgvdTLSjx2Zyn3U,8503
+tpds/pubkey_validation/pubkey_validation.py,sha256=xE2DM42-wPyMVTGHjA6Wjz-PNFIKrHqVOL4cT4qM8Cs,6659
+tpds/resource_generation/__init__.py,sha256=Ngo8b9_hFKvTH9_NR7PFW2X5_gd-6IN3UnME-3g9kJU,320
+tpds/resource_generation/resource_generation.py,sha256=67e4BgnbY3hLj8ku8Yx4IqE_8-HqSWj3Rakc8GxHN30,6265
+tpds/resource_generation/tflx_resource_generation.py,sha256=RgbGceu3eyHE9gLTw6rOrwVUT-YEvqeSK1RXVU5anWY,21716
+tpds/resource_generation/tng_manifest_generation.py,sha256=f9Ld86pNJnLlyKK14q9m3X_50QgU-Y_8VVO83vLyWE8,4910
+tpds/secure_element/__init__.py,sha256=VJzob0xESq4wSXohGW8jgdCSOUuCCIekoqOfrdlLuOg,551
+tpds/secure_element/ca_element.py,sha256=GdRmWOvtygi1CTkBK1K3xCoWluA8qL_pwozNoUhfDgU,5876
+tpds/secure_element/constants.py,sha256=jX1REJoGZXowQCwZmxc0HxbGfQkmXPq9GyNwOguJ2Sc,1862
+tpds/secure_element/ecc204.py,sha256=JFio3Bj1trkKJ7eqVOm4YFczmYsRI7oz0eRcDOJMKGI,5798
+tpds/secure_element/ecc608a.py,sha256=Fi50J4GRHoxWILJToGGB2JqCmgTFKzaXvIUm7pvJOxo,5557
+tpds/secure_element/sha10x.py,sha256=JFC1G1gQFHBLZcUDMFS4aHyKxUu_ZpLgULBePRekZ0Y,4009
+tpds/secure_element/sha204a.py,sha256=Jp_YQrp-k2CjL0nnNpCkBLxO1JwfD8WrJCTA1Qb1c4o,3580
+tpds/secure_element/sha206a.py,sha256=gbyNk-4d8YDOBlqnM_x3_Jf9A--n-r2PoPwapoXXG4k,2309
+tpds/secure_element/ta010.py,sha256=3DfeaxnUqJA4bOKeNMkngcmSRWyXQAKFz861NiZwqv4,1809
+tpds/secure_element/ta_element.py,sha256=eDTPou9tcdSlbYGj6el27YEnI42gIaA661G5od_jLHI,7231
+tpds/ta_attribute_parser/__init__.py,sha256=tnNlZ2bx9uMIkKkalgsUiFaw9gch2vzPkOLkMy1He5k,1619
+tpds/ta_attribute_parser/attr_common.py,sha256=ZMSw3dU4-Sb44Vsxf-IYlDIaLcGKREk1yYDqK07Xupo,3270
+tpds/ta_attribute_parser/attr_crl_property.py,sha256=Ui6nhiiRysczfly0vBm-1c_QNfmHAkhYg7RObqF91lY,600
+tpds/ta_attribute_parser/attr_data_property.py,sha256=Bn6h_qdWpRfSuj5OFMTKQUEw-qWoum2f23Do4gJOSvc,806
+tpds/ta_attribute_parser/attr_extractedcert_property.py,sha256=2J6LZbU0c3wIExpbuYuP0zPlIECkxy9ZLdSFNWpJ_kM,1838
+tpds/ta_attribute_parser/attr_fca_property.py,sha256=UOPspCIQrrc_SzVmejb5NLcBdilOlEIDhTWN2mMFRjs,856
+tpds/ta_attribute_parser/attr_privkey_property.py,sha256=hluX9aNY5AJrVWr7kLq7jxCGEEW6gTnT0WuKjNnCFrM,1759
+tpds/ta_attribute_parser/attr_pubkey_property.py,sha256=WwKqKcZS7CojNWMLGmlEsROFsYB7UpNp7TJepRKMCBw,1923
+tpds/ta_attribute_parser/attr_symkey_property.py,sha256=82YD8iIBUggyGGXNvcyKbbM_ttogAnqJqa_ps_I2oDo,3114
+tpds/ta_attribute_parser/attributes.py,sha256=dDvWeZjD9CxGTOgzJGDP5q20b8shb9fXV0NOOBncDLI,4863
+tpds/tp_utils/__init__.py,sha256=DRLf5cW8BGUtse3XaF8psqsNuTG6SmrLRGNurc8I-uU,1079
+tpds/tp_utils/tp_client.py,sha256=xrv54RU7XwvxwI1sb3UQmLolXakxl7oa3sAXhiR0IVE,1647
+tpds/tp_utils/tp_input_dialog.py,sha256=vJrZxNP2hT0j_rLD5OtIMnUecPuqOiSAw1Ah9F-ogu8,4601
+tpds/tp_utils/tp_keys.py,sha256=t6litdD4VKGmlz2frvLj8mNTHM28r0rOhslqw0JlAjA,13175
+tpds/tp_utils/tp_print.py,sha256=raEuN218Sj43yBafRgZQP732jtKuD65fbhCUojZyDiQ,2097
+tpds/tp_utils/tp_settings.py,sha256=nzA5xDNjiwFKIKIb7dpCuGLrk1nhjTUlpDywY91cFPM,3875
+tpds/tp_utils/tp_utils.py,sha256=4BasyOMWuuE7qTdnq2JMJtQOHFiQVRxKeW8IF1MIWr4,7095
+tpds/usecase_diagram/__init__.py,sha256=XN34DOAnrJautJelWSvMEVqZelVd8BiP0GPx6Zigvgk,612
+tpds/usecase_diagram/canvas.py,sha256=d5IXcFPAi8gxvzwFHAuvDB1Ja82kyhVG7Uu9gtV97SU,23172
 tpds/usecase_diagram/click_icon.png,sha256=DzA5v_bvPh8NMiWI2TrBDAaW_JrnkcmGtjYiQYdmz0Y,852
 tpds/usecase_diagram/done_icon.png,sha256=ghKsONhx4Uar1DJdhm6t4cOMiL7uAwqef5EQFFlgJxs,141278
-tpds/usecase_diagram/menu_icons.py,sha256=2fKUhlyOWdgFCj525T35S7Qu1Cmts5sETBB8BYG9XKQ,8557
+tpds/usecase_diagram/menu_icons.py,sha256=yD0vh2R2zcwiIvZzg09BF2sUc3adSa3XyQ3raQ68_Qs,7913
 tpds/usecase_diagram/mplab.png,sha256=jVRROo4HfZpKx3cjc7TwYxaKS7RTFXjHU9BY5L3jD5I,21422
-tpds/usecase_diagram/popup.py,sha256=qpOofKBu1jYJ8lIxMZV057yks4bsFysYnBinnRheASg,6972
-tpds/usecase_diagram/proto_boards.py,sha256=Ystd1TNwYr5gGNDHc-U7VtdidWiO5-eDzIz4jJ5DwtQ,6420
+tpds/usecase_diagram/popup.py,sha256=as1JpKgbzuGakuHEEx2-WxhVxn5_TRfOIf7jCzLvd5s,6962
+tpds/usecase_diagram/proto_boards.py,sha256=dsMCGvFH-7mjMhUHEUzFARI5ElnMSq0z86UFV3YFRD4,6013
 tpds/usecase_diagram/select.png,sha256=eUDRDnHyfBEhqODqNu6xibQo4E0nZ0L_2mruXwNPUnA,1154
-tpds/usecase_diagram/terminal.py,sha256=LoUapzhXGz2H8rS1MYgicdGAsVM7czhPSLzonJrvtHQ,2948
-tpds/usecase_diagram/usecase_diagram.py,sha256=ifOug7CPiyCFSIC9lAVwlHQ1FzWbavP8p19WWzRlHfY,6096
+tpds/usecase_diagram/terminal.py,sha256=H5NVaHCE1-Ic-kRgekMvnWqsWWJn37InV1HYButrcqE,2663
+tpds/usecase_diagram/usecase_diagram.py,sha256=XHnrKRShPmXRPtGQp9VgItkPv_GXnALFJ-Kd66vkf_8,5598
 tpds/xml_handler/ECC608A-MAH-TFLXWPC.xml,sha256=ceFs2Fg2wQrY0B3KY9J-7JxmF9Ptw494WJD-LCp3oaw,10469
 tpds/xml_handler/ECC608B_TFLXTLS.xml,sha256=b59ATmxwVl-OxOf_0ChB2_nrEaEg9KWtZfCtuPRQq7Y,15669
 tpds/xml_handler/PIC32CMLS60_ECC608.xml,sha256=ZMwnGv8wBrjW4BGd1aV_Dn7aKUxg8tgqdzh-28-6OHQ,14735
-tpds/xml_handler/__init__.py,sha256=uBEbuWNIaZ-SWlgVd3cVBuf2fHOMuscS4gs3rCYVdzU,245
-tpds/xml_handler/caencryption.py,sha256=noG4PGEzrToZ6UP_kasOWqfYOugbLBX_7N3fSQ4TNmk,1363
-tpds/xml_handler/ciphers.py,sha256=ikuj3LZgTAbWWBQWoMFfnaG97gWMrJeHZFJaFfUY6_Q,6403
-tpds/xml_handler/ecc_xml_encryption.py,sha256=76--RX2HQe-XTLavftmNmmPSwQG3SqqLNB2bK1iHHK4,8583
-tpds/xml_handler/tflxtls_xml_updates.py,sha256=tObBb5DKbP5gn4OMY3Jgwh1nFRYOZfbfU7fY3AvlIzQ,15650
-tpds/xml_handler/tflxwpc_xml_updates.py,sha256=tKF1TJSsNREcIJb9_KyEFh54lW2VpVDJwum9T-IP0zs,18226
-tpds/xml_handler/xml_processing.py,sha256=wpHgc7WeP-aYKn3sysAQ8c03N4falEgMJEmSc83d0SI,2558
-tpds/xml_handler/encrypt/__init__.py,sha256=o99r0n4-8UAkCGQf8jMNCgYMgAkFcri-eTNplwoXRew,113
-tpds/xml_handler/encrypt/ciphers.py,sha256=fiNA5_LvaUAWVBdJrC9c5wx193qxkJuMp2TQniG_YbM,6436
-tpds/xml_handler/encrypt/encrypt.py,sha256=ixcYN17vN5h_6P5COLTGFndYeXC9vk9knGrpAF3u2Yk,18273
-tpds_helper-2.3.6.dist-info/LICENSE,sha256=cur0GFIHzs4StFPUWjgSNJOazHE9PVvgcaDQE4viiCQ,1121
-tpds_helper-2.3.6.dist-info/METADATA,sha256=JQOB6hsKq6I5LXMVPSq6tDM1YZAQnOgS7VUgtHYwSy4,3291
-tpds_helper-2.3.6.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-tpds_helper-2.3.6.dist-info/top_level.txt,sha256=Tl4GsItOlkTwS5kMrk7oOjlZsRztkeFRTneAJ5ZBOjQ,5
-tpds_helper-2.3.6.dist-info/RECORD,,
+tpds/xml_handler/__init__.py,sha256=z-NULzrNHah-AuY1YN8kDmMrCpU5HpOUMNsj2YeSn3U,595
+tpds/xml_handler/caencryption.py,sha256=Y7TPC5JrKJv1gj9MJV0E9-zfdlWcmvP4CZALXJkYcfM,1362
+tpds/xml_handler/ciphers.py,sha256=Mx-ZLfEltzWeJjTtfie68KBF2pqnL6TWDbVGWtbFFxY,6379
+tpds/xml_handler/ecc_xml_encryption.py,sha256=scUdWYog7Si0F4mACimqkkOf5eT7p76dXpQT-xZexPc,8332
+tpds/xml_handler/tflxtls_xml_updates.py,sha256=WRGMAqooRtvrGo03XaFMR6Cn5zpvtq_6gHtFxKg3QE8,15090
+tpds/xml_handler/tflxwpc_xml_updates.py,sha256=1_okfFuFkHBBxYWBz3glAGnAhR7ednZaHzFafFxNcKw,17529
+tpds/xml_handler/xml_processing.py,sha256=2BoBWzOTs_3F3l0N6_v0gxJuSdokezxkaTSNm_3GOOg,2558
+tpds/xml_handler/encrypt/__init__.py,sha256=BF5ZjYiw4ptC9R4800rlXZxQ5x5iRq93UxDvpSGgmKI,249
+tpds/xml_handler/encrypt/ciphers.py,sha256=TiUaZGBbMr3jZLRlGuq1dX84UxeFnf13e6L-B0y1vr8,6621
+tpds/xml_handler/encrypt/encrypt.py,sha256=qSUiiiDQZfqjn6CzHMcuDNpAakWAgEqGm1Wya-zuh-g,18345
+tpds_helper-2.3.7.dist-info/LICENSE,sha256=cur0GFIHzs4StFPUWjgSNJOazHE9PVvgcaDQE4viiCQ,1121
+tpds_helper-2.3.7.dist-info/METADATA,sha256=CqHLrN9ty2my7jKjv9S4WxfGYCga9EPr2KUChYXWPqU,3957
+tpds_helper-2.3.7.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+tpds_helper-2.3.7.dist-info/top_level.txt,sha256=Tl4GsItOlkTwS5kMrk7oOjlZsRztkeFRTneAJ5ZBOjQ,5
+tpds_helper-2.3.7.dist-info/RECORD,,
```

