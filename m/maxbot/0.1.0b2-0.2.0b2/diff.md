# Comparing `tmp/maxbot-0.1.0b2-py3-none-any.whl.zip` & `tmp/maxbot-0.2.0b2-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,51 +1,56 @@
-Zip file size: 91345 bytes, number of entries: 49
+Zip file size: 98533 bytes, number of entries: 54
 -rw-r--r--  2.0 unx      162 b- defN 80-Jan-01 00:00 maxbot/__init__.py
 -rw-r--r--  2.0 unx       75 b- defN 80-Jan-01 00:00 maxbot/__main__.py
 -rw-r--r--  2.0 unx     2724 b- defN 80-Jan-01 00:00 maxbot/_download.py
 -rw-r--r--  2.0 unx      787 b- defN 80-Jan-01 00:00 maxbot/_hooks.py
 -rw-r--r--  2.0 unx    13150 b- defN 80-Jan-01 00:00 maxbot/bot.py
--rw-r--r--  2.0 unx    14553 b- defN 80-Jan-01 00:00 maxbot/builder.py
+-rw-r--r--  2.0 unx    14547 b- defN 80-Jan-01 00:00 maxbot/builder.py
 -rw-r--r--  2.0 unx      186 b- defN 80-Jan-01 00:00 maxbot/channels/__init__.py
--rw-r--r--  2.0 unx     7515 b- defN 80-Jan-01 00:00 maxbot/channels/_manager.py
--rw-r--r--  2.0 unx     9338 b- defN 80-Jan-01 00:00 maxbot/channels/facebook.py
--rw-r--r--  2.0 unx     5772 b- defN 80-Jan-01 00:00 maxbot/channels/telegram.py
--rw-r--r--  2.0 unx     8997 b- defN 80-Jan-01 00:00 maxbot/channels/viber.py
--rw-r--r--  2.0 unx    11077 b- defN 80-Jan-01 00:00 maxbot/channels/vk.py
--rw-r--r--  2.0 unx      383 b- defN 80-Jan-01 00:00 maxbot/cli/__init__.py
+-rw-r--r--  2.0 unx     7510 b- defN 80-Jan-01 00:00 maxbot/channels/_manager.py
+-rw-r--r--  2.0 unx     9353 b- defN 80-Jan-01 00:00 maxbot/channels/facebook.py
+-rw-r--r--  2.0 unx     5897 b- defN 80-Jan-01 00:00 maxbot/channels/telegram.py
+-rw-r--r--  2.0 unx     9097 b- defN 80-Jan-01 00:00 maxbot/channels/viber.py
+-rw-r--r--  2.0 unx    11180 b- defN 80-Jan-01 00:00 maxbot/channels/vk.py
+-rw-r--r--  2.0 unx      535 b- defN 80-Jan-01 00:00 maxbot/cli/__init__.py
 -rw-r--r--  2.0 unx     1990 b- defN 80-Jan-01 00:00 maxbot/cli/_bot.py
--rw-r--r--  2.0 unx     2061 b- defN 80-Jan-01 00:00 maxbot/cli/_journal.py
+-rw-r--r--  2.0 unx     3069 b- defN 80-Jan-01 00:00 maxbot/cli/_journal.py
 -rw-r--r--  2.0 unx     1638 b- defN 80-Jan-01 00:00 maxbot/cli/_logging.py
 -rw-r--r--  2.0 unx     1963 b- defN 80-Jan-01 00:00 maxbot/cli/_ngrok.py
--rw-r--r--  2.0 unx     7467 b- defN 80-Jan-01 00:00 maxbot/cli/_rich.py
--rw-r--r--  2.0 unx     5441 b- defN 80-Jan-01 00:00 maxbot/cli/run.py
--rw-r--r--  2.0 unx    19273 b- defN 80-Jan-01 00:00 maxbot/context.py
--rw-r--r--  2.0 unx     5087 b- defN 80-Jan-01 00:00 maxbot/dialog_manager.py
--rw-r--r--  2.0 unx    10289 b- defN 80-Jan-01 00:00 maxbot/errors.py
+-rw-r--r--  2.0 unx    10809 b- defN 80-Jan-01 00:00 maxbot/cli/_rich.py
+-rw-r--r--  2.0 unx     1018 b- defN 80-Jan-01 00:00 maxbot/cli/_yaml_dumper.py
+-rw-r--r--  2.0 unx     1297 b- defN 80-Jan-01 00:00 maxbot/cli/info.py
+-rw-r--r--  2.0 unx     5999 b- defN 80-Jan-01 00:00 maxbot/cli/run.py
+-rw-r--r--  2.0 unx     6040 b- defN 80-Jan-01 00:00 maxbot/cli/stories.py
+-rw-r--r--  2.0 unx    20507 b- defN 80-Jan-01 00:00 maxbot/context.py
+-rw-r--r--  2.0 unx     5628 b- defN 80-Jan-01 00:00 maxbot/dialog_manager.py
+-rw-r--r--  2.0 unx    10361 b- defN 80-Jan-01 00:00 maxbot/errors.py
 -rw-r--r--  2.0 unx      139 b- defN 80-Jan-01 00:00 maxbot/extensions/__init__.py
--rw-r--r--  2.0 unx     4185 b- defN 80-Jan-01 00:00 maxbot/extensions/_manager.py
--rw-r--r--  2.0 unx     2738 b- defN 80-Jan-01 00:00 maxbot/extensions/datetime.py
--rw-r--r--  2.0 unx     2568 b- defN 80-Jan-01 00:00 maxbot/extensions/format.py
+-rw-r--r--  2.0 unx     4177 b- defN 80-Jan-01 00:00 maxbot/extensions/_manager.py
+-rw-r--r--  2.0 unx     3884 b- defN 80-Jan-01 00:00 maxbot/extensions/babel.py
+-rw-r--r--  2.0 unx     2872 b- defN 80-Jan-01 00:00 maxbot/extensions/datetime.py
 -rw-r--r--  2.0 unx     1043 b- defN 80-Jan-01 00:00 maxbot/extensions/jinja_loader.py
--rw-r--r--  2.0 unx     5513 b- defN 80-Jan-01 00:00 maxbot/extensions/rasa.py
--rw-r--r--  2.0 unx     5592 b- defN 80-Jan-01 00:00 maxbot/extensions/rest.py
--rw-r--r--  2.0 unx       33 b- defN 80-Jan-01 00:00 maxbot/flows/__init__.py
+-rw-r--r--  2.0 unx     5524 b- defN 80-Jan-01 00:00 maxbot/extensions/rasa.py
+-rw-r--r--  2.0 unx     5588 b- defN 80-Jan-01 00:00 maxbot/extensions/rest.py
+-rw-r--r--  2.0 unx       32 b- defN 80-Jan-01 00:00 maxbot/flows/__init__.py
 -rw-r--r--  2.0 unx     1302 b- defN 80-Jan-01 00:00 maxbot/flows/_base.py
 -rw-r--r--  2.0 unx     2053 b- defN 80-Jan-01 00:00 maxbot/flows/dialog_flow.py
--rw-r--r--  2.0 unx    25772 b- defN 80-Jan-01 00:00 maxbot/flows/dialog_tree.py
--rw-r--r--  2.0 unx    12570 b- defN 80-Jan-01 00:00 maxbot/flows/slot_filling.py
--rw-r--r--  2.0 unx     8526 b- defN 80-Jan-01 00:00 maxbot/jinja_env.py
--rw-r--r--  2.0 unx     4542 b- defN 80-Jan-01 00:00 maxbot/markdown.py
--rw-r--r--  2.0 unx    20871 b- defN 80-Jan-01 00:00 maxbot/nlu.py
--rw-r--r--  2.0 unx    10833 b- defN 80-Jan-01 00:00 maxbot/resources.py
--rw-r--r--  2.0 unx     4728 b- defN 80-Jan-01 00:00 maxbot/rpc.py
--rw-r--r--  2.0 unx     8844 b- defN 80-Jan-01 00:00 maxbot/scenarios.py
--rw-r--r--  2.0 unx    16929 b- defN 80-Jan-01 00:00 maxbot/schemas.py
+-rw-r--r--  2.0 unx    26575 b- defN 80-Jan-01 00:00 maxbot/flows/dialog_tree.py
+-rw-r--r--  2.0 unx    13775 b- defN 80-Jan-01 00:00 maxbot/flows/slot_filling.py
+-rw-r--r--  2.0 unx     6658 b- defN 80-Jan-01 00:00 maxbot/jinja_env.py
+-rw-r--r--  2.0 unx      161 b- defN 80-Jan-01 00:00 maxbot/maxml/__init__.py
+-rw-r--r--  2.0 unx     3440 b- defN 80-Jan-01 00:00 maxbot/maxml/markup.py
+-rw-r--r--  2.0 unx     6009 b- defN 80-Jan-01 00:00 maxbot/maxml/pretty.py
+-rw-r--r--  2.0 unx    15413 b- defN 80-Jan-01 00:00 maxbot/maxml/xml_parser.py
+-rw-r--r--  2.0 unx    21817 b- defN 80-Jan-01 00:00 maxbot/nlu.py
+-rw-r--r--  2.0 unx    10827 b- defN 80-Jan-01 00:00 maxbot/resources.py
+-rw-r--r--  2.0 unx     4723 b- defN 80-Jan-01 00:00 maxbot/rpc.py
+-rw-r--r--  2.0 unx     8839 b- defN 80-Jan-01 00:00 maxbot/scenarios.py
+-rw-r--r--  2.0 unx    17214 b- defN 80-Jan-01 00:00 maxbot/schemas.py
 -rw-r--r--  2.0 unx     4164 b- defN 80-Jan-01 00:00 maxbot/state_store.py
 -rw-r--r--  2.0 unx     1051 b- defN 80-Jan-01 00:00 maxbot/user_locks.py
--rw-r--r--  2.0 unx    14851 b- defN 80-Jan-01 00:00 maxbot/xml.py
--rw-r--r--  2.0 unx     1055 b- defN 80-Jan-01 00:00 maxbot-0.1.0b2.dist-info/LICENSE
--rw-r--r--  2.0 unx     7688 b- defN 80-Jan-01 00:00 maxbot-0.1.0b2.dist-info/METADATA
--rw-r--r--  2.0 unx       88 b- defN 80-Jan-01 00:00 maxbot-0.1.0b2.dist-info/WHEEL
--rw-r--r--  2.0 unx       42 b- defN 80-Jan-01 00:00 maxbot-0.1.0b2.dist-info/entry_points.txt
-?rw-r--r--  2.0 unx     3851 b- defN 16-Jan-01 00:00 maxbot-0.1.0b2.dist-info/RECORD
-49 files, 301499 bytes uncompressed, 85371 bytes compressed:  71.7%
+-rw-r--r--  2.0 unx     1055 b- defN 80-Jan-01 00:00 maxbot-0.2.0b2.dist-info/LICENSE
+-rw-r--r--  2.0 unx     7613 b- defN 80-Jan-01 00:00 maxbot-0.2.0b2.dist-info/METADATA
+-rw-r--r--  2.0 unx       88 b- defN 80-Jan-01 00:00 maxbot-0.2.0b2.dist-info/WHEEL
+-rw-r--r--  2.0 unx       42 b- defN 80-Jan-01 00:00 maxbot-0.2.0b2.dist-info/entry_points.txt
+?rw-r--r--  2.0 unx     4263 b- defN 16-Jan-01 00:00 maxbot-0.2.0b2.dist-info/RECORD
+54 files, 325863 bytes uncompressed, 91925 bytes compressed:  71.8%
```

## zipnote {}

```diff
@@ -48,17 +48,26 @@
 
 Filename: maxbot/cli/_ngrok.py
 Comment: 
 
 Filename: maxbot/cli/_rich.py
 Comment: 
 
+Filename: maxbot/cli/_yaml_dumper.py
+Comment: 
+
+Filename: maxbot/cli/info.py
+Comment: 
+
 Filename: maxbot/cli/run.py
 Comment: 
 
+Filename: maxbot/cli/stories.py
+Comment: 
+
 Filename: maxbot/context.py
 Comment: 
 
 Filename: maxbot/dialog_manager.py
 Comment: 
 
 Filename: maxbot/errors.py
@@ -66,18 +75,18 @@
 
 Filename: maxbot/extensions/__init__.py
 Comment: 
 
 Filename: maxbot/extensions/_manager.py
 Comment: 
 
-Filename: maxbot/extensions/datetime.py
+Filename: maxbot/extensions/babel.py
 Comment: 
 
-Filename: maxbot/extensions/format.py
+Filename: maxbot/extensions/datetime.py
 Comment: 
 
 Filename: maxbot/extensions/jinja_loader.py
 Comment: 
 
 Filename: maxbot/extensions/rasa.py
 Comment: 
@@ -99,15 +108,24 @@
 
 Filename: maxbot/flows/slot_filling.py
 Comment: 
 
 Filename: maxbot/jinja_env.py
 Comment: 
 
-Filename: maxbot/markdown.py
+Filename: maxbot/maxml/__init__.py
+Comment: 
+
+Filename: maxbot/maxml/markup.py
+Comment: 
+
+Filename: maxbot/maxml/pretty.py
+Comment: 
+
+Filename: maxbot/maxml/xml_parser.py
 Comment: 
 
 Filename: maxbot/nlu.py
 Comment: 
 
 Filename: maxbot/resources.py
 Comment: 
@@ -123,26 +141,23 @@
 
 Filename: maxbot/state_store.py
 Comment: 
 
 Filename: maxbot/user_locks.py
 Comment: 
 
-Filename: maxbot/xml.py
-Comment: 
-
-Filename: maxbot-0.1.0b2.dist-info/LICENSE
+Filename: maxbot-0.2.0b2.dist-info/LICENSE
 Comment: 
 
-Filename: maxbot-0.1.0b2.dist-info/METADATA
+Filename: maxbot-0.2.0b2.dist-info/METADATA
 Comment: 
 
-Filename: maxbot-0.1.0b2.dist-info/WHEEL
+Filename: maxbot-0.2.0b2.dist-info/WHEEL
 Comment: 
 
-Filename: maxbot-0.1.0b2.dist-info/entry_points.txt
+Filename: maxbot-0.2.0b2.dist-info/entry_points.txt
 Comment: 
 
-Filename: maxbot-0.1.0b2.dist-info/RECORD
+Filename: maxbot-0.2.0b2.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## maxbot/builder.py

```diff
@@ -1,19 +1,18 @@
 """MaxBot creation."""
 from functools import cached_property, partial
 
-from marshmallow import fields
-
 from ._hooks import HookWrapper
 from .bot import MaxBot
 from .channels import ChannelManager
 from .dialog_manager import DialogManager
 from .extensions import ExtensionManager
 from .flows.dialog_flow import DialogFlow
 from .jinja_env import create_jinja_env
+from .maxml import fields
 from .resources import (
     DirectoryResources,
     FileResources,
     InlineResources,
     PackageResources,
     Resources,
 )
```

## maxbot/channels/_manager.py

```diff
@@ -1,16 +1,15 @@
 """Channels Manager."""
 
 import asyncio
 import inspect
 import pkgutil
 from abc import ABC, abstractmethod
 
-from marshmallow import Schema, fields
-
+from ..maxml import Schema, fields
 from ..schemas import ResourceSchema
 
 BUILTIN_CHANNELS = {
     "telegram": "maxbot.channels.telegram:TelegramChannel",
     "viber": "maxbot.channels.viber:ViberChannel",
     "facebook": "maxbot.channels.facebook:FacebookChannel",
     "vk": "maxbot.channels.vk:VkChannel",
```

## maxbot/channels/facebook.py

```diff
@@ -1,15 +1,16 @@
 """Facebook Bots Channel."""
 import hmac
 import logging
 from functools import cached_property
 from urllib.parse import urljoin
 
 import httpx
-from marshmallow import Schema, fields
+
+from ..maxml import Schema, fields
 
 logger = logging.getLogger(__name__)
 
 
 class Gateway:
     """Facebook sender and verifier incoming messages."""
 
@@ -158,27 +159,27 @@
         """Send an text message to the channel.
 
         @See https://developers.facebook.com/docs/messenger-platform/reference/send-api/
 
         :param dict command: a command with the payload :attr:`~maxbot.schemas.CommandSchema.text`.
         :param dict dialog: a dialog we respond in, with the schema :class:`~maxbot.schemas.DialogSchema`
         """
-        await self._api.send_text(dialog["user_id"], command["text"])
+        await self._api.send_text(dialog["user_id"], command["text"].render())
 
     async def send_image(self, command: dict, dialog: dict):
         """Send an image message to the channel.
 
         @See https://developers.facebook.com/docs/messenger-platform/reference/send-api/
 
         :param dict command: a command with the payload :attr:`~maxbot.schemas.CommandSchema.image`.
         :param dict dialog: a dialog we respond in, with the schema :class:`~maxbot.schemas.DialogSchema`
         """
         caption = command["image"].get("caption")
         if caption:
-            await self._api.send_text(dialog["user_id"], caption)
+            await self._api.send_text(dialog["user_id"], caption.render())
         await self._api.send_image(dialog["user_id"], command["image"]["url"])
 
     async def receive_text(self, messaging: dict):
         """Receive an text message from the channel.
 
         @See https://developers.facebook.com/docs/messenger-platform/reference/webhook-events/
         @See https://developers.facebook.com/docs/messenger-platform/reference/webhook-events/messages
```

## maxbot/channels/telegram.py

```diff
@@ -1,17 +1,18 @@
 """Telegram Bots Channel."""
 import logging
 import os
 from functools import cached_property
 from urllib.parse import urljoin
 
 import httpx
-from marshmallow import Schema, fields
 from telegram import Bot, Update
 
+from ..maxml import Schema, fields
+
 TG_FILE_URL = "https://api.telegram.org/file"
 
 logger = logging.getLogger(__name__)
 
 
 class TelegramChannel:
     """A channel for Telegram Bots. See https://core.telegram.org/bots.
@@ -69,15 +70,15 @@
         """Send a text command to the channel.
 
         See https://core.telegram.org/bots/api#sendmessage.
 
         :param dict command: A command with the payload :attr:`~maxbot.schemas.CommandSchema.text`.
         :param dict dialog: A dialog we respond in, with the schema :class:`~maxbot.schemas.DialogSchema`.
         """
-        await self.bot.send_message(dialog["user_id"], command["text"])
+        await self.bot.send_message(dialog["user_id"], command["text"].render())
 
     async def receive_image(self, update: Update):
         """Receive an image message from the channel.
 
         See https://core.telegram.org/bots/api#message.
         See https://core.telegram.org/bots/api#photosize.
         See https://core.telegram.org/bots/api#getfile.
@@ -101,28 +102,31 @@
 
         See https://core.telegram.org/bots/api#sendphoto.
 
         :param dict command: A command with the payload :attr:`~maxbot.schemas.CommandSchema.image`.
         :param dict dialog: A dialog we respond in, with the schema :class:`~maxbot.schemas.DialogSchema`.
         """
         image = command["image"]
+        caption = image.get("caption")
         # Error on send_photo with url starts with {TG_FILE_URL}:
         # telegram.error.BadRequest: Wrong file identifier/http url specified
         # In this case send content photo
         if image["url"].startswith(TG_FILE_URL):
             response = await self.httpx_client.get(image["url"])
             response.raise_for_status()
             await self.bot.send_photo(
                 dialog["user_id"],
                 response.content,
-                image.get("caption"),
+                None if caption is None else caption.render(),
                 filename=os.path.basename(response.url.path),
             )
         else:
-            await self.bot.send_photo(dialog["user_id"], image["url"], image.get("caption"))
+            await self.bot.send_photo(
+                dialog["user_id"], image["url"], None if caption is None else caption.render()
+            )
 
     def blueprint(self, callback, public_url=None, webhook_path=None):
         """Create web application blueprint to receive incoming updates.
 
         :param callable callback: a callback for received messages.
         :param string public_url: Base url to register webhook.
         :param string webhook_path: An url path to receive incoming updates.
```

## maxbot/channels/viber.py

```diff
@@ -1,19 +1,20 @@
 """Viber Bots Channel."""
 import logging
 from functools import cached_property
 from urllib.parse import urljoin
 
 import httpx
-from marshmallow import Schema, fields
 from viberbot.api.messages import PictureMessage
 from viberbot.api.messages.text_message import TextMessage
 from viberbot.api.viber_requests import ViberMessageRequest, create_request
 from viberbot.api.viber_requests.viber_request import ViberRequest
 
+from ..maxml import Schema, fields
+
 logger = logging.getLogger(__name__)
 
 
 class Gateway:
     """Viber Gateway."""
 
     httpx_client = httpx.AsyncClient(base_url="https://chatapi.viber.com/pa", timeout=3)
@@ -145,28 +146,31 @@
 
         See https://developers.viber.com/docs/api/python-bot-api/#apisend_messagesto-messages
         See https://developers.viber.com/docs/api/python-bot-api/#textmessage-object
 
         :param dict command: a command with the payload :attr:`~maxbot.schemas.CommandSchema.text`.
         :param dict dialog: a dialog we respond in, with the schema :class:`~maxbot.schemas.DialogSchema`
         """
-        await self._api.send_message(dialog["user_id"], TextMessage(text=command["text"]))
+        await self._api.send_message(dialog["user_id"], TextMessage(text=command["text"].render()))
 
     async def send_image(self, command: dict, dialog: dict):
         """Send an image command to the channel.
 
         See https://developers.viber.com/docs/api/python-bot-api/#apisend_messagesto-messages
         See https://developers.viber.com/docs/api/python-bot-api/#picturemessage-object
 
         :param dict command: a command with the payload :attr:`~maxbot.schemas.CommandSchema.image`.
         :param dict dialog: a dialog we respond in, with the schema :class:`~maxbot.schemas.DialogSchema`
         """
+        caption = command["image"].get("caption")
         await self._api.send_message(
             dialog["user_id"],
-            PictureMessage(media=command["image"]["url"], text=command["image"].get("caption")),
+            PictureMessage(
+                media=command["image"]["url"], text=None if caption is None else caption.render()
+            ),
         )
 
     async def receive_text(self, request: ViberRequest):
         """Receive an text message from the channel.
 
         See https://developers.viber.com/docs/api/rest-bot-api/#receive-message-from-user.
         See https://developers.viber.com/docs/api/python-bot-api/#vibermessagerequest-object.
```

## maxbot/channels/vk.py

```diff
@@ -1,17 +1,17 @@
 """VK Bots Channel."""
 import logging
 import secrets
 from functools import cached_property
 from urllib.parse import urljoin
 
 import httpx
-from marshmallow import Schema, fields
 
 from .._download import download_to_tempfile
+from ..maxml import Schema, fields
 
 logger = logging.getLogger(__name__)
 
 
 def _response_validate(response, keys):
     """Validate VK response."""
     for key in keys:
@@ -198,15 +198,15 @@
         Send an text command to the channel.
 
         See https://dev.vk.com/method/messages.send  (message)
 
         :param dict command: a command with the payload :attr:`~maxbot.schemas.CommandSchema.text`.
         :param dict dialog: a dialog we respond in, with the schema :class:`~maxbot.schemas.DialogSchema`
         """
-        await self._api.send_text(dialog["user_id"], command["text"])
+        await self._api.send_text(dialog["user_id"], command["text"].render())
 
     async def send_image(self, command: dict, dialog: dict):
         """Send an image command to the channel.
 
         See https://dev.vk.com/method/messages.send  (attachment.type=photo)
 
         :param dict command: a command with the payload :attr:`~maxbot.schemas.CommandSchema.text`.
@@ -217,15 +217,18 @@
             server, photo, hash_param = await self._api.upload_media_file(
                 upload_url,
                 download_result.determine_filename(),
                 download_result.temp_file,
                 download_result.response.headers["content-type"],
             )
             photo = await self._api.save_photo(server, photo, hash_param)
-            await self._api.send_image(dialog["user_id"], photo, command["image"].get("caption"))
+            caption = command["image"].get("caption")
+            await self._api.send_image(
+                dialog["user_id"], photo, None if caption is None else caption.render()
+            )
 
     async def receive_text(self, incoming_message: dict):
         """
         Receives an text message from the channel.
 
         @See https://dev.vk.com/api/community-events/json-schema#Сообщения
```

## maxbot/cli/__init__.py

```diff
@@ -1,21 +1,25 @@
 """MaxBot CLI."""
 import click
 import dotenv
 
+from .info import info as info_command
 from .run import run
+from .stories import stories as stories_command
 
 
 @click.group()
 def main():
     """Execute the cli script for MaxBot applications.
 
     Provides commands to run bots, test them with stories etc.
     """
     path = dotenv.find_dotenv(".env", usecwd=True)
     if path:
         dotenv.load_dotenv(path, encoding="utf-8")
 
 
 main.add_command(run)
+main.add_command(stories_command)
+main.add_command(info_command)
 
 __all__ = ("main",)
```

## maxbot/cli/_journal.py

```diff
@@ -1,63 +1,105 @@
 """Bot journals."""
-import atexit
 import json
 import os
 from dataclasses import asdict
-from datetime import datetime
 
-import click
+from ..maxml import pretty
+from ._yaml_dumper import yaml_frendly_dumps
 
 
-def create_journal(target):
+def create_journal(verbose, quiet, journal_file, journal_output):
     """Create bot journal from provided specification.
 
-    :param str target: The name of the journal and its arguments.
+    :param int verbose: Verbose level.
+    :param bool quiet: Do not log to console.
+    :param file journal_file: Logging to the file.
+    :param str journal_output: File journal output format ("json" or "yaml").
     """
-    if target == "console":
+    journal = JournalChain()
+    if not quiet:
         from ._rich import PrettyJournal  # speed up loading time
 
-        return PrettyJournal()
-    if target.startswith("file:"):
-        return JsonLineJournal(filename=target.removeprefix("file:"))
-    raise click.BadParameter(f"unknown journal {target!r}.", param_hint="--journal")
+        journal.chain.append(PrettyJournal(verbose))
+    if journal_file:
+        journal.chain.append(
+            FileJournal(
+                journal_file,
+                {"json": Dumper.json_line, "yaml": Dumper.yaml_triple_dash}[journal_output],
+            )
+        )
+    return journal
+
+
+class JournalChain:
+    """Sequentially call several journals."""
+
+    def __init__(self, chain=None):
+        """Create class instance."""
+        self.chain = chain or []
 
+    def __call__(self, ctx):
+        """Process turn context.
+
+        :param TurnContext ctx: Context of the dialog turn.
+        """
+        for journal in self.chain:
+            journal(ctx)
 
-class JsonLineJournal:
-    """A journal that writes JSON lines into a file."""
 
-    def __init__(self, filename):
+class FileJournal:
+    """A journal that write to file."""
+
+    def __init__(self, f, dumps):
         """Create class instance.
 
-        :param str filename: The name of the file to write.
+        :param file f: Target file to write.
+        :dump callable dumps: Dump object to string.
         """
-        try:
-            f = open(filename, mode="a", encoding="utf8")  # pylint: disable=consider-using-with
-        except IOError as e:
-            raise click.BadParameter(f"could not open {filename!r}: {e!r}", param_hint="--journal")
-        atexit.register(f.close)
         self.f = f
+        self.dumps = dumps
 
     def __call__(self, ctx):
         """Write turn context.
 
         :param TurnContext ctx: Context of the dialog turn.
         """
         record = {
-            "time": str(datetime.now()),
+            "time": str(ctx.utc_time),
             "dialog": ctx.dialog,
+            "intents": {
+                "top": None if ctx.intents.top is None else asdict(ctx.intents.top),
+                "ranking": [asdict(i) for i in ctx.intents.ranking],
+            },
+            "entities": [asdict(e) for e in ctx.entities.all_objects],
+            "events": ctx.journal_events,
         }
         if ctx.message:
             record["message"] = ctx.message
         if ctx.rpc:
             record["rpc"] = asdict(ctx.rpc.request)
         if ctx.commands:
-            record["response"] = ctx.commands
-        for log in ctx.logs:
-            message = log.message if isinstance(log.message, str) else repr(log.message)
-            record.setdefault("logs", []).append({"level": log.level, "message": message})
+            record["response"] = pretty.print_xml(ctx.commands, ctx.command_schema)
         if ctx.error:
             record["error"] = {"message": ctx.error.message}
             if ctx.error.snippets:
                 record["error"]["snippets"] = [s.format() for s in ctx.error.snippets]
-        self.f.write(json.dumps(record) + os.linesep)
+        self.f.write(self.dumps(record))
         self.f.flush()
+
+
+class Dumper:
+    """Dumpers for FileJournal (`dumps` in ctor)."""
+
+    @staticmethod
+    def json_line(data):
+        """Dump objects to JSON line."""
+
+        def default(o):
+            return repr(o)
+
+        return json.dumps(data, default=default) + os.linesep
+
+    @staticmethod
+    def yaml_triple_dash(data):
+        """Dump object to YAML with three dashes (`---`) at end."""
+        return yaml_frendly_dumps(data) + "---" + os.linesep
```

## maxbot/cli/_rich.py

```diff
@@ -3,59 +3,74 @@
 Rich library is heavy, we put all its stuf here and defer its load.
 
 """
 import functools
 import logging
 from dataclasses import asdict
 from datetime import datetime
+from enum import IntEnum
 
-import yaml
 from rich.console import Console
 from rich.containers import Lines
 from rich.logging import RichHandler
 from rich.pretty import Pretty
 from rich.progress import Progress as _Progress
 from rich.style import Style
 from rich.syntax import Syntax
 from rich.table import Table
 from rich.text import Text
 
-from ..errors import BotError
+from ..context import TurnContext
+from ..errors import BotError, XmlSnippet, YamlSnippet
+from ..maxml import markup, pretty
+from ._yaml_dumper import yaml_frendly_dumps
 
 STDOUT = Console()
 STDERR = Console(stderr=True)
 # Make sure the STDERR output displayed above the progress display.
 Progress = functools.partial(_Progress, console=STDERR)
 
 
 class PrettyJournal:
     """Pretty journal to console."""
 
-    def __init__(self, console=None):
+    class VerbosityLevel(IntEnum):
+        """Level of verbosity."""
+
+        NLU = 1
+        JOURNAL = 2
+
+    def __init__(self, verbose=0, console=None):
         """Create class instance.
 
+        :param int verbose: Output verbosity.
         :param Console|None console: Console to write.
         """
+        self.verbose = verbose
         self.console = console or STDOUT
 
     def __call__(self, ctx):
         """Write turn context.
 
         :param TurnContext ctx: Context of the dialog turn.
         """
         self.console.line()
         self.print_dialog(ctx.dialog)
         if ctx.message:
             self.print_message(ctx.message)
         if ctx.rpc:
             self.print_rpc(asdict(ctx.rpc.request))
         if ctx.commands:
-            self.print_commands(ctx.commands)
-        if ctx.logs:
-            self.print_logs(ctx.logs)
+            self.print_commands(ctx.commands, ctx.command_schema)
+        if self.verbose >= self.VerbosityLevel.NLU:
+            self.print_intents(ctx.intents)
+            if ctx.entities.all_objects:
+                self.print_entities(ctx.entities)
+        if ctx.journal_events:
+            self.print_journal_events(ctx.journal_events)
         if ctx.error:
             self.print_error(ctx.error)
 
     def print_dialog(self, dialog):
         """Print dialog info.
 
         :param dict dialog: Dialog information.
@@ -63,14 +78,61 @@
         turn_time = datetime.now().strftime("[%X]")
         self.console.print(
             f"{turn_time}, {dialog['channel_name']}#{dialog['user_id']}",
             style="dim",
             highlight=False,
         )
 
+    def print_intents(self, intents):
+        """Print recognized NLU intents.
+
+        :param IntentsResult intents: Intents recognized from the message.
+        """
+        output = Table.grid(padding=(0, 1))
+        output.title = "intents"
+        output.title_justify = "left"
+        output.expand = True
+        output.add_column()
+        output.add_column()
+        output.add_column(ratio=1)
+
+        def _print_intent(label, intent):
+            output.add_row(Text.styled(label, "bold"), "name", Text.styled(intent.name, "yellow"))
+            output.add_row("", "confidence", str(intent.confidence))
+
+        if intents.top is None:
+            output.add_row(Text.styled(".irrelevant", "bold"), "", "")
+        else:
+            _print_intent(".top", intents.top)
+        for i, intent in enumerate(intents.ranking):
+            label = f".ranking[{i}]"
+            _print_intent(label, intent)
+        self.console.print(output)
+
+    def print_entities(self, entities):
+        """Print recognized NLU entities.
+
+        :param EntitiesResult entities: Entities recognized from the message.
+        """
+        output = Table.grid(padding=(0, 1))
+        output.title = "entities"
+        output.title_justify = "left"
+        output.expand = True
+        output.add_column()
+        output.add_column()
+        output.add_column(ratio=1)
+        for i, entity in enumerate(entities.all_objects):
+            label = f".all_objects[{i}]"
+            output.add_row(Text.styled(label, "bold"), "name", Text.styled(entity.name, "yellow"))
+            output.add_row("", "value", str(entity.value))
+            output.add_row("", "literal", entity.literal)
+            output.add_row("", "start_char", str(entity.start_char))
+            output.add_row("", "end_char", str(entity.end_char))
+        self.console.print(output)
+
     def print_message(self, message):
         """Print user message.
 
         :param dict message: User message.
         """
         if "text" in message and len(message) == 1:
             message = message["text"]
@@ -79,60 +141,80 @@
     def print_rpc(self, rpc):
         """Print RPC request.
 
         :param RpcContext rpc: Context of RPC request.
         """
         self._print_speech("💡", rpc)
 
-    def print_commands(self, commands):
+    def print_commands(self, commands, command_schema):
         """Print response commands.
 
         :param list[dict] commands: Response commands.
+        :param Schema command_schema: Schema of commands.
+        """
+        simple_text = (
+            len(commands) == 1
+            and "text" in commands[0]
+            and isinstance(commands[0]["text"], markup.Value)
+        )
+        if simple_text:
+            commands = commands[0]["text"].render()
+            lexer = None
+        else:
+            assert command_schema
+            commands = pretty.print_xml(commands, command_schema)
+            lexer = "XML"
+        self._print_speech("🤖", commands, lexer=lexer)
+
+    def print_journal_events(self, journal_events):
+        """Print events from journal.
+
+        :param list[dict] journal_events: Journal.
         """
-        if len(commands) == 1:
-            cmd = commands[0]
-            if "text" in cmd and len(cmd) == 1:
-                commands = cmd["text"]
-        self._print_speech("🤖", commands)
-
-    def print_logs(self, logs):
-        """Print logs.
-
-        :param list[LogRecord] logs: Log records.
-        """
-        for record in logs:
-            if isinstance(record.message, str):
-                self._print_log(record.level, record.message)
-            else:
-                self._print_log(
-                    record.level, Pretty(record.message, indent_size=2, indent_guides=True)
+        verbose_journal = self.verbose >= self.VerbosityLevel.JOURNAL
+        output = Table.grid(padding=(0, 1))
+        output.title = "journal_events" if verbose_journal else "logs"
+        output.title_justify = "left"
+        output.expand = True
+        output.add_column()
+        output.add_column(ratio=1)
+        for event in journal_events:
+            level, message = self._extract_log_event(event)
+            if level:
+                if not isinstance(message, str):
+                    message = Pretty(message, indent_size=2, indent_guides=True)
+                output.add_row(self._LOG_LEVELS[level.upper()], message)
+            elif verbose_journal:
+                output.add_row(
+                    Text.styled(event.get("type", "?"), "yellow"),
+                    _yaml_syntax(event.get("payload")),
                 )
+        self.console.print(output)
 
     def print_error(self, exc):
         """Print bot error.
 
         :param BotError exc: An error occured.
         """
         message = Lines()
         message.append(exc.message)
         for snippet in exc.snippets:
             message.extend(bot_error_snippet(snippet))
         self._print_log("ERROR", message)
 
-    def _print_speech(self, speaker, data):
+    def _print_speech(self, speaker, data, lexer=None):
         output = Table.grid(padding=(0, 1))
         output.expand = True
         output.add_column()
         output.add_column(ratio=1, overflow="fold")
 
         if isinstance(data, str):
-            speech = data
+            speech = data if lexer is None else Syntax(data, lexer, background_color="default")
         else:
-            string = yaml.dump(data, Dumper=_YAMLDumper).rstrip("\n")
-            speech = Syntax(string, "YAML", background_color="default")
+            speech = _yaml_syntax(data)
 
         output.add_row(speaker, speech)
         self.console.print(output)
 
     _LOG_LEVELS = {
         "DEBUG": Text.styled("ⓘ ", "blue"),
         "WARNING": Text.styled("⚠ ", "yellow"),
@@ -143,14 +225,18 @@
         output = Table.grid(padding=(0, 1))
         output.expand = True
         output.add_column()
         output.add_column(ratio=1, overflow="fold")
         output.add_row(self._LOG_LEVELS[level.upper()], message)
         self.console.print(output)
 
+    def _extract_log_event(self, event):
+        level, message = TurnContext.extract_log_event(event)
+        return (level, message) if level in self._LOG_LEVELS else (None, None)
+
 
 class ConsoleLogHandler(RichHandler):
     """Customize rich log handler."""
 
     _level_text = {
         logging.DEBUG: "ⓘ ",
         logging.INFO: "✓",
@@ -213,30 +299,21 @@
         for snippet in exc.snippets:
             lines.extend(bot_error_snippet(snippet))
         return lines
 
 
 def bot_error_snippet(snippet):
     """Format YAML snippet to output to console."""
+    assert isinstance(snippet, (XmlSnippet, YamlSnippet))
+    lexer = "XML" if isinstance(snippet, XmlSnippet) else "YAML+Jinja"
     yield Text(snippet.format_location(), style="dim")
     yield Syntax(
         snippet.code,
-        "YAML+Jinja",
+        lexer,
         line_numbers=True,
         line_range=(snippet.line, snippet.line + 2),
         highlight_lines={snippet.line + 1},
     )
 
 
-class _YAMLDumper(yaml.SafeDumper):
-    """Console friendly dumps."""
-
-    @staticmethod
-    def represent_str_literal(dumper, data):
-        """Represent multiline strings using literal style."""
-        data = str(data)
-        if "\n" in data:
-            return dumper.represent_scalar("tag:yaml.org,2002:str", data, style="|")
-        return dumper.represent_str(data)
-
-
-_YAMLDumper.add_representer(str, _YAMLDumper.represent_str_literal)
+def _yaml_syntax(data):
+    return Syntax(yaml_frendly_dumps(data).rstrip("\n"), "YAML", background_color="default")
```

## maxbot/cli/run.py

```diff
@@ -4,15 +4,15 @@
 from ._bot import resolve_bot
 from ._journal import create_journal
 from ._logging import configure_logging
 from ._ngrok import ask_ngrok
 
 
 @click.command(
-    short_help="run the bot",
+    short_help="Run the bot",
     context_settings={
         # less is more readable, but make sure the contents fits on one page
         "max_content_width": 120
     },
 )
 @click.option(
     "--bot",
@@ -79,37 +79,54 @@
 )
 @click.option("-v", "--verbose", count=True, help="Set the verbosity level.")
 @click.option(
     "--logger",
     type=str,
     default="console",
     show_default=True,
-    help="Log to console or file:/path/to/file.log.",
+    help=(
+        "Write the developer logs to console or file:/path/to/file.log. "
+        "Use the --journal-file option to redirect the journal."
+    ),
 )
 @click.option(
-    "--journal",
-    type=str,
-    default="console",
+    "--quiet",
+    "-q",
+    is_flag=True,
+    default=False,
+    help="Do not log to console.",
+)
+@click.option(
+    "--journal-file",
+    type=click.File(mode="a", encoding="utf8"),
+    help="Write the journal to the file.",
+)
+@click.option(
+    "--journal-output",
+    type=click.Choice(choices=["json", "yaml"]),
+    default="json",
     show_default=True,
-    help="Journal conversation to console or file:/var/log/maxbot.jsonl.",
+    help="Journal file format",
 )
 @click.pass_context
 def run(
     ctx,
     bot_spec,
     updater,
     host,
     port,
     public_url,
     ngrok,
     ngrok_url,
     autoreload,
     verbose,
     logger,
-    journal,
+    quiet,
+    journal_file,
+    journal_output,
 ):
     """
     Run the bot.
 
     Examples:
 
     \b
@@ -141,26 +158,31 @@
     maxbot run --bot bot.yaml --ngrok
 
     \b
     # log to file
     maxbot run --bot bot.yaml --logger file:/var/log/maxbot.log
 
     \b
-    # journal to file
-    maxbot run --bot bot.yaml --journal file:/var/log/maxbot.jsonl
+    # journal to file and to console
+    maxbot run --bot bot.yaml --journal-file /var/log/maxbot.jsonl
+
+    \b
+    # journal to file only
+    maxbot run --bot bot.yaml -q --journal-file /var/log/maxbot.jsonl
     """
-    configure_logging(logger, verbose)
+    if not quiet:
+        configure_logging(logger, verbose)
 
     from ._rich import Progress
 
     with Progress(transient=True) as progress:
         progress.add_task("Loading resources", total=None)
 
         bot = resolve_bot(bot_spec)
-        bot.dialog_manager.journal(create_journal(journal))
+        bot.dialog_manager.journal(create_journal(verbose, quiet, journal_file, journal_output))
 
     polling_conflicts = [
         next(p.get_error_hint(ctx) for p in ctx.command.params if p.name == name)
         for name in ("host", "port", "public_url", "ngrok", "ngrok_url")
         if ctx.get_parameter_source(name) != click.core.ParameterSource.DEFAULT
     ]
```

## maxbot/context.py

```diff
@@ -1,16 +1,18 @@
 """The context of the dialog turns."""
 import logging
 from dataclasses import dataclass, field, fields
+from datetime import datetime, timezone
 from operator import attrgetter
 from types import SimpleNamespace
-from typing import Any, Optional, Union
+from typing import Optional, Union
 
 from .errors import BotError
 from .jinja_env import StateNamespace
+from .maxml import Schema
 
 logger = logging.getLogger(__name__)
 
 
 class _ReprAsIs:
     """Help to get string representation without quotes.
 
@@ -432,35 +434,32 @@
         if self.request:
             yield self.request.method, _ReprAsIs("RpcRequest(...)")
             yield "request", _ReprAsIs("RpcRequest(...)")
         else:
             yield "request", self.request
 
 
-@dataclass(frozen=True)
-class LogRecord:
-    """Contains all information about the logged event."""
-
-    # The level of the logging event.
-    level: str
-
-    # The logged message of any type.
-    message: Any
+def get_utc_time_default():
+    """Return current time in UTC (default factory for TurnContext.utc_time)."""
+    return datetime.now(timezone.utc)
 
 
 @dataclass(frozen=True)
 class TurnContext:
     """The context used by the bot when processing the user message."""
 
     # An information about the dialog.
     dialog: dict
 
     # State variables of the dialog.
     state: StateVariables = field(default_factory=StateVariables)
 
+    # Date and time of turn (in UTC)
+    utc_time: datetime = field(default_factory=get_utc_time_default)
+
     # User message processed by the bot.
     message: dict = field(default_factory=dict)
 
     # The context of the RPC request processed by the bot.
     rpc: RpcContext = field(default_factory=RpcContext)
 
     # Intents recognized from the message.
@@ -468,19 +467,22 @@
 
     # Entities recognized from the message.
     entities: EntitiesResult = field(default_factory=EntitiesResult)
 
     # Additional variables for the scenario context.
     scenario: dict = field(default_factory=SimpleNamespace, init=False)
 
+    # Process user message journal
+    journal_events: list[dict] = field(default_factory=list, init=False)
+
     # Commands to respond to the user.
     commands: list[dict] = field(default_factory=list, init=False)
 
-    # Logged records.
-    logs: list[LogRecord] = field(default_factory=list, init=False)
+    # Schema of `.commands`
+    command_schema: Optional[Schema] = field(default=None)
 
     # An error occured.
     error: Optional[BotError] = field(default=None, init=False)
 
     def __post_init__(self):
         """Make sure that turn is either foreground or background which is mutually exclusive."""
         assert bool(self.message) != bool(self.rpc)
@@ -541,35 +543,49 @@
                 "dialog": self.dialog,
                 "intents": self.intents,
                 "entities": self.entities,
                 "user": StateNamespace(self.state.user),
                 "slots": StateNamespace(self.state.slots),
                 "rpc": self.rpc,
                 "params": self.rpc.request.params if self.rpc.request else {},
+                "utc_time": self.utc_time,
+                "utc_today": self.utc_time.date(),
                 "_turn_context": self,
             }
         )
         return rv
 
     def extend(self, **attributes):
         """Add the attributes to the instance of the context if they do not exist yet.
 
         This is used by extensions to pass data between hooks.
         """
         for key, value in attributes.items():
             if not hasattr(self, key):
                 setattr(self, key, value)
 
+    def journal_event(self, event_type, payload):
+        """Add new journal event.
+
+        :param str event_type: Type of the event.
+        :param any payload: Payload of the event.
+        :return any: Payload of inserted event.
+        """
+        logger.debug("%s %s", event_type, payload)
+        event = {"type": event_type, "payload": payload}
+        self.journal_events.append(event)
+        return event["payload"]
+
     def log(self, level, message):
         """Log the message.
 
         :param str level: Log level.
         :param any message: Log message.
         """
-        self.logs.append(LogRecord(level, message))
+        self.journal_event("log", {"level": level, "message": message})
 
     def debug(self, message):
         """Log the message with level DEBUG.
 
         :param any message: Log message.
         """
         self.log("DEBUG", message)
@@ -583,7 +599,20 @@
 
     def set_error(self, error):
         """Set the error occured during context processing.
 
         :param BotError error
         """
         object.__setattr__(self, "error", error)
+
+    @staticmethod
+    def extract_log_event(event):
+        """Try to extract level and message from journal event.
+
+        :param dict event: Event from TrunContext.journal_events.
+        :return tuple: Extracted level and message or (None, None)
+        """
+        if event.get("type") == "log":
+            payload = event.get("payload")
+            if isinstance(payload, dict):
+                return payload.get("level"), payload.get("message")
+        return None, None
```

## maxbot/dialog_manager.py

```diff
@@ -1,11 +1,11 @@
 """MaxBot dialog."""
 import logging
 
-from .context import RpcContext, RpcRequest, TurnContext
+from .context import RpcContext, RpcRequest, TurnContext, get_utc_time_default
 from .flows.dialog_flow import DialogFlow
 from .resources import InlineResources
 from .rpc import RpcManager
 from .schemas import CommandSchema, DialogSchema, MessageSchema
 
 logger = logging.getLogger(__name__)
 
@@ -21,28 +21,29 @@
         dialog_schema=None,
         message_schema=None,
         command_schema=None,
     ):
         """Create new class instance.
 
         :param Nlu nlu: NLU component.
-        :param jinja2.Environment jinja_env: Jinja environment.
         :param RpcManager rpc: RPC manager.
         :param type dialog_schema: A schema class for dialog informatin.
         :param type message_schema: A schema class for user message.
         :param type command_schema: A schema class for response commands.
         """
         self.DialogSchema = dialog_schema or DialogSchema
         self.MessageSchema = message_schema or MessageSchema
         self.CommandSchema = command_schema or CommandSchema
         self._nlu = nlu  # the default value is initialized lazily
         self.dialog_flow = dialog_flow or DialogFlow(context={"schema": self.CommandSchema})
         self.rpc = rpc or RpcManager()
         self._journal_logger = logging.getLogger("maxbot.journal")
         self._journal = self.default_journal
+        self.utc_time_provider = get_utc_time_default
+        self._dialog_is_ready = False
         self._dialog_is_ready = False
 
     @property
     def nlu(self):
         """NLU component used to recognize intent and entities from user's utterance."""
         if self._nlu is None:
             # lazy import to speed up load time
@@ -83,16 +84,25 @@
             logger.warning(
                 "The dialog is not ready, messages is skipped until you load the resources."
             )
             return []
         logger.debug("process message %s, %s", message, dialog)
         message = self.MessageSchema().load(message)
         dialog = self.DialogSchema().load(dialog)
-        intents, entities = await self.nlu(message)
-        ctx = TurnContext(dialog, state, message=message, intents=intents, entities=entities)
+        utc_time = self.utc_time_provider()
+        intents, entities = await self.nlu(message, utc_time=utc_time)
+        ctx = TurnContext(
+            dialog,
+            state,
+            utc_time,
+            message=message,
+            intents=intents,
+            entities=entities,
+            command_schema=self.CommandSchema(many=True),
+        )
         await self.dialog_flow.turn(ctx)
         self._journal(ctx)
         return ctx.commands
 
     async def process_rpc(self, request, dialog, state):
         """Process RPC request.
 
@@ -106,28 +116,36 @@
             logger.warning(
                 "The dialog is not ready, rpc requests is skipped until you load the resources."
             )
             return []
         logger.debug("process rpc %s, %s", request, dialog)
         dialog = self.DialogSchema().load(dialog)
         request = self.rpc.parse_request(request)
-        ctx = TurnContext(dialog, state, rpc=RpcContext(RpcRequest(**request)))
+        ctx = TurnContext(
+            dialog,
+            state,
+            self.utc_time_provider(),
+            rpc=RpcContext(RpcRequest(**request)),
+            command_schema=self.CommandSchema(many=True),
+        )
         await self.dialog_flow.turn(ctx)
         self._journal(ctx)
         return ctx.commands
 
     def default_journal(self, ctx):
         """Get the default implementaton of journal.
 
         :param TurnContext ctx: Turn context.
         """
-        for record in ctx.logs:
-            level = getattr(logging, record.level)
-            if self._journal_logger.isEnabledFor(level):
-                self._journal_logger.log(level, record.message)
+        for event in ctx.journal_events:
+            level, message = TurnContext.extract_log_event(event)
+            if isinstance(logging.getLevelName(level), int):
+                level = getattr(logging, level)
+                if self._journal_logger.isEnabledFor(level):
+                    self._journal_logger.log(level, message)
         if ctx.error:
             raise ctx.error
 
     def journal(self, fn):
         """Register the journal callback.
 
         :param callable fn: The journal callback.
```

## maxbot/errors.py

```diff
@@ -255,23 +255,24 @@
             code = mark.buffer.rstrip("\0")
         else:
             code = pathlib.Path(mark.name).read_text(encoding="utf8")
         # do not use splitlines, because terminal line break should result in an extra line
         return code.split("\n")
 
 
-class MarkdownSnippet(Snippet):
-    """A snippet of markdown document with pointer to specific line."""
+class XmlSnippet(Snippet):
+    """A snippet of XML document with pointer to specific line and column."""
 
-    def __init__(self, lines, line):
+    def __init__(self, lines, lineno, column):
         """Create new class instance.
 
         :param list[str] lines: Lines with the source code.
-        :param int line: A line number to point to.
+        :param int lineno: A line number to point to.
+        :param int column: Number of comunt.
         """
-        super().__init__("<Markdown document>", lines, line, 0, False)
+        super().__init__("<Xml document>", lines, lineno, column, exact_column=True)
 
     def format(self):
         """Build a string description and a code snippet with a pointer."""
         location = self.format_location()
         code = textwrap.indent(self.format_code(max_lines=3), "  ")
         return f"{location}:\n{code}"
```

## maxbot/extensions/_manager.py

```diff
@@ -1,20 +1,19 @@
 """Extension Manager."""
 import importlib.metadata
 import pkgutil
 from abc import abstractmethod
 
-from marshmallow import Schema, fields
-
+from ..maxml import Schema, fields
 from ..schemas import ResourceSchema
 
 BUILTIN_EXTENSIONS = {
     "rest": "maxbot.extensions.rest.RestExtension",
     "datetime": "maxbot.extensions.datetime.DatetimeExtension",
-    "format": "maxbot.extensions.format.FormatExtension",
+    "babel": "maxbot.extensions.babel.BabelExtension",
     "rasa": "maxbot.extensions.rasa.RasaExtension",
     "strict_undefined": "maxbot.extensions.strict_undefined.StrictUndefinedExtension",
     "jinja_loader": "maxbot.extensions.jinja_loader.jinja_loader",
 }
 
 
 class _ExtensionProxy:
```

## maxbot/extensions/datetime.py

```diff
@@ -1,35 +1,51 @@
-"""Builtin MaxBot extension: date/time utils and `now` global variable."""
-from datetime import date, datetime, time
+"""Builtin MaxBot extension: date/time convertors."""
+from datetime import date, datetime, time, timezone
 
-import dateutil.parser
-from marshmallow import Schema, fields
-from pytz import timezone
+from dateutil.parser import parse
+from dateutil.tz import gettz
 
 from ..errors import BotError
 
 
+def tz_filter(name):
+    """Retrieve a time zone object from a string representation.
+
+    :param str name: A time zone name.
+    :return tzinfo:
+    """
+    tz = gettz(name)
+    if tz is None:
+        raise BotError(f"Unknown timezone: {name!r}")
+    return tz
+
+
 def datetime_filter(value):
     """Convert input value to `datetime` object.
 
     :param datetime|date|time|int|float|str value: input value.
     :raise BotError: Could not convert input value to `datetime`.
     :return datetime:
     """
+    result = _datetime_filter_impl(value)
+    return result.replace(tzinfo=timezone.utc) if result.tzinfo is None else result
+
+
+def _datetime_filter_impl(value):
     if isinstance(value, datetime):
         return value
     if isinstance(value, date):
         return datetime.combine(value, datetime.min.time())
     if isinstance(value, time):
-        return datetime.combine(datetime.now(), value)
-    if isinstance(value, (int, float)):
-        return datetime.fromtimestamp(value)
+        return datetime.combine(datetime.now(value.tzinfo), value)
     try:
-        return dateutil.parser.parse(value)
-    except (dateutil.parser.ParserError, OverflowError) as error:
+        if isinstance(value, (int, float)):
+            return datetime.fromtimestamp(value, tz=timezone.utc)
+        return parse(value)
+    except (OverflowError, ValueError) as error:
         raise BotError(f"Could not convert {value!r} to datetime: {error}") from error
 
 
 def date_filter(value):
     """Convert input value to `date` object.
 
     :param datetime|date|int|float|str value: input value.
@@ -49,38 +65,26 @@
 
     :param datetime|time|int|float|str value: input value.
     :raise BotError: Could not convert input value to `time`.
     :return time:
     """
     if not isinstance(value, datetime):
         if isinstance(value, time):
-            return value
+            return value.replace(tzinfo=timezone.utc) if value.tzinfo is None else value
         if isinstance(value, date):
             raise BotError(f"Could not convert {value!r} to time")
-    return datetime_filter(value).time()
+    return datetime_filter(value).timetz()
 
 
 class DatetimeExtension:
     """Extension class."""
 
-    class ConfigSchema(Schema):
-        """Extension configuration schema."""
-
-        tz = fields.Str()
-
     def __init__(self, builder, config):
         """Extension entry point.
 
         :param BotBuilder builder: MaxBot builder.
         :param dict config: Extension configuration.
         """
-        tz = config.get("tz")
-        self.timezone = timezone(tz) if tz else None
-        builder.before_turn(self._before_turn)
+        builder.add_template_filter(tz_filter, "tz")
         builder.add_template_filter(datetime_filter, "datetime")
         builder.add_template_filter(date_filter, "date")
         builder.add_template_filter(time_filter, "time")
-
-    def _before_turn(self, ctx):
-        dt = datetime.now(self.timezone)
-        ctx.scenario.now = dt
-        ctx.scenario.today = dt.date()
```

## maxbot/extensions/rasa.py

```diff
@@ -3,18 +3,18 @@
 from dataclasses import dataclass
 from functools import partial
 from typing import Any
 from urllib.parse import urljoin
 
 import httpx
 from dateutil.parser import isoparse
-from marshmallow import Schema, fields
 
 from ..context import EntitiesResult, IntentsResult, RecognizedEntity, RecognizedIntent
 from ..errors import BotError
+from ..maxml import Schema, fields
 from ..schemas import ResourceSchema
 
 logger = logging.getLogger(__name__)
 
 _TIME_GRANULARITY = frozenset(["hour", "minute", "second"])
 
 
@@ -132,15 +132,15 @@
 
 class _Nlu:
     def __init__(self, url, threshold):
         self.session = _Session(url)
         self.threshold = threshold
         logger.debug("threshold = %s", self.threshold)
 
-    async def __call__(self, message):
+    async def __call__(self, message, utc_time=None):
         text = message.get("text")
         if not text:
             return IntentsResult(), EntitiesResult()
 
         r = await self.session.post("model/parse", json={"text": text})
         parsed = _Parsed(r.json(), self.threshold)
         return IntentsResult.resolve(parsed.intents), EntitiesResult.resolve(parsed.entities)
```

## maxbot/extensions/rest.py

```diff
@@ -1,17 +1,17 @@
 """Builtin MaxBot extension: REST calls from jinja scenarios."""
 import logging
 from urllib.parse import urljoin
 
 import httpx
 from jinja2 import nodes
 from jinja2.ext import Extension
-from marshmallow import Schema, fields, validate
 
 from ..errors import BotError
+from ..maxml import Schema, fields, validate
 
 logger = logging.getLogger(__name__)
 
 
 class _ServiceAuth(Schema):
     user = fields.Str(required=True)
     password = fields.Str(required=True)
```

## maxbot/flows/__init__.py

```diff
@@ -1 +1 @@
-"""Сonversation Flow Models."""
+"""Conversation Flow Models."""
```

### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

## maxbot/flows/dialog_tree.py

```diff
@@ -1,14 +1,13 @@
 """Dialog Tree Conversation Flow."""
 import logging
 from functools import cached_property
 
-from marshmallow import Schema, fields, validate
-
 from ..errors import BotError, YamlSnippet
+from ..maxml import Schema, fields, validate
 from ..scenarios import ExpressionField, ScenarioField
 from ..schemas import MaxmlSchema, ResourceSchema
 from ._base import DigressionResult, FlowComponent, FlowResult
 from .slot_filling import HandlerSchema, SlotFilling, SlotSchema
 
 logger = logging.getLogger(__name__)
 
@@ -117,27 +116,19 @@
         else:
             result = self._load_one(data, **kwargs)
         return result
 
     def _load_one(self, data, **kwargs):
         if not isinstance(data, dict):
             raise BotError("Invalid input type", YamlSnippet.from_data(data))
-        for type_schema in (
-            NodeSchema,
-            SubtreeRefSchema,
-        ):
-            for field_name in [
-                n
-                for n, t in type_schema._declared_fields.items()  # pylint: disable=W0212
-                if t.required
-            ]:
+        for schema in (NodeSchema(), SubtreeRefSchema()):
+            for field_name in [n for n, t in schema.declared_fields.items() if t.required]:
                 if field_name not in data:
                     break
             else:
-                schema = type_schema()
                 schema.context.update(getattr(self, "context", {}))
                 return schema.load(data, many=False, **kwargs)
         raise BotError("Unknown node type", YamlSnippet.from_data(data))
 
 
 class SubtreeSchema(ResourceSchema):
     """Definition of the dialog sub-tree."""
@@ -439,15 +430,15 @@
         """Go through the node's slot filling flow (if any) and/or execute its response scenario.
 
         :param Node node: Triggered node.
         :param DigressionResult digression_result: The result with which we return from digression.
         :raise ValueError: Unknown slot filling result.
         :return FlowResult: The result of the turn of the flow.
         """
-        logger.debug("trigger node %s", node)
+        self.journal_event("node_triggered", node)
         if node.slot_filling:
             result = await node.slot_filling(self.ctx, digression_result)
             if result == FlowResult.DONE:
                 self.stack.remove(node)
                 return await self.response(node, digression_result)
             if result == FlowResult.LISTEN:
                 self.stack.push(node, "slot_filling")
@@ -460,27 +451,52 @@
     async def response(self, node, digression_result):
         """Execute the response scenario of the node.
 
         :param Node node: Triggered node.
         :param DigressionResult digression_result: The result with which we return from digression.
         :return FlowResult: The result of the turn of the flow.
         """
+        payload = self.journal_event("response", node)
         for command in await node.response(self.ctx, returning=digression_result is not None):
             if "jump_to" in command:
+                payload.update(control_command="jump_to")
                 return await self.command_jump_to(node, command["jump_to"])
             if "listen" in command:
+                payload.update(control_command="listen")
                 return await self.command_listen(node)
             if "end" in command:
+                payload.update(control_command="end")
                 return self.command_end()
             if "followup" in command:
+                payload.update(control_command="followup")
                 return await self.command_followup(node)
             self.ctx.commands.append(command)
         if node.followup:
+            payload.update(followup={})
             return await self.command_listen(node)
-        return await self.return_after_digression() or self.command_end()
+        result = await self.return_after_digression()
+        if result:
+            payload.update(return_after_digression={})
+        else:
+            payload.update(end={})
+            result = self.command_end()
+        return result
+
+    def journal_event(self, event_type, node, payload=None):
+        """Add journal event.
+
+        :param str event_type: Type of the event.
+        :param Node node: Traget node.
+        :param dict payload: Additional payload (optinal).
+        """
+        payload = payload or {}
+        payload["node"] = {"condition": node.condition.source}
+        if node.label:
+            payload["node"].update(label=node.label)
+        return self.ctx.journal_event(event_type, payload)
 
 
 class Tree:
     """A tree of nodes."""
 
     def __init__(self, definition, subtrees):
         """Create new class instance.
```

## maxbot/flows/slot_filling.py

```diff
@@ -1,15 +1,14 @@
 """Slot Filling Conversation Flow."""
 import logging
 from dataclasses import dataclass, field
 from typing import Optional
 
-from marshmallow import Schema, fields, post_load
-
-from ..context import EntitiesProxy, RecognizedEntity
+from ..context import EntitiesProxy, RecognizedEntity, RecognizedIntent
+from ..maxml import Schema, fields, post_load
 from ..scenarios import ExpressionField, ScenarioField
 from ..schemas import MaxmlSchema, ResourceSchema
 from ._base import DigressionResult, FlowResult
 
 logger = logging.getLogger(__name__)
 
 
@@ -226,14 +225,16 @@
         )
         if not value:
             return
         if slot.value:
             value = slot.value(self.ctx)
         if isinstance(value, (EntitiesProxy, RecognizedEntity)):
             value = value.value
+        if isinstance(value, RecognizedIntent):
+            value = True
         logger.debug("elicit slot %r value %r", slot.name, value)
         previous_value = self.ctx.state.slots.get(slot.name)
         self.ctx.state.slots[slot.name] = value
         self.found_slots.append((slot, {"previous_value": previous_value, "current_value": value}))
 
     def clear_slot(self, slot):
         """Clear slot value.
@@ -251,86 +252,104 @@
 
     async def found(self, slot, params):
         """Execute the `found` scenario and its control commands.
 
         :param Slot slot: A slot for which execute the scenario.
         :param dict params: Extra params to pass to the scenario.
         """
+        payload = self.ctx.journal_event("found", {"slot": slot.name})
         for command in await slot.found(self.ctx, **params):
             if "response" in command:
                 self.want_response = True
+                payload.update(control_command="response")
                 break
             if "prompt_again" in command:
+                payload.update(control_command="prompt_again")
                 self.clear_slot(slot)
                 break
             if "listen_again" in command:
+                payload.update(control_command="listen_again")
                 self.clear_slot(slot)
                 self.listen_again(slot)
                 break
             if "move_on" in command:
+                payload.update(control_command="move_on")
                 break
             self.ctx.commands.append(command)
 
     async def not_found(self, slot):
         """Execute the `not_found` scenario and its control commands.
 
         :param Slot slot: A slot for which execute the scenario.
         """
+        payload = self.ctx.journal_event("not_found", {"slot": slot.name})
         for command in await slot.not_found(self.ctx):
             if "response" in command:
                 self.want_response = True
+                payload.update(control_command="response")
                 break
             if "prompt_again" in command:
+                payload.update(control_command="prompt_again")
                 break
             if "listen_again" in command:
                 self.listen_again(slot)
+                payload.update(control_command="listen_again")
                 break
             self.ctx.commands.append(command)
         else:
             self.listen_again(slot)
 
     async def prompt(self, slot):
         """Execute the `prompt` scenario and its control commands.
 
         :param Slot slot: A slot for which execute the scenario.
         """
+        payload = self.ctx.journal_event("prompt", {"slot": slot.name})
         for command in await slot.prompt(self.ctx):
             if "response" in command:
                 self.want_response = True
+                payload.update(control_command="response")
                 break
             if "listen_again" in command:
                 self.listen_again(slot)
+                payload.update(control_command="listen_again")
                 break
             self.ctx.commands.append(command)
         else:
             self.listen_again(slot)
 
     async def handler(self, handler):
         """Execute the `handler.response` scenario and its control commands.
 
         :param Handler handler: A handler for which execute the scenario.
         """
+        payload = self.ctx.journal_event("slot_handler", {"condition": handler.condition.source})
         for command in await handler.response(self.ctx):
             if "response" in command:
                 self.want_response = True
+                payload.update(control_command="response")
                 break
             if "move_on" in command:
+                payload.update(control_command="move_on")
                 break
             self.ctx.commands.append(command)
 
     async def __call__(self):
         """Make a turn in a slot filling flow.
 
         :return FlowResult: The result of the turn of the flow.
         """
         # elicit
         for slot in self.enabled_slots:
             self.elicit(slot)
         # found
         for slot, params in self.found_slots:
+            self.ctx.journal_event(
+                "slot_filling", {"slot": slot.name, "value": params["current_value"]}
+            )
             if slot.found:
                 await self.found(slot, params)
         if self.state.get("slot_in_focus") and not self.found_slots:
             # perform the following operations in order until the first one succeeds
             # * slot handlers
             # * digression
             # * not found response
```

## maxbot/jinja_env.py

```diff
@@ -1,72 +1,20 @@
 """Jinja environment for NLG templates."""
 import logging
 
 import jinja2
 from jinja2 import nodes
-from jinja2.compiler import CodeGenerator
 from jinja2.exceptions import TemplateRuntimeError, UndefinedError
 from jinja2.ext import Extension
-from jinja2.runtime import Macro
 from jinja2.utils import Namespace, missing
-
-from .markdown import Markup, escape
+from markupsafe import Markup
 
 logger = logging.getLogger(__name__)
 
 
-class _AutoEscapeCodeGenerator(CodeGenerator):
-    def visit_Template(self, *args, **kwargs):  # noqa: N802
-        super().visit_Template(*args, **kwargs)
-        self.writeline("")
-        self.writeline("escape = environment.escape_fn")
-        self.writeline("Markup = environment.markup_class")
-        self.writeline("Macro = environment.macro_class")
-
-
-class _AutoEscapeMacro(Macro):
-    async def _async_invoke(self, arguments, autoescape):
-        return Markup(await self._func(*arguments))
-
-    def _invoke(self, arguments, autoescape):
-        assert autoescape
-        assert self._environment.is_async
-        return self._async_invoke(arguments, autoescape)
-
-
-class AutoEscapeEnvironment(jinja2.Environment):
-    """Jinja environment with autoescaping HTML and Markdown sequences."""
-
-    code_generator_class = _AutoEscapeCodeGenerator
-
-    def __init__(self, **kwargs):
-        """Create new class instance."""
-        super().__init__(**{**kwargs, **{"autoescape": True}})
-        for name in self.filters:
-            self._filter_return_markup(name)
-        self.filters.update(e=escape, escape=escape)
-        self.escape_fn = escape
-        self.markup_class = Markup
-        self.macro_class = _AutoEscapeMacro
-
-    def _filter_return_markup(self, name):
-        original_fn = self.filters[name]
-
-        def wrapper(*arga, **argw):
-            rv = original_fn(*arga, **argw)
-            if hasattr(rv, "__html__") and not hasattr(rv, "__markdown__"):
-                rv = Markup(rv.__html__())
-            return rv
-
-        self.filters[name] = wrapper
-        if hasattr(original_fn, "jinja_pass_arg"):
-            # @pass_* decorators
-            self.filters[name].jinja_pass_arg = original_fn.jinja_pass_arg
-
-
 def create_jinja_env(options=None):
     """Create Jinja environment with the passes options.
 
     The `autoescape` option defaults to `True`.
 
     The function and filter `mandatory` is added to the environment.
 
@@ -88,16 +36,16 @@
             StateDeleteExtension,
             LoggingExtension,
         ]
     )
     options.setdefault("undefined", EnclosedUndefined)
     options.setdefault("trim_blocks", True)
     options.setdefault("lstrip_blocks", True)
-    env_class = AutoEscapeEnvironment if options.get("autoescape", True) else jinja2.Environment
-    env = env_class(enable_async=True, **options)  # nosec: B701
+    options.setdefault("autoescape", True)
+    env = jinja2.Environment(enable_async=True, **options)  # nosec: B701
     env.filters.update(mandatory=mandatory)
     env.filters.update(nl2br=nl2br)
     env.globals.update(mandatory=mandatory)
     return env
 
 
 class StateNamespace(Namespace):
```

## maxbot/nlu.py

```diff
@@ -2,17 +2,16 @@
 import logging
 import re
 import warnings
 from functools import cached_property
 from itertools import chain
 from operator import attrgetter
 
-from marshmallow import fields, validate
-
 from .context import EntitiesResult, IntentsResult, RecognizedEntity, RecognizedIntent
+from .maxml import fields, validate
 from .resources import InlineResources
 from .schemas import ResourceSchema
 
 logger = logging.getLogger(__name__)
 
 
 class IntentSchema(ResourceSchema):
@@ -151,14 +150,15 @@
 
         :param list intents: A list of intents matched the :class:`~IntentSchema`.
         """
         self.examples, self.labels = [], []
         for intent in intents:
             self.examples.extend([self.spacy_nlp.make_doc(e) for e in intent["examples"]])
             self.labels.extend([intent["name"]] * len(intent["examples"]))
+        logger.debug("%s similarity based intents loaded", len(intents))
 
     def _preprocess(self, doc):
         return [t.lower_ for t in doc]
 
     def __call__(self, doc):
         """Recognize intents.
 
@@ -209,19 +209,21 @@
         for entity in entities:
             for value in entity["values"]:
                 key = f"{entity['name']}-{value['name']}"
                 match_id = self.spacy_nlp.vocab.strings.add(key)
                 self.ids[match_id] = (entity["name"], value["name"])
                 patterns = list(self.spacy_nlp.pipe(value["phrases"]))
                 self._matcher.add(key, patterns)
+        logger.debug("%s phrase entities loaded", len([e for e in entities if e["values"]]))
 
-    def __call__(self, doc):
+    def __call__(self, doc, utc_time=None):
         """Recognize entities in the given `doc`.
 
         :param spacy.tokens.Doc doc: Spacy doc containing the user input.
+        :param datetime utc_time: Date and time of dialog turn.
         :return Iterable[RecognizedEntity]: Recognized pharse entities.
         """
         if self._matcher:
             for match_id, start, end in self._matcher(doc):
                 name, value = self.ids[match_id]
                 span = doc[start:end]
                 # TODO deal with entities overlap
@@ -247,19 +249,21 @@
                     self.regexps.append(
                         {
                             "label": entity["name"],
                             "id": value["name"],
                             "pattern": re.compile(regexp),
                         }
                     )
+        logger.debug("%s regexp entities loaded", len(self.regexps))
 
-    def __call__(self, doc):
+    def __call__(self, doc, utc_time=None):
         """Recognize entities in the given `doc`.
 
         :param spacy.tokens.Doc doc: Spacy doc containing the user input.
+        :param datetime utc_time: Date and time of dialog turn.
         :return Iterable[RecognizedEntity]: Recognized regexps entities.
         """
         for p in self.regexps:
             for match in re.finditer(p["pattern"], doc.text):
                 start, end = match.span()
                 if start == end:
                     continue
@@ -298,18 +302,19 @@
 
         matcher = Matcher(self.spacy_nlp.vocab)
         matcher.add("number", [[{"LIKE_NUM": True, "OP": "+"}]], greedy="LONGEST")
         matcher.add("email", [[{"LIKE_EMAIL": True}]])
         matcher.add("url", [[{"LIKE_URL": True}]])
         return matcher
 
-    def __call__(self, doc):
+    def __call__(self, doc, utc_time=None):
         """Recognize entities in the given `doc`.
 
         :param spacy.tokens.Doc doc: Spacy doc containing the user input.
+        :param datetime utc_time: Date and time of dialog turn.
         :return Iterable[RecognizedEntity]: Recognized entities.
         """
         matches = self.matcher(doc, as_spans=True)
         # does spacy reverse the order while matching greedly?
         matches = sorted(matches, key=attrgetter("start"))
         for span in matches:
             if span.label_ == "number":
@@ -345,36 +350,39 @@
     builtin_definitions = [
         {"name": "date"},
         {"name": "time"},
     ]
 
     ddp = None
 
-    def __call__(self, doc):
+    def __call__(self, doc, utc_time=None):
         """Recognize entities in the given `doc`.
 
         :param spacy.tokens.Doc doc: Spacy doc containing the user input.
+        :param datetime utc_time: Date and time of dialog turn.
         :return Iterable[RecognizedEntity]: Recognized entities.
         """
         from dateparser import parse
         from dateparser.date import DateDataParser
         from dateparser.search import search_dates
 
         if self.ddp is None:
             # language autodetection slows down the parser, provide language explicitly
             self.ddp = DateDataParser(languages=["en"], settings={"RETURN_TIME_AS_PERIOD": True})
 
         # suppress known PytzUsageWarning from dateparser
         with warnings.catch_warnings():
             warnings.simplefilter("ignore")
 
+            search_dates_settings = {"PREFER_DATES_FROM": "future"}
+            if utc_time:
+                search_dates_settings["RELATIVE_BASE"] = utc_time
+
             shift = 0
-            results = search_dates(
-                doc.text, languages=["en"], settings={"PREFER_DATES_FROM": "future"}
-            )
+            results = search_dates(doc.text, languages=["en"], settings=search_dates_settings)
             if results is None:
                 return
             for literal, dt in results:
                 start_char = doc.text.index(literal, shift)
                 end_char = start_char + len(literal)
                 shift = end_char
                 # a bit tricky way to split date and time parts
@@ -401,39 +409,41 @@
     """
 
     def __init__(self, spacy_nlp):
         """Create new class instance.
 
         :param spacy.Language nlp: Spacy language model.
         """
+        self._spacy_nlp = spacy_nlp
         self.dateparser_entities = DateParserEntities()
         self.spacy_matcher_entities = SpacyMatcherEntities(spacy_nlp)
 
     @property
     def builtin_definitions(self):
         """Get the list of builtin entity definitions.
 
         :return list:
         """
         rv = []
         rv.extend(self.spacy_matcher_entities.builtin_definitions)
         rv.extend(self.dateparser_entities.builtin_definitions)
         return rv
 
-    def __call__(self, doc):
+    def __call__(self, doc, utc_time=None):
         """Recognize entities in the given `doc`.
 
         :param spacy.tokens.Doc doc: Spacy doc containing the user input.
+        :param datetime utc_time: Date and time of dialog turn.
         :return Iterable[RecognizedEntity]: Recognized entities.
         """
         seen_chars = set()
-        for entity in self.dateparser_entities(doc):
+        for entity in self.dateparser_entities(doc, utc_time=utc_time):
             seen_chars.update(range(entity.start_char, entity.end_char))
             yield entity
-        for entity in self.spacy_matcher_entities(doc):
+        for entity in self.spacy_matcher_entities(doc, utc_time=utc_time):
             if entity.name == "number" and (
                 entity.start_char in seen_chars or entity.end_char - 1 in seen_chars
             ):
                 continue
             yield entity
 
 
@@ -442,15 +452,15 @@
 
     # A threshold passed to :meth:`~IntentsResult.resolve`.
     threshold = 0.5
 
     def __init__(self, spacy_nlp=None):
         """Create new class instance.
 
-        :param spacy.Language nlp: Spacy language model.
+        :param spacy.Language spacy_nlp: Spacy language model.
         """
         self._spacy_nlp = spacy_nlp
         self._intent_recognizer = None
         self._entity_recognizers = None
         self._intent_definitinos = None
         self._entity_definitions = None
 
@@ -539,34 +549,36 @@
     def load_inline_resources(self, source):
         """Load NLU resources from YAML-string.
 
         :param str source: A YAML-string with resources.
         """
         self.load_resources(InlineResources(source))
 
-    async def __call__(self, message):
+    async def __call__(self, message, utc_time=None):
         """Recognize intents and entities for the given message.
 
         Uses `message['text']` as the user utterance. If the key is missing, it skips recognition.
 
         :param dict message: A user message that matched :class:`~MessageSchema`.
+        :param datetime utc_time: Date and time of dialog turn.
         :return Tuple[IntentsResult, EntitiesResult]: Recognized intents and entities.
         """
         intents, entities = IntentsResult(), EntitiesResult()
         if "text" in message:
             doc = self.spacy_nlp(  # the spacy is callable, so pylint: disable=not-callable
                 message["text"]
             )
             intents = IntentsResult.resolve(
                 self.intent_recognizer(doc), self.threshold, self.resolve_intent_definitions()
             )
             entities = EntitiesResult.resolve(
                 list(
                     chain.from_iterable(
-                        recognizer(doc=doc) for recognizer in self.entity_recognizers
+                        recognizer(doc=doc, utc_time=utc_time)
+                        for recognizer in self.entity_recognizers
                     )
                 ),
                 self.resolve_entity_definitions(),
             )
         return intents, entities
 
     def resolve_intent_definitions(self):
```

## maxbot/resources.py

```diff
@@ -1,16 +1,15 @@
 """MaxBot resources."""
 import importlib
 import importlib.resources
 import logging
 from pathlib import Path
 
-from marshmallow import fields
-
 from .errors import BotError
+from .maxml import fields
 from .schemas import ResourceSchema
 
 logger = logging.getLogger(__name__)
 
 
 class BotSchema(ResourceSchema):
     """A schema for resources used to create a bot.
```

## maxbot/rpc.py

```diff
@@ -1,11 +1,11 @@
 """MaxBot RPC."""
-from marshmallow import Schema, ValidationError, fields
 
 from .errors import BotError, YamlSnippet
+from .maxml import Schema, ValidationError, fields
 from .resources import InlineResources
 from .schemas import ResourceSchema
 
 
 class RpcManager:
     """Handle RPC calls."""
```

## maxbot/scenarios.py

```diff
@@ -1,15 +1,15 @@
 """NLG scenarios and templates."""
 from dataclasses import dataclass, field
 
 import jinja2
-from marshmallow import ValidationError, fields
 
 from .errors import BotError, YamlSnippet
 from .jinja_env import create_jinja_env
+from .maxml import ValidationError, fields
 from .schemas import CommandSchema
 
 # Default jinja environment for :class:`~Expression` and :class:`~Scenario'.
 DEFAULT_JINJA_ENV = create_jinja_env()
 
 # Scenario errors we turn into :class:`~BotError`.
 JINJA_ERRORS = (
```

## maxbot/schemas.py

```diff
@@ -2,18 +2,18 @@
 import os
 import re
 import textwrap
 from collections.abc import Hashable
 
 import marshmallow.exceptions
 import yaml
-from marshmallow import Schema, fields, post_load, pre_load
 
-from .errors import BotError, MarkdownSnippet, YamlSnippet, YamlSymbols
-from .markdown import MarkdownRender
+from .errors import BotError, XmlSnippet, YamlSnippet, YamlSymbols
+from .maxml import Schema, fields, markup, post_load, pre_load
+from .maxml.xml_parser import XmlParser
 
 
 class LoaderFactory(yaml.BaseLoader):  # pylint: disable=R0901
     """Make yaml loader customizable.
 
     YAML loaders are customized at class level. We perform dynamic subclassing and use class-level
     customization methods to create different loaders with various capabilities.
@@ -30,14 +30,28 @@
         try:
             # nosec note: actualy we derive a safe loader
             return yaml.load(data, Loader=cls)  # nosec B506
         except yaml.MarkedYAMLError as exc:
             raise YamlParsingError(exc) from exc
 
     @classmethod
+    def register_unknown_tag_error(cls):
+        """Raise `yaml.constructor.ConstructorError` on unknown tag."""
+
+        def _raise_constructor_error(loader, node):
+            raise yaml.constructor.ConstructorError(
+                None,
+                None,
+                f"could not determine a constructor for the tag {node.tag!r}",
+                node.start_mark,
+            )
+
+        cls.add_constructor(None, _raise_constructor_error)
+
+    @classmethod
     def register_variable_substitution(cls):
         """Add capability to substitute special placeholders with environment variables.
 
         Variables are replaced in string scalars beginning with the `!ENV` tag. Default values
         provided after the colon `:`. Example:
 
             username: !ENV ${DB_USER:paws}
@@ -172,14 +186,15 @@
         * :meth:`~LoaderFactory.set_post_construct_debug_watcher`.
     """
 
     def __init__(self):
         """Create new class instance."""
         self.Loader = LoaderFactory.new_loader()
         self.Loader.register_variable_substitution()
+        self.Loader.register_unknown_tag_error()
         self.Loader.set_pre_construct_strict_map_checker()
         self.Loader.set_post_construct_debug_watcher()
 
     def loads(self, data):
         """Deserialize a YAML data structure to an object defined by this Schema's fields.
 
         :param str data: A YAML string of the data to deserialize.
@@ -376,80 +391,75 @@
         :param dict kwargs: Ignored arguments.
         """
         if isinstance(data, str):
             data = {"text": data}
         return data
 
 
-class ImageCommand(Schema):
-    """An image command payload."""
-
-    # HTTP URL to get a file from the Internet.
-    url = fields.Url(required=True)
-
-    # Caption of the image to be sent.
-    caption = fields.Str(metadata={"maxml": "element"})
-
-
 class MaxmlSchema(MarshmallowSchema):
     """Base schema for MAXML commands."""
 
     class Meta:
         """Options object for a Schema."""
 
-        render_module = MarkdownRender()
+        render_module = XmlParser()
 
     class _Error(Exception):
         def __init__(self, message, data, key):
             self.message = message
             self.data = data
             self.key = key
 
     def _create_error(self, message, data, key=None):
         return self._Error(message, data, key)
 
     def loads(self, json_data, **kwargs):
-        """Load commands from Markdown document."""
+        """Load commands from headless XML document."""
         symbols = {}
-        try:
-            unvalidated = self.opts.render_module.loads(
-                json_data, maxml_command_schema=self, maxml_symbols=symbols
-            )
-        except self.opts.render_module.EXCEPTION_CLASS as exc:
-            raise BotError(
-                exc.message, MarkdownSnippet(json_data.splitlines(), exc.lineno)
-            ) from exc
+        unvalidated = self.opts.render_module.loads(
+            json_data, maxml_command_schema=self, maxml_symbols=symbols
+        )
 
         try:
             return self.load(unvalidated, **kwargs)
         except self._Error as exc:
-            linenum = None
+            ptr = None
             if isinstance(exc.data, dict) and exc.key is not None:
-                linenum = symbols.get(id(exc.data.get(exc.key)))
-            if linenum is None:
-                linenum = symbols.get(id(exc.data))
-            snippet = None if linenum is None else MarkdownSnippet(json_data.splitlines(), linenum)
+                ptr = symbols.get(id(exc.data.get(exc.key)))
+            if ptr is None:
+                ptr = symbols.get(id(exc.data))
+            snippet = XmlSnippet(json_data.splitlines(), ptr.lineno, ptr.column) if ptr else None
             # chain with original marshmallow.exceptions.ValidationError
             raise BotError(exc.message, snippet) from exc.__cause__
 
 
+class ImageCommand(Schema):
+    """An image command payload."""
+
+    # HTTP URL to get a file from the Internet.
+    url = fields.Url(required=True)
+
+    # Caption of the image to be sent.
+    caption = markup.Field()
+
+
 class CommandSchema(MaxmlSchema):
     """Command to send to user.
 
     This schema is implemented as an envelope for a different command types. The schema field
     represents a command of particular type. The field name is the name of the command type. The
     field type is the payload for the command of that type. Typically, only one field is
     populated for the command and commands are loaded in whole lists. For example, a list of
     two commands:
 
         CommandSchema(many=True).loads('''
             Hello world!
-            ![](http://example.com/hello.png)
+            <image url="http://example.com/hello.png" />
         ''')
-        # [{'text': 'Hello world!'}, {'image': {'url': 'http://example.com/hello.png'}}]
+        # [{'text': <maxml.markup.Value'Hello world!'>}, {'image': {'url': 'http://example.com/hello.png'}}]
 
     The schema supports most widely used command types in a platform-independent way. You can
     customize the schema by adding new types and overriding existing types. For example, given
     the payload for new command type 'location':
 
         class LocationCommand(Schema):
             longitude = fields.Float()
@@ -474,11 +484,11 @@
             Here is my location.
             <location latitude="40.7580" longitude="-73.9855" />
         ''')
         # [{'text': 'Here is my location.'}, {'location': {'latitude': 40.7580, 'longitude': 40.7580}}]
     """
 
     # Text message.
-    text = fields.Str()
+    text = markup.Field()
 
     # Image message.
     image = fields.Nested(ImageCommand)
```

## Comparing `maxbot/xml.py` & `maxbot/maxml/xml_parser.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,216 +1,275 @@
 """Parsing XML documents containing commands."""
 import logging
+from dataclasses import dataclass
 from xml.sax.handler import ContentHandler, ErrorHandler  # nosec
 
 from defusedxml.sax import parseString
-from marshmallow import fields
+
+from ..errors import BotError, XmlSnippet
+from . import fields, markup
 
 logger = logging.getLogger(__name__)
 
 
-class XmlError(Exception):
-    """XML parsing error."""
+_ROOT_ELEM_NAME = "root"
+KNOWN_ROOT_ELEMENTS = frozenset(
+    list(markup.PlainTextRenderer.KNOWN_START_TAGS.keys())
+    + list(markup.PlainTextRenderer.KNOWN_END_TAGS.keys())
+)
+
+
+@dataclass(frozen=True)
+class Pointer:
+    """Pointer to specific line and column in XML document."""
 
-    def __init__(self, message, lineno):
-        """Create new class instance.
+    # Line number (zero-based)
+    lineno: int
 
-        :param str message: Error message.
-        :param int lineno: Zero-based line number.
-        """
-        super().__init__()
-        self.message = message
-        self.lineno = lineno
+    # Number of column (zero-based)
+    column: int
 
 
 class _ContentHandler(ContentHandler):
     def __init__(self, schema, register_symbol):
         super().__init__()
-        self.__schema = schema
-        self.__register_symbol = register_symbol
+        self.schema = schema
+        self.register_symbol = register_symbol
         self.maxbot_commands = []
-        self.__nested = []
-
-    def startElement(self, name, attrs):  # noqa: N802 (function name should be lowercase)
-        if not self.__nested:
-            if name != "p":
-                raise _InternalError(f"Unexpected root element: {name!r}")
-            self.__nested.append(
-                _ParagraphElement(name, self.register_symbol_factory, attrs, self.__schema)
-            )
+        self.nested = None
+        self.startElement = self._create_hanler(self._on_start_element)
+        self.endElement = self._create_hanler(self._on_end_element)
+        self.characters = self._create_hanler(self._on_characters)
+
+    def _on_start_element(self, name, attrs):
+        if not self.nested:
+            assert self.nested is None
+            assert name == _ROOT_ELEM_NAME
+            self.nested = [_RootElement(name, self.register_symbol_factory, attrs, self.schema)]
         else:
-            nested = self.__nested[-1].on_starttag(name, attrs)
+            nested = self.nested[-1].on_starttag(name, attrs)
             if nested:
-                self.__nested.append(nested)
+                self.nested.append(nested)
 
-    def endElement(self, name):  # noqa: N802 (function name should be lowercase)
-        value = self.__nested[-1].on_endtag(name)
+    def _on_end_element(self, name):
+        value = self.nested[-1].on_endtag(name)
         if value is not None:
-            processed = self.__nested.pop()
-            if self.__nested:
-                self.__nested[-1].on_nested_processed(processed.tag, value)
+            processed = self.nested.pop()
+            if self.nested:
+                self.nested[-1].on_nested_processed(processed.tag, value)
             else:
                 assert isinstance(value, list)
                 self.maxbot_commands += value
 
-    def characters(self, content):
-        self.__nested[-1].on_data(content)
+    def _on_characters(self, content):
+        self.nested[-1].on_data(content)
+
+    def _create_hanler(self, handler):
+        def _impl(*args, **kwargs):
+            try:
+                return handler(*args, **kwargs)
+            except _Error as exc:
+                if exc.ptr is None:
+                    # skip exception without pointer
+                    raise _Error(exc.message, self._get_ptr()) from exc.__cause__
+                raise
 
-    def get_lineno(self):
-        lineno = (1 if self._locator is None else self._locator.getLineNumber()) - 1
+        return _impl
+
+    def _get_ptr(self):
+        if self._locator is None:
+            return None
+        lineno = self._locator.getLineNumber() - 1
         assert lineno >= 0
-        return lineno
+        return Pointer(lineno, self._locator.getColumnNumber())
 
     def register_symbol_factory(self):
-        register_symbol_fn, lineno = self.__register_symbol, self.get_lineno()
+        captured_ptr = self._get_ptr()
 
         def _register_symbol(value):
-            return register_symbol_fn(value, lineno)
+            if captured_ptr:
+                self.register_symbol(value, captured_ptr)
 
         return _register_symbol
 
 
 class _ErrorHandler(ErrorHandler):
     def error(self, exception):
         return self.fatalError(exception)
 
     def fatalError(self, exception):  # noqa: N802 (function name should be lowercase)
-        lineno = getattr(exception, "getLineNumber", lambda: 1)() - 1
-        assert lineno >= 0
-        raise XmlError(f"{exception.__class__.__name__}: {exception.getMessage()}", lineno)
+        get_lineno = getattr(exception, "getLineNumber", None)
+        get_column = getattr(exception, "getColumnNumber", None)
+        ptr = Pointer(get_lineno() - 1, get_column()) if get_lineno and get_column else None
+        raise _Error(f"{exception.__class__.__name__}: {exception.getMessage()}", ptr)
 
     def warning(self, exception):
         logger.warning("XML warning: %s", exception)
 
 
 class XmlParser:
     """Parse MaxBot commands from XML document."""
 
     CONTENT_HANDLER_CLASS = _ContentHandler
     ERROR_HANDLER_CLASS = _ErrorHandler
 
     PARSE_STRING_OPTIONS = {"forbid_dtd": True}
 
-    def parse_paragraph(self, content, schema, register_symbol):
-        """Parse MaxBot commands from XML document.
+    def loads(self, document, *, maxml_command_schema=None, maxml_symbols=None, **kwargs):
+        """Load MaxBot command list from headless XML document.
 
-        :param str content: XML document.
-        :param type schema: A schema of commands.
-        :param callable register_symbol: Register symbol as code snippet.
-        :raise XmlError: XML parsing error.
+        :param str document: Headless XML document.
+        :param type maxml_command_schema: A schema of commands.
+        :param dict maxml_symbols: Map id of values to `Pointer`s
+        :param dict kwargs: Ignored.
         """
-        encoded = content.encode("utf-8")
-        content_handler = self.CONTENT_HANDLER_CLASS(schema, register_symbol)
+        for command_name, command_schema in maxml_command_schema.declared_fields.items():
+            if command_schema.metadata.get("maxml", "element") != "element":
+                raise BotError(f"Command {command_name!r} is not described as an element")
+
+        # +1 lineno
+        encoded = f"<{_ROOT_ELEM_NAME}>\n{document}</{_ROOT_ELEM_NAME}>".encode("utf-8")
+
+        def _register_symbol(value, ptr):
+            assert ptr.lineno >= 1
+            if maxml_symbols is not None:
+                maxml_symbols[id(value)] = Pointer(ptr.lineno - 1, ptr.column)
+
+        content_handler = self.CONTENT_HANDLER_CLASS(maxml_command_schema, _register_symbol)
         try:
             parseString(
                 encoded,
                 content_handler,
                 errorHandler=self.ERROR_HANDLER_CLASS(),
                 **self.PARSE_STRING_OPTIONS,
             )
-        except _InternalError as exc:
-            raise XmlError(exc.message, content_handler.get_lineno()) from exc
+        except _Error as exc:
+            snippet = None
+            if exc.ptr:
+                # correct lineno
+                assert exc.ptr.lineno >= 1
+                snippet = XmlSnippet(document.splitlines(), exc.ptr.lineno - 1, exc.ptr.column)
+            # skip _Error
+            raise BotError(exc.message, snippet) from exc.__cause__
+
         return content_handler.maxbot_commands
 
 
-class _InternalError(Exception):
-    def __init__(self, message):
+class _Error(Exception):
+    def __init__(self, message, ptr=None):
         self.message = message
-
-
-class _UnexpectedScalarChild(_InternalError):
-    pass
+        self.ptr = ptr
 
 
 class _ElementBase:
     def __init__(self, tag, register_symbol_factory):
         self.tag = tag
         self.register_symbol_factory = register_symbol_factory
         self.register_symbol = self.register_symbol_factory()
 
     def attrs_to_dict(self, attrs, schema):
         value = {}
         for field_name, field_value in attrs.items():
-            field_schema = _get_object_field_schema(schema, field_name, entity="Field")
+            field_schema = _get_object_field_schema(schema, field_name, "Attribute")
             if field_schema.metadata.get("maxml", "attribute") != "attribute":
-                raise _InternalError(f"Field {field_name!r} is not described as an attribute")
+                _raise_not_described("Attribute", field_name)
             self.register_symbol_factory()(field_value)
             value[field_name] = field_value
         return value
 
     def check_no_attr(self, attrs, tag=None):
         if attrs:
-            element_name = self.tag if tag is None else tag
-            raise _InternalError(
-                f"Element {element_name!r} has undescribed attributes {dict(attrs)}"
-            )
+            _raise_not_described("Attribute", attrs.keys()[0])
 
 
 class _ScalarElement(_ElementBase):
     def __init__(self, tag, register_symbol_factory, attrs):
         super().__init__(tag, register_symbol_factory)
         self.check_no_attr(attrs)
-        self.value = [""]
+        self.value = ""
 
     def on_starttag(self, tag, attrs):
-        if tag == "br":
-            self.check_no_attr(attrs, tag)
-            self.value.append("")
-        else:
-            raise _UnexpectedScalarChild(
-                f"Element {self.tag!r} has undescribed child element {tag!r}"
-            )
+        _raise_not_described("Element", tag)
+
+    def on_endtag(self, tag):
+        assert tag == self.tag
+        self.register_symbol(self.value)
+        return self.value
+
+    def on_data(self, data):
+        assert isinstance(data, str)
+        self.value += data
+
+
+class _MarkupElement(_ElementBase):
+    def __init__(self, tag, register_symbol_factory, attrs):
+        super().__init__(tag, register_symbol_factory)
+        self.check_no_attr(attrs)
+        self.tag_level = 1
+        self.items = []
+
+    def on_starttag(self, tag, attrs):
+        assert self.tag_level >= 1
+        self.tag_level += 1
+        self.items.append(markup.Item(markup.START_TAG, tag, dict(attrs) if attrs else None))
 
     def on_endtag(self, tag):
-        if tag == "br":
+        assert self.tag_level >= 1
+        self.tag_level -= 1
+        if self.tag_level > 0:
+            self.items.append(markup.Item(markup.END_TAG, tag))
             return None
 
-        assert tag == self.tag
-        value = "\n".join([_normalize_spaces(s) for s in self.value])
+        assert self.tag == tag
+        value = markup.Value(self.items)
         self.register_symbol(value)
         return value
 
     def on_data(self, data):
-        self.value[-1] += f"{data}"
+        assert isinstance(data, str)
+        if self.items and self.items[-1].kind == markup.TEXT:
+            self.items[-1] = markup.Item(markup.TEXT, self.items[-1].value + data)
+        else:
+            self.items.append(markup.Item(markup.TEXT, data))
 
 
 class _DictElement(_ElementBase):
     def __init__(self, tag, register_symbol_factory, attrs, schema):
         super().__init__(tag, register_symbol_factory)
         self.schema = schema
         self.value = self.attrs_to_dict(attrs, schema)
 
     def on_starttag(self, tag, attrs):
         if tag in self.value and not isinstance(self.value[tag], list):
-            raise _InternalError(f"Value {tag!r} already defined")
+            raise _Error(f"Element {tag!r} is duplicated")
+
+        field_schema = _get_object_field_schema(self.schema, tag, "Element")
 
-        field_schema = _get_object_field_schema(self.schema, tag)
-        default_maxml = "attribute" if _is_known_scalar(field_schema) else "element"
-        if field_schema.metadata.get("maxml", default_maxml) != "element":
-            raise _InternalError(f"Field {tag!r} is not described as an element")
+        if get_metadata_maxml(field_schema) != "element":
+            _raise_not_described("Element", tag)
 
         return _factory(tag, self.register_symbol_factory, attrs, field_schema, self.value)
 
     def on_endtag(self, tag):
         assert tag == self.tag
         self.register_symbol(self.value)
         return self.value
 
     def on_data(self, data):
         if _normalize_spaces(data):
-            raise _InternalError(f"Element {self.tag!r} has undescribed text")
+            raise _Error(f"Element {self.tag!r} has undescribed text")
 
     def on_nested_processed(self, tag, value):
         self.value[tag] = value
 
 
 class _ListElement(_ElementBase):
     def __init__(self, tag, register_symbol_factory, attrs, item_schema, parent):
         if not isinstance(parent, dict):
-            raise _InternalError(f"The list ({tag!r}) should be a dictionary field")
+            raise _Error(f"The list ({tag!r}) should be a dictionary field")
 
         super().__init__(tag, register_symbol_factory)
         self.parent = parent
         self.item = _factory(tag, register_symbol_factory, attrs, item_schema)
 
     def on_starttag(self, tag, attrs):
         return self.item.on_starttag(tag, attrs)
@@ -233,29 +292,27 @@
     def on_nested_processed(self, tag, value):
         return self.item.on_nested_processed(tag, value)
 
 
 class _ContentElement(_ElementBase):
     def __init__(self, tag, register_symbol_factory, attrs, schema, field_name, field_schema):
         child_elements = [
-            f
-            for f in _get_declared_fields(schema).items()
-            if f[1].metadata.get("maxml") == "element"
+            f for f in schema().declared_fields.items() if f[1].metadata.get("maxml") == "element"
         ]
         if child_elements:
             child_names = ", ".join(repr(i[0]) for i in child_elements)
-            raise _InternalError(
+            raise _Error(
                 f"An {tag!r} element with a {field_name!r} content field cannot contain child elements: {child_names}"
             )
-        if not _is_known_scalar(field_schema):
-            raise _InternalError(f"Field {field_name!r} must be a scalar")
+        if not is_known_scalar(field_schema) and not isinstance(field_schema, markup.Field):
+            raise _Error(f"Field {field_name!r} must be a scalar")
 
         super().__init__(tag, register_symbol_factory)
         self.field_name = field_name
-        self.field = _ScalarElement(tag, register_symbol_factory, {})
+        self.field = _factory(tag, register_symbol_factory, attrs={}, schema=field_schema)
         self.value = self.attrs_to_dict(attrs, schema)
 
     def on_starttag(self, tag, attrs):
         return self.field.on_starttag(tag, attrs)
 
     def on_endtag(self, tag):
         value = self.field.on_endtag(tag)
@@ -266,165 +323,126 @@
         self.register_symbol(self.value)
         return self.value
 
     def on_data(self, data):
         return self.field.on_data(data)
 
 
-class _ParagraphElement(_ElementBase):
+class _RootElement(_ElementBase):
     def __init__(self, tag, register_symbol_factory, attrs, schema):
         super().__init__(tag, register_symbol_factory)
         self.check_no_attr(attrs)
         self.schema = schema
         self.commands = []
         self._text_harverter = None
-        self._text_harverter_register_symbol = None
-        self.tag_level = 1
+        self._text_harverter_level = 1
 
     def on_starttag(self, name, attrs):
-        if name == "p":
-            self._end_of_text_harverter()
-            return _ParagraphElement(name, self.register_symbol_factory, attrs, self.schema)
-
-        command_schema = _get_declared_fields(self.schema).get(name)
+        command_schema = self.schema.declared_fields.get(name)
         if command_schema:
             self._end_of_text_harverter()
-            _check_command_schema(name, command_schema)
             return _factory(name, self.register_symbol_factory, attrs, command_schema)
 
-        self.tag_level += 1
-        if name == "img":
-            self._end_of_text_harverter()
-            value = {}
-            for src, dst in {"src": "url", "alt": "caption"}.items():
-                field = attrs.get(src)
-                if field:
-                    value[dst] = field
-            self.register_symbol_factory()(value)
-            self.commands.append({"image": value})
-            return None
+        if name not in KNOWN_ROOT_ELEMENTS:
+            _raise_not_described("Command", name)
 
-        try:
-            return self.text_harverter.on_starttag(name, attrs)
-        except _UnexpectedScalarChild as exc:
-            raise _InternalError(f"{name!r} command not found") from exc
+        self._text_harverter_level += 1
+        return self.text_harverter.on_starttag(name, attrs)
 
     def on_endtag(self, name):
-        self.tag_level -= 1
-        if name == "img":
-            return None
-
-        if self.tag_level:
+        self._text_harverter_level -= 1
+        if self._text_harverter_level:
             value = self.text_harverter.on_endtag(name)
             assert value is None
             return None
 
         assert name == self.tag
         self._end_of_text_harverter()
         return self.commands
 
     def on_data(self, data):
         if data.strip() or self._text_harverter:
             self.text_harverter.on_data(data)
 
     def on_nested_processed(self, tag, value):
-        if isinstance(value, list):
-            self.commands += value
-        else:
-            self.commands.append({tag: value})
+        self.commands.append({tag: value})
 
     @property
     def text_harverter(self):
         if self._text_harverter is None:
-
-            def _empty_register_symbol_factory():
-                return lambda *_: None
-
-            self._text_harverter = _create_command_element(
-                self.schema, "text", _empty_register_symbol_factory, attrs={}
-            )
-            self._text_harverter_register_symbol = self.register_symbol_factory()
-            self._text_harverter.tag = self.tag
+            self._text_harverter = _MarkupElement(self.tag, self.register_symbol_factory, attrs={})
         return self._text_harverter
 
     def _end_of_text_harverter(self):
         if self._text_harverter:
             value = self._text_harverter.on_endtag(self._text_harverter.tag)
             assert value is not None
             if value:
-                self._text_harverter_register_symbol(value)
                 self.commands.append({"text": value})
             self._text_harverter = None
 
 
 def _factory(tag, register_symbol_factory, attrs, schema, parent=None):
-    if _is_known_scalar(schema):
+    if isinstance(schema, markup.Field):
+        return _MarkupElement(tag, register_symbol_factory, attrs)
+    if is_known_scalar(schema):
         return _ScalarElement(tag, register_symbol_factory, attrs)
     if isinstance(schema, fields.Nested):
         if schema.many:
             return _ListElement(
                 tag,
                 register_symbol_factory,
                 attrs,
                 fields.Nested(schema.nested),
                 parent,
             )
         content_fields = [
             f
-            for f in _get_declared_fields(schema.nested).items()
+            for f in schema.nested().declared_fields.items()
             if f[1].metadata.get("maxml") == "content"
         ]
         if len(content_fields) > 1:
             field_names = ", ".join(repr(i[0]) for i in content_fields)
-            raise _InternalError(
-                f"There can be no more than one field marked `content`: {field_names}"
-            )
+            raise _Error(f"There can be no more than one field marked `content`: {field_names}")
         if len(content_fields) == 1:
             return _ContentElement(
                 tag, register_symbol_factory, attrs, schema.nested, *content_fields[0]
             )
         return _DictElement(tag, register_symbol_factory, attrs, schema.nested)
     if isinstance(schema, fields.List):
         return _ListElement(tag, register_symbol_factory, attrs, schema.inner, parent)
-    raise _InternalError(f"Unexpected schema ({type(schema)}) for element {tag!r}")
+    raise _Error(f"Unexpected schema ({type(schema)}) for element {tag!r}")
 
 
-def _get_declared_fields(schema):
-    return schema._declared_fields  # pylint: disable-msg=W0212
+def _raise_not_described(entity, name):
+    raise _Error(f"{entity} {name!r} is not described in the schema")
 
 
-def _get_object_field_schema(schema, field_name, entity="Element"):
-    field_schema = _get_declared_fields(schema).get(field_name)
+def _get_object_field_schema(schema, field_name, entity):
+    field_schema = schema().declared_fields.get(field_name)
     if field_schema is None:
-        raise _InternalError(f"{entity} {field_name!r} is not described in the schema")
+        _raise_not_described(entity, field_name)
     return field_schema
 
 
-def _check_command_schema(name, command_schema):
-    if command_schema.metadata.get("maxml", "element") != "element":
-        raise _InternalError(f"Command {name!r} is not described as an element")
-
-
-def _create_command_element(schema, name, register_symbol_factory, attrs):
-    command_schema = _get_declared_fields(schema).get(name)
-    if command_schema is None:
-        raise _InternalError(f"{name!r} command not found")
-    _check_command_schema(name, command_schema)
-    return _factory(name, register_symbol_factory, attrs, command_schema)
-
-
 def _normalize_spaces(s):
     return " ".join(s.split()) if s else ""
 
 
-def _is_known_scalar(schema):
+def is_known_scalar(schema):
+    """Check for known scalar field (or inherited)."""
     if isinstance(schema, fields.String):
         return True
     if isinstance(schema, fields.Number):
         return True
     if isinstance(schema, fields.Boolean):
         return True
     if isinstance(schema, fields.DateTime):
         return True
     if isinstance(schema, fields.TimeDelta):
         return True
     return False
+
+
+def get_metadata_maxml(schema):
+    """Get "maxml" value of metadata."""
+    return schema.metadata.get("maxml", "attribute" if is_known_scalar(schema) else "element")
```

## Comparing `maxbot-0.1.0b2.dist-info/LICENSE` & `maxbot-0.2.0b2.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `maxbot-0.1.0b2.dist-info/METADATA` & `maxbot-0.2.0b2.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,26 +1,28 @@
 Metadata-Version: 2.1
 Name: maxbot
-Version: 0.1.0b2
+Version: 0.2.0b2
 Summary: Maxbot is an open source library and framework for creating conversational apps.
 Home-page: https://maxbot.ai
 License: MIT
 Keywords: maxbot,conversational-apps,nlp,conversational-ai,bot,chatbot,text-bot,voice-bot,botkit,chatbot-framework
 Author: Maxbot team
 Author-email: hello@maxbot.ai
 Maintainer: Maxbot team
 Maintainer-email: hello@maxbot.ai
-Requires-Python: >=3.9,<3.10
+Requires-Python: >=3.9,<3.12
 Classifier: Development Status :: 4 - Beta
 Classifier: Intended Audience :: Developers
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Operating System :: MacOS :: MacOS X
 Classifier: Operating System :: POSIX :: Linux
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
 Classifier: Topic :: Software Development :: Libraries
 Requires-Dist: Babel (>=2.9,<2.13)
 Requires-Dist: Jinja2 (>=3.1,<4.0)
 Requires-Dist: MarkupSafe (>=2.1.2,<3.0.0)
 Requires-Dist: PyYAML (>=6.0,<7.0)
 Requires-Dist: SQLAlchemy (>=1.4.36,<3.0)
 Requires-Dist: click (>=8.1,<9.0)
@@ -29,15 +31,14 @@
 Requires-Dist: httpx (>=0.23,<0.24)
 Requires-Dist: markdown-it-py (>=2.1.0,<3.0.0)
 Requires-Dist: marshmallow (>=3.19,<4.0)
 Requires-Dist: number-parser (>=0.3,<0.4)
 Requires-Dist: python-dateutil (>=2.8,<3.0)
 Requires-Dist: python-dotenv (>=1.0,<2.0)
 Requires-Dist: python-telegram-bot[ujson] (>=20.1,<21.0)
-Requires-Dist: pytz (>=2022.5,<2023.0)
 Requires-Dist: regex (<=2023.4.0)
 Requires-Dist: rich (>=13.3,<14.0)
 Requires-Dist: sanic (>=21.12,<22.13)
 Requires-Dist: spacy (>=3.5,<4.0)
 Requires-Dist: textdistance (>=4.5,<5.0)
 Requires-Dist: viberbot (>=1.0,<2.0)
 Requires-Dist: websockets (>=10,<11)
@@ -77,16 +78,16 @@
 
 
 ## Install Maxbot
 
 For detailed installation instructions, see the
 [documentation](https://maxbot.ai/getting-started/installation).
 
-- **Operating system**: macOS / OS X · Linux
-- **Python version**: Python 3.9 (only 64 bit)
+- **Operating system**: macOS / OS X · Unix/Linux · Windows
+- **Python version**: Python 3.9-3.11 (only 64 bit)
 - **Package managers**: [pip](https://pypi.org/project/maxbot/)
 
 ### Pip
 
 Using pip, **Maxbot** releases are available as source packages and binary wheels.
 Before you install **Maxbot** and its dependencies, make sure that
 your `pip` and `wheel` are up to date.
@@ -189,12 +190,9 @@
 [stack overflow]: https://stackoverflow.com/questions/tagged/maxbot
 
 
 ## The near future
 
 - Integration of deterministic dialog models (Dialog Tree, Slot Filling) with large language models (LLM) such as ChatGPT, LLaMA, etc.
 - Improved debugging and logging tools.
-- Switch from Markdown to command language (XML-based) in bot response scripts.
-- Improved built-in date and time extensions.
 - Released new examples of using the library to create complex bots.
-- Support for Python 3.10, 3.11.
```

## Comparing `maxbot-0.1.0b2.dist-info/RECORD` & `maxbot-0.2.0b2.dist-info/RECORD`

 * *Files 18% similar despite different names*

```diff
@@ -1,49 +1,54 @@
 maxbot/__init__.py,sha256=1stvGd3RYotkovV8rakT4hZ9aWeiEvm-GdtNT8EhB-c,162
 maxbot/__main__.py,sha256=oRavGlwnAm3mnWZYtmBngUziHKUv2iJJJIG5g-j3X2o,75
 maxbot/_download.py,sha256=shRYW-z2Achu4P9PnTjLq2hs6eafZBJR7rQDDmPH-mg,2724
 maxbot/_hooks.py,sha256=JRy28tlwFGFUcvECZUkF_GMs0KsAPEzVfYtIc8h0k6A,787
 maxbot/bot.py,sha256=16cL6kFh6Y_VBXC921cvhsMJUZUCtM57NHq6RhQ7Lqs,13150
-maxbot/builder.py,sha256=cNB5uKQ739uzbnt9zbz8DgRekgiQghx-wtvbV059Dh0,14553
+maxbot/builder.py,sha256=6xlG46Qe0rVubFQ3QpPEOfIeESGbduMBBvk3Shrp7PU,14547
 maxbot/channels/__init__.py,sha256=pODVSwZ1ATay3XHGhP1WS5jy79M1sp9J7STKBGB08ts,186
-maxbot/channels/_manager.py,sha256=oUu_I5mTuLTpsUBrGXtAx6kqy4dhAv_Yzr9HvXYIhAM,7515
-maxbot/channels/facebook.py,sha256=_udxtI56ipC0TdRQJ21e6NI1bNrp3oDAN8f2JlIseCU,9338
-maxbot/channels/telegram.py,sha256=zLEP6-p34MuA-L_4UwZEjYbBjkbk0w88iSuMTp0uVAs,5772
-maxbot/channels/viber.py,sha256=cFA5p3nEyfP38DD71bhkP5muT65JXNK1UXbq2bZqyTo,8997
-maxbot/channels/vk.py,sha256=edIoLyIOF-3OcwSG4Y_8vr2cWOrKdgYe2JXqyMBKd_M,11077
-maxbot/cli/__init__.py,sha256=N0o4CUJeXps5gxyI4EFMHF-nWQJm5kJTMcrz5ASUrs8,383
+maxbot/channels/_manager.py,sha256=jC71wOMOVpvsi0XXo5_39I_2rTVae6EmS3pw8MeE7Fs,7510
+maxbot/channels/facebook.py,sha256=HW0OzJvf4lFSddha5aAIXMXzzbSJ3I_qKdFd0T3ZmjI,9353
+maxbot/channels/telegram.py,sha256=qqpeZJMDjf_72x4gMO7dWiBfu5AxzcK6HSv7IvIYvVY,5897
+maxbot/channels/viber.py,sha256=-VRtsHhekLJBnYrN7b2bFb54rRsVwYa9f2XY1rvuCDg,9097
+maxbot/channels/vk.py,sha256=ydYvls9AauUF0KILw_UjEi8wwZqQswUu_4ZZ_z3rxDc,11180
+maxbot/cli/__init__.py,sha256=J3CimQDZdnLR0d8varcLoyLA6dZfZfW-RYqb6k1g1qU,535
 maxbot/cli/_bot.py,sha256=F3ho_42xMugRbHVEMiujyQhztqdFzLZXe-00v_XuEZg,1990
-maxbot/cli/_journal.py,sha256=LwdvBedKVPIo6P5GnzIsQzrdOGQaLAyYeKkod9Yb0dE,2061
+maxbot/cli/_journal.py,sha256=PcFyz1jh0I_RWVg6_7KJaC9Rx9fu62lc8XM_ij_HLdg,3069
 maxbot/cli/_logging.py,sha256=-XBLl7eS8tRRGUw3ICJjiuxljEvdHUaP6aANsUvQblQ,1638
 maxbot/cli/_ngrok.py,sha256=l7BMJQs5Cupm0jV_eCR70kwsVmJbDRx5mt2Jrz2Zatg,1963
-maxbot/cli/_rich.py,sha256=kH_fXJvWji8wFphII6Pfy11u9Q-32zzcMNHEghCeoL0,7467
-maxbot/cli/run.py,sha256=T3VaBopmaLO8yTRVK9LZVsNa6jYvsOkhGn_72JbGneo,5441
-maxbot/context.py,sha256=MFdifr-8FtWmgwEWRDN2Kq1zNIQ0-isLprUr2iJkVcU,19273
-maxbot/dialog_manager.py,sha256=4hRggMvXimTYgTwBtp5ruoFps69a0lYvgqeWiPdQCgQ,5087
-maxbot/errors.py,sha256=Bgaig3Wkznd5xFRZWHExbjiQyamISc33D-w2fIU_Sso,10289
+maxbot/cli/_rich.py,sha256=H_R_-0Jy5atFPoCNEbpCQg4oNy_B1JHbPpJayzLOM2w,10809
+maxbot/cli/_yaml_dumper.py,sha256=vmiO4RtXzSAbvnphgIsJ8f5tiXkb0WnQaTE9JGGUpa8,1018
+maxbot/cli/info.py,sha256=vN9T9vPSn_0AjVQ1bUunyJNDv2-J_ssFLwfwtArbkjk,1297
+maxbot/cli/run.py,sha256=3PG8PyJUTSfnv3euOggk6lbelWvxOySoMxp9-vdRsDM,5999
+maxbot/cli/stories.py,sha256=-3o1sv47P0Wm7VDZYRNnuIFCozSIofb2FGhco99UCs8,6040
+maxbot/context.py,sha256=lr6rGzHYaLEWEJBT_IJMPQz_NRP5-YMIK9VQIncKMgk,20507
+maxbot/dialog_manager.py,sha256=hpSSBxdv_rocThOR2fnlcF-fXZi49jshsoFIdy325cg,5628
+maxbot/errors.py,sha256=hs5N6UqEY3HVA8HasP_9gOIYvxEa_5P1GAqTAcUDz98,10361
 maxbot/extensions/__init__.py,sha256=L__Wgj_sMv61E8Hu9KMBpZPm6aoWzM5ALZmxt-zoxNI,139
-maxbot/extensions/_manager.py,sha256=6dKlsgvb9fCZDKJyJ-UBFypjkCZkF9d4yLXjD7snpjk,4185
-maxbot/extensions/datetime.py,sha256=yWitoAqaBK3HFpQ-SIoU-xuRC7HT8zqVnRMXRsI9P8A,2738
-maxbot/extensions/format.py,sha256=hB1z7huKx6_pKbouo93b6IzaMQH8nGtCOReOM6YAWR8,2568
+maxbot/extensions/_manager.py,sha256=wyNGrH_2pePBphu7ZVkiiKHH-C_zdMmUS89vv-gGyw8,4177
+maxbot/extensions/babel.py,sha256=UHecAex31B97BAJQN9pQbbW8rDim9eIfKN3yupDeGZU,3884
+maxbot/extensions/datetime.py,sha256=hTEVmX2l8AS1ob4yyqBoPJEAF1Un9o6KCjXVgIs5syU,2872
 maxbot/extensions/jinja_loader.py,sha256=fl97FessN7RoAxH68N-GRhUdUMuNfoamSxvz-YqV6P8,1043
-maxbot/extensions/rasa.py,sha256=HlPfUhtsL6ifBy6_3IxfB1eq10huhHY3rkzF963u9DA,5513
-maxbot/extensions/rest.py,sha256=azbsq2jOk21Cs407Cw7SKDwlC-xIAqsqviXc9Zgl9CQ,5592
-maxbot/flows/__init__.py,sha256=KmUx1coxa5Y10qrFqam16nAi_sXWGzTUwlC3vVkk53Q,33
+maxbot/extensions/rasa.py,sha256=J3W6bXDQI0UaIQAVcLTvbk7VCbxAonLOf9eFpwvutgE,5524
+maxbot/extensions/rest.py,sha256=F8mqC-RTAf726PvJ0PCl7OKJOamMCAFVmGdZvPP05-s,5588
+maxbot/flows/__init__.py,sha256=0s6R2gvjP4u8VWFDjFwJAoe6upVSfixvxLf5_jFfwUo,32
 maxbot/flows/_base.py,sha256=3-Mdti-_srsqNtaJQpKWGHgfRc2Aes2a-d5QmB2J7fo,1302
 maxbot/flows/dialog_flow.py,sha256=nR5sSPUESpdH-lPjGg4HvjcT_q4zub90i9ivOnc6KBw,2053
-maxbot/flows/dialog_tree.py,sha256=EvKlScmhR9d4Qw3ei2eKU575dtOop87x4Z2uvkMaRBA,25772
-maxbot/flows/slot_filling.py,sha256=0t5ZnKz5dRxIJMKnomOXPrtjk2-kE6nqrjLpRugwvtQ,12570
-maxbot/jinja_env.py,sha256=2xryJYWY0-U9B4jQktRqM3CL50m7JVhNr1swKVQiDgw,8526
-maxbot/markdown.py,sha256=lCWwJRPo7RssuUVDOZ7Jel8xYDSj9OKbBF6KM5Z2WWs,4542
-maxbot/nlu.py,sha256=sT_15WhOCE2ryHRYuJ_qXUllA3Oq2NF5WnAjRcKXhMA,20871
-maxbot/resources.py,sha256=k_Z86NjC-ha3QSMgaMWeKmQ4SrQl8fVoOfJHOFxlYfo,10833
-maxbot/rpc.py,sha256=Ph8SeI7aTTIV0MpvLVurz2AYkq5xrJS-q1gjqNalqUs,4728
-maxbot/scenarios.py,sha256=rb4etJUcoN9LOU7jn8_ZetOHGiRpBtkOeusBW81Hy1c,8844
-maxbot/schemas.py,sha256=374wYhTWUdVvE1Od45bz9cmk6wLP_IRGjd93YU0uacc,16929
+maxbot/flows/dialog_tree.py,sha256=FE9S24ZuH_-VMVxGZNMoZDAbj75JGPqwrQuA8ag6pU4,26575
+maxbot/flows/slot_filling.py,sha256=YtOhfTZM82Tb4_uA_DIEplc6NZs3mT7ujGNJeOyk6jk,13775
+maxbot/jinja_env.py,sha256=K_dIHORqvrf6EY5zyDolHq2TIRb9TByoSIb_Qn-PMAI,6658
+maxbot/maxml/__init__.py,sha256=VAx8XFYaBSVRIUOTbGAfW9QjUiLUnqbEmG8uPTTZhBA,161
+maxbot/maxml/markup.py,sha256=pV9DQl00ZP9N6AztY-xECyDpj9F32_i-viFA_9a_0y0,3440
+maxbot/maxml/pretty.py,sha256=IcseDc2jOTMDQx0q426o4Od08uWIJfj5Z27fk-TV0xE,6009
+maxbot/maxml/xml_parser.py,sha256=arqxqAqhGpGjOjRQqPbREYgQ5QYzT_gGFXlMwm38pf0,15413
+maxbot/nlu.py,sha256=JlxPzK7xJmAz4UzlhHkJ45QBIH-CLa6qEBgi4XuOkqo,21817
+maxbot/resources.py,sha256=twuUXJM4UQM86b2GaFBW5ko8HdmCdeexpzUeL0AyM_E,10827
+maxbot/rpc.py,sha256=BzWLx3uA8VJb6VtbqCEA4jBdxnEp2IgfZJF0b1xwRzQ,4723
+maxbot/scenarios.py,sha256=o9oLYp1NHuSgyi1spE1DwpBR0i2WzIGKglu28w11WdM,8839
+maxbot/schemas.py,sha256=zRPX70i80PnuKEkQpmxyu75n5YaFBFB9Cn0TkOBug84,17214
 maxbot/state_store.py,sha256=yaPLekUo4czgMSTGBkSRi_IjolIvSp2urwKj51sS5pY,4164
 maxbot/user_locks.py,sha256=_FnI_G4sPwjTaXiEw7Sj9tkiV_UGmhgF-F8H4vFudBA,1051
-maxbot/xml.py,sha256=R6RmyotAI43CEPINyUNI-sFHdNciz0YzboezA3QIZgA,14851
-maxbot-0.1.0b2.dist-info/LICENSE,sha256=g6TcBHQ6jwWbD2xQGQYGtK0pvcb4G2gx0f8B7QschKI,1055
-maxbot-0.1.0b2.dist-info/METADATA,sha256=nwAfJq4193g1yj7pnuBTc4Aaj5jGBUw541d0PmG7t00,7688
-maxbot-0.1.0b2.dist-info/WHEEL,sha256=7Z8_27uaHI_UZAc4Uox4PpBhQ9Y5_modZXWMxtUi4NU,88
-maxbot-0.1.0b2.dist-info/entry_points.txt,sha256=BORdoo0s_bCrrWHTB-b4Sykb1KPIErzt7c-Oc0Uu4zw,42
-maxbot-0.1.0b2.dist-info/RECORD,,
+maxbot-0.2.0b2.dist-info/LICENSE,sha256=g6TcBHQ6jwWbD2xQGQYGtK0pvcb4G2gx0f8B7QschKI,1055
+maxbot-0.2.0b2.dist-info/METADATA,sha256=tTLfEahvn2lrQOthHePKYld-M2ZKjo4Kiv8mJi3AMzo,7613
+maxbot-0.2.0b2.dist-info/WHEEL,sha256=7Z8_27uaHI_UZAc4Uox4PpBhQ9Y5_modZXWMxtUi4NU,88
+maxbot-0.2.0b2.dist-info/entry_points.txt,sha256=BORdoo0s_bCrrWHTB-b4Sykb1KPIErzt7c-Oc0Uu4zw,42
+maxbot-0.2.0b2.dist-info/RECORD,,
```

