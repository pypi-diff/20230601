# Comparing `tmp/mhm-5.12.1.dev21.tar.gz` & `tmp/mhm-5.13.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "mhm-5.12.1.dev21.tar", last modified: Mon Nov 21 13:40:46 2022, max compression
+gzip compressed data, was "mhm-5.13.0.tar", last modified: Thu Jun  1 07:33:43 2023, max compression
```

## Comparing `mhm-5.12.1.dev21.tar` & `mhm-5.13.0.tar`

### file list

```diff
@@ -1,149 +1,216 @@
-drwxr-xr-x   0 runner    (1001) docker     (122)        0 2022-11-21 13:40:46.231203 mhm-5.12.1.dev21/
--rw-r--r--   0 runner    (1001) docker     (122)     2040 2022-11-21 13:40:18.000000 mhm-5.12.1.dev21/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (122)    42142 2022-11-21 13:40:18.000000 mhm-5.12.1.dev21/LICENSE
--rw-r--r--   0 runner    (1001) docker     (122)     3921 2022-11-21 13:40:46.227202 mhm-5.12.1.dev21/PKG-INFO
-drwxr-xr-x   0 runner    (1001) docker     (122)        0 2022-11-21 13:40:46.207200 mhm-5.12.1.dev21/cmake/
--rw-r--r--   0 runner    (1001) docker     (122)      426 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/cmake/.gitrepo
--rw-r--r--   0 runner    (1001) docker     (122)     7652 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/cmake/LICENSE
--rw-r--r--   0 runner    (1001) docker     (122)     3408 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/cmake/README.md
-drwxr-xr-x   0 runner    (1001) docker     (122)        0 2022-11-21 13:40:46.207200 mhm-5.12.1.dev21/cmake/cmake-cache-files/
--rw-r--r--   0 runner    (1001) docker     (122)      215 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/cmake/cmake-cache-files/eve
--rw-r--r--   0 runner    (1001) docker     (122)      387 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/cmake/cmake-cache-files/example
--rw-r--r--   0 runner    (1001) docker     (122)      186 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/cmake/cmake-cache-files/specificSetup
-drwxr-xr-x   0 runner    (1001) docker     (122)        0 2022-11-21 13:40:46.207200 mhm-5.12.1.dev21/cmake/cmake-modules/
--rw-r--r--   0 runner    (1001) docker     (122)    35135 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/cmake/cmake-modules/CPM.cmake
--rw-r--r--   0 runner    (1001) docker     (122)    30952 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/cmake/cmake-modules/CodeCoverage.cmake
--rw-r--r--   0 runner    (1001) docker     (122)     3542 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/cmake/cmake-modules/FindNetCDF.cmake
--rw-r--r--   0 runner    (1001) docker     (122)     2224 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/cmake/cmake-modules/compileoptions.cmake
--rw-r--r--   0 runner    (1001) docker     (122)     4026 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/cmake/cmake-modules/fortranpreprocessor.cmake
--rw-r--r--   0 runner    (1001) docker     (122)     3137 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/cmake/cmake-modules/version.cmake
-drwxr-xr-x   0 runner    (1001) docker     (122)        0 2022-11-21 13:40:46.207200 mhm-5.12.1.dev21/pybind/
--rw-r--r--   0 runner    (1001) docker     (122)     2646 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/pybind/README.md
-drwxr-xr-x   0 runner    (1001) docker     (122)        0 2022-11-21 13:40:46.211201 mhm-5.12.1.dev21/pybind/examples/
--rw-r--r--   0 runner    (1001) docker     (122)      428 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/pybind/examples/01_simple_run.py
--rw-r--r--   0 runner    (1001) docker     (122)      750 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/pybind/examples/02_time_steps.py
--rw-r--r--   0 runner    (1001) docker     (122)     1252 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/pybind/examples/03_plot.py
--rw-r--r--   0 runner    (1001) docker     (122)      885 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/pybind/examples/04_grid_info.py
-drwxr-xr-x   0 runner    (1001) docker     (122)        0 2022-11-21 13:40:46.211201 mhm-5.12.1.dev21/pybind/mhm/
--rw-r--r--   0 runner    (1001) docker     (122)     1539 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/pybind/mhm/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (122)      701 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/pybind/mhm/__init__.py
--rw-r--r--   0 runner    (1001) docker     (122)       28 2022-11-21 13:40:45.000000 mhm-5.12.1.dev21/pybind/mhm/_version.py
--rw-r--r--   0 runner    (1001) docker     (122)      267 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/pybind/mhm/cli.py
--rw-r--r--   0 runner    (1001) docker     (122)     1838 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/pybind/mhm/tools.py
--rw-r--r--   0 runner    (1001) docker     (122)    25213 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/pybind/mhm/wrapper.f90
-drwxr-xr-x   0 runner    (1001) docker     (122)        0 2022-11-21 13:40:46.211201 mhm-5.12.1.dev21/pybind/mhm.egg-info/
--rw-r--r--   0 runner    (1001) docker     (122)     3921 2022-11-21 13:40:45.000000 mhm-5.12.1.dev21/pybind/mhm.egg-info/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (122)     3885 2022-11-21 13:40:46.000000 mhm-5.12.1.dev21/pybind/mhm.egg-info/SOURCES.txt
--rw-r--r--   0 runner    (1001) docker     (122)        1 2022-11-21 13:40:45.000000 mhm-5.12.1.dev21/pybind/mhm.egg-info/dependency_links.txt
--rw-r--r--   0 runner    (1001) docker     (122)       36 2022-11-21 13:40:45.000000 mhm-5.12.1.dev21/pybind/mhm.egg-info/entry_points.txt
--rw-r--r--   0 runner    (1001) docker     (122)        1 2022-11-21 13:40:43.000000 mhm-5.12.1.dev21/pybind/mhm.egg-info/not-zip-safe
--rw-r--r--   0 runner    (1001) docker     (122)       14 2022-11-21 13:40:45.000000 mhm-5.12.1.dev21/pybind/mhm.egg-info/requires.txt
--rw-r--r--   0 runner    (1001) docker     (122)        4 2022-11-21 13:40:45.000000 mhm-5.12.1.dev21/pybind/mhm.egg-info/top_level.txt
--rw-r--r--   0 runner    (1001) docker     (122)     2654 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/pyproject.toml
--rw-r--r--   0 runner    (1001) docker     (122)       38 2022-11-21 13:40:46.231203 mhm-5.12.1.dev21/setup.cfg
--rw-r--r--   0 runner    (1001) docker     (122)      884 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/setup.py
-drwxr-xr-x   0 runner    (1001) docker     (122)        0 2022-11-21 13:40:46.211201 mhm-5.12.1.dev21/src/
--rw-r--r--   0 runner    (1001) docker     (122)     2818 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/CMakeLists.txt
-drwxr-xr-x   0 runner    (1001) docker     (122)        0 2022-11-21 13:40:46.215201 mhm-5.12.1.dev21/src/MPR/
--rw-r--r--   0 runner    (1001) docker     (122)     3678 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/MPR/mo_mpr_constants.f90
--rw-r--r--   0 runner    (1001) docker     (122)     7452 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/MPR/mo_mpr_eval.f90
--rw-r--r--   0 runner    (1001) docker     (122)     3851 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/MPR/mo_mpr_file.f90
--rw-r--r--   0 runner    (1001) docker     (122)    12354 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/MPR/mo_mpr_global_variables.f90
--rwxr-xr-x   0 runner    (1001) docker     (122)     9989 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/MPR/mo_mpr_neutrons.f90
--rw-r--r--   0 runner    (1001) docker     (122)    17698 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/MPR/mo_mpr_pet.f90
--rw-r--r--   0 runner    (1001) docker     (122)    47752 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/MPR/mo_mpr_read_config.f90
--rw-r--r--   0 runner    (1001) docker     (122)    21813 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/MPR/mo_mpr_restart.f90
--rw-r--r--   0 runner    (1001) docker     (122)     7834 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/MPR/mo_mpr_runoff.f90
--rw-r--r--   0 runner    (1001) docker     (122)    33842 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/MPR/mo_mpr_smhorizons.f90
--rw-r--r--   0 runner    (1001) docker     (122)    30418 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/MPR/mo_mpr_soilmoist.f90
--rw-r--r--   0 runner    (1001) docker     (122)    20191 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/MPR/mo_mpr_startup.f90
--rw-r--r--   0 runner    (1001) docker     (122)    59950 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/MPR/mo_multi_param_reg.f90
--rw-r--r--   0 runner    (1001) docker     (122)     8225 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/MPR/mo_prepare_gridded_lai.f90
--rw-r--r--   0 runner    (1001) docker     (122)     6741 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/MPR/mo_read_lut.f90
--rw-r--r--   0 runner    (1001) docker     (122)    17700 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/MPR/mo_read_wrapper.f90
--rw-r--r--   0 runner    (1001) docker     (122)    19524 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/MPR/mo_soil_database.f90
--rw-r--r--   0 runner    (1001) docker     (122)    24012 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/MPR/mo_upscaling_operators.f90
--rw-r--r--   0 runner    (1001) docker     (122)     4295 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/MPR/mpr_driver.F90
-drwxr-xr-x   0 runner    (1001) docker     (122)        0 2022-11-21 13:40:46.219202 mhm-5.12.1.dev21/src/common/
--rw-r--r--   0 runner    (1001) docker     (122)     2547 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/common/mo_check.f90
--rw-r--r--   0 runner    (1001) docker     (122)    18554 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/common/mo_clean_up.f90
--rw-r--r--   0 runner    (1001) docker     (122)     3041 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/common/mo_common_MPI_tools.F90
--rw-r--r--   0 runner    (1001) docker     (122)     1604 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/common/mo_common_constants.f90
--rw-r--r--   0 runner    (1001) docker     (122)     6439 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/common/mo_common_datetime_type.f90
--rw-r--r--   0 runner    (1001) docker     (122)     1063 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/common/mo_common_file.f90
--rw-r--r--   0 runner    (1001) docker     (122)     1319 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/common/mo_common_functions.f90
--rw-r--r--   0 runner    (1001) docker     (122)    20499 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/common/mo_common_read_config.F90
--rw-r--r--   0 runner    (1001) docker     (122)     6356 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/common/mo_common_read_data.f90
--rw-r--r--   0 runner    (1001) docker     (122)     8443 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/common/mo_common_restart.f90
--rw-r--r--   0 runner    (1001) docker     (122)     4269 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/common/mo_common_run_variables.f90
--rw-r--r--   0 runner    (1001) docker     (122)    12712 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/common/mo_common_variables.F90
--rw-r--r--   0 runner    (1001) docker     (122)    17770 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/common/mo_grid.f90
--rw-r--r--   0 runner    (1001) docker     (122)     4538 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/common/mo_read_latlon.f90
--rw-r--r--   0 runner    (1001) docker     (122)    32973 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/common/mo_read_nc.f90
--rw-r--r--   0 runner    (1001) docker     (122)    13880 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/common/mo_read_spatial_data.f90
--rw-r--r--   0 runner    (1001) docker     (122)     9833 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/common/mo_read_timeseries.f90
-drwxr-xr-x   0 runner    (1001) docker     (122)        0 2022-11-21 13:40:46.219202 mhm-5.12.1.dev21/src/common_mHM_mRM/
--rw-r--r--   0 runner    (1001) docker     (122)      990 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/common_mHM_mRM/mo_common_mHM_mRM_file.f90
--rw-r--r--   0 runner    (1001) docker     (122)    14118 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/common_mHM_mRM/mo_common_mHM_mRM_read_config.f90
--rw-r--r--   0 runner    (1001) docker     (122)     4579 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/common_mHM_mRM/mo_common_mHM_mRM_restart.f90
--rw-r--r--   0 runner    (1001) docker     (122)     6009 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/common_mHM_mRM/mo_common_mHM_mRM_variables.f90
--rw-r--r--   0 runner    (1001) docker     (122)    10867 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/common_mHM_mRM/mo_optimization.F90
-drwxr-xr-x   0 runner    (1001) docker     (122)        0 2022-11-21 13:40:46.223202 mhm-5.12.1.dev21/src/mHM/
--rw-r--r--   0 runner    (1001) docker     (122)     5380 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mHM/mhm_driver.f90
--rw-r--r--   0 runner    (1001) docker     (122)     4209 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mHM/mo_canopy_interc.f90
--rw-r--r--   0 runner    (1001) docker     (122)     1933 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mHM/mo_file.F90
--rw-r--r--   0 runner    (1001) docker     (122)    13587 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mHM/mo_global_variables.f90
--rw-r--r--   0 runner    (1001) docker     (122)    13095 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mHM/mo_init_states.f90
--rw-r--r--   0 runner    (1001) docker     (122)    31334 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mHM/mo_meteo_forcings.f90
--rw-r--r--   0 runner    (1001) docker     (122)    33361 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mHM/mo_mhm.f90
--rw-r--r--   0 runner    (1001) docker     (122)     2977 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mHM/mo_mhm_bfi.f90
--rw-r--r--   0 runner    (1001) docker     (122)     3527 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mHM/mo_mhm_cli.F90
--rw-r--r--   0 runner    (1001) docker     (122)     2765 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mHM/mo_mhm_constants.f90
--rw-r--r--   0 runner    (1001) docker     (122)     7372 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mHM/mo_mhm_eval.f90
--rw-r--r--   0 runner    (1001) docker     (122)    16449 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mHM/mo_mhm_interface.F90
--rw-r--r--   0 runner    (1001) docker     (122)    40353 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mHM/mo_mhm_interface_run.f90
--rw-r--r--   0 runner    (1001) docker     (122)     6660 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mHM/mo_mhm_messages.F90
--rw-r--r--   0 runner    (1001) docker     (122)    19788 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mHM/mo_mhm_read_config.f90
--rw-r--r--   0 runner    (1001) docker     (122)    32858 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mHM/mo_neutrons.f90
--rw-r--r--   0 runner    (1001) docker     (122)    99518 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mHM/mo_objective_function.F90
--rw-r--r--   0 runner    (1001) docker     (122)    16477 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mHM/mo_pet.f90
--rw-r--r--   0 runner    (1001) docker     (122)     3911 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mHM/mo_read_optional_data.f90
--rw-r--r--   0 runner    (1001) docker     (122)    36782 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mHM/mo_restart.f90
--rw-r--r--   0 runner    (1001) docker     (122)     9193 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mHM/mo_runoff.f90
--rw-r--r--   0 runner    (1001) docker     (122)     4889 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mHM/mo_snow_accum_melt.f90
--rw-r--r--   0 runner    (1001) docker     (122)    17558 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mHM/mo_soil_moisture.f90
--rw-r--r--   0 runner    (1001) docker     (122)    11980 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mHM/mo_spatial_agg_disagg_forcing.f90
--rw-r--r--   0 runner    (1001) docker     (122)     9515 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mHM/mo_startup.f90
--rw-r--r--   0 runner    (1001) docker     (122)    12912 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mHM/mo_temporal_disagg_forcing.f90
--rw-r--r--   0 runner    (1001) docker     (122)    25772 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mHM/mo_write_ascii.f90
--rwxr-xr-x   0 runner    (1001) docker     (122)    32764 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mHM/mo_write_fluxes_states.f90
-drwxr-xr-x   0 runner    (1001) docker     (122)        0 2022-11-21 13:40:46.227202 mhm-5.12.1.dev21/src/mRM/
--rw-r--r--   0 runner    (1001) docker     (122)     2186 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mRM/mo_mrm_constants.F90
--rw-r--r--   0 runner    (1001) docker     (122)     3919 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mRM/mo_mrm_file.f90
--rw-r--r--   0 runner    (1001) docker     (122)    13918 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mRM/mo_mrm_global_variables.f90
--rw-r--r--   0 runner    (1001) docker     (122)    25004 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mRM/mo_mrm_init.f90
--rw-r--r--   0 runner    (1001) docker     (122)     9981 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mRM/mo_mrm_mpr.f90
--rw-r--r--   0 runner    (1001) docker     (122)    79520 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mRM/mo_mrm_net_startup.f90
--rw-r--r--   0 runner    (1001) docker     (122)    91073 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mRM/mo_mrm_objective_function_runoff.F90
--rw-r--r--   0 runner    (1001) docker     (122)    17622 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mRM/mo_mrm_pre_routing.f90
--rw-r--r--   0 runner    (1001) docker     (122)    21963 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mRM/mo_mrm_read_config.f90
--rw-r--r--   0 runner    (1001) docker     (122)    20300 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mRM/mo_mrm_read_data.f90
--rw-r--r--   0 runner    (1001) docker     (122)    30769 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mRM/mo_mrm_restart.f90
--rw-r--r--   0 runner    (1001) docker     (122)    35464 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mRM/mo_mrm_riv_temp_class.f90
--rw-r--r--   0 runner    (1001) docker     (122)    12123 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mRM/mo_mrm_river_head.f90
--rw-r--r--   0 runner    (1001) docker     (122)    21880 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mRM/mo_mrm_routing.f90
--rw-r--r--   0 runner    (1001) docker     (122)    40763 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mRM/mo_mrm_signatures.f90
--rw-r--r--   0 runner    (1001) docker     (122)    46208 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mRM/mo_mrm_write.f90
--rw-r--r--   0 runner    (1001) docker     (122)    20187 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/mRM/mo_mrm_write_fluxes_states.f90
-drwxr-xr-x   0 runner    (1001) docker     (122)        0 2022-11-21 13:40:46.227202 mhm-5.12.1.dev21/src/tests/
--rw-r--r--   0 runner    (1001) docker     (122)      361 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/tests/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (122)     1926 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/tests/test_canopy_interc.pf
--rw-r--r--   0 runner    (1001) docker     (122)     5820 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/tests/test_grid.pf
--rw-r--r--   0 runner    (1001) docker     (122)     2552 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/tests/test_pet.pf
--rw-r--r--   0 runner    (1001) docker     (122)     4572 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/tests/test_runoff.pf
--rw-r--r--   0 runner    (1001) docker     (122)     4501 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/tests/test_snow_accum_melt.pf
--rw-r--r--   0 runner    (1001) docker     (122)     7148 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/tests/test_soil_moisture.pf
--rw-r--r--   0 runner    (1001) docker     (122)     7678 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/tests/test_spatial_agg_disagg_forcing.pf
--rw-r--r--   0 runner    (1001) docker     (122)     3679 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/src/tests/test_temporal_disagg_forcing.pf
--rw-r--r--   0 runner    (1001) docker     (122)       12 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/version.txt
--rw-r--r--   0 runner    (1001) docker     (122)        9 2022-11-21 13:40:19.000000 mhm-5.12.1.dev21/version_date.txt
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-01 07:33:43.582932 mhm-5.13.0/
+-rw-r--r--   0 runner    (1001) docker     (123)      420 2023-06-01 07:33:19.000000 mhm-5.13.0/AUTHORS
+-rw-r--r--   0 runner    (1001) docker     (123)     2070 2023-06-01 07:33:19.000000 mhm-5.13.0/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    35149 2023-06-01 07:33:19.000000 mhm-5.13.0/COPYING
+-rw-r--r--   0 runner    (1001) docker     (123)     7652 2023-06-01 07:33:19.000000 mhm-5.13.0/COPYING.LESSER
+-rw-r--r--   0 runner    (1001) docker     (123)    24360 2023-06-01 07:33:19.000000 mhm-5.13.0/LICENSE.md
+-rw-r--r--   0 runner    (1001) docker     (123)     5890 2023-06-01 07:33:43.578932 mhm-5.13.0/PKG-INFO
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-01 07:33:43.558931 mhm-5.13.0/cmake/
+-rw-r--r--   0 runner    (1001) docker     (123)       67 2023-06-01 07:33:19.000000 mhm-5.13.0/cmake/AUTHORS
+-rw-r--r--   0 runner    (1001) docker     (123)    35202 2023-06-01 07:33:19.000000 mhm-5.13.0/cmake/CPM.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)    30952 2023-06-01 07:33:19.000000 mhm-5.13.0/cmake/CodeCoverage.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)     4762 2023-06-01 07:33:19.000000 mhm-5.13.0/cmake/FindNetCDF.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)     2652 2023-06-01 07:33:19.000000 mhm-5.13.0/cmake/FindYAC.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-06-01 07:33:19.000000 mhm-5.13.0/cmake/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)     4546 2023-06-01 07:33:19.000000 mhm-5.13.0/cmake/README.md
+-rw-r--r--   0 runner    (1001) docker     (123)     3451 2023-06-01 07:33:19.000000 mhm-5.13.0/cmake/compileoptions.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)     5265 2023-06-01 07:33:19.000000 mhm-5.13.0/cmake/fortranpreprocessor.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)     4346 2023-06-01 07:33:19.000000 mhm-5.13.0/cmake/version.cmake
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-01 07:33:43.562931 mhm-5.13.0/forces/
+-rw-rw-r--   0 runner    (1001) docker     (123)      327 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/AUTHORS
+-rw-rw-r--   0 runner    (1001) docker     (123)     2276 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/CMakeLists.txt
+-rw-rw-r--   0 runner    (1001) docker     (123)    35149 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/COPYING
+-rw-rw-r--   0 runner    (1001) docker     (123)     7652 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/COPYING.LESSER
+-rw-rw-r--   0 runner    (1001) docker     (123)     7327 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/LICENSE.md
+-rwxrwxr-x   0 runner    (1001) docker     (123)     3478 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/README.md
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-01 07:33:43.562931 mhm-5.13.0/forces/cmake/
+-rw-rw-r--   0 runner    (1001) docker     (123)       67 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/cmake/AUTHORS
+-rw-rw-r--   0 runner    (1001) docker     (123)    35202 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/cmake/CPM.cmake
+-rw-rw-r--   0 runner    (1001) docker     (123)    30952 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/cmake/CodeCoverage.cmake
+-rw-rw-r--   0 runner    (1001) docker     (123)     4762 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/cmake/FindNetCDF.cmake
+-rw-rw-r--   0 runner    (1001) docker     (123)     2652 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/cmake/FindYAC.cmake
+-rw-rw-r--   0 runner    (1001) docker     (123)     1088 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/cmake/LICENSE
+-rw-rw-r--   0 runner    (1001) docker     (123)     4546 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/cmake/README.md
+-rw-rw-r--   0 runner    (1001) docker     (123)     3451 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/cmake/compileoptions.cmake
+-rw-rw-r--   0 runner    (1001) docker     (123)     5265 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/cmake/fortranpreprocessor.cmake
+-rw-rw-r--   0 runner    (1001) docker     (123)     4346 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/cmake/version.cmake
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-01 07:33:43.562931 mhm-5.13.0/forces/include/
+-rw-rw-r--   0 runner    (1001) docker     (123)     3474 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/include/logging.h
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-01 07:33:43.570932 mhm-5.13.0/forces/src/
+-rw-rw-r--   0 runner    (1001) docker     (123)     6135 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/CMakeLists.txt
+-rw-rw-r--   0 runner    (1001) docker     (123)     6043 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/common.fypp
+-rw-rw-r--   0 runner    (1001) docker     (123)    63162 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_anneal.f90
+-rwxrwxr-x   0 runner    (1001) docker     (123)    82363 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_append.f90
+-rw-rw-r--   0 runner    (1001) docker     (123)    10208 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_boxcox.f90
+-rw-rw-r--   0 runner    (1001) docker     (123)    26665 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_cli.f90
+-rw-rw-r--   0 runner    (1001) docker     (123)     8341 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_constants.f90
+-rw-rw-r--   0 runner    (1001) docker     (123)     5884 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_corr.f90
+-rw-rw-r--   0 runner    (1001) docker     (123)     8256 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_cost.f90
+-rw-rw-r--   0 runner    (1001) docker     (123)    29283 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_dds.F90
+-rwxrwxr-x   0 runner    (1001) docker     (123)     7069 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_eckhardt_filter.f90
+-rw-rw-r--   0 runner    (1001) docker     (123)   108187 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_errormeasures.f90
+-rw-rw-r--   0 runner    (1001) docker     (123)     1189 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_forces_info.F90
+-rw-rw-r--   0 runner    (1001) docker     (123)     4194 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_integrate.f90
+-rwxrwxr-x   0 runner    (1001) docker     (123)     4595 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_io.f90
+-rw-rw-r--   0 runner    (1001) docker     (123)    46860 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_julian.f90
+-rw-rw-r--   0 runner    (1001) docker     (123)   100621 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_kernel.f90
+-rwxrwxr-x   0 runner    (1001) docker     (123)     1938 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_kind.F90
+-rw-rw-r--   0 runner    (1001) docker     (123)    10027 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_likelihood.f90
+-rw-rw-r--   0 runner    (1001) docker     (123)     9634 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_linfit.f90
+-rw-rw-r--   0 runner    (1001) docker     (123)    18985 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_logging.F90
+-rwxrwxr-x   0 runner    (1001) docker     (123)    13550 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_mad.f90
+-rw-rw-r--   0 runner    (1001) docker     (123)    96122 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_mcmc.F90
+-rwxrwxr-x   0 runner    (1001) docker     (123)     8159 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_message.F90
+-rw-rw-r--   0 runner    (1001) docker     (123)    60328 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_moment.f90
+-rw-rw-r--   0 runner    (1001) docker     (123)    76853 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_ncread.f90
+-rw-rw-r--   0 runner    (1001) docker     (123)   226283 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_ncwrite.f90
+-rw-rw-r--   0 runner    (1001) docker     (123)    50501 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_nelmin.f90
+-rw-rw-r--   0 runner    (1001) docker     (123)   144318 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_netcdf.f90
+-rw-rw-r--   0 runner    (1001) docker     (123)    43779 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_netcdf.fypp
+-rw-rw-r--   0 runner    (1001) docker     (123)     8951 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_nml.f90
+-rw-rw-r--   0 runner    (1001) docker     (123)   149983 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_opt_functions.f90
+-rw-rw-r--   0 runner    (1001) docker     (123)     5170 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_optimization_types.f90
+-rw-rw-r--   0 runner    (1001) docker     (123)     2250 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_optimization_utils.f90
+-rwxrwxr-x   0 runner    (1001) docker     (123)   512630 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_orderpack.f90
+-rw-rw-r--   0 runner    (1001) docker     (123)    25021 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_os.F90
+-rw-rw-r--   0 runner    (1001) docker     (123)    29913 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_percentile.f90
+-rw-rw-r--   0 runner    (1001) docker     (123)    28928 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_poly.f90
+-rw-rw-r--   0 runner    (1001) docker     (123)    15825 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_poly.fypp
+-rw-rw-r--   0 runner    (1001) docker     (123)    85244 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_sce.F90
+-rw-rw-r--   0 runner    (1001) docker     (123)    12731 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_sentinel.f90
+-rw-rw-r--   0 runner    (1001) docker     (123)     6566 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_sentinel.fypp
+-rw-rw-r--   0 runner    (1001) docker     (123)    26920 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_spatialsimilarity.f90
+-rw-rw-r--   0 runner    (1001) docker     (123)    14766 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_standard_score.f90
+-rwxrwxr-x   0 runner    (1001) docker     (123)    24807 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_string_utils.f90
+-rw-rw-r--   0 runner    (1001) docker     (123)    10445 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_temporal_aggregation.f90
+-rw-rw-r--   0 runner    (1001) docker     (123)    11110 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_timer.f90
+-rwxrwxr-x   0 runner    (1001) docker     (123)    56689 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_utils.F90
+-rw-rw-r--   0 runner    (1001) docker     (123)    67143 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/src/mo_xor4096.f90
+-rw-rw-r--   0 runner    (1001) docker     (123)        6 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/version.txt
+-rw-rw-r--   0 runner    (1001) docker     (123)        9 2023-03-17 12:42:15.000000 mhm-5.13.0/forces/version_date.txt
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-01 07:33:43.570932 mhm-5.13.0/pybind/
+-rw-r--r--   0 runner    (1001) docker     (123)     4221 2023-06-01 07:33:19.000000 mhm-5.13.0/pybind/README.md
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-01 07:33:43.570932 mhm-5.13.0/pybind/examples/
+-rw-r--r--   0 runner    (1001) docker     (123)      318 2023-06-01 07:33:19.000000 mhm-5.13.0/pybind/examples/01_simple_run.py
+-rw-r--r--   0 runner    (1001) docker     (123)      623 2023-06-01 07:33:19.000000 mhm-5.13.0/pybind/examples/02_time_steps.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1287 2023-06-01 07:33:19.000000 mhm-5.13.0/pybind/examples/03_plot.py
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-06-01 07:33:19.000000 mhm-5.13.0/pybind/examples/04_grid_info.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3954 2023-06-01 07:33:19.000000 mhm-5.13.0/pybind/examples/05_spotpy_optimization.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-01 07:33:43.570932 mhm-5.13.0/pybind/mhm/
+-rw-r--r--   0 runner    (1001) docker     (123)      228 2023-06-01 07:33:19.000000 mhm-5.13.0/pybind/mhm/.f2py_f2cmap
+-rw-r--r--   0 runner    (1001) docker     (123)     2763 2023-06-01 07:33:19.000000 mhm-5.13.0/pybind/mhm/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1560 2023-06-01 07:33:19.000000 mhm-5.13.0/pybind/mhm/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)       22 2023-06-01 07:33:41.000000 mhm-5.13.0/pybind/mhm/_version.py
+-rw-r--r--   0 runner    (1001) docker     (123)      553 2023-06-01 07:33:19.000000 mhm-5.13.0/pybind/mhm/cli.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4088 2023-06-01 07:33:19.000000 mhm-5.13.0/pybind/mhm/download.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2843 2023-06-01 07:33:19.000000 mhm-5.13.0/pybind/mhm/tools.py
+-rw-r--r--   0 runner    (1001) docker     (123)    31416 2023-06-01 07:33:19.000000 mhm-5.13.0/pybind/mhm/wrapper.f90
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-01 07:33:43.570932 mhm-5.13.0/pybind/mhm.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (123)     5890 2023-06-01 07:33:42.000000 mhm-5.13.0/pybind/mhm.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)     5347 2023-06-01 07:33:43.000000 mhm-5.13.0/pybind/mhm.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-06-01 07:33:42.000000 mhm-5.13.0/pybind/mhm.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       68 2023-06-01 07:33:42.000000 mhm-5.13.0/pybind/mhm.egg-info/entry_points.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-06-01 07:33:40.000000 mhm-5.13.0/pybind/mhm.egg-info/not-zip-safe
+-rw-r--r--   0 runner    (1001) docker     (123)       14 2023-06-01 07:33:42.000000 mhm-5.13.0/pybind/mhm.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        4 2023-06-01 07:33:42.000000 mhm-5.13.0/pybind/mhm.egg-info/top_level.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     2775 2023-06-01 07:33:19.000000 mhm-5.13.0/pyproject.toml
+-rw-r--r--   0 runner    (1001) docker     (123)       38 2023-06-01 07:33:43.582932 mhm-5.13.0/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (123)     2838 2023-06-01 07:33:19.000000 mhm-5.13.0/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-01 07:33:43.570932 mhm-5.13.0/src/
+-rw-r--r--   0 runner    (1001) docker     (123)     3151 2023-06-01 07:33:19.000000 mhm-5.13.0/src/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-01 07:33:43.574932 mhm-5.13.0/src/MPR/
+-rw-r--r--   0 runner    (1001) docker     (123)     3894 2023-06-01 07:33:19.000000 mhm-5.13.0/src/MPR/mo_mpr_constants.f90
+-rw-r--r--   0 runner    (1001) docker     (123)     7616 2023-06-01 07:33:19.000000 mhm-5.13.0/src/MPR/mo_mpr_eval.f90
+-rw-r--r--   0 runner    (1001) docker     (123)     3540 2023-06-01 07:33:19.000000 mhm-5.13.0/src/MPR/mo_mpr_file.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    12845 2023-06-01 07:33:19.000000 mhm-5.13.0/src/MPR/mo_mpr_global_variables.f90
+-rwxr-xr-x   0 runner    (1001) docker     (123)    10088 2023-06-01 07:33:19.000000 mhm-5.13.0/src/MPR/mo_mpr_neutrons.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    17900 2023-06-01 07:33:19.000000 mhm-5.13.0/src/MPR/mo_mpr_pet.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    47490 2023-06-01 07:33:19.000000 mhm-5.13.0/src/MPR/mo_mpr_read_config.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    21082 2023-06-01 07:33:19.000000 mhm-5.13.0/src/MPR/mo_mpr_restart.f90
+-rw-r--r--   0 runner    (1001) docker     (123)     8040 2023-06-01 07:33:19.000000 mhm-5.13.0/src/MPR/mo_mpr_runoff.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    34097 2023-06-01 07:33:19.000000 mhm-5.13.0/src/MPR/mo_mpr_smhorizons.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    30660 2023-06-01 07:33:19.000000 mhm-5.13.0/src/MPR/mo_mpr_soilmoist.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    19484 2023-06-01 07:33:19.000000 mhm-5.13.0/src/MPR/mo_mpr_startup.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    55376 2023-06-01 07:33:19.000000 mhm-5.13.0/src/MPR/mo_multi_param_reg.f90
+-rw-r--r--   0 runner    (1001) docker     (123)     8609 2023-06-01 07:33:19.000000 mhm-5.13.0/src/MPR/mo_prepare_gridded_lai.f90
+-rw-r--r--   0 runner    (1001) docker     (123)     6894 2023-06-01 07:33:19.000000 mhm-5.13.0/src/MPR/mo_read_lut.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    17891 2023-06-01 07:33:19.000000 mhm-5.13.0/src/MPR/mo_read_wrapper.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    19902 2023-06-01 07:33:19.000000 mhm-5.13.0/src/MPR/mo_soil_database.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    24240 2023-06-01 07:33:19.000000 mhm-5.13.0/src/MPR/mo_upscaling_operators.f90
+-rw-r--r--   0 runner    (1001) docker     (123)     4364 2023-06-01 07:33:19.000000 mhm-5.13.0/src/MPR/mpr_driver.F90
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-01 07:33:43.574932 mhm-5.13.0/src/common/
+-rw-r--r--   0 runner    (1001) docker     (123)     2948 2023-06-01 07:33:19.000000 mhm-5.13.0/src/common/mo_check.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    16769 2023-06-01 07:33:19.000000 mhm-5.13.0/src/common/mo_clean_up.f90
+-rw-r--r--   0 runner    (1001) docker     (123)     3320 2023-06-01 07:33:19.000000 mhm-5.13.0/src/common/mo_common_MPI_tools.F90
+-rw-r--r--   0 runner    (1001) docker     (123)     1853 2023-06-01 07:33:19.000000 mhm-5.13.0/src/common/mo_common_constants.f90
+-rw-r--r--   0 runner    (1001) docker     (123)     6747 2023-06-01 07:33:19.000000 mhm-5.13.0/src/common/mo_common_datetime_type.f90
+-rw-r--r--   0 runner    (1001) docker     (123)     1301 2023-06-01 07:33:19.000000 mhm-5.13.0/src/common/mo_common_file.f90
+-rw-r--r--   0 runner    (1001) docker     (123)     1568 2023-06-01 07:33:19.000000 mhm-5.13.0/src/common/mo_common_functions.f90
+-rw-r--r--   0 runner    (1001) docker     (123)     1221 2023-06-01 07:33:19.000000 mhm-5.13.0/src/common/mo_common_mHM_mRM_file.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    13654 2023-06-01 07:33:19.000000 mhm-5.13.0/src/common/mo_common_mHM_mRM_read_config.f90
+-rw-r--r--   0 runner    (1001) docker     (123)     6233 2023-06-01 07:33:19.000000 mhm-5.13.0/src/common/mo_common_mHM_mRM_variables.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    21829 2023-06-01 07:33:19.000000 mhm-5.13.0/src/common/mo_common_read_config.F90
+-rw-r--r--   0 runner    (1001) docker     (123)     6636 2023-06-01 07:33:19.000000 mhm-5.13.0/src/common/mo_common_read_data.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    16057 2023-06-01 07:33:19.000000 mhm-5.13.0/src/common/mo_common_restart.f90
+-rw-r--r--   0 runner    (1001) docker     (123)     4565 2023-06-01 07:33:19.000000 mhm-5.13.0/src/common/mo_common_run_variables.f90
+-rw-r--r--   0 runner    (1001) docker     (123)     5477 2023-06-01 07:33:19.000000 mhm-5.13.0/src/common/mo_common_types.F90
+-rw-r--r--   0 runner    (1001) docker     (123)     9550 2023-06-01 07:33:19.000000 mhm-5.13.0/src/common/mo_common_variables.F90
+-rw-r--r--   0 runner    (1001) docker     (123)    17997 2023-06-01 07:33:19.000000 mhm-5.13.0/src/common/mo_grid.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    20244 2023-06-01 07:33:19.000000 mhm-5.13.0/src/common/mo_nc_output.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    11037 2023-06-01 07:33:19.000000 mhm-5.13.0/src/common/mo_optimization.F90
+-rw-r--r--   0 runner    (1001) docker     (123)     4784 2023-06-01 07:33:19.000000 mhm-5.13.0/src/common/mo_read_latlon.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    29094 2023-06-01 07:33:19.000000 mhm-5.13.0/src/common/mo_read_nc.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    14409 2023-06-01 07:33:19.000000 mhm-5.13.0/src/common/mo_read_spatial_data.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    10018 2023-06-01 07:33:19.000000 mhm-5.13.0/src/common/mo_read_timeseries.f90
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-01 07:33:43.578932 mhm-5.13.0/src/mHM/
+-rw-r--r--   0 runner    (1001) docker     (123)     3813 2023-06-01 07:33:19.000000 mhm-5.13.0/src/mHM/mhm_driver.f90
+-rw-r--r--   0 runner    (1001) docker     (123)     4447 2023-06-01 07:33:19.000000 mhm-5.13.0/src/mHM/mo_canopy_interc.f90
+-rw-r--r--   0 runner    (1001) docker     (123)     2188 2023-06-01 07:33:19.000000 mhm-5.13.0/src/mHM/mo_file.F90
+-rw-r--r--   0 runner    (1001) docker     (123)     9225 2023-06-01 07:33:19.000000 mhm-5.13.0/src/mHM/mo_global_variables.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    13327 2023-06-01 07:33:19.000000 mhm-5.13.0/src/mHM/mo_init_states.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    27116 2023-06-01 07:33:19.000000 mhm-5.13.0/src/mHM/mo_mhm.f90
+-rw-r--r--   0 runner    (1001) docker     (123)     3212 2023-06-01 07:33:19.000000 mhm-5.13.0/src/mHM/mo_mhm_bfi.f90
+-rw-r--r--   0 runner    (1001) docker     (123)     4555 2023-06-01 07:33:19.000000 mhm-5.13.0/src/mHM/mo_mhm_cli.f90
+-rw-r--r--   0 runner    (1001) docker     (123)     2997 2023-06-01 07:33:19.000000 mhm-5.13.0/src/mHM/mo_mhm_constants.f90
+-rw-r--r--   0 runner    (1001) docker     (123)     7572 2023-06-01 07:33:19.000000 mhm-5.13.0/src/mHM/mo_mhm_eval.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    16823 2023-06-01 07:33:19.000000 mhm-5.13.0/src/mHM/mo_mhm_interface.F90
+-rw-r--r--   0 runner    (1001) docker     (123)    38831 2023-06-01 07:33:19.000000 mhm-5.13.0/src/mHM/mo_mhm_interface_run.f90
+-rw-r--r--   0 runner    (1001) docker     (123)     6695 2023-06-01 07:33:19.000000 mhm-5.13.0/src/mHM/mo_mhm_messages.F90
+-rw-r--r--   0 runner    (1001) docker     (123)    16084 2023-06-01 07:33:19.000000 mhm-5.13.0/src/mHM/mo_mhm_read_config.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    32833 2023-06-01 07:33:19.000000 mhm-5.13.0/src/mHM/mo_neutrons.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    99329 2023-06-01 07:33:19.000000 mhm-5.13.0/src/mHM/mo_objective_function.F90
+-rw-r--r--   0 runner    (1001) docker     (123)    16675 2023-06-01 07:33:19.000000 mhm-5.13.0/src/mHM/mo_pet.f90
+-rw-r--r--   0 runner    (1001) docker     (123)     4060 2023-06-01 07:33:19.000000 mhm-5.13.0/src/mHM/mo_read_optional_data.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    29282 2023-06-01 07:33:19.000000 mhm-5.13.0/src/mHM/mo_restart.f90
+-rw-r--r--   0 runner    (1001) docker     (123)     9288 2023-06-01 07:33:19.000000 mhm-5.13.0/src/mHM/mo_runoff.f90
+-rw-r--r--   0 runner    (1001) docker     (123)     5109 2023-06-01 07:33:19.000000 mhm-5.13.0/src/mHM/mo_snow_accum_melt.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    17737 2023-06-01 07:33:19.000000 mhm-5.13.0/src/mHM/mo_soil_moisture.f90
+-rw-r--r--   0 runner    (1001) docker     (123)     6118 2023-06-01 07:33:19.000000 mhm-5.13.0/src/mHM/mo_startup.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    25998 2023-06-01 07:33:19.000000 mhm-5.13.0/src/mHM/mo_write_ascii.f90
+-rwxr-xr-x   0 runner    (1001) docker     (123)    17226 2023-06-01 07:33:19.000000 mhm-5.13.0/src/mHM/mo_write_fluxes_states.f90
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-01 07:33:43.578932 mhm-5.13.0/src/mRM/
+-rw-r--r--   0 runner    (1001) docker     (123)     2424 2023-06-01 07:33:19.000000 mhm-5.13.0/src/mRM/mo_mrm_constants.F90
+-rw-r--r--   0 runner    (1001) docker     (123)     4125 2023-06-01 07:33:19.000000 mhm-5.13.0/src/mRM/mo_mrm_file.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    14454 2023-06-01 07:33:19.000000 mhm-5.13.0/src/mRM/mo_mrm_global_variables.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    24079 2023-06-01 07:33:19.000000 mhm-5.13.0/src/mRM/mo_mrm_init.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    10136 2023-06-01 07:33:19.000000 mhm-5.13.0/src/mRM/mo_mrm_mpr.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    79856 2023-06-01 07:33:19.000000 mhm-5.13.0/src/mRM/mo_mrm_net_startup.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    91765 2023-06-01 07:33:19.000000 mhm-5.13.0/src/mRM/mo_mrm_objective_function_runoff.F90
+-rw-r--r--   0 runner    (1001) docker     (123)    17876 2023-06-01 07:33:19.000000 mhm-5.13.0/src/mRM/mo_mrm_pre_routing.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    22535 2023-06-01 07:33:19.000000 mhm-5.13.0/src/mRM/mo_mrm_read_config.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    20445 2023-06-01 07:33:19.000000 mhm-5.13.0/src/mRM/mo_mrm_read_data.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    31005 2023-06-01 07:33:19.000000 mhm-5.13.0/src/mRM/mo_mrm_restart.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    31812 2023-06-01 07:33:19.000000 mhm-5.13.0/src/mRM/mo_mrm_riv_temp_class.f90
+-rw-r--r--   0 runner    (1001) docker     (123)     6008 2023-06-01 07:33:19.000000 mhm-5.13.0/src/mRM/mo_mrm_river_head.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    22114 2023-06-01 07:33:19.000000 mhm-5.13.0/src/mRM/mo_mrm_routing.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    40775 2023-06-01 07:33:19.000000 mhm-5.13.0/src/mRM/mo_mrm_signatures.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    44729 2023-06-01 07:33:19.000000 mhm-5.13.0/src/mRM/mo_mrm_write.f90
+-rw-r--r--   0 runner    (1001) docker     (123)     7011 2023-06-01 07:33:19.000000 mhm-5.13.0/src/mRM/mo_mrm_write_fluxes_states.f90
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-01 07:33:43.578932 mhm-5.13.0/src/meteo/
+-rw-r--r--   0 runner    (1001) docker     (123)    50973 2023-06-01 07:33:19.000000 mhm-5.13.0/src/meteo/mo_meteo_handler.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    18696 2023-06-01 07:33:19.000000 mhm-5.13.0/src/meteo/mo_meteo_helper.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    12168 2023-06-01 07:33:19.000000 mhm-5.13.0/src/meteo/mo_meteo_spatial_tools.f90
+-rw-r--r--   0 runner    (1001) docker     (123)     5799 2023-06-01 07:33:19.000000 mhm-5.13.0/src/meteo/mo_meteo_temporal_tools.f90
+-rw-r--r--   0 runner    (1001) docker     (123)        7 2023-06-01 07:33:19.000000 mhm-5.13.0/version.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        9 2023-06-01 07:33:19.000000 mhm-5.13.0/version_date.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        7 2023-06-01 07:33:19.000000 mhm-5.13.0/version_forces.txt
```

### Comparing `mhm-5.12.1.dev21/CMakeLists.txt` & `mhm-5.13.0/CMakeLists.txt`

 * *Files 18% similar despite different names*

```diff
@@ -1,26 +1,25 @@
 # mHM cmake script
 cmake_minimum_required(VERSION 3.14)
 # get version and date from files (version.txt and version_date.txt)
-include(cmake/cmake-modules/version.cmake)
+include(cmake/version.cmake)
 get_version(MHM_VER MHM_VER_DEV MHM_DATE)
 # create the project
 project(mhm
   VERSION ${MHM_VER}
   DESCRIPTION "The mesoscale Hydrological Model"
   HOMEPAGE_URL "https://www.ufz.de/mhm"
   LANGUAGES Fortran
 )
 
 option(BUILD_MHM_DRIVER "Build mHM with executable driver." ON)
 option(BUILD_MHM_PYBIND "Build mHM python bindings." OFF)
 
 if(BUILD_MHM_PYBIND)
   set(BUILD_MHM_LIB_SHARED ON)
-  set(BUILD_MHM_DRIVER ON)
 endif()
 
 add_subdirectory(src)
 
 if(BUILD_MHM_DRIVER)
   add_executable(mhm src/mHM/mhm_driver.f90)
   target_link_libraries(mhm PRIVATE mhm_lib)
@@ -37,30 +36,31 @@
 # add full version and date to pre-processor flags (qoutes need in before hand)
 target_compile_definitions(mhm_lib PRIVATE
   MHMVERSION='${MHM_VER_DEV}'
   MHMDATE='${MHM_DATE}'
 )
 
 # setup coverage with GNU
-if(CMAKE_Fortran_COMPILER_ID MATCHES "GNU" AND CMAKE_WITH_COVERAGE)
-  include(cmake/cmake-modules/CodeCoverage.cmake)
+if(CMAKE_Fortran_COMPILER_ID MATCHES "GNU" AND CMAKE_WITH_COVERAGE AND EXISTS "CI-scripts")
+  message(STATUS "mHM: add coverage")
+  include(cmake/CodeCoverage.cmake)
   append_coverage_compiler_flags_to_target(mhm_lib)
   append_coverage_compiler_flags_to_target(mhm)
   SETUP_TARGET_FOR_COVERAGE_LCOV(
     NAME mhm_coverage_CI
     EXECUTABLE ../CI-scripts/run_cmake_coverage.sh
     DEPENDENCIES mhm mhm_lib
     GENHTML_ARGS -t "mHM coverage" --html-prolog ../doc/html_files/cov_header.prolog
   )
 endif()
 # automatically enable testing (OFF by default)
 option(BUILD_TESTING "Build with pfUnit tests." OFF)
 include(CTest)
 # add pfunit test folder
-if(BUILD_TESTING)
+if(BUILD_TESTING AND EXISTS "src/tests")
   add_subdirectory(src/tests)
 endif()
 
 # With this, paths are added to the INSTALL_RPATH, and via the second command also to the build.
 if (CMAKE_BUILD_MODULE_SYSTEM_INDEPENDENT)
   set_target_properties(mhm
     PROPERTIES
```

### Comparing `mhm-5.12.1.dev21/LICENSE` & `mhm-5.13.0/COPYING`

 * *Files 10% similar despite different names*

```diff
@@ -1,205 +1,11 @@
-==============
-SOFTWARE LICENCE
-==============
-
-This file is part of the UFZ CHS mesoscale hydrologic model mHM which
-is a spatially explicit distributed hydrologic model that uses grid
-cells as a primary hydrologic unit.
-
-
-------------------
-
-Copyright(c) 2005-2021,
-Helmholtz-Zentrum fuer Umweltforschung GmbH - UFZ.
-All rights reserved.
-
-The code is a property of:
-
-Helmholtz-Zentrum fuer Umweltforschung GmbH - UFZ
-Registered Office: Leipzig
-Registration Office: Amtsgericht Leipzig
-Trade Register: Nr. B 4703
-Chairman of the Supervisory Board: MinDirig Wilfried Kraus
-Scientific Director: Prof. Dr. Dr. h.c. Georg Teutsch
-Administrative Director: Dr. Heike Grassmann
-
-------------------
-
-
-The UFZ CHS mesoscale hydrologic model mHM is free software. You can
-redistribute it and/or modify it under the terms of the GNU General
-Public License as published by the free Software Foundation either
-version 3 of the License, or (at your option) any later version.
-
-
-This program is distributed in the hope that it will be useful, but
-WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-See the GNU General Public License for more details.
-
-
-You received a copy of the GNU Lesser General Public License along
-with the UFZ CHS mesoscale hydrologic model mHM. It can be found
-in the section "GNU General Public License" in this document. The
-complete GNU license text can also be found at
-<http://www.gnu.org/licenses/>.
-
-
-==============
-Contact
-==============
-
-Dr. Luis Samaniego
-Dr. Rohini Kumar
-Department Computational Hydrosystems
-
-Mail: Permoserstrasse 15, 04318 Leipzig, Germany
-E-mail: luis.samaniego@ufz.de
-E-mail: rohini.kumar@ufz.de
-
-
-==============
-Redistribution
-==============
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions
-are met:
-
-*  Redistributions of source code must retain the above
-   copyright notice, this list of conditions, the following disclaimer
-   and the modification conditions.
-*  Redistributions in binary form must reproduce the above copyright
-   notice, this list of conditions, the following disclaimer and the
-   modification conditions in the documentation and/or other materials
-   provided with the distribution.
-*  Neither the name of Helmholtz-Zentrum fuer Umweltforschung GmbH -
-   UFZ, nor the names of its contributors may be used to endorse or
-   promote products derived from this software without specific prior
-   written permission.
-*  Redistributions of source code are allowed for research purposes
-   ONLY. For commercial applications you need to consult the
-   authorities of the UFZ.
-
-
-==============
-Modification
-==============
-
-If software is modified to produce derivative works, such modified
-software should be clearly marked, so as not to confuse it with the
-version available from UFZ. The following sources are to be
-acknowledged:
-
-*   Samaniego L., R. Kumar, S. Attinger (2010): Multiscale parameter
-    regionalization of a grid-based hydrologic model at the mesoscale.
-    Water Resour. Res., 46,W05523, doi:10.1029/2008WR007327.
-*   Kumar, R., L. Samaniego, and S. Attinger(2013): Implications of
-    distributed hydrologic model parameterization on water fluxes at
-    multiple scales and locations, Water Resour. Res., 49,
-    doi:10.1029/2012WR012195.
-
-
-==============
-Disclaimer of Warranty
-==============
-
-THERE IS NO WARRANTY FOR THIS SOFTWARE, TO THE EXTENT PERMITTED BY
-APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE
-HELMHOLTZ-ZENTRUM FUER UMWELTFORSCHUNG GMBH - UFZ AND CONTRIBUTORS
-PROVIDE THIS SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
-EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
-THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS
-WITH YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF
-ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
-
-
-==============
-Limitation of Liability
-==============
-
-IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL THE HELMHOLTZ-ZENTRUM FUER UMWELTFORSCHUNG GMBH - UFZ AND
-CONTRIBUTORS OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE
-SOFTWARE AS PERMITTED BY GNU GENERAL PUBLIC LICENSE, BE LIABLE FOR
-DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL
-DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE SOFTWARE
-(INCLUDING BUT NOT LIMITED TO LOSS OF DATA, OR DATA BEING RENDERED
-INACCURATE OR LOSSES SUSTAINED BY THE USER OR THIRD PARTIES OR A
-FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER PROGRAMS),  EVEN IF
-ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-
-==============
-Redistribution of Example Data
-==============
-
-The example data provided with the UFZ CHS mesoscale hydrologic model
-mHM are strictly for use in non-commercial research and non-commercial
-education projects only. They are not to be redistributed or used
-without the consideration of the licenses they were originally provided
-under. The following list acknowledges the providers of the example
-data for mHM and links to the licenses the data was provided under.
-
--- E-OBS gridded dataset
-**  We acknowledge the E-OBS dataset for temperature and precipitation
-    from the EU-FP6 project ENSEMBLES
-    (http://ensembles-eu.metoffice.com) and the data providers in the
-    ECA&D project (http://www.ecad.eu)
-
-**  Haylock, M.R., N. Hofstra, A.M.G. Klein Tank, E.J. Klok,
-    P.D. Jones, M. New. 2008: A European daily high-resolution gridded
-    dataset of surface temperature and precipitation.
-    J. Geophys. Res (Atmospheres), 113, D20119, doi:10.1029/2008JD10201
-
-**  http://www.ecad.eu/download/ensembles/ensembles.php (08.04.2014)
-
-
--- Harmonized World Soil Database
-**  We acknowledge the Harmonized World Soil Database dataset of the
-    Food and Agriculture Organization of the United Nations (FAO), the
-    International Institute for Applied Systems Analysis (IIASA),
-    International Soil Reference and Information Centre (ISRIC),
-    Institute of Soil Science at Chinese Academy of Sciences (ISSCAS)
-    and Joint Research Centre of the European Commission (JRC) for
-    providing the soil data.
-
-**  FAO/IIASA/ISRIC/ISSCAS/JRC, 2012. Harmonized World Soil Database
-    (version 1.2). FAO, Rome, Italy and IIASA, Laxenburg, Austria.
-
-**  http://webarchive.iiasa.ac.at/Research/LUC/External-World-soil-
-    database/HTML/ (08.04.2014)
-
-
--- SRTM
-**  We acknowledge the U.S. Geological Survey's Earth Resources
-    Observation and Science (EROS) Center and NASA's Land Processes
-    Distributed Active Archive Center (LP DAAC) for providing the
-    digital elevation model.
-
-**  https://lta.cr.usgs.gov/citation (08.04.2014)
-
-
--- European Soil Database
-**  We acknowledge the European Commission for providing
-    hydrogeological data.
-
-**  http://ec.europa.eu/geninfo/legal_notices_en.htm (08.04.2014)
-
-
-==============
-GNU General Public License
-==============
-
                     GNU GENERAL PUBLIC LICENSE
                        Version 3, 29 June 2007
 
- Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
+ Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
  Everyone is permitted to copy and distribute verbatim copies
  of this license document, but changing it is not allowed.
 
                             Preamble
 
   The GNU General Public License is a free, copyleft license for
 software and other kinds of works.
@@ -835,15 +641,15 @@
 
     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
 
     You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+    along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 Also add information on how to contact you by electronic and paper mail.
 
   If the program does terminal interaction, make it output a short
 notice like this when it starts in an interactive mode:
 
     <program>  Copyright (C) <year>  <name of author>
@@ -854,18 +660,15 @@
 The hypothetical commands `show w' and `show c' should show the appropriate
 parts of the General Public License.  Of course, your program's commands
 might be different; for a GUI interface, you would use an "about box".
 
   You should also get your employer (if you work as a programmer) or school,
 if any, to sign a "copyright disclaimer" for the program, if necessary.
 For more information on this, and how to apply and follow the GNU GPL, see
-<http://www.gnu.org/licenses/>.
+<https://www.gnu.org/licenses/>.
 
   The GNU General Public License does not permit incorporating your program
 into proprietary programs.  If your program is a subroutine library, you
 may consider it more useful to permit linking proprietary applications with
 the library.  If this is what you want to do, use the GNU Lesser General
 Public License instead of this License.  But first, please read
-<http://www.gnu.org/philosophy/why-not-lgpl.html>.
-
-
-
+<https://www.gnu.org/licenses/why-not-lgpl.html>.
```

### Comparing `mhm-5.12.1.dev21/cmake/LICENSE` & `mhm-5.13.0/COPYING.LESSER`

 * *Files identical despite different names*

### Comparing `mhm-5.12.1.dev21/cmake/cmake-modules/CPM.cmake` & `mhm-5.13.0/cmake/CPM.cmake`

 * *Files 0% similar despite different names*

```diff
@@ -24,15 +24,15 @@
   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   SOFTWARE.
 ]]
 
 cmake_minimum_required(VERSION 3.14 FATAL_ERROR)
 
-set(CURRENT_CPM_VERSION 0.35.6)
+set(CURRENT_CPM_VERSION 0.36.0)
 
 get_filename_component(CPM_CURRENT_DIRECTORY "${CMAKE_CURRENT_LIST_DIR}" REALPATH)
 if(CPM_DIRECTORY)
   if(NOT CPM_DIRECTORY STREQUAL CPM_CURRENT_DIRECTORY)
     if(CPM_VERSION VERSION_LESS CURRENT_CPM_VERSION)
       message(
         AUTHOR_WARNING
@@ -804,14 +804,18 @@
       "${${name}_BINARY_DIR}"
       PARENT_SCOPE
   )
   set(${name}_ADDED
       "${${name}_ADDED}"
       PARENT_SCOPE
   )
+  set(CPM_LAST_PACKAGE_NAME
+      "${name}"
+      PARENT_SCOPE
+  )
 endmacro()
 
 # declares a package, so that any call to CPMAddPackage for the package name will use these
 # arguments instead. Previous declarations will not be overridden.
 macro(CPMDeclarePackage Name)
   if(NOT DEFINED "CPM_DECLARATION_${Name}")
     set("CPM_DECLARATION_${Name}" "${ARGN}")
```

### Comparing `mhm-5.12.1.dev21/cmake/cmake-modules/CodeCoverage.cmake` & `mhm-5.13.0/cmake/CodeCoverage.cmake`

 * *Files identical despite different names*

### Comparing `mhm-5.12.1.dev21/pybind/mhm/tools.py` & `mhm-5.13.0/pybind/mhm/tools.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,32 +1,63 @@
-"""Tools to interact with mHM."""
+"""!
+Tools to interact with mHM.
+
+@copyright Copyright 2005-@today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+    mHM is released under the LGPLv3+ license @license_note
+@ingroup mhm
+"""
 import numpy as np
 
 from .wrapper import get
 
 
+def get_parameter():
+    """
+    Get parameter names and configuration.
+
+    @retval names (List[Str]): Names of all used parameters in mHM.
+    @retval config (numpy.ndarray): Configuration for all used parameters (min, max, value, flag, scale).
+    """
+    para_n = get.parameter_length()
+    names = [
+        get.parameter_name(i).decode("utf-8").strip() for i in range(1, para_n + 1)
+    ]
+    config = get.parameter_config(para_n)
+    return names, config
+
+
 def get_runoff():
     """
     Get 2D array of runoff time-series for all gauges.
 
     @retval runoff (numpy.ndarray): The runoff for all gauges with dims (time, gauge).
     """
     shp = get.runoff_shape()
     return get.runoff(*shp)
 
 
-def get_variable(name, index=1, indexing="xy"):
+def get_runoff_eval(gauge_id):
+    """
+    Get 2D array of simulated and observed runoff time-series for selected gauges.
+
+    @retval runoff (numpy.ndarray(TS, 2)): The runoff for selected gauges with dims (time-steps, 2).
+    """
+    length = get.runoff_eval_length(gauge_id)
+    return get.runoff_eval(gauge_id, length)
+
+
+def get_variable(name, index=1, indexing="ij"):
     """
     Get a specific variable from mHM in the current time-step.
 
     @param name (str): Name of the variable
     @param index (int, optional): If the variable has an additional dimension,
         one needs to specify an index, by default 1
     @param indexing (str, optional): Indexing for the 2D variable,
-        either "xy" or "ij", by default "xy"
+        either "xy" or "ij", by default "ij"
     @retval variable (numpy.ndarray): Numpy array holding the desired variable.
     @throws ValueError: If the variable name doesn't start with "L0", "L1", "L11" or "L2".
     """
     name = name.upper()  # convention
     grid = name.split("_")[0].lower()
     if grid not in ["l0", "l1", "l11", "l2"]:
         raise ValueError(f"Unknown variable: {name}")
@@ -39,9 +70,9 @@
     var = getattr(get, grid + "_variable")(name=name, n=n, idx=index)
     # reshaping
     mask = mask.ravel(order="F")
     output = np.ma.empty_like(mask, dtype=float)
     output.fill_value = grid_info[-1]
     output.mask = ~mask
     output[mask] = var
-    output = output.reshape((grid_info[1], grid_info[0]), order="F")
-    return output.T if indexing == "ij" else output
+    output = output.reshape((grid_info[0], grid_info[1]), order="C")
+    return output.T if indexing == "xy" else output
```

### Comparing `mhm-5.12.1.dev21/pybind/mhm/wrapper.f90` & `mhm-5.13.0/pybind/mhm/wrapper.f90`

 * *Files 22% similar despite different names*

```diff
@@ -1,35 +1,65 @@
 !> \file    wrapper.f90
 !> \brief   Module to wrap mHM with f2py to control it with Python.
 !> \authors Sebastian Mueller
 !> \date    Nov 2022
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
 
 !> \brief   Python wrapper module to control a mHM model.
+!> \date    Nov 2022
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup mhm
 module model
+  use mo_kind, only : i4, dp
   implicit none
 contains
   !> \brief Initialize a mHM model.
   subroutine init(namelist_mhm, namelist_mhm_param, namelist_mhm_output, namelist_mrm_output, cwd)
     use mo_mhm_interface, only: mhm_interface_init
     implicit none
     character(*), intent(in) :: namelist_mhm !< path to mHM configuration namelist
+    !f2py character(*) :: namelist_mhm = "mhm.nml"
     character(*), intent(in) :: namelist_mhm_param !< path to mHM parameter namelist
+    !f2py character(*) :: namelist_mhm_param = "mhm_parameter.nml"
     character(*), intent(in) :: namelist_mhm_output !< path to mHM output namelist
+    !f2py character(*) :: namelist_mhm_output = "mhm_outputs.nml"
     character(*), intent(in) :: namelist_mrm_output !< path to mRM output namelist
+    !f2py character(*) :: namelist_mrm_output = "mrm_outputs.nml"
     character(*), intent(in) :: cwd !< desired working directory
+    !f2py character(*) :: cwd = "."
     call mhm_interface_init(namelist_mhm, namelist_mhm_param, namelist_mhm_output, namelist_mrm_output, cwd)
   end subroutine init
 
   !> \brief Execute a mHM model.
   subroutine run()
     use mo_mhm_interface, only: mhm_interface_run
     implicit none
     call mhm_interface_run
   end subroutine run
 
+  !> \brief disable all mHM/mRM outputs during runtime.
+  subroutine disable_output()
+    use mo_mrm_global_variables, only : outputFlxState_mrm
+    use mo_global_variables, only : outputFlxState
+    implicit none
+    outputFlxState_mrm = .False.
+    outputFlxState = .False.
+  end subroutine disable_output
+
+  !> \brief Execute a mHM model with given parameters.
+  subroutine run_with_parameter(parameter, n)
+    use mo_mhm_eval, only: mhm_eval
+    implicit none
+    integer(i4) :: n !< number of parameters
+    real(dp), intent(in) :: parameter(n) !< parameter
+    call mhm_eval(parameter)
+  end subroutine run_with_parameter
+
   !> \brief Execute a mHM model or an optimization depending on the configuration.
   subroutine run_or_optimize()
     use mo_common_mHM_mRM_variables, only: optimize
     use mo_mhm_interface, only: &
       mhm_interface_run, &
       mhm_interface_run_optimization
     implicit none
@@ -52,40 +82,53 @@
 
   !> \brief Finalize a mHM model.
   subroutine finalize()
     use mo_mhm_interface, only: mhm_interface_finalize
     implicit none
     call mhm_interface_finalize
   end subroutine finalize
+
+  !> \brief Set verbosity level of mHM.
+  subroutine set_verbosity(level)
+    use mo_mhm_cli, only: set_verbosity_level
+    implicit none
+    integer(i4), intent(in) :: level !< verbosity level (0, 1, 2)
+    call set_verbosity_level(level)
+  end subroutine set_verbosity
 end module model
 
 !> \brief   Python wrapper module to control a mHM model run per time step.
+!> \date    Nov 2022
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup mhm
 module run
+  use mo_kind, only : i4, dp
   implicit none
 contains
   !> \brief Prepare a mHM model run.
   subroutine prepare()
     use mo_mhm_interface_run, only: mhm_interface_run_prepare
     implicit none
     call mhm_interface_run_prepare
   end subroutine prepare
 
   !> \brief Get the number of domains of the current mHM model run.
   subroutine get_ndomains(n)
     use mo_mhm_interface_run, only: mhm_interface_run_get_ndomains
     implicit none
-    integer, intent(out) :: n !< number of domains
+    integer(i4), intent(out) :: n !< number of domains
     call mhm_interface_run_get_ndomains(n)
   end subroutine get_ndomains
 
   !> \brief Prepare a certain domain of the current mHM model run.
   subroutine prepare_domain(domain)
     use mo_mhm_interface_run, only: mhm_interface_run_prepare_domain
     implicit none
-    integer, intent(in) :: domain !< domain index (1 based and 1 by default)
+    integer(i4), intent(in) :: domain !< domain index (1 based and 1 by default)
     !f2py integer :: domain = 1
     call mhm_interface_run_prepare_domain(domain)
   end subroutine prepare_domain
 
   !> \brief Check if the current mHM model time loop is finished.
   subroutine finished(output)
     use mo_mhm_interface_run, only: mhm_interface_run_finished
@@ -122,224 +165,332 @@
     call mhm_interface_run_finalize
   end subroutine finalize
 
   !> \brief Get the current time the current domain of the current mHM model run.
   subroutine current_time(year, month, day, hour)
     use mo_common_run_variables, only : run_cfg
     implicit none
-    integer, intent(out) :: year !< current year
-    integer, intent(out) :: month !< current month
-    integer, intent(out) :: day !< current day
-    integer, intent(out) :: hour !< current hour
+    integer(i4), intent(out) :: year !< current year
+    integer(i4), intent(out) :: month !< current month
+    integer(i4), intent(out) :: day !< current day
+    integer(i4), intent(out) :: hour !< current hour
     year = run_cfg%domainDateTime%year
     month = run_cfg%domainDateTime%month
     day = run_cfg%domainDateTime%day
     hour = run_cfg%domainDateTime%hour
   end subroutine current_time
 end module run
 
 !> \brief   Python wrapper module to get internal variables of a mHM model run.
+!> \date    Nov 2022
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup mhm
 module get
+  use mo_kind, only : i4, dp
   implicit none
 contains
+
+  !> \name parameter
+
+  !> \brief Get the number of parameters in mHM.
+  subroutine parameter_length(length)
+    use mo_mhm_interface, only : mhm_interface_get_parameter_number
+    implicit none
+    integer(i4), intent(out) :: length !< length of the parmeter array
+    call mhm_interface_get_parameter_number(length)
+  end subroutine parameter_length
+
+  !> \name parameter
+
+  !> \brief Get the parameter settings of mHM.
+  subroutine parameter_config(config, n)
+    use mo_common_variables, only: global_parameters
+
+    implicit none
+    integer(i4) :: n !< number of parameters
+    real(dp), intent(out) :: config(n, 5) !< parameter configuration
+
+    config = global_parameters
+  end subroutine parameter_config
+
+  !> \name parameter
+  !> \brief access parameters of mHM
+
+  !> \brief Get the parameter names of mHM.
+  subroutine parameter_name(para_name, n)
+    use mo_common_variables, only: global_parameters_name
+
+    implicit none
+    character(256), intent(out) :: para_name !< parameter name
+    !f2py character(f2py_len=256) para_name
+    integer(i4), intent(in) :: n !< number of parameters
+
+    para_name = global_parameters_name(n)
+  end subroutine parameter_name
+
+  !> \name runoff
+
+  !> \brief Get the shape of mHM model runoff output for evaluation.
+  subroutine runoff_eval_length(gauge_id, length)
+    use mo_common_mhm_mrm_variables, only : evalPer, nTstepDay, warmingDays
+    use mo_mrm_global_variables, only : gauge, nMeasPerDay
+    implicit none
+    integer(i4), intent(in) :: gauge_id !< gauge id
+    integer(i4), intent(out) :: length !< length of the runoff time series
+
+    integer(i4) :: iDomain
+
+    ! extract domain Id from gauge Id
+    iDomain = gauge%domainId(gauge_id)
+    ! get length of evaluation period times TPD_obs
+    length = (evalPer(iDomain)%julEnd - evalPer(iDomain)%julStart + 1) * nMeasPerDay
+  end subroutine runoff_eval_length
+
+  !> \brief Get the mHM model runoff output.
+  subroutine runoff_eval(gauge_id, output, m)
+    use mo_mrm_objective_function_runoff, only : extract_runoff
+    use mo_mrm_global_variables, only: mRM_runoff
+    implicit none
+    integer(i4) :: m !< number of time-steps for evaluation
+    real(dp), intent(out) :: output(m, 2) !< runoff
+    integer(i4), intent(in) :: gauge_id !< gauge id
+
+    ! aggregated simulated runoff
+    real(dp), dimension(:), allocatable :: runoff_agg, runoff_obs
+    logical, dimension(:), allocatable :: runoff_obs_mask
+
+    call extract_runoff(gauge_id, mRM_runoff, runoff_agg, runoff_obs, runoff_obs_mask)
+    output(:, 1) = runoff_agg
+    output(:, 2) = runoff_obs
+  end subroutine runoff_eval
+
+  !> \name runoff
+
   !> \brief Get the shape of mHM model runoff output.
   subroutine runoff_shape(shp)
     use mo_mrm_global_variables, only: mRM_runoff
     implicit none
-    integer, intent(out) :: shp(2) !< 2D shape of the runoff
+    integer(i4), intent(out) :: shp(2) !< 2D shape of the runoff
     shp = shape(mRM_runoff)
   end subroutine runoff_shape
 
+  !> \name runoff
+  !> \brief access generated runoff of mHM
+
   !> \brief Get the mHM model runoff output.
   subroutine runoff(output, m, n)
     use mo_mrm_global_variables, only: mRM_runoff
     implicit none
-    integer :: m !< number of time-steps
-    integer :: n !< number of gauges
-    real*8, intent(out) :: output(m, n) !< runoff
+    integer(i4) :: m !< number of time-steps
+    integer(i4) :: n !< number of gauges
+    real(dp), intent(out) :: output(m, n) !< runoff
     output = mRM_runoff
   end subroutine runoff
 
+  !> \name Level 0
+
   !> \brief Get number of unmasked celles on Level-0 of the mHM model.
   subroutine L0_domain_size(n, domain)
     use mo_common_variables, only : level0
     use mo_common_run_variables, only : run_cfg
     implicit none
-    integer, intent(out) :: n !< number of unmasked celles
-    integer, intent(in) :: domain !< selected domain (0 by default for current domain)
+    integer(i4), intent(out) :: n !< number of unmasked celles
+    integer(i4), intent(in) :: domain !< selected domain (0 by default for current domain)
     !f2py integer :: domain = 0
-    integer :: iDomain, i
+    integer(i4) :: iDomain, i
     i = domain
     if ( i == 0 ) i = run_cfg%selected_domain
     iDomain = run_cfg%get_domain_index(i)
     n = level0(iDomain)%nCells
   end subroutine L0_domain_size
 
+  !> \name Level 0
+
   !> \brief Get the shape of Level-0 of the mHM model.
   subroutine L0_domain_shape(shp, domain)
     use mo_common_variables, only : level0
     use mo_common_run_variables, only : run_cfg
     implicit none
-    integer, intent(out) :: shp(2) !< shape of Level-0
-    integer, intent(in) :: domain !< selected domain (0 by default for current domain)
+    integer(i4), intent(out) :: shp(2) !< shape of Level-0
+    integer(i4), intent(in) :: domain !< selected domain (0 by default for current domain)
     !f2py integer :: domain = 0
-    integer :: iDomain, i
+    integer(i4) :: iDomain, i
     i = domain
     if ( i == 0 ) i = run_cfg%selected_domain
     iDomain = run_cfg%get_domain_index(i)
     shp = shape(level0(iDomain)%mask)
   end subroutine L0_domain_shape
 
+  !> \name Level 0
+
   !> \brief Get the mask of Level-0 of the mHM model.
   subroutine L0_domain_mask(mask, n, m, domain)
     use mo_common_variables, only : level0
     use mo_common_run_variables, only : run_cfg
     implicit none
-    integer :: m !< number of columns
-    integer :: n !< number of rows
+    integer(i4) :: m !< number of columns
+    integer(i4) :: n !< number of rows
     logical, intent(out) :: mask(m, n) !< mask at Level-0
-    integer, intent(in) :: domain !< selected domain (0 by default for current domain)
+    integer(i4), intent(in) :: domain !< selected domain (0 by default for current domain)
     !f2py integer :: domain = 0
-    integer :: iDomain, i
+    integer(i4) :: iDomain, i
     i = domain
     if ( i == 0 ) i = run_cfg%selected_domain
     iDomain = run_cfg%get_domain_index(i)
     mask = level0(iDomain)%mask
   end subroutine L0_domain_mask
 
+  !> \name Level 0
+
   !> \brief Get the information of Level-0 of the mHM model.
   subroutine L0_domain_info(ncols, nrows, ncells, xll, yll, cell_size, no_data, domain)
     use mo_common_variables, only : level0
     use mo_common_constants, only : nodata_dp
     use mo_common_run_variables, only : run_cfg
     implicit none
-    integer, intent(out) :: ncols !< number of columns
-    integer, intent(out) :: nrows !< number of rows
-    integer, intent(out) :: ncells !< number of cells
-    real*8, intent(out) :: xll !< x coordinate of lower left corner
-    real*8, intent(out) :: yll !< y coordinate of lower left corner
-    real*8, intent(out) :: cell_size !< cell-size
-    real*8, intent(out) :: no_data !< no data value
-    integer, intent(in) :: domain !< selected domain (0 by default for current domain)
+    integer(i4), intent(out) :: ncols !< number of columns
+    integer(i4), intent(out) :: nrows !< number of rows
+    integer(i4), intent(out) :: ncells !< number of cells
+    real(dp), intent(out) :: xll !< x coordinate of lower left corner
+    real(dp), intent(out) :: yll !< y coordinate of lower left corner
+    real(dp), intent(out) :: cell_size !< cell-size
+    real(dp), intent(out) :: no_data !< no data value
+    integer(i4), intent(in) :: domain !< selected domain (0 by default for current domain)
     !f2py integer :: domain = 0
-    integer :: iDomain, i
+    integer(i4) :: iDomain, i
     i = domain
     if ( i == 0 ) i = run_cfg%selected_domain
     iDomain = run_cfg%get_domain_index(i)
     ncols = level0(iDomain)%ncols
     nrows = level0(iDomain)%nrows
     ncells = level0(iDomain)%nCells
     xll = level0(iDomain)%xllcorner
     yll = level0(iDomain)%yllcorner
     cell_size = level0(iDomain)%cellsize
     ! no_data = level0(iDomain)%nodata_value
     no_data = nodata_dp
   end subroutine L0_domain_info
 
+  !> \name Level 0
+  !> \brief access Level 0 information and variables
+
   !> \brief Get a variable on Level-0 of the mHM model.
   subroutine L0_variable(output, n, name, idx)
     use mo_common_run_variables, only : run_cfg
     use mo_common_variables, only : level0, domainMeta
     use mo_mpr_global_variables, only : L0_gridded_LAI
     implicit none
-    integer :: n !< size of the variable
-    real*8, intent(out) :: output(n) !< the desired variable
+    integer(i4) :: n !< size of the variable
+    real(dp), intent(out) :: output(n) !< the desired variable
     character(*), intent(in) :: name !< name to select the variable
-    integer, intent(in) :: idx !< optional index if the variable has multiple layer (1 by default)
+    integer(i4), intent(in) :: idx !< optional index if the variable has multiple layer (1 by default)
     !f2py integer :: idx = 1
-    integer :: iDomain, s0, e0
+    integer(i4) :: iDomain, s0, e0
 
     iDomain = run_cfg%get_domain_index(run_cfg%selected_domain)
     s0 = level0(domainMeta%L0DataFrom(iDomain))%iStart
     e0 = level0(domainMeta%L0DataFrom(iDomain))%iEnd
     select case(name)
       case("L0_GRIDDED_LAI")
         output = L0_gridded_LAI(s0 : e0, idx)
       case default
         print*, "unknown variable: " // name
         stop "get.L0_variable: unknown variable"
     end select
   end subroutine L0_variable
 
+  !> \name Level 1
+
   !> \brief Get number of unmasked celles on Level-1 of the mHM model.
   subroutine L1_domain_size(n, domain)
     use mo_common_variables, only : level1
     use mo_common_run_variables, only : run_cfg
     implicit none
-    integer, intent(out) :: n !< number of unmasked celles
-    integer, intent(in) :: domain !< selected domain (0 by default for current domain)
+    integer(i4), intent(out) :: n !< number of unmasked celles
+    integer(i4), intent(in) :: domain !< selected domain (0 by default for current domain)
     !f2py integer :: domain = 0
-    integer :: iDomain, i
+    integer(i4) :: iDomain, i
     i = domain
     if ( i == 0 ) i = run_cfg%selected_domain
     iDomain = run_cfg%get_domain_index(i)
     n = level1(iDomain)%nCells
   end subroutine L1_domain_size
 
+  !> \name Level 1
+
   !> \brief Get the shape of Level-1 of the mHM model.
   subroutine L1_domain_shape(shp, domain)
     use mo_common_variables, only : level1
     use mo_common_run_variables, only : run_cfg
     implicit none
-    integer, intent(out) :: shp(2) !< shape of Level-1
-    integer, intent(in) :: domain !< selected domain (0 by default for current domain)
+    integer(i4), intent(out) :: shp(2) !< shape of Level-1
+    integer(i4), intent(in) :: domain !< selected domain (0 by default for current domain)
     !f2py integer :: domain = 0
-    integer :: iDomain, i
+    integer(i4) :: iDomain, i
     i = domain
     if ( i == 0 ) i = run_cfg%selected_domain
     iDomain = run_cfg%get_domain_index(i)
     shp = shape(level1(iDomain)%mask)
   end subroutine L1_domain_shape
 
+  !> \name Level 1
+
   !> \brief Get the mask of Level-1 of the mHM model.
   subroutine L1_domain_mask(mask, n, m, domain)
     use mo_common_variables, only : level1
     use mo_common_run_variables, only : run_cfg
     implicit none
-    integer :: m !< number of columns
-    integer :: n !< number of rows
+    integer(i4) :: m !< number of columns
+    integer(i4) :: n !< number of rows
     logical, intent(out) :: mask(m, n) !< mask at Level-1
-    integer, intent(in) :: domain !< selected domain (0 by default for current domain)
+    integer(i4), intent(in) :: domain !< selected domain (0 by default for current domain)
     !f2py integer :: domain = 0
-    integer :: iDomain, i
+    integer(i4) :: iDomain, i
     i = domain
     if ( i == 0 ) i = run_cfg%selected_domain
     iDomain = run_cfg%get_domain_index(i)
     mask = level1(iDomain)%mask
   end subroutine L1_domain_mask
 
+  !> \name Level 1
+  !> \brief access Level 1 information and variables
+
   !> \brief Get the information of Level-1 of the mHM model.
   subroutine L1_domain_info(ncols, nrows, ncells, xll, yll, cell_size, no_data, domain)
     use mo_common_variables, only : level1
     use mo_common_constants, only : nodata_dp
     use mo_common_run_variables, only : run_cfg
     implicit none
-    integer, intent(out) :: ncols !< number of columns
-    integer, intent(out) :: nrows !< number of rows
-    integer, intent(out) :: ncells !< number of cells
-    real*8, intent(out) :: xll !< x coordinate of lower left corner
-    real*8, intent(out) :: yll !< y coordinate of lower left corner
-    real*8, intent(out) :: cell_size !< cell-size
-    real*8, intent(out) :: no_data !< no data value
-    integer, intent(in) :: domain !< selected domain (0 by default for current domain)
+    integer(i4), intent(out) :: ncols !< number of columns
+    integer(i4), intent(out) :: nrows !< number of rows
+    integer(i4), intent(out) :: ncells !< number of cells
+    real(dp), intent(out) :: xll !< x coordinate of lower left corner
+    real(dp), intent(out) :: yll !< y coordinate of lower left corner
+    real(dp), intent(out) :: cell_size !< cell-size
+    real(dp), intent(out) :: no_data !< no data value
+    integer(i4), intent(in) :: domain !< selected domain (0 by default for current domain)
     !f2py integer :: domain = 0
-    integer :: iDomain, i
+    integer(i4) :: iDomain, i
     i = domain
     if ( i == 0 ) i = run_cfg%selected_domain
     iDomain = run_cfg%get_domain_index(i)
     ncols = level1(iDomain)%ncols
     nrows = level1(iDomain)%nrows
     ncells = level1(iDomain)%nCells
     xll = level1(iDomain)%xllcorner
     yll = level1(iDomain)%yllcorner
     cell_size = level1(iDomain)%cellsize
     ! no_data = level1(iDomain)%nodata_value
     no_data = nodata_dp
   end subroutine L1_domain_info
 
+  !> \name Level 1
+  !> \brief access Level 1 information and variables
+
   !> \brief Get a variable on Level-1 of the mHM model.
   subroutine L1_variable(output, n, name, idx)
     use mo_common_run_variables, only : run_cfg
     use mo_mpr_global_variables, only : &
       L1_fSealed, & ! 1d
       L1_soilMoistSat ! 2d
     use mo_global_variables, only : &
@@ -361,18 +512,18 @@
       L1_fastRunoff, & ! 1d
       L1_slowRunoff, & ! 1d
       L1_baseflow, & ! 1d
       L1_percol, & ! 1d
       L1_infilSoil, & ! 2d
       L1_preEffect ! 1d
     implicit none
-    integer :: n !< size of the variable
-    real*8, intent(out) :: output(n) !< the desired variable
+    integer(i4) :: n !< size of the variable
+    real(dp), intent(out) :: output(n) !< the desired variable
     character(*), intent(in) :: name !< name to select the variable
-    integer, intent(in) :: idx !< optional index if the variable has multiple layer (1 by default)
+    integer(i4), intent(in) :: idx !< optional index if the variable has multiple layer (1 by default)
     !f2py integer :: idx = 1
     select case(name)
       case("L1_FSEALED")
         output = L1_fSealed(run_cfg%s1 : run_cfg%e1, 1, run_cfg%domainDateTime%yId)
       case("L1_FNOTSEALED")
         output = run_cfg%L1_fNotSealed(run_cfg%s1 : run_cfg%e1, 1, run_cfg%domainDateTime%yId)
       case("L1_INTER")
@@ -427,103 +578,114 @@
         output = L1_infilSoil(run_cfg%s1 : run_cfg%e1, idx)
       case default
         print*, "unknown variable: " // name
         stop "get.variable: unknown variable"
     end select
   end subroutine L1_variable
 
+  !> \name Level 11
+
   !> \brief Get number of unmasked celles on Level-11 of the mHM model.
   subroutine L11_domain_size(n, domain)
     use mo_mrm_global_variables, only : level11
     use mo_common_run_variables, only : run_cfg
     implicit none
-    integer, intent(out) :: n !< number of unmasked celles
-    integer, intent(in) :: domain !< selected domain (0 by default for current domain)
+    integer(i4), intent(out) :: n !< number of unmasked celles
+    integer(i4), intent(in) :: domain !< selected domain (0 by default for current domain)
     !f2py integer :: domain = 0
-    integer :: iDomain, i
+    integer(i4) :: iDomain, i
     i = domain
     if ( i == 0 ) i = run_cfg%selected_domain
     iDomain = run_cfg%get_domain_index(i)
     n = level11(iDomain)%nCells
   end subroutine L11_domain_size
 
+  !> \name Level 11
+
   !> \brief Get the shape of Level-11 of the mHM model.
   subroutine L11_domain_shape(shp, domain)
     use mo_mrm_global_variables, only : level11
     use mo_common_run_variables, only : run_cfg
     implicit none
-    integer, intent(out) :: shp(2) !< shape of Level-11
-    integer, intent(in) :: domain !< selected domain (0 by default for current domain)
+    integer(i4), intent(out) :: shp(2) !< shape of Level-11
+    integer(i4), intent(in) :: domain !< selected domain (0 by default for current domain)
     !f2py integer :: domain = 0
-    integer :: iDomain, i
+    integer(i4) :: iDomain, i
     i = domain
     if ( i == 0 ) i = run_cfg%selected_domain
     iDomain = run_cfg%get_domain_index(i)
     shp = shape(level11(iDomain)%mask)
   end subroutine L11_domain_shape
 
+  !> \name Level 11
+
   !> \brief Get the mask of Level-11 of the mHM model.
   subroutine L11_domain_mask(mask, n, m, domain)
     use mo_mrm_global_variables, only : level11
     use mo_common_run_variables, only : run_cfg
     implicit none
-    integer :: m !< number of columns
-    integer :: n !< number of rows
+    integer(i4) :: m !< number of columns
+    integer(i4) :: n !< number of rows
     logical, intent(out) :: mask(m, n) !< mask at Level-11
-    integer, intent(in) :: domain !< selected domain (0 by default for current domain)
+    integer(i4), intent(in) :: domain !< selected domain (0 by default for current domain)
     !f2py integer :: domain = 0
-    integer :: iDomain, i
+    integer(i4) :: iDomain, i
     i = domain
     if ( i == 0 ) i = run_cfg%selected_domain
     iDomain = run_cfg%get_domain_index(i)
     mask = level11(iDomain)%mask
   end subroutine L11_domain_mask
 
+  !> \name Level 11
+
   !> \brief Get the information of Level-11 of the mHM model.
   subroutine L11_domain_info(ncols, nrows, ncells, xll, yll, cell_size, no_data, domain)
     use mo_mrm_global_variables, only : level11
     use mo_common_constants, only : nodata_dp
     use mo_common_run_variables, only : run_cfg
     implicit none
-    integer, intent(out) :: ncols !< number of columns
-    integer, intent(out) :: nrows !< number of rows
-    integer, intent(out) :: ncells !< number of cells
-    real*8, intent(out) :: xll !< x coordinate of lower left corner
-    real*8, intent(out) :: yll !< y coordinate of lower left corner
-    real*8, intent(out) :: cell_size !< cell-size
-    real*8, intent(out) :: no_data !< no data value
-    integer, intent(in) :: domain !< selected domain (0 by default for current domain)
+    integer(i4), intent(out) :: ncols !< number of columns
+    integer(i4), intent(out) :: nrows !< number of rows
+    integer(i4), intent(out) :: ncells !< number of cells
+    real(dp), intent(out) :: xll !< x coordinate of lower left corner
+    real(dp), intent(out) :: yll !< y coordinate of lower left corner
+    real(dp), intent(out) :: cell_size !< cell-size
+    real(dp), intent(out) :: no_data !< no data value
+    integer(i4), intent(in) :: domain !< selected domain (0 by default for current domain)
     !f2py integer :: domain = 0
-    integer :: iDomain, i
+    integer(i4) :: iDomain, i
     i = domain
     if ( i == 0 ) i = run_cfg%selected_domain
     iDomain = run_cfg%get_domain_index(i)
     ncols = level11(iDomain)%ncols
     nrows = level11(iDomain)%nrows
     ncells = level11(iDomain)%nCells
     xll = level11(iDomain)%xllcorner
     yll = level11(iDomain)%yllcorner
     cell_size = level11(iDomain)%cellsize
     ! no_data = level11(iDomain)%nodata_value
     no_data = nodata_dp
   end subroutine L11_domain_info
 
+  !> \name Level 11
+  !> \brief access Level 11 information and variables
+
   !> \brief Get a variable on Level-11 of the mHM model.
   subroutine L11_variable(output, n, name, idx)
     use mo_common_run_variables, only : run_cfg
     use mo_mrm_global_variables, only : &
       L11_qMod, &
       L11_qOUT, &
       L11_qTIN, &
       L11_qTR
     implicit none
-    integer :: n !< size of the variable
-    real*8, intent(out) :: output(n) !< the desired variable
+    integer(i4) :: n !< size of the variable
+    real(dp), intent(out) :: output(n) !< the desired variable
     character(*), intent(in) :: name !< name to select the variable
-    integer, intent(in) :: idx !< optional index if the variable has multiple layer (1 by default)
+    integer(i4), intent(in) :: idx !< optional index if the variable has multiple layer (1 by default)
     !f2py integer :: idx = 1
     select case(name)
       case("L11_QMOD")
         output = L11_qMod(run_cfg%s11 : run_cfg%e11)
       case("L11_QOUT")
         output = L11_qOUT(run_cfg%s11 : run_cfg%e11)
       case("L11_QTIN")
@@ -532,108 +694,126 @@
         output = L11_qTR(run_cfg%s11 : run_cfg%e11, idx)
       case default
         print*, "unknown variable: " // name
         stop "get.L11_variable: unknown variable"
     end select
   end subroutine L11_variable
 
+  !> \name Level 2
+
   !> \brief Get number of unmasked celles on Level-2 of the mHM model.
   subroutine L2_domain_size(n, domain)
-    use mo_global_variables, only : level2
+    use mo_global_variables, only : meteo_handler
     use mo_common_run_variables, only : run_cfg
     implicit none
-    integer, intent(out) :: n !< number of unmasked celles
-    integer, intent(in) :: domain !< selected domain (0 by default for current domain)
+    integer(i4), intent(out) :: n !< number of unmasked celles
+    integer(i4), intent(in) :: domain !< selected domain (0 by default for current domain)
     !f2py integer :: domain = 0
-    integer :: iDomain, i
+    integer(i4) :: iDomain, i
     i = domain
     if ( i == 0 ) i = run_cfg%selected_domain
     iDomain = run_cfg%get_domain_index(i)
-    n = level2(iDomain)%nCells
+    n = meteo_handler%level2(iDomain)%nCells
   end subroutine L2_domain_size
 
+  !> \name Level 2
+
   !> \brief Get the shape of Level-2 of the mHM model.
   subroutine L2_domain_shape(shp, domain)
-    use mo_global_variables, only : level2
+    use mo_global_variables, only : meteo_handler
     use mo_common_run_variables, only : run_cfg
     implicit none
-    integer, intent(out) :: shp(2) !< shape of Level-2
-    integer, intent(in) :: domain !< selected domain (0 by default for current domain)
+    integer(i4), intent(out) :: shp(2) !< shape of Level-2
+    integer(i4), intent(in) :: domain !< selected domain (0 by default for current domain)
     !f2py integer :: domain = 0
-    integer :: iDomain, i
+    integer(i4) :: iDomain, i
     i = domain
     if ( i == 0 ) i = run_cfg%selected_domain
     iDomain = run_cfg%get_domain_index(i)
-    shp = shape(level2(iDomain)%mask)
+    shp = shape(meteo_handler%level2(iDomain)%mask)
   end subroutine L2_domain_shape
 
+  !> \name Level 2
+
   !> \brief Get the mask of Level-2 of the mHM model.
   subroutine L2_domain_mask(mask, n, m, domain)
-    use mo_global_variables, only : level2
+    use mo_global_variables, only : meteo_handler
     use mo_common_run_variables, only : run_cfg
     implicit none
-    integer :: m !< number of columns
-    integer :: n !< number of rows
+    integer(i4) :: m !< number of columns
+    integer(i4) :: n !< number of rows
     logical, intent(out) :: mask(m, n) !< mask at Level-2
-    integer, intent(in) :: domain !< selected domain (0 by default for current domain)
+    integer(i4), intent(in) :: domain !< selected domain (0 by default for current domain)
     !f2py integer :: domain = 0
-    integer :: iDomain, i
+    integer(i4) :: iDomain, i
     i = domain
     if ( i == 0 ) i = run_cfg%selected_domain
     iDomain = run_cfg%get_domain_index(i)
-    mask = level2(iDomain)%mask
+    mask = meteo_handler%level2(iDomain)%mask
   end subroutine L2_domain_mask
 
+  !> \name Level 2
+  !> \brief access Level 2 information
+
   !> \brief Get the information of Level-2 of the mHM model.
   subroutine L2_domain_info(ncols, nrows, ncells, xll, yll, cell_size, no_data, domain)
-    use mo_global_variables, only : level2
+    use mo_global_variables, only : meteo_handler
     use mo_common_constants, only : nodata_dp
     use mo_common_run_variables, only : run_cfg
     implicit none
-    integer, intent(out) :: ncols !< number of columns
-    integer, intent(out) :: nrows !< number of rows
-    integer, intent(out) :: ncells !< number of cells
-    real*8, intent(out) :: xll !< x coordinate of lower left corner
-    real*8, intent(out) :: yll !< y coordinate of lower left corner
-    real*8, intent(out) :: cell_size !< cell-size
-    real*8, intent(out) :: no_data !< no data value
-    integer, intent(in) :: domain !< selected domain (0 by default for current domain)
-    !f2py integer :: domain = 0
-    integer :: iDomain, i
+    integer(i4), intent(out) :: ncols !< number of columns
+    integer(i4), intent(out) :: nrows !< number of rows
+    integer(i4), intent(out) :: ncells !< number of cells
+    real(dp), intent(out) :: xll !< x coordinate of lower left corner
+    real(dp), intent(out) :: yll !< y coordinate of lower left corner
+    real(dp), intent(out) :: cell_size !< cell-size
+    real(dp), intent(out) :: no_data !< no data value
+    integer(i4), intent(in) :: domain !< selected domain (0 by default for current domain)
+    !f2py integer :: domain = 0
+    integer(i4) :: iDomain, i
     i = domain
     if ( i == 0 ) i = run_cfg%selected_domain
     iDomain = run_cfg%get_domain_index(i)
-    ncols = level2(iDomain)%ncols
-    nrows = level2(iDomain)%nrows
-    ncells = level2(iDomain)%nCells
-    xll = level2(iDomain)%xllcorner
-    yll = level2(iDomain)%yllcorner
-    cell_size = level2(iDomain)%cellsize
-    ! no_data = level2(iDomain)%nodata_value
+    ncols = meteo_handler%level2(iDomain)%ncols
+    nrows = meteo_handler%level2(iDomain)%nrows
+    ncells = meteo_handler%level2(iDomain)%nCells
+    xll = meteo_handler%level2(iDomain)%xllcorner
+    yll = meteo_handler%level2(iDomain)%yllcorner
+    cell_size = meteo_handler%level2(iDomain)%cellsize
+    ! no_data = meteo_handler%level2(iDomain)%nodata_value
     no_data = nodata_dp
   end subroutine L2_domain_info
 
 end module get
 
 !> \brief   Python wrapper module to set internal variables of a mHM model run.
+!> \date    Nov 2022
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup mhm
 module set
+  use mo_kind, only : i4, dp
   implicit none
 contains
+
+  !> \name Level 0
+  !> \brief alter Level 0 variables
+
   !> \brief Set a variable on Level-0 of the mHM model.
   subroutine L0_variable(input, n, name, idx)
     use mo_common_run_variables, only : run_cfg
     use mo_common_variables, only : level0, domainMeta
     use mo_mpr_global_variables, only : L0_gridded_LAI
     implicit none
-    integer :: n !< size of the variable
-    real*8, intent(in) :: input(n) !< the variable value
+    integer(i4) :: n !< size of the variable
+    real(dp), intent(in) :: input(n) !< the variable value
     character(*), intent(in) :: name !< name to select the variable
-    integer, intent(in) :: idx !< optional index if the variable has multiple layer (1 by default)
+    integer(i4), intent(in) :: idx !< optional index if the variable has multiple layer (1 by default)
     !f2py integer :: idx = 1
-    integer :: iDomain, s0, e0
+    integer(i4) :: iDomain, s0, e0
 
     iDomain = run_cfg%get_domain_index(run_cfg%selected_domain)
     s0 = level0(domainMeta%L0DataFrom(iDomain))%iStart
     e0 = level0(domainMeta%L0DataFrom(iDomain))%iEnd
     select case(name)
       case("L0_GRIDDED_LAI")
         L0_gridded_LAI(s0 : e0, idx) = input
```

### Comparing `mhm-5.12.1.dev21/pyproject.toml` & `mhm-5.13.0/pyproject.toml`

 * *Files 12% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 [build-system]
 requires = [
     "setuptools>=63,<64",
-    "setuptools_scm[toml]>=7",
+    "setuptools_scm[toml]>=7,<8",
     "scikit-build>=0.16,<0.17",
     "oldest_supported_numpy",
     "cmake",
     "ninja",
     "fypp",
 ]
 build-backend = "setuptools.build_meta"
 
 [project]
 requires-python = ">=3.8"
 name = "mhm"
 description = "Python distribution of mHM with bindings."
 authors = [{name = "mHM Developers", email = "mhm-admin@ufz.de"}]
-readme = "README.md"
+readme = "pybind/README.md"
 license = {text = "LGPL-3.0"}
-dynamic = ["version"]
+dynamic = ["version", "entry-points"]
 keywords = ["mHM"]
 classifiers = [
     "Development Status :: 3 - Alpha",
     "Intended Audience :: Developers",
     "Intended Audience :: End Users/Desktop",
     "Intended Audience :: Science/Research",
     "Intended Audience :: Education",
@@ -48,16 +48,17 @@
 Changelog = "https://www.mhm-ufz.org"
 Conda-Forge = "https://anaconda.org/conda-forge/mhm"
 Documentation = "https://www.mhm-ufz.org"
 Homepage = "https://www.mhm-ufz.org"
 Source = "https://www.mhm-ufz.org"
 Tracker = "https://www.mhm-ufz.org"
 
-[project.scripts]
-mhm = "mhm.cli:mhm"
+# https://github.com/pypa/setuptools/issues/3599
+[tool.setuptools]
+license-files = ["COPYING", "COPYING.LESSER", "LICENSE.md", "AUTHORS"]
 
 [tool.setuptools_scm]
 write_to = "pybind/mhm/_version.py"
 write_to_template = "__version__ = '{version}'"
 local_scheme = "no-local-version"
 fallback_version = "0.0.0.dev0"
 search_parent_directories = true
@@ -77,12 +78,12 @@
 # skip py37, pypy and musl
 skip = ["cp37*", "pp*", "*-musllinux_*"]
 # check command
 test-command = "mhm -h && mhm {project}"
 
 [tool.cibuildwheel.linux]
 environment = { FC="gfortran", F77="gfortran", CC="gcc", CXX="g++" }
-before-all = "source CI-scripts/install-deps /usr && ldconfig"
+before-all = "source CI-scripts/install-deps -c -p /usr"
 
 [tool.cibuildwheel.macos]
 environment = { FC="gfortran-11", F77="gfortran-11", CC="gcc-11", CXX="g++-11" }
-before-all = "source CI-scripts/install-deps-sudo /opt/local"
+before-all = "source CI-scripts/install-deps -s -p /opt/local"
```

### Comparing `mhm-5.12.1.dev21/src/CMakeLists.txt` & `mhm-5.13.0/src/CMakeLists.txt`

 * *Files 7% similar despite different names*

```diff
@@ -1,37 +1,43 @@
 set (LIB_NAME mhm_lib)
 # use all mo_*.f90/F90 files for the library
 file(GLOB sources_mpr MPR/*mo_*.*90)
 file(GLOB sources_mhm mHM/*mo_*.*90)
 file(GLOB sources_mrm mRM/*mo_*.*90)
-file(GLOB sources_common common*/*mo_*.*90)
-list(APPEND sources ${sources_mpr} ${sources_mhm} ${sources_mrm} ${sources_common})
+file(GLOB sources_common common/*mo_*.*90)
+file(GLOB sources_meteo meteo/*mo_*.*90)
+list(APPEND sources ${sources_mpr} ${sources_mhm} ${sources_mrm} ${sources_common} ${sources_meteo})
 option(BUILD_MHM_LIB_SHARED "Build mhm library as shared." OFF)
 if(BUILD_MHM_LIB_SHARED)
   add_library(${LIB_NAME} SHARED ${sources})
 else()
   add_library(${LIB_NAME} STATIC ${sources})
 endif()
 target_include_directories(${LIB_NAME} PUBLIC ${CMAKE_CURRENT_BINARY_DIR})
 
-include(../cmake/cmake-modules/CPM.cmake)
+# add FORCES
+include(../cmake/CPM.cmake)
 if(EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/../forces")
   message(STATUS "mHM: found local forces directory")
   set(CPM_forces_SOURCE "${CMAKE_CURRENT_SOURCE_DIR}/../forces" CACHE PATH "Local source path for FORCES.")
 else()
   set(CPM_forces_SOURCE "" CACHE PATH "Local source path for FORCES.")
 endif()
-CPMAddPackage("https://git.ufz.de/chs/forces.git@0.3.2")
+# check forces version file
+file(STRINGS "${CMAKE_CURRENT_SOURCE_DIR}/../version_forces.txt" ver_forces LIMIT_COUNT 1)
+# cmake directive to specify forces version: CPM_forces_VERSION
+set(CPM_forces_VERSION "${ver_forces}" CACHE STRING "FORCES version to download with CPM.")
+CPMAddPackage("https://git.ufz.de/chs/forces.git#${CPM_forces_VERSION}")
 if(BUILD_MHM_LIB_SHARED)
   set_property(TARGET forces PROPERTY POSITION_INDEPENDENT_CODE ON)
 endif()
 target_link_libraries(${LIB_NAME} PUBLIC forces)
 
 # add all compile options (MPI, OpenMP, Lapack, Coverage)
-include(../cmake/cmake-modules/compileoptions.cmake)
+include(../cmake/compileoptions.cmake)
 if (CMAKE_WITH_MPI)
   target_compile_definitions(${LIB_NAME} PRIVATE MPI)
   target_link_libraries(${LIB_NAME} PRIVATE MPI::MPI_Fortran)
 endif()
 if (CMAKE_WITH_OpenMP)
   target_link_libraries(${LIB_NAME} PRIVATE OpenMP::OpenMP_Fortran)
 endif()
```

### Comparing `mhm-5.12.1.dev21/src/MPR/mo_mpr_constants.f90` & `mhm-5.13.0/src/MPR/mo_mpr_constants.f90`

 * *Files 26% similar despite different names*

```diff
@@ -1,19 +1,18 @@
-!>       \file mo_mpr_constants.f90
-
-!>       \brief Provides MPR specific constants
-
-!>       \details Provides MPR specific constants such as flood plain elevation.
-
-!>       \authors Matthias Cuntz
-
-!>       \date Nov 2011
-
-! Modifications:
-
+!> \file mo_mpr_constants.f90
+!> \brief \copybrief mo_mpr_constants
+!> \details \copydetails mo_mpr_constants
+
+!> \brief Provides MPR specific constants
+!> \details Provides MPR specific constants such as flood plain elevation.
+!> \authors Matthias Cuntz
+!> \date Nov 2011
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mpr
 MODULE mo_mpr_constants
 
   USE mo_kind, ONLY : i4, dp
 
   IMPLICIT NONE
 
   PRIVATE
```

### Comparing `mhm-5.12.1.dev21/src/MPR/mo_mpr_eval.f90` & `mhm-5.13.0/src/MPR/mo_mpr_eval.f90`

 * *Files 3% similar despite different names*

```diff
@@ -1,19 +1,18 @@
-!>       \file mo_mpr_eval.f90
-
-!>       \brief Runs MPR and writes to global effective parameters
-
-!>       \details Runs MPR and writes to global effective parameters
-
-!>       \authors Robert Schweppe
-
-!>       \date Feb 2018
-
-! Modifications:
-
+!> \file mo_mpr_eval.f90
+!> \brief \copybrief mo_mpr_eval
+!> \details \copydetails mo_mpr_eval
+
+!> \brief Runs MPR
+!> \details Runs MPR and writes to global effective parameters
+!> \authors Robert Schweppe
+!> \date Feb 2018
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mpr
 MODULE mo_mpr_eval
 
   USE mo_kind, ONLY : i4, dp
 
   IMPLICIT NONE
 
   PRIVATE
```

### Comparing `mhm-5.12.1.dev21/src/MPR/mo_mpr_file.f90` & `mhm-5.13.0/src/MPR/mo_mpr_file.f90`

 * *Files 12% similar despite different names*

```diff
@@ -1,19 +1,18 @@
-!>       \file mo_mpr_file.f90
-
-!>       \brief Provides file names and units for mRM
-
-!>       \details Provides all filenames as well as all units used for the multiscale Routing Model mRM.
-
-!>       \authors Matthias Cuntz, Stephan Thober
-
-!>       \date Aug 2015
-
-! Modifications:
-
+!> \file mo_mpr_file.f90
+!> \brief \copybrief mo_mpr_file
+!> \details \copydetails mo_mpr_file
+
+!> \brief Provides file names and units for mRM
+!> \details Provides all filenames as well as all units used for the multiscale Routing Model mRM.
+!> \authors Matthias Cuntz, Stephan Thober
+!> \date Aug 2015
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mpr
 MODULE mo_mpr_file
 
   IMPLICIT NONE
 
   !> Current mHM model version
   CHARACTER(len = *), PARAMETER :: version = '0.1'                         ! Version
   !> Time of current mHM model version release
@@ -63,17 +62,8 @@
   INTEGER, PARAMETER :: ugeolut = 64                            !
 
   !> LAI classes lookup table file
   CHARACTER(len = *), PARAMETER :: file_lailut = 'LAI_classdefinition.txt'     ! LAI classes lookup table
   !> Unit for LAI classes lookup table file
   INTEGER, PARAMETER :: ulailut = 65                            !
 
-  !> Input nCols and nRows of binary meteo and LAI files are in header file
-  CHARACTER(len = *), PARAMETER :: file_meteo_header = 'header.txt'                  ! Meteo and LAI header
-  !> Unit for meteo header file
-  INTEGER, PARAMETER :: umeteo_header = 50                            !
-  !> File ending of meteo files
-  CHARACTER(len = *), PARAMETER :: file_meteo_binary_end = '.bin'                        ! Meteo and LAI
-  !> Unit for meteo files
-  INTEGER, PARAMETER :: umeteo = 51                            !
-
 END MODULE mo_mpr_file
```

### Comparing `mhm-5.12.1.dev21/src/MPR/mo_mpr_global_variables.f90` & `mhm-5.13.0/src/MPR/mo_mpr_global_variables.f90`

 * *Files 14% similar despite different names*

```diff
@@ -1,24 +1,30 @@
-!>       \file mo_mpr_global_variables.f90
-
-!>       \brief Global variables for mpr only
-!>       \details
-
-!>       \details TODO: add description
-
-!>       \authors Robert Schweppe
-
-!>       \date Dec 2017
-
-! Modifications:
-
+!> \dir MPR
+!> \brief \copybrief f_mpr
+!> \details \copydetails f_mpr
+
+!> \defgroup   f_mpr MPR - Fortran modules
+!> \brief      Core modules of MPR.
+!> \details    These modules provide the core components of the Multiscale Parameter Regionalization scheme of mHM.
+
+!> \file mo_mpr_global_variables.f90
+!> \brief \copybrief mo_mpr_global_variables
+!> \details \copydetails mo_mpr_global_variables
+
+!> \brief Global variables for mpr only
+!> \details Global variables used to run MPR for mHM.
+!> \authors Robert Schweppe
+!> \date Dec 2017
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mpr
 module mo_mpr_global_variables
 
   use mo_kind, only : i4, dp
-  use mo_common_variables, only : period
+  use mo_common_types, only: period
 
   implicit none
 
   private
 
   ! ------------------------------------------------------------------
   ! SOIL DATA
@@ -152,15 +158,15 @@
   !                                                                           !        water content
   real(dp), public, dimension(:, :, :), allocatable :: L1_tempThresh          ! [degC]   Threshold temperature for snow/rain
   real(dp), public, dimension(:, :, :), allocatable :: L1_unsatThresh         ! [mm]  Threshold waterdepth controlling fast interflow
   real(dp), public, dimension(:, :, :), allocatable :: L1_sealedThresh        ! [mm]  Threshold waterdepth for surface runoff
   !                                                                           !       in sealed surfaces
   real(dp), public, dimension(:, :, :), allocatable :: L1_wiltingPoint        ! [mm]  Permanent wilting point: below which neither
   !                                                                           !       plant can take water nor water can drain in
-  !>> COSMIC neutron count realated parameters -- only those which are regionlized
+  ! >> COSMIC neutron count realated parameters -- only those which are regionlized
   !!   defined here others are treated as global parameters...
-  real(dp), public, dimension(:,:,:), allocatable :: L1_No_Count     !   N0 COUNT      >> in Desilets and COSMIC routines 
-  real(dp), public, dimension(:,:,:), allocatable :: L1_bulkDens     !   Bulk density  >> in COSMIC routines 
-  real(dp), public, dimension(:,:,:), allocatable :: L1_latticeWater !   lattice water >> in COSMIC routines 
-  real(dp), public, dimension(:,:,:), allocatable :: L1_COSMICL3     !   !COSMIC L3    >> in COSMIC routines 
+  real(dp), public, dimension(:,:,:), allocatable :: L1_No_Count     !   N0 COUNT      >> in Desilets and COSMIC routines
+  real(dp), public, dimension(:,:,:), allocatable :: L1_bulkDens     !   Bulk density  >> in COSMIC routines
+  real(dp), public, dimension(:,:,:), allocatable :: L1_latticeWater !   lattice water >> in COSMIC routines
+  real(dp), public, dimension(:,:,:), allocatable :: L1_COSMICL3     !   !COSMIC L3    >> in COSMIC routines
 
 end module mo_mpr_global_variables
```

### Comparing `mhm-5.12.1.dev21/src/MPR/mo_mpr_neutrons.f90` & `mhm-5.13.0/src/MPR/mo_mpr_neutrons.f90`

 * *Files 3% similar despite different names*

```diff
@@ -1,17 +1,18 @@
 !> \file mo_mpr_neutrons.f90
+!> \brief \copybrief mo_mpr_neutrons
+!> \details \copydetails mo_mpr_neutrons
 
 !> \brief   Multiscale parameter regionalization (MPR) for neutrons
-
-!> \details This module contains all routines required for parametrizing
-!>          neutrons processes.
-
+!> \details This module contains all routines required for parametrizing neutrons processes.
 !> \author Maren Kaluza
 !> \date Dec 2017
-
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mpr
 module mo_mpr_neutrons
 
   use mo_kind, only: i4, dp
 
   implicit none
 
   public :: mpr_neutrons
@@ -96,37 +97,37 @@
        COSMIC_L3_till      , & ! OUT: COSMIC paramter L3 tillage layer
        latWat_till         , & ! OUT: lattice water content tillage layer
        COSMIC_L3           , & ! OUT: COSMIC paramter L3 tillage layer
        latWat                & ! OUT: lattice water contente
        )
 
     ! lots of lines copy-pasted from mo_mpr_soilmoist.f90
-    use mo_message,              only: message
+    use mo_message, only: error_message
     use mo_mpr_global_variables, only: iFlag_soilDB
     !$  use omp_lib
 
     implicit none
 
     ! Input --------------------------------------------------------------------
     integer(i4),                   intent(in)  :: process_case ! process case
-    real(dp),    dimension(:),     intent(in)  :: param        ! global parameters   !! dim = 3 for case 1 and 9 for case 2 
+    real(dp),    dimension(:),     intent(in)  :: param        ! global parameters   !! dim = 3 for case 1 and 9 for case 2
     integer(i4), dimension(:),     intent(in)  :: is_present   ! indicates whether soiltype is present
     integer(i4), dimension(:),     intent(in)  :: nHorizons    ! Number of Horizons per soiltype
     integer(i4), dimension(:),     intent(in)  :: nTillHorizons! Number of Tillage Horizons
     real(dp),    dimension(:,:),   intent(in)  :: DbM          ! mineral Bulk density
     real(dp),    dimension(:,:,:), intent(in)  :: Db           ! Bulk density
     integer(i4), dimension(:),     intent(in)  :: LCOVER0      ! land cover ids at level 0
     real(dp),    dimension(:,:),   intent(in)  :: clay         ! clay content
 
     ! Output -------------------------------------------------------------------
     real(dp),    dimension(:,:,:), intent(out) :: COSMIC_L3_till ! COSMIC parameter L3 tillage layer
     real(dp),    dimension(:,:,:), intent(out) :: latWat_till    ! lattice water content tillage layer
     real(dp),    dimension(:,:),   intent(out) :: COSMIC_L3      ! COSMIC parameter L3
     real(dp),    dimension(:,:),   intent(out) :: latWat         ! lattice water content
-                                                              
+
     ! Local variables
     integer(i4)                               :: i               ! loop index
     integer(i4)                               :: j               ! loop index
     integer(i4)                               :: l               ! loop index
     integer(i4)                               :: tmp_minSoilHorizon
 
 
@@ -136,18 +137,18 @@
     ! with zero there will be problem with
     ! upscaling with harmonic mean for the COMSIC_L3
     ! in case of process_case .EQ. 1
     COSMIC_L3_till = 0.000001_dp
     COSMIC_L3      = 0.000001_dp
     latWat_till    = 0.000001_dp
     latWat         = 0.000001_dp
-    
+
     ! select case according to a given soil database flag
     SELECT CASE(iFlag_soilDB)
-       
+
        ! classical mHM soil database format
        CASE(0)
           do i = 1, size(is_present)
              if ( is_present(i) .lt. 1 ) cycle
              horizon: do j = 1, nHorizons(i)
                 ! calculating other soil hydraulic properties
                 ! tillage horizons
@@ -167,79 +168,77 @@
                       call calcL3(param(6:7), DbM(i,j), COSMIC_L3(i,j-tmp_minSoilHorizon))
                       call latticeWater(param(8:9), clay(i,j), latWat(i,j-tmp_minSoilHorizon))
                    end if
                 end if
              end do horizon
           end do
 
-       ! to handle multiple soil horizons with unique soil class   
+       ! to handle multiple soil horizons with unique soil class
        CASE(1)
            do i = 1, size(is_present)
              if ( is_present(i) .lt. 1 ) cycle
              ! **** FOR THE TILLAGE TYPE OF SOIL *****
              ! there is actually no soil horizons/soil type in this case
              ! but we assign of j = 1 to use variables as defined in the classical option (iFlag_soil = 0)
-             do j = 1, 1   
+             do j = 1, 1
                 ! tillage horizons properties depending on the LC class
                 do L = 1, maxval( LCOVER0 )
                    if(process_case .EQ. 1) call latticeWater(param(2:3), clay(i,j), latWat_till(i,j,L))
                    if(process_case .EQ. 2) then
                       call calcL3(param(6:7), Db(i,j,L), COSMIC_L3_till(i,j,L))
                       call latticeWater(param(8:9), clay(i,j), latWat_till(i,j,L))
                    end if
                 end do
-                
+
                 ! *** FOR NON-TILLAGE TYPE OF SOILS ***
                 ! note j = 1
                 if(process_case .EQ. 1) call latticeWater(param(2:3), clay(i,j), latWat(i,j))
                 if(process_case .EQ. 2) then
                    call calcL3(param(6:7), DbM(i,j), COSMIC_L3(i,j))
                    call latticeWater(param(8:9), clay(i,j), latWat(i,j))
                 end if
 
-             end do  !>> HORIZON
-          end do   !>> SOIL TYPE
-          
+             end do  ! >> HORIZON
+          end do   ! >> SOIL TYPE
+
        CASE DEFAULT
-          call message()
-          call message('***ERROR: iFlag_soilDB option given does not exist. Only 0 and 1 is taken at the moment.')
-          stop
+          call error_message('***ERROR: iFlag_soilDB option given does not exist. Only 0 and 1 is taken at the moment.')
        END SELECT
        !
-       
+
    end subroutine
 
 
-  !!>> L3 parameter
+  !! >> L3 parameter
   subroutine calcL3(param, bulkDensity, L3)
     ! param(1) = COSMIC_L30
     ! param(2) = COSMIC_L31
     implicit none
     real(dp), dimension(2),  intent(in)       :: param
     real(dp),                intent(in)       :: bulkDensity
     real(dp),                intent(inout)    :: L3
- 
+
     L3 = bulkDensity*param(1) - param(2)
     if( bulkDensity .LT. 0.4_dp ) then ! bulkDensity<0.39 yields negative L3, bulkDensity=0.39 yields L3=0
        L3 = 1.0_dp                     ! Prevent division by zero later on; added by joost Iwema to COSMIC 1.13, Feb. 2017
     endif
 
   end subroutine calcL3
 
 
-  !!>>>> lattice water
+  !! >>>> lattice water
   subroutine latticeWater( param, clay, latWat )
     ! param(1) = COSMIC_LW0 or deslet_LW0
     ! param(2) = COSMIC_LW1 or deslet_LW0
     implicit none
     ! Input
     real(dp), dimension(2), intent(in)  :: param
     real(dp),               intent(in)  :: clay
     ! Output
     real(dp),               intent(out) :: latWat
 
     !Martin Schroen's dissertation
     latWat = ( param(1)*clay/100.0_dp + param(2) )
- 
+
   end subroutine latticeWater
 
 end module mo_mpr_neutrons
```

### Comparing `mhm-5.12.1.dev21/src/MPR/mo_mpr_pet.f90` & `mhm-5.13.0/src/MPR/mo_mpr_pet.f90`

 * *Files 2% similar despite different names*

```diff
@@ -1,19 +1,18 @@
-!>       \file mo_mpr_pet.f90
-
-!>       \brief TODO: add description
-
-!>       \details This module sets up pet correction factor at level-1 based on LAI
-
-!>       \authors Mehmet Cuneyd Demirel, Simon Stisen
-
-!>       \date May 2017
-
-! Modifications:
-
+!> \file mo_mpr_pet.f90
+!> \brief \copybrief mo_mpr_pet
+!> \details \copydetails mo_mpr_pet
+
+!> \brief MPR routine for PET.
+!> \details This module sets up pet correction factor at level-1 based on LAI
+!> \authors Mehmet Cuneyd Demirel, Simon Stisen
+!> \date May 2017
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mpr
 module mo_mpr_pet
 
   use mo_kind, only : i4, dp
 
   implicit none
 
   PUBLIC :: pet_correctbyLAI          ! estimate PET correction factor with distributed LAI
@@ -264,15 +263,15 @@
             param(1) + (tmp_maxCorrectionFactorPET - param(1)) / param(3) * asp0, &
             asp0 < param(3))
     fAsp0S = merge(fAsp0S, nodata, Id0 /= int(nodata, i4))
     !$OMP END PARALLEL
 
     !$OMP PARALLEL
     fAsp0 = merge(fAsp0, fAsp0S, mask_north_hemisphere_l0)
-    !$OMP END PARALLEL 
+    !$OMP END PARALLEL
 
   end subroutine pet_correctbyASP
 
   ! ----------------------------------------------------------------------------
 
   !    NAME
   !        priestley_taylor_alpha
```

### Comparing `mhm-5.12.1.dev21/src/MPR/mo_mpr_read_config.f90` & `mhm-5.13.0/src/MPR/mo_mpr_read_config.f90`

 * *Files 2% similar despite different names*

```diff
@@ -1,23 +1,27 @@
-!>       \file mo_mpr_read_config.f90
-
-!>       \brief read mpr config
-
-!>       \details This module contains all mpr subroutines related to
-!>       reading the mpr configuration from file.
-
-!>       \authors Stephan Thober
-
-!>       \date Aug 2015
-
-! Modifications:
-! Robert Schweppe Dec 2017 - adapted for MPR
-! Robert Schweppe Jun 2018 - refactoring and reformatting
-! M. Cuneyd Demirel, Simon Stisen Jun 2020 - added Feddes and FC dependency on root fraction coefficient processCase(3) = 4
-! Rohini Kumar                    Oct 2021 - Added Neutron count module to mHM integrate into develop branch (5.11.2)
+!> \file mo_mpr_read_config.f90
+!> \brief \copybrief mo_mpr_read_config
+!> \details \copydetails mo_mpr_read_config
+
+!> \brief read mpr config
+!> \details This module contains all mpr subroutines related to reading the mpr configuration from file.
+!> \changelog
+!! - Robert Schweppe Dec 2017
+!!   - adapted for MPR
+!! - Robert Schweppe Jun 2018
+!!   - refactoring and reformatting
+!! - M. Cuneyd Demirel, Simon Stisen Jun 2020
+!!   - added Feddes and FC dependency on root fraction coefficient processCase(3) = 4
+!! - Rohini Kumar                    Oct 2021
+!!   - Added Neutron count module to mHM integrate into develop branch (5.11.2)
+!> \authors Stephan Thober
+!> \date Aug 2015
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mpr
 module mo_mpr_read_config
 
   use mo_kind, only : i4, dp
 
   implicit none
 
   public :: mpr_read_config
@@ -55,15 +59,15 @@
 
   subroutine mpr_read_config(file_namelist, unamelist, file_namelist_param, unamelist_param)
 
     use mo_append, only : append
     use mo_common_constants, only : eps_dp, maxNoDomains, nColPars, nodata_dp
     use mo_common_functions, only : in_bound
     use mo_common_variables, only : global_parameters, global_parameters_name, domainMeta, processMatrix
-    use mo_message, only : message
+    use mo_message, only : message, error_message
     use mo_mpr_constants, only : maxGeoUnit, &
                                  maxNoSoilHorizons
     use mo_mpr_global_variables, only : HorizonDepth_mHM, dirgridded_LAI, fracSealed_cityArea, iFlag_soilDB, &
                                         inputFormat_gridded_LAI, nGeoUnits, nSoilHorizons_mHM, tillageDepth, &
                                         timeStep_LAI_input
     use mo_nml, only : close_nml, open_nml, position_nml
     use mo_string_utils, only : num2str
@@ -213,33 +217,33 @@
     real(dp), dimension(nColPars) :: gain_loss_GWreservoir_karstic
 
     real(dp), dimension(maxGeoUnit, nColPars) :: GeoParam
 
     real(dp), dimension(nColPars) :: Desilets_N0
 
     real(dp), dimension(nColPars) :: Desilets_LW0
-    
+
     real(dp), dimension(nColPars) :: Desilets_LW1
-    
+
     real(dp), dimension(nColPars) :: COSMIC_N0
 
     real(dp), dimension(nColPars) :: COSMIC_N1
 
     real(dp), dimension(nColPars) :: COSMIC_N2
 
     real(dp), dimension(nColPars) :: COSMIC_alpha0
 
     real(dp), dimension(nColPars) :: COSMIC_alpha1
 
     real(dp), dimension(nColPars) :: COSMIC_L30
 
     real(dp), dimension(nColPars) :: COSMIC_L31
-    
+
     real(dp), dimension(nColPars) :: COSMIC_LW0
-    
+
     real(dp), dimension(nColPars) :: COSMIC_LW1
 
     integer(i4) :: iDomain, domainID
 
 
     ! namelist directories
     namelist /directories_MPR/ dir_gridded_LAI
@@ -295,15 +299,15 @@
             roughnesslength_momentum_coeff, roughnesslength_heat_coeff, stomatal_resistance
     namelist /interflow1/ interflowStorageCapacityFactor, interflowRecession_slope, fastInterflowRecession_forest, &
             slowInterflowRecession_Ks, exponentSlowInterflow
     namelist /percolation1/ rechargeCoefficient, rechargeFactor_karstic, gain_loss_GWreservoir_karstic
     namelist /neutrons1/ Desilets_N0, Desilets_LW0, Desilets_LW1
     namelist /neutrons2/ COSMIC_N0, COSMIC_N1, COSMIC_N2, COSMIC_alpha0, COSMIC_alpha1, COSMIC_L30, COSMIC_L31, &
          COSMIC_LW0, COSMIC_LW1
-         
+
     !
     namelist /geoparameter/ GeoParam
 
     !===============================================================
     ! INITIALIZATION
     !===============================================================
     soil_Depth = 0.0_dp
@@ -327,36 +331,30 @@
     allocate(HorizonDepth_mHM(nSoilHorizons_mHM))
     HorizonDepth_mHM(:) = 0.0_dp
     ! last layer is reset to 0 in MPR in case of iFlag_soilDB is 0
     HorizonDepth_mHM(1 : nSoilHorizons_mHM) = soil_Depth(1 : nSoilHorizons_mHM)
 
     ! counter checks -- soil horizons
     if (nSoilHorizons_mHM .GT. maxNoSoilHorizons) then
-      call message()
-      call message('***ERROR: Number of soil horizons is resticted to ', trim(num2str(maxNoSoilHorizons)), '!')
-      stop
+      call error_message('***ERROR: Number of soil horizons is resticted to ', trim(num2str(maxNoSoilHorizons)), '!')
     end if
 
     ! the default is the HorizonDepths are all set up to last
     ! as is the default for option-1 where horizon specific information are taken into consideration
     if(iFlag_soilDB .eq. 0) then
       ! classical mhm soil database
       HorizonDepth_mHM(nSoilHorizons_mHM) = 0.0_dp
     else if(iFlag_soilDB .ne. 1) then
-      call message()
-      call message('***ERROR: iFlag_soilDB option given does not exist. Only 0 and 1 is taken at the moment.')
-      stop
+      call error_message('***ERROR: iFlag_soilDB option given does not exist. Only 0 and 1 is taken at the moment.')
     end if
 
     ! some consistency checks for the specification of the tillage depth
     if(iFlag_soilDB .eq. 1) then
       if(count(abs(HorizonDepth_mHM(:) - tillageDepth) .lt. eps_dp)  .eq. 0) then
-        call message()
-        call message('***ERROR: Soil tillage depth must conform with one of the specified horizon (lower) depth.')
-        stop
+        call error_message('***ERROR: Soil tillage depth must conform with one of the specified horizon (lower) depth.')
       end if
     end if
 
     !===============================================================
     ! Read LAI related information
     !===============================================================
     call position_nml('LAI_data_information', unamelist)
@@ -372,17 +370,15 @@
       allocate(dirgridded_LAI(domainMeta%nDomains))
       do iDomain = 1, domainMeta%nDomains
         domainID = domainMeta%indices(iDomain)
         dirgridded_LAI(iDomain) = dir_gridded_LAI(domainID)
       end do
 
       if (timeStep_LAI_input .GT. 1) then
-        call message()
-        call message('***ERROR: option for selected timeStep_LAI_input not coded yet')
-        stop
+        call error_message('***ERROR: option for selected timeStep_LAI_input not coded yet')
       end if
     end if
 
     call close_nml(unamelist)
 
     !===============================================================
     ! Read namelist global parameters
@@ -402,23 +398,20 @@
       call append(global_parameters, reshape(canopyInterceptionFactor, (/1, nColPars/)))
 
       call append(global_parameters_name, (/  &
               'canopyInterceptionFactor'/))
 
       ! check if parameter are in range
       if (.not. in_bound(global_parameters)) then
-        call message('***ERROR: parameter in namelist "interception1" out of bound in ', &
+        call error_message('***ERROR: parameter in namelist "interception1" out of bound in ', &
                 trim(adjustl(file_namelist_param)))
-        stop
       end if
 
     case DEFAULT
-      call message()
-      call message('***ERROR: Process description for process "interception" does not exist!')
-      stop
+       call error_message('***ERROR: Process description for process "interception" does not exist!')
     end select
 
     ! Process 2 - snow
     select case (processMatrix(2, 1))
       ! 1 - degree-day approach
     case(1)
       call position_nml('snow1', unamelist_param)
@@ -443,23 +436,20 @@
                       'increaseDegreeDayFactorByPrecip', &
                       'maxDegreeDayFactor_forest      ', &
                       'maxDegreeDayFactor_impervious  ', &
                       'maxDegreeDayFactor_pervious    '/))
 
       ! check if parameter are in range
       if (.not. in_bound(global_parameters)) then
-        call message('***ERROR: parameter in namelist "snow1" out of bound in ', &
+        call error_message('***ERROR: parameter in namelist "snow1" out of bound in ', &
                 trim(adjustl(file_namelist_param)))
-        stop
       end if
 
     case DEFAULT
-      call message()
-      call message('***ERROR: Process description for process "snow" does not exist!')
-      stop
+       call error_message('***ERROR: Process description for process "snow" does not exist!')
     end select
 
     ! Process 3 - soilmoisture
     select case (processMatrix(3, 1))
 
       ! 1 - Feddes equation for PET reduction, bucket approach, Brooks-Corey like
     case(1)
@@ -502,17 +492,16 @@
                       'rootFractionCoefficient_forest    ', &
                       'rootFractionCoefficient_impervious', &
                       'rootFractionCoefficient_pervious  ', &
                       'infiltrationShapeFactor           '/))
 
       ! check if parameter are in range
       if (.not. in_bound(global_parameters)) then
-        call message('***ERROR: parameter in namelist "soilmoisture1" out of bound in ', &
+        call error_message('***ERROR: parameter in namelist "soilmoisture1" out of bound in ', &
                 trim(adjustl(file_namelist_param)))
-        stop
       end if
 
       ! 2- Jarvis equation for PET reduction, bucket approach, Brooks-Corey like
     case(2)
       call position_nml('soilmoisture2', unamelist_param)
       read(unamelist_param, nml = soilmoisture2)
       processMatrix(3, 2) = 18_i4
@@ -554,17 +543,16 @@
                       'rootFractionCoefficient_impervious', &
                       'rootFractionCoefficient_pervious  ', &
                       'infiltrationShapeFactor           ', &
                       'jarvis_sm_threshold_c1            '/))
 
       ! check if parameter are in range
       if (.not. in_bound(global_parameters)) then
-        call message('***ERROR: parameter in namelist "soilmoisture2" out of bound in ', &
+        call error_message('***ERROR: parameter in namelist "soilmoisture2" out of bound in ', &
                 trim(adjustl(file_namelist_param)))
-        stop
       end if
 
       ! 3- Jarvis equation for ET reduction and FC dependency on root fraction coefficient
     case(3)
       call position_nml('soilmoisture3', unamelist_param)
       read(unamelist_param, nml = soilmoisture3)
       processMatrix(3, 2) = 22_i4
@@ -615,17 +603,16 @@
                       'rootFractionCoefficient_clay      ', &
                       'FCmin_glob                        ', &
                       'FCdelta_glob                      ', &
                       'jarvis_sm_threshold_c1            '/))
 
       ! check if parameter are in range
       if (.not. in_bound(global_parameters)) then
-        call message('***ERROR: parameter in namelist "soilmoisture3" out of bound in ', &
+        call error_message('***ERROR: parameter in namelist "soilmoisture3" out of bound in ', &
                 trim(adjustl(file_namelist_param)))
-        stop
       end if
 
       ! 4- Feddes equation for ET reduction and FC dependency on root fraction coefficient
     case(4)
       call position_nml('soilmoisture4', unamelist_param)
       read(unamelist_param, nml = soilmoisture4)
       processMatrix(3, 2) = 21_i4
@@ -673,24 +660,21 @@
                       'rootFractionCoefficient_sand      ', &
                       'rootFractionCoefficient_clay      ', &
                       'FCmin_glob                        ', &
                       'FCdelta_glob                      '/))
 
       ! check if parameter are in range
       if (.not. in_bound(global_parameters)) then
-        call message('***ERROR: parameter in namelist "soilmoisture4" out of bound in ', &
+        call error_message('***ERROR: parameter in namelist "soilmoisture4" out of bound in ', &
                 trim(adjustl(file_namelist_param)))
-        stop
       end if
 
 
     case DEFAULT
-      call message()
-      call message('***ERROR: Process description for process "soilmoisture" does not exist!')
-      stop
+      call error_message('***ERROR: Process description for process "soilmoisture" does not exist!')
     end select
 
     ! Process 4 - sealed area directRunoff
     select case (processMatrix(4, 1))
       ! 1 - bucket exceedance approach
     case(1)
       call position_nml('directRunoff1', unamelist_param)
@@ -699,23 +683,20 @@
       processMatrix(4, 3) = sum(processMatrix(1 : 4, 2))
       call append(global_parameters, reshape(imperviousStorageCapacity, (/1, nColPars/)))
 
       call append(global_parameters_name, (/'imperviousStorageCapacity'/))
 
       ! check if parameter are in range
       if (.not. in_bound(global_parameters)) then
-        call message('***ERROR: parameter in namelist "directRunoff1" out of bound in ', &
+        call error_message('***ERROR: parameter in namelist "directRunoff1" out of bound in ', &
                 trim(adjustl(file_namelist_param)))
-        stop
       end if
 
     case DEFAULT
-      call message()
-      call message('***ERROR: Process description for process "directRunoff" does not exist!')
-      stop
+      call error_message('***ERROR: Process description for process "directRunoff" does not exist!')
     end select
 
     ! Process 5 - potential evapotranspiration (PET)
     select case (processMatrix(5, 1))
     case(-1) ! 0 - PET is input, correct PET by LAI
       call position_nml('PETminus1', unamelist_param)
       read(unamelist_param, nml = PETminus1)
@@ -732,17 +713,16 @@
                       'PET_a_impervious ', &
                       'PET_a_pervious   ', &
                       'PET_b            ', &
                       'PET_c            '/))
 
       ! check if parameter are in range
       if (.not. in_bound(global_parameters)) then
-        call message('***ERROR: parameter in namelist "PETminus1" out of bound  n ', &
+        call error_message('***ERROR: parameter in namelist "PETminus1" out of bound  n ', &
                 trim(adjustl(file_namelist_param)))
-        stop 1
       end if
 
     case(0) ! 0 - PET is input, correct PET by aspect
       call position_nml('PET0', unamelist_param)
       read(unamelist_param, nml = PET0)
       processMatrix(5, 2) = 3_i4
       processMatrix(5, 3) = sum(processMatrix(1 : 5, 2))
@@ -753,17 +733,16 @@
       call append(global_parameters_name, (/ &
                   'minCorrectionFactorPET ', &
                   'maxCorrectionFactorPET ', &
                   'aspectTresholdPET      '/))
 
       ! check if parameter are in range
       if (.not. in_bound(global_parameters)) then
-        call message('***ERROR: parameter in namelist "PET0" out of bound in ', &
+        call error_message('***ERROR: parameter in namelist "PET0" out of bound in ', &
                 trim(adjustl(file_namelist_param)))
-        stop
       end if
 
     case(1) ! 1 - Hargreaves-Samani method (HarSam) - additional input needed: Tmin, Tmax
       call position_nml('PET1', unamelist_param)
       read(unamelist_param, nml = PET1)
       processMatrix(5, 2) = 4_i4
       processMatrix(5, 3) = sum(processMatrix(1 : 5, 2))
@@ -775,17 +754,16 @@
                    'minCorrectionFactorPET', &
                    'maxCorrectionFactorPET', &
                    'aspectTresholdPET     ', &
                    'HargreavesSamaniCoeff '/))
 
       ! check if parameter are in range
       if (.not. in_bound(global_parameters)) then
-        call message('***ERROR: parameter in namelist "PET1" out of bound in ', &
+        call error_message('***ERROR: parameter in namelist "PET1" out of bound in ', &
                 trim(adjustl(file_namelist_param)))
-        stop
       end if
 
     case(2) ! 2 - Priestley-Taylor method (PrieTay) - additional input needed: net_rad
       call position_nml('PET2', unamelist_param)
       read(unamelist_param, nml = PET2)
       processMatrix(5, 2) = 2_i4
       processMatrix(5, 3) = sum(processMatrix(1 : 5, 2))
@@ -793,17 +771,16 @@
       call append(global_parameters, reshape(PriestleyTaylorLAIcorr, (/1, nColPars/)))
       call append(global_parameters_name, (/ &
                    'PriestleyTaylorCoeff  ', &
                    'PriestleyTaylorLAIcorr'/))
 
       ! check if parameter are in range
       if (.not. in_bound(global_parameters)) then
-        call message('***ERROR: parameter in namelist "PET2" out of bound in ', &
+        call error_message('***ERROR: parameter in namelist "PET2" out of bound in ', &
                 trim(adjustl(file_namelist_param)))
-        stop
       end if
 
     case(3) ! 3 - Penman-Monteith method - additional input needed: net_rad, abs. vapour pressue, windspeed
       call position_nml('PET3', unamelist_param)
       read(unamelist_param, nml = PET3)
       processMatrix(5, 2) = 7_i4
       processMatrix(5, 3) = sum(processMatrix(1 : 5, 2))
@@ -823,23 +800,20 @@
            'displacementheight_coeff      ', &
            'roughnesslength_momentum_coeff', &
            'roughnesslength_heat_coeff    ', &
            'stomatal_resistance           '/))
 
       ! check if parameter are in range
       if (.not. in_bound(global_parameters)) then
-        call message('***ERROR: parameter in namelist "PET3" out of bound in ', &
+        call error_message('***ERROR: parameter in namelist "PET3" out of bound in ', &
                 trim(adjustl(file_namelist_param)))
-        stop
       end if
 
     case DEFAULT
-      call message()
-      call message('***ERROR: Process description for process "actualET" does not exist!')
-      stop
+      call error_message('***ERROR: Process description for process "actualET" does not exist!')
     end select
 
 
     ! Process 6 - interflow
     select case (processMatrix(6, 1))
       ! 1 - parallel soil reservoir approach
     case(1)
@@ -858,23 +832,20 @@
            'interflowRecession_slope      ', &
            'fastInterflowRecession_forest ', &
            'slowInterflowRecession_Ks     ', &
            'exponentSlowInterflow         '/))
 
       ! check if parameter are in range
       if (.not. in_bound(global_parameters)) then
-        call message('***ERROR: parameter in namelist "interflow1" out of bound in ', &
+        call error_message('***ERROR: parameter in namelist "interflow1" out of bound in ', &
                 trim(adjustl(file_namelist_param)))
-        stop
       end if
 
     case DEFAULT
-      call message()
-      call message('***ERROR: Process description for process "interflow" does not exist!')
-      stop
+      call error_message('***ERROR: Process description for process "interflow" does not exist!')
     end select
 
     ! Process 7 - percolation
     select case (processMatrix(7, 1))
       ! 1 - GW layer is assumed as bucket
     case(1)
       call position_nml('percolation1', unamelist_param)
@@ -888,23 +859,20 @@
       call append(global_parameters_name, (/ &
               'rechargeCoefficient          ', &
               'rechargeFactor_karstic       ', &
               'gain_loss_GWreservoir_karstic'/))
 
       ! check if parameter are in range
       if (.not. in_bound(global_parameters)) then
-        call message('***ERROR: parameter in namelist "percolation1" out of bound in ', &
+        call error_message('***ERROR: parameter in namelist "percolation1" out of bound in ', &
                 trim(adjustl(file_namelist_param)))
-        stop
       end if
 
     case DEFAULT
-      call message()
-      call message('***ERROR: Process description for process "percolation" does not exist!')
-      stop
+      call error_message('***ERROR: Process description for process "percolation" does not exist!')
     end select
 
     ! Process 8 - routing
     select case (processMatrix(8, 1))
     case(0)
       ! 0 - deactivated
       call message()
@@ -926,17 +894,15 @@
       call append(global_parameters_name, (/'dummy'/))
     case(3)
       processMatrix(8, 2) = 1_i4
       processMatrix(8, 3) = sum(processMatrix(1 : 8, 2))
       call append(global_parameters, dummy_2d_dp_2)
       call append(global_parameters_name, (/'dummy'/))
     case DEFAULT
-      call message()
-      call message('***ERROR: Process description for process "routing" does not exist!')
-      stop
+      call error_message('***ERROR: Process description for process "routing" does not exist!')
     end select
 
     !===============================================================
     ! Geological formations
     !===============================================================
     dummy = dummy // ''   ! only to avoid warning
 
@@ -966,38 +932,35 @@
       do ii = 1, nGeoUnits
         dummy = 'GeoParam(' // trim(adjustl(num2str(ii))) // ',:)'
         call append(global_parameters_name, (/ trim(dummy) /))
       end do
 
       ! check if parameter are in range
       if (.not. in_bound(global_parameters)) then
-        call message('***ERROR: parameter in namelist "geoparameter" out of bound in ', &
+        call error_message('***ERROR: parameter in namelist "geoparameter" out of bound in ', &
                 trim(adjustl(file_namelist_param)))
-        stop
       end if
 
     case DEFAULT
-      call message()
-      call message('***ERROR: Process description for process "geoparameter" does not exist!')
-      stop
-   end select
-   
+      call error_message('***ERROR: Process description for process "geoparameter" does not exist!')
+    end select
+
     !===============================================================
     ! NEUTRON COUNT
     !===============================================================
     ! Process 10 - neutrons
     !   0 - deactivated
     !   1 - inverse N0 based on Desilets et al. 2010
     !   2 - COSMIC forward operator by Shuttlworth et al. 2013
     select case (processMatrix(10, 1))
     case(0)
       ! 0 - deactivated
       call message()
       call message('***SELECTION: Neutron count routine is deativated! ')
-      
+
     case(1)
       ! 1 - inverse N0 based on Desilets et al. 2010
       call position_nml('neutrons1', unamelist_param)
       read(unamelist_param, nml = neutrons1)
 
       processMatrix(10,2) = 3_i4
       processMatrix(10,3) = sum(processMatrix(1:10, 2))
@@ -1005,20 +968,19 @@
       call append(global_parameters, reshape(Desilets_LW0, (/1, nColPars/)))
       call append(global_parameters, reshape(Desilets_LW1, (/1, nColPars/)))
 
        call append(global_parameters_name, (/  &
            'Desilets_N0   ', &
            'Desilets_LW0  ', &
            'Desilets_LW1  '/))
- 
+
       ! check if parameter are in range
       if (.not. in_bound(global_parameters)) then
-        call message('***ERROR: parameter in namelist "neutrons1" out of bound in ', &
+        call error_message('***ERROR: parameter in namelist "neutrons1" out of bound in ', &
                 trim(adjustl(file_namelist_param)))
-        stop
       end if
 
     case(2)
       ! 2 - COSMIC version
       call position_nml('neutrons2', unamelist_param)
       read(unamelist_param, nml = neutrons2)
 
@@ -1042,24 +1004,21 @@
            'COSMIC_alpha1 ', &
            'COSMIC_L30    ', &
            'COSMIC_L31    ', &
            'COSMIC_LW0    ', &
            'COSMIC_LW1    '/))
       ! check if parameter are in range
       if (.not. in_bound(global_parameters)) then
-        call message('***ERROR: parameter in namelist "neutrons2" out of bound in ', &
+        call error_message('***ERROR: parameter in namelist "neutrons2" out of bound in ', &
                 trim(adjustl(file_namelist_param)))
-        stop
       end if
-      
-     case DEFAULT
-      call message()
-      call message('***ERROR: Process description for process "NEUTRON count" does not exist!')
-      stop
-   end select
 
-    
+    case DEFAULT
+      call error_message('***ERROR: Process description for process "NEUTRON count" does not exist!')
+    end select
+
+
     call close_nml(unamelist_param)
 
   end subroutine mpr_read_config
 
 end module mo_mpr_read_config
```

### Comparing `mhm-5.12.1.dev21/src/MPR/mo_mpr_restart.f90` & `mhm-5.13.0/src/MPR/mo_mpr_restart.f90`

 * *Files 5% similar despite different names*

```diff
@@ -1,104 +1,75 @@
-!>       \file mo_mpr_restart.f90
-
-!>       \brief reading and writing states, fluxes and configuration for restart of mHM.
-
-!>       \details routines are seperated for reading and writing variables for:
-!>       - states and fluxes, and
-!>       - configuration.
-!>       Reading of L11 configuration is also seperated from the rest,
-!>       since it is only required when routing is activated.
-
-!>       \authors Stephan Thober
-
-!>       \date Jul 2013
-
-! Modifications:
-
+!> \file mo_mpr_restart.f90
+!> \brief \copybrief mo_mpr_restart
+!> \details \copydetails mo_mpr_restart
+
+!> \brief reading and writing states, fluxes and configuration for restart of mHM.
+!> \details routines are seperated for reading and writing variables for:
+!!  - states and fluxes, and
+!!  - configuration.
+!!
+!! Reading of L11 configuration is also seperated from the rest, since it is only required when routing is activated.
+!> \authors Stephan Thober
+!> \date Jul 2013
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mpr
 MODULE mo_mpr_restart
 
   ! This module is a restart for the UFZ CHS mesoscale hydrologic model mHM.
 
   ! Written  Stephan Thober, Apr 2011
 
   IMPLICIT NONE
 
   PRIVATE
 
   PUBLIC :: write_eff_params            ! read restart files for configuration from a given path
   PUBLIC :: write_mpr_restart_files     ! write restart files for configuration to a given path
 
-  !    NAME
-  !        unpack_field_and_write
-
-  !    PURPOSE
-  !>       \brief TODO: add description
-
-  !>       \details TODO: add description
-
-  !    INTENT(INOUT)
-  !>       \param[inout] "type(NcDataset) :: nc" NcDataset to add variable to
-
-  !    INTENT(IN)
-  !>       \param[in] "character(*) :: var_name"                    variable name
-  !>       \param[in] "type(NcDimension), dimension(:) :: var_dims" vector of Variable dimensions
-  !>       \param[in] "integer(i4) :: fill_value"                   fill value used for missing values
-  !>       \param[in] "integer(i4), dimension(:) :: data"           packed data to be set to variable
-  !>       \param[in] "logical, dimension(:, :) :: mask"            mask used for unpacking
-
-  !    INTENT(IN), OPTIONAL
-  !>       \param[in] "character(*), optional :: var_long_name" variable long name attribute
-
-  !    HISTORY
-  !>       \authors Robert Schweppe
-
-  !>       \date Jun 2018
-
-  ! Modifications:
-
 
+  !> \brief unpack parameter fields and write them to file
+  !> \param[inout] "type(NcDataset) :: nc"                    NcDataset to add variable to
+  !> \param[in] "character(*) :: var_name"                    variable name
+  !> \param[in] "type(NcDimension), dimension(:) :: var_dims" vector of Variable dimensions
+  !> \param[in] "integer(i4) :: fill_value"                   fill value used for missing values
+  !> \param[in] "integer(i4/dp), dimension(...) :: data"      packed data to be set to variable
+  !> \param[in] "logical, dimension(:, :) :: mask"            mask used for unpacking
+  !> \param[in] "character(*), optional :: var_long_name"     variable long name attribute
+  !> \authors Robert Schweppe
+  !> \date Jun 2018
   INTERFACE unpack_field_and_write
     MODULE PROCEDURE unpack_field_and_write_1d_i4, &
             unpack_field_and_write_1d_dp, &
             unpack_field_and_write_2d_dp, &
             unpack_field_and_write_3d_dp
   end interface unpack_field_and_write
 
 
 CONTAINS
-  ! ------------------------------------------------------------------
-
-  !    NAME
-  !        write_mpr_restart_files
-
-  !    PURPOSE
-  !>       \brief write restart files for each domain
-
-  !>       \details write restart files for each domain. For each domain
-  !>       three restart files are written. These are xxx_states.nc,
-  !>       xxx_L11_config.nc, and xxx_config.nc (xxx being the three digit
-  !>       domain index). If a variable is added here, it should also be added
-  !>       in the read restart routines below.
-  !>       ADDITIONAL INFORMATION
-  !>       write_restart
-
-  !    INTENT(IN)
-  !>       \param[in] "character(256), dimension(:) :: OutFile" Output Path for each domain
-
-  !    HISTORY
-  !>       \authors Stephan Thober
-
-  !>       \date Jun 2014
-
-  ! Modifications:
-  ! Stephan Thober     Aug  2015 - moved write of routing states to mRM
-  ! David Schaefer     Nov  2015 - mo_netcdf
-  ! Stephan Thober     Nov  2016 - moved processMatrix to common variables
-  ! Zink M. Demirel C. Mar 2017 - Added Jarvis soil water stress function at SM process(3)
 
+  !> \brief write restart files for each domain
+  !> \details write restart files for each domain. For each domain
+  !! three restart files are written. These are xxx_states.nc,
+  !! xxx_L11_config.nc, and xxx_config.nc (xxx being the three digit
+  !! domain index). If a variable is added here, it should also be added
+  !! in the read restart routines below.
+  !! ADDITIONAL INFORMATION
+  !! write_restart
+  !> \changelog
+  !! - Stephan Thober Aug 2015
+  !!   - moved write of routing states to mRM
+  !! - David Schaefer Nov 2015
+  !!   - mo_netcdf
+  !! - Stephan Thober Nov 2016
+  !!   - moved processMatrix to common variables
+  !! - Zink M. Demirel C. Mar 2017
+  !!   - Added Jarvis soil water stress function at SM process(3)
+  !> \authors Stephan Thober
+  !> \date Jun 2014
   subroutine write_mpr_restart_files(OutFile)
 
     use mo_common_restart, only : write_grid_info
     use mo_common_variables, only : level1, nLCoverScene, domainMeta, LC_year_start, LC_year_end
     use mo_kind, only : i4, dp
     use mo_message, only : message
     use mo_mpr_global_variables, only : nLAI, nSoilHorizons_mHM, HorizonDepth_mHM
@@ -106,15 +77,15 @@
     use mo_string_utils, only : num2str
     use mo_common_constants, only : soilHorizonsVarName, landCoverPeriodsVarName, LAIVarName
 
     implicit none
 
     character(256) :: Fname
 
-    ! Output Path for each domain
+    !> Output Path for each domain
     character(256), dimension(:), intent(in) :: OutFile
 
     integer(i4) :: iDomain, domainID
 
     ! start index at level 1
     integer(i4) :: s1
 
@@ -173,88 +144,62 @@
       deallocate(mask1)
       call nc%close()
 
     end do domain_loop
 
   end subroutine write_mpr_restart_files
 
-  !    NAME
-  !        write_eff_params
-
-  !    PURPOSE
-  !>       \brief TODO: add description
-
-  !>       \details TODO: add description
-
-  !    INTENT(IN)
-  !>       \param[in] "logical, dimension(:, :) :: mask1"                        mask at level 1
-  !>       \param[in] "integer(i4) :: s1"                                        start index at level 1
-  !>       \param[in] "integer(i4) :: e1"                                        end index at level 1
-  !>       \param[in] "type(NcDimension) :: rows1, cols1, soil1, lcscenes, lais"
-  !>       \param[in] "type(NcDimension) :: rows1, cols1, soil1, lcscenes, lais"
-  !>       \param[in] "type(NcDimension) :: rows1, cols1, soil1, lcscenes, lais"
-  !>       \param[in] "type(NcDimension) :: rows1, cols1, soil1, lcscenes, lais"
-  !>       \param[in] "type(NcDimension) :: rows1, cols1, soil1, lcscenes, lais"
-
-  !    INTENT(INOUT)
-  !>       \param[inout] "type(NcDataset) :: nc"
-
-  !    HISTORY
-  !>       \authors Robert Schweppe
-
-  !>       \date Jun 2018
-  !> Rohini Kumar             Oct 2021 - Added Neutron count module
-  !                                      to mHM integrate into develop branch (5.11.2)
-  
-
-  ! Modifications:
 
+  !> \brief write effective parameter fields to given restart file
+  !> \changelog
+  !!  - Rohini Kumar Oct 2021
+  !!    - Added Neutron count module to mHM integrate into develop branch (5.11.2)
+  !!  - Sebastian Mller Mar 2023
+  !!    - made L1_alpha, L1_kSlowFlow, L1_kBaseFlow and L1_kPerco land cover dependent
+  !> \authors Robert Schweppe
+  !> \date Jun 2018
   subroutine write_eff_params(mask1, s1, e1, rows1, cols1, soil1, lcscenes, lais, nc)
 
     use mo_common_constants, only : nodata_dp, nodata_i4
     use mo_common_variables, only : LC_year_end, LC_year_start, processMatrix
     use mo_kind, only : i4
     use mo_mpr_global_variables, only : L1_HarSamCoeff, L1_PrieTayAlpha, L1_aeroResist, &
                                         L1_alpha, L1_degDay, L1_degDayInc, L1_degDayMax, L1_degDayNoPre, L1_fAsp, &
                                         L1_fRoots, L1_fSealed, L1_jarvis_thresh_c1, L1_kBaseFlow, L1_kPerco, &
                                         L1_kSlowFlow, L1_karstLoss, L1_kfastFlow, L1_maxInter, L1_petLAIcorFactor, &
                                         L1_sealedThresh, L1_soilMoistExp, L1_soilMoistFC, L1_soilMoistSat, L1_surfResist, &
                                         L1_tempThresh, L1_unsatThresh, L1_wiltingPoint, &
                                         ! neutron count
                                         L1_No_Count, L1_bulkDens, L1_latticeWater, L1_COSMICL3
-    
+
     use mo_netcdf, only : NcDataset, NcDimension, NcVariable
 
     implicit none
 
-    ! mask at level 1
-    logical, dimension(:, :), allocatable, intent(in) :: mask1
-
-    ! start index at level 1
-    integer(i4), intent(in) :: s1
-
-    ! end index at level 1
-    integer(i4), intent(in) :: e1
-
-    type(NcDimension), intent(in) :: rows1, cols1, soil1, lcscenes, lais
-
-    type(NcDataset), intent(inout) :: nc
+    logical, dimension(:, :), allocatable, intent(in) :: mask1 !< mask at level 1
+    integer(i4), intent(in) :: s1 !< start index at level 1
+    integer(i4), intent(in) :: e1 !< end index at level 1
+    type(NcDimension), intent(in) :: rows1 !< y dimension
+    type(NcDimension), intent(in) :: cols1 !< x dimension
+    type(NcDimension), intent(in) :: soil1 !< soil dimension
+    type(NcDimension), intent(in) :: lcscenes !< land conver scenes dimension
+    type(NcDimension), intent(in) :: lais !< LAI dimension
+    type(NcDataset), intent(inout) :: nc !< NetCDF file to write to
 
     type(NcVariable) :: var
 
-
     !-------------------------------------------
     ! EFFECTIVE PARAMETERS
     !-------------------------------------------
     call unpack_field_and_write(nc, "L1_fSealed", &
             (/rows1, cols1, lcscenes/), nodata_dp, L1_fSealed(s1 : e1, 1, :), mask1, &
             "fraction of Sealed area at level 1")
 
     call unpack_field_and_write(nc, "L1_alpha", &
-            (/rows1, cols1/), nodata_dp, L1_alpha(s1 : e1, 1, 1), mask1, &
+            (/rows1, cols1, lcscenes/), nodata_dp, L1_alpha(s1 : e1, 1, :), mask1, &
             "exponent for the upper reservoir at level 1")
 
     call unpack_field_and_write(nc, "L1_degDayInc", &
             (/rows1, cols1, lcscenes/), nodata_dp, L1_degDayInc(s1 : e1, 1, :), mask1, &
             "increase of the Degree-day factor per mm of increase in precipitation at level 1")
 
     call unpack_field_and_write(nc, "L1_degDayMax", &
@@ -282,23 +227,23 @@
             "Maximum interception at level 1")
 
     call unpack_field_and_write(nc, "L1_kfastFlow", &
             (/rows1, cols1, lcscenes/), nodata_dp, L1_kfastFlow(s1 : e1, 1, :), mask1, &
             "fast interflow recession coefficient at level 1")
 
     call unpack_field_and_write(nc, "L1_kSlowFlow", &
-            (/rows1, cols1/), nodata_dp, L1_kSlowFlow(s1 : e1, 1, 1), mask1, &
+            (/rows1, cols1, lcscenes/), nodata_dp, L1_kSlowFlow(s1 : e1, 1, :), mask1, &
             "slow interflow recession coefficient at level 1")
 
     call unpack_field_and_write(nc, "L1_kBaseFlow", &
-            (/rows1, cols1/), nodata_dp, L1_kBaseFlow(s1 : e1, 1, 1), mask1, &
+            (/rows1, cols1, lcscenes/), nodata_dp, L1_kBaseFlow(s1 : e1, 1, :), mask1, &
             "baseflow recession coefficient at level 1")
 
     call unpack_field_and_write(nc, "L1_kPerco", &
-            (/rows1, cols1/), nodata_dp, L1_kPerco(s1 : e1, 1, 1), mask1, &
+            (/rows1, cols1, lcscenes/), nodata_dp, L1_kPerco(s1 : e1, 1, :), mask1, &
             "percolation coefficient at level 1")
 
     call unpack_field_and_write(nc, "L1_soilMoistFC", &
             (/rows1, cols1, soil1, lcscenes/), nodata_dp, L1_soilMoistFC(s1 : e1, :, :), mask1, &
             "SM below which actual ET is reduced linearly till PWP at level 1 for processCase(3)=1")
 
     call unpack_field_and_write(nc, "L1_soilMoistSat", &
@@ -376,15 +321,15 @@
            "N0 count at level 1")
       call unpack_field_and_write(nc, "L1_bulkDens", &
            (/rows1, cols1, soil1, lcscenes/), nodata_dp, L1_bulkDens(s1:e1, :, :), mask1, &
            "Bulk density at level 1 for processCase(10)")
       call unpack_field_and_write(nc, "L1_latticeWater", &
            (/rows1, cols1, soil1, lcscenes/), nodata_dp, L1_latticeWater(s1:e1, :, :), mask1, &
            "Lattice water content at level 1 for processCase(10)")
-      
+
    case(2) ! COSMIC
       call unpack_field_and_write(nc, "L1_No_Count", &
            (/rows1, cols1/), nodata_dp, L1_No_Count(s1 : e1, 1, 1), mask1, &
            "N0 count at level 1")
       call unpack_field_and_write(nc, "L1_bulkDens", &
            (/rows1, cols1, soil1, lcscenes/), nodata_dp, L1_bulkDens(s1 : e1, :, :), mask1, &
            "Bulk density at level 1 for processCase(10)")
@@ -394,14 +339,15 @@
       call unpack_field_and_write(nc, "L1_COSMICL3", &
            (/rows1, cols1, soil1, lcscenes/), nodata_dp, L1_COSMICL3(s1 : e1, :, :), mask1, &
            "COSMIC L3 parameter at level 1 for processCase(10)")
    end select
 
   end subroutine write_eff_params
 
+  !> \copydoc unpack_field_and_write
   subroutine unpack_field_and_write_1d_i4(nc, var_name, var_dims, fill_value, data, mask, var_long_name)
 
     use mo_kind, only : i4
     use mo_netcdf, only : NcDataset, NcDimension, NcVariable
 
     implicit none
 
@@ -439,14 +385,15 @@
     ! optionally set attributes
     if (present(var_long_name)) then
       call var%setAttribute("long_name", trim(var_long_name))
     end if
 
   end subroutine
 
+  !> \copydoc unpack_field_and_write
   subroutine unpack_field_and_write_1d_dp(nc, var_name, var_dims, fill_value, data, mask, var_long_name)
 
     use mo_kind, only : dp
     use mo_netcdf, only : NcDataset, NcDimension, NcVariable
 
     implicit none
 
@@ -484,14 +431,15 @@
     ! optionally set attributes
     if (present(var_long_name)) then
       call var%setAttribute("long_name", trim(var_long_name))
     end if
 
   end subroutine
 
+  !> \copydoc unpack_field_and_write
   subroutine unpack_field_and_write_2d_dp(nc, var_name, var_dims, fill_value, data, mask, var_long_name)
 
     use mo_kind, only : dp, i4
     use mo_netcdf, only : NcDataset, NcDimension, NcVariable
 
     implicit none
 
@@ -541,14 +489,15 @@
     ! optionally set attributes
     if (present(var_long_name)) then
       call var%setAttribute("long_name", trim(var_long_name))
     end if
 
   end subroutine
 
+  !> \copydoc unpack_field_and_write
   subroutine unpack_field_and_write_3d_dp(nc, var_name, var_dims, fill_value, data, mask, var_long_name)
 
     use mo_kind, only : dp, i4
     use mo_netcdf, only : NcDataset, NcDimension, NcVariable
 
     implicit none
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `mhm-5.12.1.dev21/src/MPR/mo_mpr_runoff.f90` & `mhm-5.13.0/src/MPR/mo_mpr_runoff.f90`

 * *Files 11% similar despite different names*

```diff
@@ -1,19 +1,18 @@
-!>       \file mo_mpr_runoff.f90
-
-!>       \brief multiscale parameter regionalization for runoff generation
-
-!>       \details This contains the routine for multiscale parameter regionalization of the runoff parametrization.
-
-!>       \authors Stephan Thober, Rohini Kumar
-
-!>       \date Dec 2012
-
-! Modifications:
-
+!> \file mo_mpr_runoff.f90
+!> \brief \copybrief mo_mpr_runoff
+!> \details \copydetails mo_mpr_runoff
+
+!> \brief multiscale parameter regionalization for runoff generation
+!> \details This contains the routine for multiscale parameter regionalization of the runoff parametrization.
+!> \authors Stephan Thober, Rohini Kumar
+!> \date Dec 2012
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mpr
 module mo_mpr_runoff
 
   use mo_kind, only : i4, dp
 
   implicit none
 
   private
@@ -134,15 +133,15 @@
 
     !-----------------------------
     ! FAST INTERFLOW
     !-----------------------------
     ! HL1 = f(soil properties; No reference found)
     ! Based on the saturation deficit from the field capacity status
     ! seems more reasonable and intutative.
-    ! NOTE: This value for the sandy soils will have higher value of HL1, as compared to 
+    ! NOTE: This value for the sandy soils will have higher value of HL1, as compared to
     !       to clayey soil and so these soils can hold larger amount of amount.
     tmp = merge(param(1) * SMs_FC0, nodata_dp, cell_id0 .ne. nodata_i4)
     L1_HL1 = upscale_arithmetic_mean(nL0_in_L1, Upp_row_L1, Low_row_L1, &
             Lef_col_L1, Rig_col_L1, cell_id0, mask0, nodata_dp, tmp)
 
     ! 1/K0 = f(terrain slope) [Booij, et. al.(2005), JoH]
     ! Steeper slopes resists (1/K0) fast water flows lesser as
@@ -154,22 +153,22 @@
 
     tmp = merge(param(2) * (2.0_dp - slope_emp0), nodata_dp, cell_id0 .ne. nodata_i4)
     tmp = merge(tmp * param(3), tmp, LCOVER0 .eq. 1)
     L1_K0 = upscale_arithmetic_mean(nL0_in_L1, Upp_row_L1, Low_row_L1, &
             Lef_col_L1, Rig_col_L1, cell_id0, mask0, nodata_dp, tmp)
 
     ! To avoid numerical error in fully impervious areas (K0 == 0)
-    ! minimum value of K0 is 1-day 
+    ! minimum value of K0 is 1-day
     L1_K0 = merge(1.0_dp, L1_K0, L1_K0 .lt. 1.0_dp)
 
     ! ------------------------------------------------------------------
     ! SLOW INTERFLOW
     ! ------------------------------------------------------------------
     !   K1 = f(terrian slope, Booij, et. al.(2005), JoH)
-    !      = f(soil properties, LC & New modification)  
+    !      = f(soil properties, LC & New modification)
     !  K1  = K0 + K1(soil-Ks)
 
     tmp = merge(param(2) * (2.0_dp - slope_emp0) + param(4) * (1.0_dp + KsVar_H0), &
             nodata_dp, cell_id0 .ne. nodata_i4)
     L1_K1 = upscale_arithmetic_mean(nL0_in_L1, Upp_row_L1, Low_row_L1, &
             Lef_col_L1, Rig_col_L1, cell_id0, mask0, nodata_dp, tmp)
```

### Comparing `mhm-5.12.1.dev21/src/MPR/mo_mpr_smhorizons.f90` & `mhm-5.13.0/src/MPR/mo_mpr_smhorizons.f90`

 * *Files 2% similar despite different names*

```diff
@@ -1,19 +1,18 @@
-!>       \file mo_mpr_smhorizons.f90
-
-!>       \brief setting up the soil moisture horizons
-
-!>       \details This module sets up the soil moisture horizons
-
-!>       \authors Stephan Thober, Rohini Kumar
-
-!>       \date Dec 2012
-
-! Modifications:
-
+!> \file mo_mpr_smhorizons.f90
+!> \brief \copybrief mo_mpr_smhorizons
+!> \details \copydetails mo_mpr_smhorizons
+
+!> \brief setting up the soil moisture horizons
+!> \details This module sets up the soil moisture horizons
+!> \authors Stephan Thober, Rohini Kumar
+!> \date Dec 2012
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mpr
 module mo_mpr_SMhorizons
 
   use mo_kind, only : i4, dp
   use mo_common_constants, only : nodata_dp
 
   implicit none
 
@@ -126,16 +125,16 @@
                            latWat_till   , & ! lattice water upto tillage depth
                            COSMIC_L3_till, & ! COSMIC parameter L3 upto tillage depth
                            latWat        , & ! lattice water
                            COSMIC_L3     , & ! COSMIC paramter L3
                            L1_bulkDens   , & ! L bulk density
                            L1_latticeWater,& ! L1 lattice water content
                            L1_COSMICL3   )   ! L1 COSMIC L3 parameter from neutron module
- 
-    use mo_message, only : message
+
+    use mo_message, only : message, error_message
     use mo_string_utils, only : num2str
     use mo_upscaling_operators, only : upscale_harmonic_mean
     !$ use omp_lib
 
     implicit none
 
     ! parameters
@@ -287,15 +286,15 @@
 
     ! [10^-3 m] permanent wilting point
     real(dp), dimension(size(LCOVER0, 1)) :: PW0
 
     ! neutron count
     real(dp), dimension(size(LCOVER0,1))    :: LW0     ! lattice water
     real(dp), dimension(size(LCOVER0,1))    :: L30     ! COSMIC parameter L3
- 
+
 
     ! fraction of roots in soil horizons
     real(dp), dimension(size(LCOVER0, 1)) :: fRoots0
 
     real(dp) :: tmp_rootFractionCoefficient_forest
 
     real(dp) :: tmp_rootFractionCoefficient_impervious
@@ -312,15 +311,15 @@
 
     ! Model parameter describing the threshold for actual
     ! ET reduction for clay
     real(dp) :: tmp_rootFractionCoefficient_clay
 
     real(dp) :: FCmin_glob
 
-    real(dp) :: FCdelta_glob
+    ! real(dp) :: FCdelta_glob
 
     real(dp) :: FCmax_glob
 
     real(dp) :: FCnorm
     ! the minimum number of till horizons
     integer(i4) :: min_nTH
 
@@ -379,20 +378,20 @@
           dpth_f = 0.0_dp
           dpth_t = HorizonDepth(H)
           ! check for the layer (2, ... n-1 layers) update depth
           if( (H .gt. 1) .and. (H .lt. nHorizons_mHM) ) then
              dpth_f = HorizonDepth(H-1)
              dpth_t = HorizonDepth(H)
           end if
-          
+
           !$OMP PARALLEL
           !$OMP DO PRIVATE( l, s ) SCHEDULE( STATIC )
           cellloop0 : do k = 1, size(LCOVER0, 1)
              l = LCOVER0(k)
-             s = soilID0(k, 1)  !>> in this case the second dimension of soilId0 = 1
+             s = soilID0(k, 1)  ! >> in this case the second dimension of soilId0 = 1
              ! depth weightage bulk density
              Bd0(k) = sum(Db(s, : nTillHorizons(s), L) * Wd(S, H, 1 : nTillHorizons(S)), &
                   Wd(S, H, 1 : nTillHorizons(S)) > 0.0_dp) &
                   + sum(dbM(S, nTillHorizons(S) + 1 : nHorizons(S)) &
                   * Wd(S, H, nTillHorizons(S) + 1 : nHorizons(S)), &
                   Wd(S, H, nTillHorizons(S) + 1 : nHorizons(S)) >= 0.0_dp)
              ! depth weightage thetaS
@@ -420,15 +419,15 @@
              ! neutron count --> depth weightage LW and L30
              LW0(k) = sum( latWat_till(S, : nTillHorizons(s), L) &
                   * Wd(S, H, 1 : nTillHorizons(S) ), &
                   Wd(S, H, 1 : nTillHorizons(S)) > 0.0_dp ) &
                   + sum( latWat(S,nTillHorizons(S) + 1 - min_nTH : nHorizons(s) - min_nTH) &
                   * Wd(S, H, nTillHorizons(S) + 1 : nHorizons(S)), &
                   Wd(S, H, nTillHorizons(S) + 1 : nHorizons(S)) > 0.0_dp )
-             
+
              L30(k) = sum( COSMIC_L3_till(S, : nTillHorizons(s), L) &
                   * Wd(S, H, 1 : nTillHorizons(S) ), &
                   Wd(S, H, 1 : nTillHorizons(S)) > 0.0_dp ) &
                   + sum( COSMIC_L3(S,nTillHorizons(S) + 1 - min_nTH : nHorizons(s) - min_nTH) &
                   * Wd(S, H, nTillHorizons(S) + 1 : nHorizons(S)), &
                   Wd(S, H, nTillHorizons(S) + 1 : nHorizons(S)) > 0.0_dp )
 
@@ -510,42 +509,43 @@
                    ! The normalization is based on Demirel et al 2018 (doi: 10.5194/hess-22-1299-2018)
                    ! Case 3 is based on Jarvis (doi: 10.1016/0022-1694(89)90050-4)
                    ! Case 4 is based on Feddes (doi: 10.1016/0022-1694(76)90017-2)
 
                    FCnorm = (((FC0(k) / (dpth_t - dpth_f)) - FCmin_glob) / (FCmax_glob - FCmin_glob))
 
                    if(FCnorm .lt. 0.0_dp) then
-                      print*, "FCnorm is below 0, will become 0", FCnorm
+                      ! print*, "FCnorm is below 0, will become 0", FCnorm
                       FCnorm=0.0_dp
                    else if(FCnorm .gt. 1.0_dp) then
-                      print*, "FCnorm is above 1, will become 1", FCnorm
+                      ! print*, "FCnorm is above 1, will become 1", FCnorm
                       FCnorm=1.0_dp
                    end if
 
                    tmp_rootFractionCoefficient_perviousFC = (FCnorm * tmp_rootFractionCoefficient_clay) &
-                        + ((1 - FCnorm) * tmp_rootFractionCoefficient_sand) 
+                        + ((1 - FCnorm) * tmp_rootFractionCoefficient_sand)
 
                    fRoots0(k) = (1.0_dp - tmp_rootFractionCoefficient_perviousFC**(dpth_t * 0.1_dp)) &
                         - (1.0_dp - tmp_rootFractionCoefficient_perviousFC**(dpth_f * 0.1_dp))
 
                 end select
 
                 if((fRoots0(k) .lt. 0.0_dp) .OR. (fRoots0(k) .gt. 1.0_dp)) then
-                   call message('***ERROR: Fraction of roots out of range [0,1]. Cell', &
+                  ! why is this not stopping here?
+                  call message('***ERROR: Fraction of roots out of range [0,1]. Cell', &
                         num2str(k), ' has value ', num2str(fRoots0(k)))
-                   ! stop
+                  ! stop
                 end if
              end select
 
           end do celllloop0
           !$OMP END DO
           !$OMP END PARALLEL
 
           beta0 = Bd0 * param(4)
-          
+
           !---------------------------------------------
           ! Upscale the soil related parameters
           !---------------------------------------------
           L1_SMs(:, h) = upscale_harmonic_mean(nL0_in_L1, Upp_row_L1, Low_row_L1, &
                Lef_col_L1, Rig_col_L1, cell_id0, mask0, nodata_dp, SMs0)
           L1_beta(:, h) = upscale_harmonic_mean(nL0_in_L1, Upp_row_L1, Low_row_L1, &
                Lef_col_L1, Rig_col_L1, cell_id0, mask0, nodata_dp, beta0)
@@ -561,30 +561,30 @@
                Lef_col_L1, Rig_col_L1, cell_id0, mask0, nodata_dp, Bd0 )
           L1_latticeWater(:,h) = upscale_harmonic_mean( nL0_in_L1, Upp_row_L1, Low_row_L1, &
                Lef_col_L1, Rig_col_L1, cell_id0, mask0, nodata_dp, LW0 )
           L1_COSMICL3(:,h) = upscale_harmonic_mean( nL0_in_L1, Upp_row_L1, Low_row_L1, &
                Lef_col_L1, Rig_col_L1, cell_id0, mask0, nodata_dp, L30 )
 
        end do
-      
+
       ! to handle multiple soil horizons with unique soil class
     CASE(1)
       ! horizon wise calculation
       do h = 1, nHorizons_mHM
         Bd0 = nodata_dp
         SMs0 = nodata_dp
         FC0 = nodata_dp
         PW0 = nodata_dp
         fRoots0 = nodata_dp
         tmp_rootFractionCoefficient_perviousFC = nodata_dp
 
         ! neutron count
         LW0     = nodata_dp
         L30     = nodata_dp
-        
+
         ! initalise mHM horizon depth
         if (h .eq. 1) then
           dpth_f = 0.0_dp
           dpth_t = HorizonDepth(h)
           ! check for the layer (2, ... n-1 layers) update depth
         else
           dpth_f = HorizonDepth(h - 1)
@@ -597,21 +597,21 @@
           L = LCOVER0(k)
           s = soilID0(k, h)
           if (h .le. nTillHorizons(1)) then
             Bd0(k) = Db(s, 1, L)
             SMs0(k)= thetaS_till (s, 1, L) * (dpth_t - dpth_f)  ! in mm
             FC0(k) = thetaFC_till(s, 1, L) * (dpth_t - dpth_f)  ! in mm
             PW0(k) = thetaPW_till(s, 1, L) * (dpth_t - dpth_f)  ! in mm
-            LW0(k) = latWat_till(s, 1, L)  * (dpth_t - dpth_f)  ! in mm  !>> neutron count
+            LW0(k) = latWat_till(s, 1, L)  * (dpth_t - dpth_f)  ! in mm  ! >> neutron count
           else
             Bd0(k) = DbM(s, 1)
             SMs0(k)= thetaS (s, 1) * (dpth_t - dpth_f)  ! in mm
             FC0(k) = thetaFC(s, 1) * (dpth_t - dpth_f)  ! in mm
             PW0(k) = thetaPW(s, 1) * (dpth_t - dpth_f)  ! in mm
-            LW0(k) = latWat(s, 1)  * (dpth_t - dpth_f)  ! in mm  !>> neutron count       
+            LW0(k) = latWat(s, 1)  * (dpth_t - dpth_f)  ! in mm  ! >> neutron count
           end if
         end do cellloop1
         !$OMP END DO
         !$OMP END PARALLEL
 
 
         !$OMP PARALLEL
@@ -646,35 +646,36 @@
               ! introducing global FC dependency on root frac. coef. by Simon Stisen and M. Cuneyd Demirel from GEUS.dk
               ! The normalization is based on Demirel et al 2018 (doi: 10.5194/hess-22-1299-2018)
               ! Case 3 is based on Jarvis (doi: 10.1016/0022-1694(89)90050-4)
               ! Case 4 is based on Feddes (doi: 10.1016/0022-1694(76)90017-2)
               FCnorm = (((FC0(k) / (dpth_t - dpth_f)) - FCmin_glob) / (FCmax_glob - FCmin_glob))
 
               if(FCnorm .lt. 0.0_dp) then
-              print*, "FCnorm is below 0, will become 0", FCnorm
-                 FCnorm=0.0_dp
+                ! print*, "FCnorm is below 0, will become 0", FCnorm
+                FCnorm=0.0_dp
               else if(FCnorm .gt. 1.0_dp) then
-              print*, "FCnorm is above 1, will become 1", FCnorm
-                 FCnorm=1.0_dp
+                ! print*, "FCnorm is above 1, will become 1", FCnorm
+                FCnorm=1.0_dp
               end if
 
               tmp_rootFractionCoefficient_perviousFC = (FCnorm * tmp_rootFractionCoefficient_clay) &
-                      + ((1 - FCnorm) * tmp_rootFractionCoefficient_sand) 
+                      + ((1 - FCnorm) * tmp_rootFractionCoefficient_sand)
 
 
               fRoots0(k) = (1.0_dp - tmp_rootFractionCoefficient_perviousFC**(dpth_t * 0.1_dp)) &
                       - (1.0_dp - tmp_rootFractionCoefficient_perviousFC**(dpth_f * 0.1_dp))
 
             end select
 
             if((fRoots0(k) .lt. 0.0_dp) .OR. (fRoots0(k) .gt. 1.0_dp)) then
-               call message('***ERROR: Fraction of roots out of range [0,1]. Cell', &
+              ! why is this not stopping here?
+              call message('***ERROR: Fraction of roots out of range [0,1]. Cell', &
                     num2str(k), ' has value ', num2str(fRoots0(k)))
-                ! stop
-              end if
+              ! stop
+            end if
           end select
 
         end do celllloop1
         !$OMP END DO
         !$OMP END PARALLEL
 
         ! beta parameter
@@ -699,17 +700,15 @@
              Lef_col_L1, Rig_col_L1, cell_id0, mask0, nodata_dp, LW0  )
         L1_COSMICL3(:,h)   = upscale_harmonic_mean( nL0_in_L1, Upp_row_L1, Low_row_L1, &
              Lef_col_L1, Rig_col_L1, cell_id0, mask0, nodata_dp, L30  )
 
       end do
       ! anything else
     CASE DEFAULT
-      call message()
-      call message('***ERROR: iFlag_soilDB option given does not exist. Only 0 and 1 is taken at the moment.')
-      stop
+      call error_message('***ERROR: iFlag_soilDB option given does not exist. Only 0 and 1 is taken at the moment.')
     END SELECT
 
 
     ! below operations are common to all soil databases flags
     !$OMP PARALLEL
     !------------------------------------------------------------------------
     ! CHECK LIMITS OF PARAMETERS
```

### Comparing `mhm-5.12.1.dev21/src/MPR/mo_mpr_soilmoist.f90` & `mhm-5.13.0/src/MPR/mo_mpr_soilmoist.f90`

 * *Files 2% similar despite different names*

```diff
@@ -1,23 +1,22 @@
-!>       \file mo_mpr_soilmoist.f90
-
-!>       \brief Multiscale parameter regionalization (MPR) for soil moisture
-
-!>       \details This module contains all routines required for parametrizing
-!>       soil moisture processes.
-
-!>       \authors Stephan Thober, Rohini Kumar
-
-!>       \date Dec 2012
-
-! Modifications:
-
+!> \file mo_mpr_soilmoist.f90
+!> \brief \copybrief mo_mpr_soilmoist
+!> \details \copydetails mo_mpr_soilmoist
+
+!> \brief Multiscale parameter regionalization (MPR) for soil moisture
+!> \details This module contains all routines required for parametrizing soil moisture processes.
+!> \authors Stephan Thober, Rohini Kumar
+!> \date Dec 2012
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mpr
 module mo_mpr_soilmoist
 
   use mo_kind, only : i4, dp
+  use mo_message, only : message, error_message
 
   implicit none
 
   public :: mpr_sm
 
   private
 
@@ -98,15 +97,14 @@
   ! M. Cuneyd Demirel, Simon Stisen Jun 2020 - added Feddes and FC dependency on root fraction coefficient processCase(3) = 4
   ! Rohini Kumar                    Oct 2021 - Neutron count module to mHM integrate into develop branch (5.11.2)
 
   subroutine mpr_sm(param, processMatrix, is_present, nHorizons, nTillHorizons, sand, clay, DbM, ID0, soilId0, LCover0, &
                    thetaS_till, thetaFC_till, thetaPW_till, thetaS, thetaFC, thetaPW, Ks, Db, KsVar_H0, KsVar_V0, SMs_FC0)
 
     use mo_common_constants, only : nodata_dp, nodata_i4
-    use mo_message, only : message
     use mo_mpr_constants, only : BulkDens_OrgMatter
     use mo_mpr_global_variables, only : iFlag_soilDB
     !$ use omp_lib
 
     implicit none
 
     ! global parameters
@@ -288,15 +286,15 @@
               case(1)               ! forest
                 pOM = tmp_orgMatterContent_forest
               case(2)               ! impervious
                 pOM = tmp_orgMatterContent_impervious !param(2)
               case(3)               ! permeable
                 pOM = tmp_orgMatterContent_pervious
               case default
-                stop 'Error mpr_sm: pOM used uninitialized.'
+                 call error_message('Error mpr_sm: pOM used uninitialized.')
               end select
               pM = 100.0_dp - pOM
               ! bulk density acording to Rawl's (1982) paper
               Db(i, j, L) = 100.0_dp / ((pOM / BulkDens_OrgMatter) + (pM / DbM(i, j)))
               ! Effect of organic matter content
               ! This is taken into account in a simplified form by using
               ! the ratio of(Bd / BdOM)
@@ -323,16 +321,16 @@
           end if
         end do horizon
       end do
       !$OMP END DO
 
       ! calculate other soil properties at each location [L0] for regionalising model parameters
       !$OMP DO PRIVATE( s, j ) SCHEDULE( STATIC )
-      cellloop : do i = 1, size(soilId0, 1) !>> here = ncells0
-        s = soilId0(i, 1)                    !>> in this case the second dimension of soilId0 = 1
+      cellloop : do i = 1, size(soilId0, 1) ! >> here = ncells0
+        s = soilId0(i, 1)                    ! >> in this case the second dimension of soilId0 = 1
         do j = 1, nHorizons(s)
           if (j .le. nTillHorizons(s)) then
             ! Soil properties over the whole soil coloum depth
             KsVar_H0(i) = KsVar_H0(i) + thetaS_till(s, j, LCover0(i)) * Ks(s, j, LCover0(i))
             KsVar_V0(i) = KsVar_V0(i) + thetaS_till(s, j, LCover0(i)) / Ks(s, j, LCover0(i))
             SMs_FC0(i) = SMs_FC0(i) + thetaFC_till(s, j, LCover0(i))
             SMs_tot0(i) = SMs_tot0(i) + thetaS_till (s, j, LCover0(i))
@@ -366,28 +364,28 @@
         if (is_present(i) .lt. 1) cycle
         ! **** FOR THE TILLAGE TYPE OF SOIL *****
         ! there is actually no soil horizons/soil type in this case
         ! but we assign of j = 1 to use variables as defined in the classical option (iFlag_soil = 0)
         do j = 1, 1
           ! calculating vertical hydraulic conductivity
           call hydro_cond(Ks_tmp, param(10 : 13), sand(i, j), clay(i, j))
-          Ks_non_till(i, j) = Ks_tmp  !>> non-till
-          Ks(i, j, :) = Ks_tmp  !>> till layers
+          Ks_non_till(i, j) = Ks_tmp  ! >> non-till
+          Ks(i, j, :) = Ks_tmp  ! >> till layers
           ! calculating other soil hydraulic properties
           ! tillage horizons properties depending on the LC class
           do L = 1, max_LCover
             select case (L)
             case(1)               ! forest
               pOM = tmp_orgMatterContent_forest
             case(2)               ! impervious
               pOM = tmp_orgMatterContent_impervious !param(2)
             case(3)               ! permeable
               pOM = tmp_orgMatterContent_pervious
             case default
-              STOP 'Error mpr_sm: pOM used is not initialized.'
+               call error_message('Error mpr_sm: pOM used is not initialized.')
             end select
             pM = 100.0_dp - pOM
             ! bulk density acording to Rawl's (1982) paper
             Db(i, j, L) = 100.0_dp / ((pOM / BulkDens_OrgMatter) + (pM / DbM(i, j)))
             ! Effect of organic matter content on Ks estimates
             ! This is taken into account in a simplified form by using
             ! the ratio of (Bd/BdOM)
@@ -409,16 +407,16 @@
           ! estimate SMs & van Genuchten's shape parameter (n)
           call Genuchten(thetaS(i, j), Genu_Mual_n, Genu_Mual_alpha, param(4 : 9), sand(i, j), clay(i, j), DbM(i, j))
           ! estimate field capacity
           call field_cap(thetaFC(i, j), Ks_tmp, thetaS(i, j), Genu_Mual_n)
           ! estimate permanent wilting point
           call PWP(Genu_Mual_n, Genu_Mual_alpha, thetaS(i, j), thetaPW(i, j))
 
-        end do  !>> HORIZON
-      end do   !>> SOIL TYPE
+        end do  ! >> HORIZON
+      end do   ! >> SOIL TYPE
 
       ! calculate other soil properties at each location [L0] for regionalising model parameters
       do i = 1, size(soilId0, 1)     !! over all cells
         do j = 1, size(soilId0, 2)  !! over horizons
           s = soilId0(i, j)
           if (j .le. nTillHorizons(1)) then
             ! soil properties over the whole soil coloum depth
@@ -443,17 +441,15 @@
         ! Ks variability over the whole soil coloum depth for
         ! both horizontal and vertical flows including relative variabilities
         KsVar_H0(i) = KsVar_H0(i) / SMs_tot0(i) / param(13)
         KsVar_V0(i) = SMs_tot0(i) / KsVar_V0(i) / param(13)
       end do
 
     CASE DEFAULT
-      call message()
-      call message('***ERROR: iFlag_soilDB option given does not exist. Only 0 and 1 is taken at the moment.')
-      stop
+      call error_message('***ERROR: iFlag_soilDB option given does not exist. Only 0 and 1 is taken at the moment.')
     END SELECT
 
     ! free space **
     deallocate(SMs_tot0)
     if(allocated(Ks_non_till)) deallocate(Ks_non_till)
 
   end subroutine mpr_sm
@@ -677,29 +673,29 @@
     end if
 
     ! Mualem alpha
     Genu_Mual_alpha = exp(x)
 
     ! hard coded limits, according to (Zacharias et al, 2007, soil Phy.)
     if (thetaS < 0.01_dp) then
-      write(*, *) 'thetaS below threshold limit 1e-2, reset.'
+      call message('thetaS below threshold limit 1e-2, reset.')
       ! Put constrains on theta_S
       thetaS = 0.01_dp
     end if
     if (thetaS > 1.0_dp) then
-      write(*, *) 'thetaS above 1, reset.'
+      call message('thetaS above 1, reset.')
       ! Put constrains on theta_S
       thetaS = 1.0_dp
     end if
     if (Genu_Mual_n < 1.01000_dp) then
-      write(*, *) 'Genu_Mual_n below threshold limit 1.01, reset.'
+      call message('Genu_Mual_n below threshold limit 1.01, reset.')
       Genu_Mual_n = 1.01000_dp
     end if
     if (Genu_Mual_alpha < 0.00001_dp) then
-      write(*, *) 'Genu_Mual_alpha below threshold limit 1e-5, reset.'
+      call message('Genu_Mual_alpha below threshold limit 1e-5, reset.')
       Genu_Mual_alpha = 0.00001_dp
     end if
 
   end subroutine Genuchten
 
   ! ----------------------------------------------------------------------------
 
@@ -763,15 +759,15 @@
     ! Fix it in the namelist, i.e. in
     ! mhm_parameter.nml set the 4th value (=FLAG) to 0 and the third value to 60.96
     !   PTF_Ks_curveSlope = 60.96, 60.96, 60.96, 0, 1
     x = param(1) + param(2) * sand - param(3) * clay
     Ks = param(4) * exp(X * log(Ks_c))
 
     if (Ks < 1.10_dp) then
-      write(*, *) 'JMJMJM-Ks-BAD'
+      call message('JMJMJM-Ks-BAD')
     end if
 
     ! minimum value of Ks = 1.1cm/d
     if (Ks < 1.10_dp) Ks = 1.10_dp
 
   end subroutine hydro_cond
```

### Comparing `mhm-5.12.1.dev21/src/MPR/mo_mpr_startup.f90` & `mhm-5.13.0/src/MPR/mo_mpr_startup.f90`

 * *Files 15% similar despite different names*

```diff
@@ -1,77 +1,70 @@
-!>       \file mo_mpr_startup.f90
-
-!>       \brief Startup procedures for mHM.
-
-!>       \details This module initializes all variables required to run mHM. This
-!>       module needs to be run only one time at the beginning of a simulation if
-!>       re-starting files do not exist.
-
-!>       \authors Luis Samaniego, Rohini Kumar
-
-!>       \date Dec 2012
-
-! Modifications:
-
+!> \file mo_mpr_startup.f90
+!> \brief \copybrief mo_mpr_startup
+!> \details \copydetails mo_mpr_startup
+
+!> \brief Startup procedures for mHM.
+!> \details This module initializes all variables required to run mHM. This
+!! module needs to be run only one time at the beginning of a simulation if re-starting files do not exist.
+!> \authors Luis Samaniego, Rohini Kumar
+!> \date Dec 2012
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mpr
 MODULE mo_mpr_startup
 
-  ! This module provides the startup routines for mHM.
-
-  ! Written Luis Samaniego, Rohini Kumar, Dec 2012
-
   USE mo_kind, ONLY : i4, dp
   use mo_common_constants, only : nodata_i4, nodata_dp   ! global nodata values (i4, dp)
 
   IMPLICIT NONE
 
   PRIVATE
 
   PUBLIC :: mpr_initialize, init_eff_params                      ! initialization sequence
 
 CONTAINS
 
-  ! ------------------------------------------------------------------
-
-  !    NAME
-  !        mpr_initialize
-
-  !    PURPOSE
-  !>       \brief Initialize main mHM variables
-
-  !>       \details Initialize main mHM variables for a given domain.
-  !>       Calls the following procedures in this order:
-  !>       - Constant initialization.
-  !>       - Generate soil database.
-  !>       - Checking inconsistencies input fields.
-  !>       - Variable initialization at level-0.
-  !>       - Variable initialization at level-1.
-  !>       - Variable initialization at level-11.
-  !>       - Space allocation of remaining variable/parameters.
-  !>       Global variables will be used at this stage.
-
-  !    HISTORY
-  !>       \authors Luis Samaniego, Rohini Kumar
-
-  !>       \date Dec 2012
-
-  ! Modifications:
-  ! Luis Samaniego Mar 2008 - fully distributed multilayer
-  ! Rohini Kumar   Oct 2010 - matrix to vector version
-  !                         - openmp parallelization
-  !                         - routing level 11
-  ! Luis Samaniego Jul 2012 - removal of IMSL dependencies
-  ! Luis Samaniego Dec 2012 - modular version
-  ! Rohini Kumar   May 2013 - code cleaned and error checks
-  ! Rohini Kumar   Nov 2013 - updated documentation
-  ! Stephan Thober Jun 2014 - copied L2 initialization from mo_meteo_forcings
-  ! Stephan Thober Jun 2014 - updated flag for read_restart
-  ! Stephan Thober Aug 2015 - removed initialisation of routing
-  ! Rohini Kumar   Mar 2016 - changes for handling multiple soil database options
-  ! Robert Schweppe Jun 2018 - refactoring and reformatting
-
+  !> \brief Initialize main mHM variables
+  !> \details Initialize main mHM variables for a given domain.
+  !! Calls the following procedures in this order:
+  !! - Constant initialization.
+  !! - Generate soil database.
+  !! - Checking inconsistencies input fields.
+  !! - Variable initialization at level-0.
+  !! - Variable initialization at level-1.
+  !! - Variable initialization at level-11.
+  !! - Space allocation of remaining variable/parameters.
+  !! Global variables will be used at this stage.
+  !> \changelog
+  !! - Luis Samaniego Mar 2008
+  !!   - fully distributed multilayer
+  !! - Rohini Kumar   Oct 2010
+  !!   - matrix to vector version
+  !!   - openmp parallelization
+  !!   - routing level 11
+  !! - Luis Samaniego Jul 2012
+  !!   - removal of IMSL dependencies
+  !! - Luis Samaniego Dec 2012
+  !!   - modular version
+  !! - Rohini Kumar   May 2013
+  !!   - code cleaned and error checks
+  !! - Rohini Kumar   Nov 2013
+  !!   - updated documentation
+  !! - Stephan Thober Jun 2014
+  !!   - copied L2 initialization from mo_meteo_forcings
+  !! - Stephan Thober Jun 2014
+  !!   - updated flag for read_restart
+  !! - Stephan Thober Aug 2015
+  !!   - removed initialisation of routing
+  !! - Rohini Kumar   Mar 2016
+  !!   - changes for handling multiple soil database options
+  !! - Robert Schweppe Jun 2018
+  !!   - refactoring and reformatting
+  !> \authors Luis Samaniego, Rohini Kumar
+  !> \date Dec 2012
   subroutine mpr_initialize
 
     use mo_common_variables, only : l0_l1_remap, level0, level1, domainMeta, resolutionHydrology
     use mo_grid, only : init_lowres_level, set_domain_indices
     use mo_kind, only : i4
     use mo_read_latlon, only : read_latlon
     use mo_soil_database, only : generate_soil_database
@@ -111,180 +104,153 @@
     end do
 
     call set_domain_indices(level1)
 
   end subroutine mpr_initialize
 
 
-  ! ------------------------------------------------------------------
-
-  !    NAME
-  !        L0_check_input
-
-  !    PURPOSE
-  !>       \brief Check for errors in L0 input data
-
-  !>       \details Check for possible errors in input data (morphological and land cover) at level-0
-
-  !    INTENT(IN)
-  !>       \param[in] "integer(i4) :: iDomain" domain id
-
-  !    HISTORY
-  !>       \authors Rohini Kumar
-
-  !>       \date Jan 2013
-
-  ! Modifications:
-  ! Rohini Kumar   Aug  2013 - added iFlag_LAI_data_format to handle LAI options, and changed within the code made accordingly
-  ! Rohini  Kumar  Sep 2013 - read input data for routing processes according & Stephan Thober,           to process_matrix flag
-  ! Stephan Thober Aug 2015 - moved check of L0 routing variables to mRM
-  ! Rohini Kumar   Mar 2016 - changes for handling multiple soil database options
-  ! Robert Schweppe Jun 2018 - refactoring and reformatting
-
+  !> \brief Check for errors in L0 input data
+  !> \details Check for possible errors in input data (morphological and land cover) at level-0
+  !> \changelog
+  !! - Rohini Kumar   Aug  2013
+  !!   - added iFlag_LAI_data_format to handle LAI options, and changed within the code made accordingly
+  !! - Rohini  Kumar  Sep 2013
+  !!   - read input data for routing processes according & Stephan Thober, to process_matrix flag
+  !! - Stephan Thober Aug 2015
+  !!   - moved check of L0 routing variables to mRM
+  !! - Rohini Kumar   Mar 2016
+  !!   - changes for handling multiple soil database options
+  !! - Robert Schweppe Jun 2018
+  !!   - refactoring and reformatting
+  !> \authors Rohini Kumar
+  !> \date Jan 2013
   subroutine L0_check_input(iDomain)
 
     use mo_common_constants, only : eps_dp
     use mo_common_variables, only : L0_LCover, L0_elev, level0, nLCoverScene
-    use mo_message, only : message
+    use mo_message, only : error_message
     use mo_mpr_global_variables, only : L0_asp, L0_geoUnit, L0_gridded_LAI, &
                                         L0_slope, L0_soilId, iFlag_soilDB, nSoilHorizons_mHM, timeStep_LAI_input
     use mo_string_utils, only : num2str
     use mo_utils, only : eq
 
     implicit none
 
-    ! domain id
+    !> domain id
     integer(i4), intent(in) :: iDomain
 
     integer(i4) :: k, n, nH
 
     CHARACTER(len=1024) :: message_text = ''
 
     ! START CHECKING VARIABLES
     do k = level0(iDomain)%iStart, level0(iDomain)%iEnd
 
       ! elevation [m]
       if (abs(L0_elev(k) - nodata_dp) .lt. eps_dp) then
         message_text = trim(num2str(k, '(I5)')) // ',' // trim(num2str(iDomain, '(I5)'))
-        call message(' Error: elevation has missing value within the valid masked area at cell in domain ', &
+        call error_message(' Error: elevation has missing value within the valid masked area at cell in domain ', &
                 trim(message_text))
-        stop
       end if
 
       ! slope [%]
       if (abs(L0_slope(k) - nodata_dp) .lt. eps_dp) then
         message_text = trim(num2str(k, '(I5)')) // ',' // trim(num2str(iDomain, '(I5)'))
-        call message(' Error: slope has missing value within the valid masked area at cell in domain ', &
+        call error_message(' Error: slope has missing value within the valid masked area at cell in domain ', &
                 trim(message_text))
-        stop
       end if
 
       ! aspect [degree]
       if (abs(L0_asp(k) - nodata_dp) .lt. eps_dp) then
         message_text = trim(num2str(k, '(I5)')) // ',' // trim(num2str(iDomain, '(I5)'))
-        call message(' Error: aspect has missing values within the valid masked area at cell in domain ', &
+        call error_message(' Error: aspect has missing values within the valid masked area at cell in domain ', &
                 trim(message_text))
-        stop
       end if
 
       ! soil-Id [-]
       nH = 1 !> by default; when iFlag_soilDB = 0
       if (iFlag_soilDB .eq. 1) nH = nSoilHorizons_mHM
       ! another option to handle multiple soil horizons properties
       do n = 1, nH
         if (L0_soilId(k, n) .eq. nodata_i4) then
           message_text = trim(num2str(k, '(I5)')) // ',' // trim(num2str(iDomain, '(I5)')) // ',' // trim(num2str(n, '(I5)'))
-          call message(' Error: soil id has missing values within the valid masked area at cell in domain and horizon ', &
+          call error_message(' Error: soil id has missing values within the valid masked area at cell in domain and horizon ', &
                   trim(message_text))
-          stop
         end if
       end do
 
       ! geological-Id [-]
       if (L0_geoUnit(k) .eq. nodata_i4) then
         message_text = trim(num2str(k, '(I5)')) // ',' // trim(num2str(iDomain, '(I5)'))
-        call message(' Error: geological formation id has missing values within the valid masked area at cell in domain ', &
+        call error_message(' Error: geological formation id has missing values within the valid masked area at cell in domain ', &
                 trim(message_text))
-        stop
       end if
 
       ! landcover scenes
       do  n = 1, nLCoverScene
         if (L0_LCover(k, n) .eq. nodata_i4) then
           message_text = trim(num2str(k, '(I5)')) // ',' // trim(num2str(iDomain, '(I5)')) // ',' // trim(num2str(n, '(I5)'))
-          call message(' Error: land cover id has missing values within the valid masked area at cell in domain and scene ', &
+          call error_message(' Error: land cover id has missing values within the valid masked area at cell in domain and scene ', &
                   trim(message_text))
-          stop
         end if
       end do
 
       ! land cover scenes related to LAI
       if(timeStep_LAI_input .EQ. 0) then
         if (eq(L0_gridded_LAI(k, 1), nodata_dp)) then
           message_text = trim(num2str(k, '(G5.3)')) // ',' // trim(num2str(iDomain, '(I5)'))
-          call message(' Error: gridded LAI has missing values within the valid masked area at cell in domain ', &
+          call error_message(' Error: gridded LAI has missing values within the valid masked area at cell in domain ', &
                   trim(message_text))
-          stop
         end if
       end if
 
     end do
 
   end subroutine L0_check_input
 
-  ! ------------------------------------------------------------------
-
-  !    NAME
-  !        L0_variable_init
-
-  !    PURPOSE
-  !>       \brief level 0 variable initialization
-
-  !>       \details following tasks are performed for L0 data sets
-  !>       -  cell id & numbering
-  !>       -  storage of cell cordinates (row and coloum id)
-  !>       -  empirical dist. of terrain slope
-  !>       -  flag to determine the presence of a particular soil id
-  !>       in this configuration of the model run
-  !>       If a variable is added or removed here, then it also has to
-  !>       be added or removed in the subroutine config_variables_set in
-  !>       module mo_restart and in the subroutine set_config in module
-  !>       mo_set_netcdf_restart
-
-  !    INTENT(IN)
-  !>       \param[in] "integer(i4) :: iDomain" domain id
-
-  !    HISTORY
-  !>       \authors Rohini Kumar
-
-  !>       \date Jan 2013
-
-  ! Modifications:
-  ! Rohini Kumar & Matthias Cuntz  May 2014 - cell area calulation based on a regular lat-lon grid or
-  !                                           on a regular X-Y coordinate system
-  ! Matthias Cuntz                 May 2014 - changed empirical distribution function so that doubles get the same value
-  ! Matthias Zink & Matthias Cuntz Feb 2016 - code speed up due to reformulation of CDF calculation
-  ! Rohini Kumar                   Mar 2016 - changes for handling multiple soil database options
-  ! Maren Kaluza                   Feb 2018 - removed slope_val, temp, only sort the index to speed up
-  !                                           finding the empirical distribution slope_emp
-  ! Robert Schweppe                Jun 2018 - refactoring and reformatting
 
+  !> \brief level 0 variable initialization
+  !> \details following tasks are performed for L0 data sets
+  !! -  cell id & numbering
+  !! -  storage of cell cordinates (row and coloum id)
+  !! -  empirical dist. of terrain slope
+  !! -  flag to determine the presence of a particular soil id
+  !! in this configuration of the model run
+  !! If a variable is added or removed here, then it also has to
+  !! be added or removed in the subroutine config_variables_set in
+  !! module mo_restart and in the subroutine set_config in module
+  !! mo_set_netcdf_restart
+  !> \changelog
+  !! - Rohini Kumar & Matthias Cuntz  May 2014
+  !!   - cell area calulation based on a regular lat-lon grid or on a regular X-Y coordinate system
+  !! - Matthias Cuntz           May 2014
+  !!   - changed empirical distribution function so that doubles get the same value
+  !! - Matthias Zink & Matthias Cuntz Feb 2016
+  !!   - code speed up due to reformulation of CDF calculation
+  !! - Rohini Kumar             Mar 2016
+  !!   - changes for handling multiple soil database options
+  !! - Maren Kaluza             Feb 2018
+  !!   - removed slope_val, temp, only sort the index to speed up finding the empirical distribution slope_emp
+  !! - Robert Schweppe          Jun 2018
+  !!   - refactoring and reformatting
+  !> \authors Rohini Kumar
+  !> \date Jan 2013
   subroutine L0_variable_init(iDomain)
 
     use mo_append, only : append
     use mo_common_variables, only : level0
     use mo_grid, only : L0_grid_setup
     use mo_mpr_global_variables, only : L0_slope, L0_slope_emp, L0_soilId, iFlag_soilDB, nSoilHorizons_mHM, &
             nSoilTypes, soilDB
     use mo_orderpack, only : sort_index
     use mo_utils, only : eq
 
     implicit none
 
-    ! domain id
+    !> domain id
     integer(i4), intent(in) :: iDomain
 
     real(dp), dimension(:), allocatable :: slope_emp
 
     integer(i4), dimension(:), allocatable :: slope_sorted_index
 
     integer(i4) :: i, j, k, nH, i_sort, i_sortpost
@@ -366,60 +332,55 @@
 
     ! free space
     deallocate(slope_emp, slope_sorted_index)
 
 
   end subroutine L0_variable_init
 
-  ! ------------------------------------------------------------------
-
-  !    NAME
-  !        init_eff_params
-
-  !    PURPOSE
-  !>       \brief Allocation of space for mHM related L1 and L11 variables.
-
-  !>       \details Allocation of space for mHM related L1 and L11 variables (e.g., states,
-  !>       fluxes, and parameters) for a given domain. Variables allocated here is
-  !>       defined in them mo_global_variables.f90 file. After allocating any variable
-  !>       in this routine, initalize them in the following variables_default_init
-  !>       subroutine:
-
-  !    INTENT(IN)
-  !>       \param[in] "integer(i4) :: ncells1"
-
-  !    HISTORY
-  !>       \authors Rohini Kumar
-
-  !>       \date Jan 2013
-
-  ! Modifications:
-  ! R. Kumar           Sep 2013 - documentation added according to the template
-  ! S. Thober          Aug 2015 - removed routing related variables
-  ! Zink M. Demirel C. Mar 2017 - Init Jarvis soil water stress variable at SM process(3)
-  ! Robert Schweppe    Dec 2017 - restructured allocation in variables_alloc, expanded dimensions of effective parameters
-  ! Robert Schweppe    Jun 2018 - refactoring and reformatting
-  ! Rohini Kumar       Oct 2021 - Added Neutron count module to mHM integrate into develop branch (5.11.2)
 
+  !> \brief Allocation of space for mHM related L1 and L11 variables.
+  !> \details Allocation of space for mHM related L1 and L11 variables (e.g., states,
+  !! fluxes, and parameters) for a given domain. Variables allocated here is
+  !! defined in them mo_global_variables.f90 file. After allocating any variable
+  !! in this routine, initalize them in the following variables_default_init
+  !! subroutine.
+  !> \changelog
+  !! - R. Kumar           Sep 2013
+  !!   - documentation added according to the template
+  !! - S. Thober          Aug 2015
+  !!   - removed routing related variables
+  !! - Zink M. Demirel C. Mar 2017
+  !!   - Init Jarvis soil water stress variable at SM process(3)
+  !! - Robert Schweppe    Dec 2017
+  !!   - restructured allocation in variables_alloc, expanded dimensions of effective parameters
+  !! - Robert Schweppe    Jun 2018
+  !!   - refactoring and reformatting
+  !! - Rohini Kumar       Oct 2021
+  !!   - Added Neutron count module to mHM integrate into develop branch (5.11.2)
+  !! - Sebastian Mller Mar 2023
+  !!   - made L1_alpha, L1_kSlowFlow, L1_kBaseFlow and L1_kPerco land cover dependent
+  !> \authors Rohini Kumar
+  !> \date Jan 2013
   subroutine init_eff_params(ncells1)
 
     use mo_append, only : append
     use mo_constants, only : YearMonths
     use mo_common_constants, only : P1_InitStateFluxes
-    use mo_common_variables, only : nLCoverScene 
+    use mo_common_variables, only : nLCoverScene
     use mo_mpr_global_variables, only : L1_HarSamCoeff, L1_PrieTayAlpha, L1_aeroResist, L1_alpha, L1_degDay, &
                                         L1_degDayInc, L1_degDayMax, L1_degDayNoPre, L1_fAsp, L1_fRoots, L1_fSealed, &
                                         L1_jarvis_thresh_c1, L1_kBaseFlow, L1_kPerco, L1_kSlowFlow, L1_karstLoss, &
                                         L1_kfastFlow, L1_maxInter, L1_petLAIcorFactor, L1_sealedThresh, L1_soilMoistExp, &
                                         L1_soilMoistFC, L1_soilMoistSat, L1_surfResist, L1_tempThresh, L1_unsatThresh, &
                                         L1_wiltingPoint, nLAI, nSoilHorizons_mHM, &
                                         L1_No_Count, L1_bulkDens, L1_latticeWater, L1_COSMICL3
 
     implicit none
 
+    !> number of L1 cells
     integer(i4), intent(in) :: ncells1
 
     real(dp), dimension(:, :, :), allocatable :: dummy_3D
 
     integer(i4) :: max_extent
 
 
@@ -432,15 +393,15 @@
     dummy_3D = P1_InitStateFluxes
 
     !-------------------------------------------
     ! EFFECTIVE PARAMETERS
     !-------------------------------------------
     call append(L1_fSealed, dummy_3D(:, 1 : 1, 1 : nLCoverScene))
     ! exponent for the upper reservoir
-    call append(L1_alpha, dummy_3D(:, 1 : 1, 1 : 1))
+    call append(L1_alpha, dummy_3D(:, 1 : 1, 1 : nLCoverScene))
     ! increase of the Degree-day factor per mm of increase in precipitation
     call append(L1_degDayInc, dummy_3D(:, 1 : 1, 1 : nLCoverScene))
     ! maximum degree-day factor
     call append(L1_degDayMax, dummy_3D(:, 1 : 1, 1 : nLCoverScene))
     ! degree-day factor with no precipitation
     call append(L1_degDayNoPre, dummy_3D(:, 1 : 1, 1 : nLCoverScene))
     ! degree-day factor
@@ -462,19 +423,19 @@
     ! Fraction of roots in soil horizons
     call append(L1_fRoots, dummy_3D(:, 1 : nSoilHorizons_mHM, 1 : nLCoverScene))
     ! Maximum interception
     call append(L1_maxInter, dummy_3D(:, 1 : nLAI, 1 : 1))
     ! fast interflow recession coefficient
     call append(L1_kfastFlow, dummy_3D(:, 1 : 1, 1 : nLCoverScene))
     ! slow interflow recession coefficient
-    call append(L1_kSlowFlow, dummy_3D(:, 1 : 1, 1 : 1))
+    call append(L1_kSlowFlow, dummy_3D(:, 1 : 1, 1 : nLCoverScene))
     ! baseflow recession coefficient
-    call append(L1_kBaseFlow, dummy_3D(:, 1 : 1, 1 : 1))
+    call append(L1_kBaseFlow, dummy_3D(:, 1 : 1, 1 : nLCoverScene))
     ! percolation coefficient
-    call append(L1_kPerco, dummy_3D(:, 1 : 1, 1 : 1))
+    call append(L1_kPerco, dummy_3D(:, 1 : 1, 1 : nLCoverScene))
     ! Soil moisture below which actual ET is reduced linearly till PWP
     call append(L1_soilMoistFC, dummy_3D(:, 1 : nSoilHorizons_mHM, 1 : nLCoverScene))
     ! Saturation soil moisture for each horizon [mm]
     call append(L1_soilMoistSat, dummy_3D(:, 1 : nSoilHorizons_mHM, 1 : nLCoverScene))
     ! jarvis critical value for normalized soil water content
     call append(L1_jarvis_thresh_c1, dummy_3D(:, 1 : 1, 1 : 1))
     ! Exponential parameter to how non-linear is the soil water retention
@@ -483,19 +444,19 @@
     call append(L1_tempThresh, dummy_3D(:, 1 : 1, 1 : nLCoverScene))
     ! Threshold water depth controlling fast interflow
     call append(L1_unsatThresh, dummy_3D(:, 1 : 1, 1 : 1))
     ! Threshold water depth for surface runoff in sealed surfaces
     call append(L1_sealedThresh, dummy_3D(:, 1 : 1, 1 : 1))
     ! Permanent wilting point
     call append(L1_wiltingPoint, dummy_3D(:, 1 : nSoilHorizons_mHM, 1 : nLCoverScene))
-    ! neutron count related parameters 
-    call append(L1_No_Count,     dummy_3D(:, 1:1,                 1:1))            ! N0 count   
+    ! neutron count related parameters
+    call append(L1_No_Count,     dummy_3D(:, 1:1,                 1:1))            ! N0 count
     call append(L1_bulkDens,     dummy_3D(:, 1:nSoilHorizons_mHM, 1:nLCoverScene)) ! bulk density
     call append(L1_latticeWater, dummy_3D(:, 1:nSoilHorizons_mHM, 1:nLCoverScene)) ! lattice water
     call append(L1_COSMICL3,     dummy_3D(:, 1:nSoilHorizons_mHM, 1:nLCoverScene)) ! cosmic L3 parameter
-   
+
     ! free space
     if (allocated(dummy_3D)) deallocate(dummy_3D)
 
   end subroutine init_eff_params
 
 END MODULE mo_mpr_startup
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `mhm-5.12.1.dev21/src/MPR/mo_multi_param_reg.f90` & `mhm-5.13.0/src/MPR/mo_multi_param_reg.f90`

 * *Files 4% similar despite different names*

```diff
@@ -1,289 +1,183 @@
-!>       \file mo_multi_param_reg.f90
-
-!>       \brief Multiscale parameter regionalization (MPR).
-
-!>       \details This module provides the routines for multiscale parameter regionalization (MPR).
-
-!>       \authors Stephan Thober, Rohini Kumar
-
-!>       \date Dec 2012
-
-! Modifications:
-
+!> \file mo_multi_param_reg.f90
+!> \brief \copybrief mo_multi_param_reg
+!> \details \copydetails mo_multi_param_reg
+
+!> \brief Multiscale parameter regionalization (MPR).
+!> \details This module provides the routines for multiscale parameter regionalization (MPR).
+!> \authors Stephan Thober, Rohini Kumar
+!> \date Dec 2012
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mpr
 MODULE mo_multi_param_reg
 
   use mo_kind, only : i4, dp
   use mo_common_constants, only : nodata_dp, nodata_i4
+  use mo_message, only : message, error_message
 
   implicit none
 
   private
 
   PUBLIC :: mpr                     ! calculates effective regionalised parameters
   PUBLIC :: canopy_intercept_param  ! estimate effective max. canopy interception
 
 contains
-  ! ---------------------------------------------------------------------------
-
-  !    NAME
-  !        mpr
-
-  !    PURPOSE
-  !>       \brief Regionalizing and Upscaling process parameters
-
-  !>       \details calculating process parameters at L0 scale (Regionalization), like:
-  !>       - Baseflow recession parameter
-  !>       - Soil moisture parameters
-  !>       - PET correction for aspect
-
-  !>       and upscale these parameters to retrieve effective parameters at scale
-  !>       L1.
-  !>       Further parameter regionalizations are done for:
-  !>       - snow accumulation and melting parameters
-  !>       - threshold parameter for runoff generation on impervious layer
-  !>       - karstic percolation loss
-  !>       - setting up the Regionalized Routing Parameters
-
-  !    INTENT(IN)
-  !>       \param[in] "logical, dimension(:, :) :: mask0"         mask at level 0 field
-  !>       \param[in] "integer(i4), dimension(:) :: geoUnit0"     L0 geological units
-  !>       \param[in] "integer(i4), dimension(:, :) :: soilId0"   soil Ids at level 0
-  !>       \param[in] "real(dp), dimension(:) :: Asp0"            [degree] Aspect at Level 0
-  !>       \param[in] "real(dp), dimension(:, :) :: gridded_LAI0" LAI grid at level 0, with dim2 = time
-  !>       \param[in] "integer(i4), dimension(:, :) :: LCOVER0"   land cover at level 0
-  !>       \param[in] "real(dp), dimension(:) :: slope_emp0"      Empirical quantiles of slope
-  !>       \param[in] "real(dp), dimension(:) :: y0"              y0 at level 0
-  !>       \param[in] "integer(i4), dimension(:) :: Id0"          Cell ids at level 0
-  !>       \param[in] "integer(i4), dimension(:) :: upper_bound1" Upper row of hi res block
-  !>       \param[in] "integer(i4), dimension(:) :: lower_bound1" Lower row of hi res block
-  !>       \param[in] "integer(i4), dimension(:) :: left_bound1"  Left column of hi res block
-  !>       \param[in] "integer(i4), dimension(:) :: right_bound1" Right column of hi res block
-  !>       \param[in] "integer(i4), dimension(:) :: n_subcells1"  Number of L0 cells within a L1 cell
-
-  !    INTENT(INOUT)
-  !>       \param[inout] "real(dp), dimension(:, :, :) :: fSealed1"         [1] fraction of sealed area
-  !>       \param[inout] "real(dp), dimension(:, :, :) :: alpha1"           [1] Exponent for the upper reservoir
-  !>       \param[inout] "real(dp), dimension(:, :, :) :: degDayInc1"       [d-1 degreeC-1]  Increase of the
-  !>       Degree-day factor per mm of
-  !>       increase in precipitation
-  !>       \param[inout] "real(dp), dimension(:, :, :) :: degDayMax1"       [mm-1 degreeC-1] Maximum Degree-day factor
-  !>       \param[inout] "real(dp), dimension(:, :, :) :: degDayNoPre1"     [mm-1 degreeC-1] Degree-day factor with
-  !>       no precipitation
-  !>       \param[inout] "real(dp), dimension(:, :, :) :: fAsp1"            [1]     PET correction for Aspect at level 1
-  !>       \param[inout] "real(dp), dimension(:, :, :) :: HarSamCoeff1"     [1]     PET Hargreaves Samani coeff. at
-  !>       level 1
-  !>       \param[inout] "real(dp), dimension(:, :, :) :: PrieTayAlpha1"    [1]     PET Priestley Taylor coeff. at level
-  !>       1
-  !>       \param[inout] "real(dp), dimension(:, :, :) :: aeroResist1"      [s m-1] PET aerodynamical resitance at level
-  !>       1
-  !>       \param[inout] "real(dp), dimension(:, :, :) :: surfResist1"      [s m-1] PET bulk surface resitance at level
-  !>       1
-  !>       \param[inout] "real(dp), dimension(:, :, :) :: fRoots1"          fraction of roots in soil horizon
-  !>       \param[inout] "real(dp), dimension(:, :, :) :: kFastFlow1"       [10^-3 m] Recession coefficient
-  !>       of the upper reservoir, upper outlet
-  !>       \param[inout] "real(dp), dimension(:, :, :) :: kSlowFlow1"       [10^-3 m] Recession coefficient
-  !>       of the upper reservoir, lower outlet
-  !>       \param[inout] "real(dp), dimension(:, :, :) :: kBaseFlow1"       Level 1 baseflow recession
-  !>       \param[inout] "real(dp), dimension(:, :, :) :: kPerco1"          [d-1] percolation coefficient
-  !>       \param[inout] "real(dp), dimension(:, :, :) :: karstLoss1"
-  !>       \param[inout] "real(dp), dimension(:, :, :) :: soilMoistFC1"     [10^-3 m] field capacity
-  !>       \param[inout] "real(dp), dimension(:, :, :) :: soilMoistSat1"    [10^-3 m] depth of saturated SM
-  !>       \param[inout] "real(dp), dimension(:, :, :) :: soilMoistExp1"    Parameter that determines the rel.
-  !>       contribution to SM, upscal. Bulk den.
-  !>       \param[inout] "real(dp), dimension(:, :, :) :: jarvis_thresh_c1" [1] jarvis critical value for norm SWC
-  !>       \param[inout] "real(dp), dimension(:, :, :) :: tempThresh1"      [degreeC] threshold temperature
-  !>       for snow rain
-  !>       \param[inout] "real(dp), dimension(:, :, :) :: unsatThresh1"     [10^-3 m] Threshhold water depth
-  !>       in upper reservoir (for Runoff
-  !>       contribution)
-  !>       \param[inout] "real(dp), dimension(:, :, :) :: sealedThresh1"    threshold parameter
-  !>       \param[inout] "real(dp), dimension(:, :, :) :: wiltingPoint1"    [10^-3 m] permanent wilting point
-  !>       \param[inout] "real(dp), dimension(:, :, :) :: maxInter1"
-  !>       \param[inout] "real(dp), dimension(:, :, :) :: petLAIcorFactor"
-  !
-  !>       \param[inout] "real(dp), dimension(:, :, :) :: N0_Count1"     [-]  inital count
-  !>       \param[inout] "real(dp), dimension(:, :, :) :: bulkDens1"     [gcm-3] bulk density
-  !>       \param[inout] "real(dp), dimension(:, :, :) :: latticeWater1" [mm/mm] lattice water content
-  !>       \param[inout] "real(dp), dimension(:, :, :) :: COSMICL31"     [-] cosmic L3 parameter
-
-  !    INTENT(IN), OPTIONAL
-  !>       \param[in] "real(dp), dimension(:), optional :: parameterset"
-
-  !    HISTORY
-  !>       \authors Stephan Thober, Rohini Kumar
-
-  !>       \date Dec 2012
-
-  ! Modifications:
-  ! Stephan Thober           Jan 2013 - updated calling sequence for upscaling operators
-  ! Luis Samaniego           Feb 2013 - calling sequence, initial CHECK, call mpr_runoff
-  ! Stephan Thober           Feb 2013 - added subroutine for karstic percolation loss removed L1_, L0_ in variable names
-  ! Stephan Thober           Aug 2015 - moved regionalization of routing to mRM
-  ! Rohini Kumar             Mar 2016 - changes for handling multiple soil database options
-  ! Zink M. & Demirel M.C.   Mar 2017 - Added Jarvis soil water stress function at SM process(3)
-  ! Demirel M.C. & S. Stisen Apr 2017 - Added FC dependency on root fraction coefficient at SM process(3)
-  ! Robert Schweppe          Dec 2017 - added loop over LCscenes inside MPR, renamed variables rewrite
-  ! Robert Schweppe          Jun 2018 - refactoring and reformatting
-  ! Demirel M.C. & S. Stisen Jun 2020 - Added Feddes and global FC dependency on root fraction coefficient at SM process(3)=4
-  ! Rohini Kumar             Oct 2021 - Added Neutron count module to mHM integrate into develop branch (5.11.2)
 
-  subroutine mpr(mask0, geoUnit0, soilId0, Asp0, gridded_LAI0, LCover0, slope_emp0, y0, Id0, upper_bound1, lower_bound1, &
+  !> \brief Regionalizing and Upscaling process parameters
+  !> \details calculating process parameters at L0 scale (Regionalization), like:
+  !! - Baseflow recession parameter
+  !! - Soil moisture parameters
+  !! - PET correction for aspect
+  !!
+  !! and upscale these parameters to retrieve effective parameters at scale L1.
+  !! Further parameter regionalizations are done for:
+  !! - snow accumulation and melting parameters
+  !! - threshold parameter for runoff generation on impervious layer
+  !! - karstic percolation loss
+  !! - setting up the Regionalized Routing Parameters
+  !!
+  !> \changelog
+  !! - Stephan Thober           Jan 2013
+  !!   - updated calling sequence for upscaling operators
+  !! - Luis Samaniego           Feb 2013
+  !!   - calling sequence, initial CHECK, call mpr_runoff
+  !! - Stephan Thober           Feb 2013
+  !!   - added subroutine for karstic percolation loss removed L1_, L0_ in variable names
+  !! - Stephan Thober           Aug 2015
+  !!   - moved regionalization of routing to mRM
+  !! - Rohini Kumar             Mar 2016
+  !!   - changes for handling multiple soil database options
+  !! - Zink M. & Demirel M.C.   Mar 2017
+  !!   - Added Jarvis soil water stress function at SM process(3)
+  !! - Demirel M.C. & S. Stisen Apr 2017
+  !!   - Added FC dependency on root fraction coefficient at SM process(3)
+  !! - Robert Schweppe          Dec 2017
+  !!   - added loop over LCscenes inside MPR, renamed variables rewrite
+  !! - Robert Schweppe          Jun 2018
+  !!   - refactoring and reformatting
+  !! - Demirel M.C. & S. Stisen Jun 2020
+  !!   - Added Feddes and global FC dependency on root fraction coefficient at SM process(3)=4
+  !! - Rohini Kumar             Oct 2021
+  !!   - Added Neutron count module to mHM integrate into develop branch (5.11.2)
+  !! - Sebastian Mller         Mar 2023
+  !!   - made L1_alpha, L1_kSlowFlow, L1_kBaseFlow and L1_kPerco land cover dependent
+  !> \authors Stephan Thober, Rohini Kumar
+  !> \date Dec 2012
+subroutine mpr(mask0, geoUnit0, soilId0, Asp0, gridded_LAI0, LCover0, slope_emp0, y0, Id0, upper_bound1, lower_bound1, &
        left_bound1, right_bound1, n_subcells1, fSealed1, alpha1, degDayInc1, degDayMax1, degDayNoPre1, fAsp1, &
        HarSamCoeff1, PrieTayAlpha1, aeroResist1, surfResist1, fRoots1, kFastFlow1, kSlowFlow1, kBaseFlow1, &
        kPerco1, karstLoss1, soilMoistFC1, soilMoistSat1, soilMoistExp1, jarvis_thresh_c1, tempThresh1, &
        unsatThresh1, sealedThresh1, wiltingPoint1, maxInter1, petLAIcorFactor, &
        No_Count1, bulkDens1, latticeWater1, COSMICL31, &
        parameterset )
 
     use mo_common_variables, only : global_parameters, processMatrix
-    use mo_message, only : message
     use mo_mpr_SMhorizons, only : mpr_SMhorizons
     use mo_mpr_global_variables, only : HorizonDepth_mHM, fracSealed_CityArea, iFlag_soilDB, nSoilHorizons_mHM, &
          soilDB
     use mo_mpr_pet, only : bulksurface_resistance, pet_correctbyASP, pet_correctbyLAI, priestley_taylor_alpha
     use mo_mpr_runoff, only : mpr_runoff
     use mo_mpr_soilmoist, only : mpr_sm
     use mo_upscaling_operators, only : L0_fractionalCover_in_Lx, &
          upscale_arithmetic_mean
     use mo_mpr_neutrons,        only: mpr_neutrons
     implicit none
 
-    ! mask at level 0 field
+    !> mask at level 0 field
     logical, dimension(:, :), intent(in) :: mask0
-
-    ! L0 geological units
+    !> L0 geological units
     integer(i4), dimension(:), intent(in) :: geoUnit0
-
-    ! soil Ids at level 0
+    !> soil Ids at level 0
     integer(i4), dimension(:, :), intent(in) :: soilId0
-
-    ! [degree] Aspect at Level 0
+    !> [degree] Aspect at Level 0
     real(dp), dimension(:), intent(in) :: Asp0
-
-    ! LAI grid at level 0, with dim2 = time
+    !> LAI grid at level 0, with dim2 = time
     real(dp), dimension(:, :), intent(in) :: gridded_LAI0
-
-    ! land cover at level 0
+    !> land cover at level 0
     integer(i4), dimension(:, :), intent(in) :: LCOVER0
-
-    ! Empirical quantiles of slope
+    !> Empirical quantiles of slope
     real(dp), dimension(:), intent(in) :: slope_emp0
-
-    ! Cell ids at level 0
+    !> Cell ids at level 0
     integer(i4), dimension(:), intent(in) :: Id0
-
-    ! Upper row of hi res block
+    !> Upper row of hi res block
     integer(i4), dimension(:), intent(in) :: upper_bound1
-
-    ! Lower row of hi res block
+    !> Lower row of hi res block
     integer(i4), dimension(:), intent(in) :: lower_bound1
-
-    ! Left column of hi res block
+    !> Left column of hi res block
     integer(i4), dimension(:), intent(in) :: left_bound1
-
-    ! Right column of hi res block
+    !> Right column of hi res block
     integer(i4), dimension(:), intent(in) :: right_bound1
-
-    ! Number of L0 cells within a L1 cell
+    !> Number of L0 cells within a L1 cell
     integer(i4), dimension(:), intent(in) :: n_subcells1
-
-    ! y0 at level 0
+    !> y0 at level 0
     real(dp), dimension(:), intent(in) :: y0
-
-    ! [1] fraction of sealed area
+    !> [1] fraction of sealed area
     real(dp), dimension(:, :, :), intent(inout) :: fSealed1
-
-    ! Parameter that determines the rel.
-    ! contribution to SM, upscal. Bulk den.
+    !> Parameter that determines the rel. contribution to SM, upscal. Bulk den.
     real(dp), dimension(:, :, :), intent(inout) :: soilMoistExp1
-
-    ! [1] jarvis critical value for norm SWC
+    !> [1] jarvis critical value for norm SWC
     real(dp), dimension(:, :, :), intent(inout) :: jarvis_thresh_c1
-
-    ! [10^-3 m] depth of saturated SM
+    !> [10^-3 m] depth of saturated SM
     real(dp), dimension(:, :, :), intent(inout) :: soilMoistSat1
-
-    ! [10^-3 m] field capacity
+    !> [10^-3 m] field capacity
     real(dp), dimension(:, :, :), intent(inout) :: soilMoistFC1
-
-    ! [10^-3 m] permanent wilting point
+    !> [10^-3 m] permanent wilting point
     real(dp), dimension(:, :, :), intent(inout) :: wiltingPoint1
-
-    ! fraction of roots in soil horizon
+    !> fraction of roots in soil horizon
     real(dp), dimension(:, :, :), intent(inout) :: fRoots1
-
-    ! [degreeC] threshold temperature
-    ! for snow rain
+    !> [degreeC] threshold temperature for snow rain
     real(dp), dimension(:, :, :), intent(inout) :: tempThresh1
-
-    ! [mm-1 degreeC-1] Degree-day factor with
-    ! no precipitation
+    !> [mm-1 degreeC-1] Degree-day factor with no precipitation
     real(dp), dimension(:, :, :), intent(inout) :: degDayNoPre1
-
-    ! [mm-1 degreeC-1] Maximum Degree-day factor
+    !> [mm-1 degreeC-1] Maximum Degree-day factor
     real(dp), dimension(:, :, :), intent(inout) :: degDayMax1
-
-    ! [d-1 degreeC-1]  Increase of the
-    ! Degree-day factor per mm of
-    ! increase in precipitation
+    !> [d-1 degreeC-1]  Increase of the Degree-day factor per mm of increase in precipitation
     real(dp), dimension(:, :, :), intent(inout) :: degDayInc1
-
-    ! [1]     PET correction for Aspect at level 1
+    !> [1]     PET correction for Aspect at level 1
     real(dp), dimension(:, :, :), intent(inout) :: fAsp1
-
-    ! [1]     PET Hargreaves Samani coeff. at level 1
+    !> [1]     PET Hargreaves Samani coeff. at level 1
     real(dp), dimension(:, :, :), intent(inout) :: HarSamCoeff1
-
-    ! [1]     PET Priestley Taylor coeff. at level 1
+    !> [1]     PET Priestley Taylor coeff. at level 1
     real(dp), dimension(:, :, :), intent(inout) :: PrieTayAlpha1
-
-    ! [s m-1] PET aerodynamical resitance at level 1
+    !> [s m-1] PET aerodynamical resitance at level 1
     real(dp), dimension(:, :, :), intent(inout) :: aeroResist1
-
-    ! [s m-1] PET bulk surface resitance at level 1
+    !> [s m-1] PET bulk surface resitance at level 1
     real(dp), dimension(:, :, :), intent(inout) :: surfResist1
-
-    ! threshold parameter
+    !> threshold parameter
     real(dp), dimension(:, :, :), intent(inout) :: sealedThresh1
-
-    ! [10^-3 m] Threshhold water depth
-    ! in upper reservoir (for Runoff
-    ! contribution)
+    !> [10^-3 m] Threshhold water depth in upper reservoir (for Runoff contribution)
     real(dp), dimension(:, :, :), intent(inout) :: unsatThresh1
-
-    ! [10^-3 m] Recession coefficient
-    ! of the upper reservoir, upper outlet
+    !> [10^-3 m] Recession coefficient of the upper reservoir, upper outlet
     real(dp), dimension(:, :, :), intent(inout) :: kFastFlow1
-
-    ! [10^-3 m] Recession coefficient
-    ! of the upper reservoir, lower outlet
+    !> [10^-3 m] Recession coefficient of the upper reservoir, lower outlet
     real(dp), dimension(:, :, :), intent(inout) :: kSlowFlow1
-
-    ! Level 1 baseflow recession
+    !> Level 1 baseflow recession
     real(dp), dimension(:, :, :), intent(inout) :: kBaseFlow1
-
-    ! [1] Exponent for the upper reservoir
+    !> [1] Exponent for the upper reservoir
     real(dp), dimension(:, :, :), intent(inout) :: alpha1
-
-    ! [d-1] percolation coefficient
+    !> [d-1] percolation coefficient
     real(dp), dimension(:, :, :), intent(inout) :: kPerco1
-
+    !> karstic percolation loss
     real(dp), dimension(:, :, :), intent(inout) :: karstLoss1
-
+    !> max interception
     real(dp), dimension(:, :, :), intent(inout) :: maxInter1
-
+    !> pet cor factor at level-1
     real(dp), dimension(:, :, :), intent(inout) :: petLAIcorFactor
-
-    !>> neutron count related parameters
+    !> [-] inital neutron count
     real(dp), dimension(:, :, :), intent(inout) :: No_Count1
+    !> [gcm-3] bulk density
     real(dp), dimension(:, :, :), intent(inout) :: bulkDens1
+    !> [mm/mm] lattice water content
     real(dp), dimension(:, :, :), intent(inout) :: latticeWater1
+    !> [-] cosmic L3 parameter
     real(dp), dimension(:, :, :), intent(inout) :: COSMICL31
 
+    !> array of global parameters
     real(dp), dimension(:), intent(in), optional, target :: parameterset
 
     ! array of global parameters
     real(dp), dimension(:), pointer :: param
 
     real(dp), dimension(:, :, :), allocatable :: thetaS_till
 
@@ -292,19 +186,16 @@
     real(dp), dimension(:, :, :), allocatable :: thetaPW_till
 
     ! saturated hydraulic conductivity
     real(dp), dimension(:, :, :), allocatable :: Ks
 
     ! Bulk density
     real(dp), dimension(:, :, :), allocatable :: Db
-
     real(dp), dimension(:, :), allocatable :: thetaS
-
     real(dp), dimension(:, :), allocatable :: thetaFC
-
     real(dp), dimension(:, :), allocatable :: thetaPW
 
     ! neutron count
     real(dp), dimension(:,:,:), allocatable :: latWat_till
     real(dp), dimension(:,:,:), allocatable :: COSMIC_L3_till
     real(dp), dimension(:,:), allocatable   :: latWat         ! lattice water
     real(dp), dimension(:,:), allocatable   :: COSMIC_L3      ! COSMIC parameter L3
@@ -321,14 +212,17 @@
     ! soil mositure deficit from
     ! field cap. w.r.t to saturation
     real(dp), dimension(:), allocatable :: SMs_FC0
 
     ! L0 baseflow parameter
     real(dp), dimension(size(Id0, 1)) :: k2_0
 
+    ! L1 baseflow parameter
+    real(dp), dimension(:), allocatable :: k2_1
+
     ! L0 Aspect
     real(dp), dimension(size(Id0, 1)) :: fAsp0
 
     ! number of soil classes
     integer(i4) :: mSoil
 
     ! maximum of number of Tillage horizons
@@ -397,37 +291,35 @@
        ! based on the sealing fraction[0-1] in cities
        !---------------------------------------------------------
        ! a factor is applied to the sealed area, effectively reducing it
        fSealed1(:, 1, iiLC) = fracSealed_CityArea * fSealed1(:, 1, iiLC)
        ! the forest area is kept constant, but the permeable area is increased so that the
        ! sum off all fractions equals 1 again
        fPerm1(:) = 1.0_dp - fSealed1(:, 1, iiLC) - fForest1(:)
-       
+
        ! ------------------------------------------------------------------
-       ! snow parameters 
+       ! snow parameters
        ! ------------------------------------------------------------------
        select case(processMatrix(2,1))
        case(1)
 
           iStart = processMatrix(2, 3) - processMatrix(2, 2) + 1
           iEnd = processMatrix(2, 3)
 
           call snow_acc_melt_param(param(iStart : iEnd), & ! intent(in)
                fForest1, fSealed1(:, 1, iiLC), fPerm1, & ! intent(in)
                tempThresh1(:, 1, iiLC), degDayNoPre1(:, 1, iiLC), & ! intent(out)
                degDayInc1(:, 1, iiLC), degDayMax1(:, 1, iiLC) & ! intent(out)
                )
        case DEFAULT
-          call message()
-          call message('***ERROR: Process description for process "snow pack" does not exist! mo_multi_param_reg')
-          stop
+          call error_message('***ERROR: Process description for process "snow pack" does not exist! mo_multi_param_reg')
        end select
 
        ! ------------------------------------------------------------------
-       ! Soil moisture parametrization 
+       ! Soil moisture parametrization
        ! ------------------------------------------------------------------
        msoil = size(soilDB%is_present, 1)
        mLC = maxval(LCover0(:, iiLC), (LCover0(:, iiLC) .ne. nodata_i4))
 
        ! depending on which kind of soil database processing is to be performed
        if(iFlag_soilDB .eq. 0)then
           mtill = maxval(soilDB%nTillHorizons, (soilDB%nTillHorizons .ne. nodata_i4))
@@ -452,23 +344,23 @@
        allocate(thetaFC(msoil, mHor))
        allocate(thetaPW(msoil, mHor))
        allocate(Ks(msoil, mHor, mLC))
        allocate(Db(msoil, mHor, mLC))
 
        ! neutron count related ones
        ! allocate and initalize here
-       allocate(   latWat_till(msoil, mtill, mLC)) 
-       allocate(COSMIC_L3_till(msoil, mtill, mLC))  
-       allocate(        latWat(msoil, mHor      )) 
+       allocate(   latWat_till(msoil, mtill, mLC))
+       allocate(COSMIC_L3_till(msoil, mtill, mLC))
+       allocate(        latWat(msoil, mHor      ))
        allocate(     COSMIC_L3(msoil, mHor      ))
        latWat_till    = 0.000001_dp
        COSMIC_L3_till = 0.000001_dp
        COSMIC_L3      = 0.000001_dp
        latWat         = 0.000001_dp
-       
+
 
 
        ! earlier these variables were allocated with  size(soilId0,1)
        ! in which the variable "soilId0" changes according to the iFlag_soilDB
        ! so better to use other variable which is common to both soilDB (0 AND 1) flags
        allocate(KsVar_H0(size(Id0, 1)))
        allocate(KsVar_V0(size(Id0, 1)))
@@ -523,28 +415,26 @@
           ! next four parameters go here
           ! (the first three for the fRoots and the fourth one for the beta)
           iStart2 = processMatrix(3, 3) - 7
           iEnd2 = processMatrix(3, 3)
           !write(*,*) 'iStart, iEnd, iStart2, iEnd2 = ', iStart, iEnd, iStart2, iEnd2
 
        case DEFAULT
-          call message()
-          call message('***ERROR: Process description for process "soil moisture parametrization"', &
+          call error_message('***ERROR: Process description for process "soil moisture parametrization"', &
                'does not exist! mo_multi_param_reg')
-          stop 1
        end select
 
        call mpr_sm(param(iStart : iEnd), processMatrix, &
             soilDB%is_present, soilDB%nHorizons, soilDB%nTillHorizons, &
             soilDB%sand, soilDB%clay, soilDB%DbM, &
             Id0, soilId0, LCover0(:, iiLC), &
             thetaS_till, thetaFC_till, thetaPW_till, thetaS, &
             thetaFC, thetaPW, Ks, Db, KsVar_H0, KsVar_V0, SMs_FC0)
 
-       !>> neutron count related parameters
+       ! >> neutron count related parameters
        if ( processMatrix(10,1) .GT. 0 ) &
             call mpr_neutrons( processMatrix(10,1), &  ! IN: processmatrix case
             param( processMatrix(10,3)-processMatrix(10,2)+1:processMatrix(10,3) ) , & ! IN:  global parameter set
             soilDB%is_present       , & ! IN:  flag indicating presence of soil
             soilDB%nHorizons        , & ! IN:  Number of Horizons of Soiltype
             soilDB%nTillHorizons    , & ! IN:  Number of tillage Horizons
             LCover0(:, iiLC)        , & ! IN:  land cover ids at level 0
@@ -564,33 +454,33 @@
             thetaS_till, thetaFC_till, thetaPW_till, &
             thetaS, thetaFC, thetaPW, &
             soilDB%Wd, Db, soilDB%DbM, soilDB%RZdepth, &
             mask0, Id0, &
             upper_bound1, lower_bound1, left_bound1, right_bound1, n_subcells1, &
             soilMoistExp1(:, :, iiLC), soilMoistSat1(:, :, iiLC), soilMoistFC1(:, :, iiLC), &
             wiltingPoint1(:, :, iiLC), fRoots1(:, :, iiLC), &
-            !>>>>>> neutron count
+            ! >>>>>> neutron count
             latWat_till, COSMIC_L3_till, latWat, COSMIC_L3, &
             bulkDens1(:,:,iiLC), latticeWater1(:,:,iiLC), COSMICL31(:,:,iiLC) &
             )
 
        deallocate(thetaS_till)
        deallocate(thetaFC_till)
        deallocate(thetaPW_till)
        deallocate(thetaS)
        deallocate(thetaFC)
        deallocate(thetaPW)
        deallocate(Ks)
        deallocate(Db)
 
        ! neutron count
-       deallocate( latWat_till    ) 
-       deallocate( COSMIC_L3_till ) 
-       deallocate( latWat     ) 
-       deallocate( COSMIC_L3  ) 
+       deallocate( latWat_till    )
+       deallocate( COSMIC_L3_till )
+       deallocate( latWat     )
+       deallocate( COSMIC_L3  )
 
        ! ------------------------------------------------------------------
        ! potential evapotranspiration (PET)
        ! ------------------------------------------------------------------
        ! Penman-Monteith method is only method that is LCscene dependent
        if (processMatrix(5, 1) == 3) then
           iStart = processMatrix(5, 3) - processMatrix(5, 2) + 1
@@ -617,19 +507,17 @@
           iStart = processMatrix(6, 3) - processMatrix(6, 2) + 1
           iEnd = processMatrix(6, 3)
           ! TODO: this subroutine should be split into each param (or at least extract kFastFlow1)
           ! because it is in the loop unnecessarily
           call mpr_runoff(LCover0(:, iiLC), mask0, SMs_FC0, slope_emp0, &
                KsVar_H0, param(iStart : iEnd), Id0, upper_bound1, lower_bound1, &
                left_bound1, right_bound1, n_subcells1, unsatThresh1(:, 1, 1), kFastFlow1(:, 1, iiLC), &
-               kSlowFlow1(:, 1, 1), alpha1(:, 1, 1))
+               kSlowFlow1(:, 1, iiLC), alpha1(:, 1, iiLC))
        case DEFAULT
-          call message()
-          call message('***ERROR: Process description for process "interflow" does not exist! mo_multi_param_reg')
-          stop
+          call error_message('***ERROR: Process description for process "interflow" does not exist! mo_multi_param_reg')
        END select
 
        ! ------------------------------------------------------------------
        ! percolation cofficient, karstic percolation loss
        ! ------------------------------------------------------------------
        select case(processMatrix(7, 1))
        case(1)
@@ -637,42 +525,38 @@
           iStart = processMatrix(7, 3) - processMatrix(7, 2) + 1
           iEnd = processMatrix(7, 3)
           call karstic_layer(& ! In
                param(iStart : iEnd), & ! In
                geoUnit0, mask0, & ! In
                SMs_FC0, KsVar_V0, Id0, & ! In
                n_subcells1, upper_bound1, lower_bound1, left_bound1, right_bound1, & ! In
-               karstLoss1(:, 1, 1), kPerco1(:, 1, 1)                                & ! Out
+               karstLoss1(:, 1, 1), kPerco1(:, 1, iiLC)                            & ! Out
                )
 
        case DEFAULT
-          call message()
-          call message('***ERROR: Process description for process "percolation" does not exist! mo_multi_param_reg')
-          stop
+          call error_message('***ERROR: Process description for process "percolation" does not exist! mo_multi_param_reg')
        end select
 
        deallocate(KsVar_H0)
        deallocate(KsVar_V0)
        deallocate(SMs_FC0)
 
-    end do !!>>>>>>> LAND COVER SCENE LOOP
+    end do !! >>>>>>> LAND COVER SCENE LOOP
 
 
     ! ------------------------------------------------------------------
     ! sealed area threshold for runoff generation
     ! ------------------------------------------------------------------
     select case(processMatrix(4, 1))
     case (1)
        iStart = processMatrix(4, 3) - processMatrix(4, 2) + 1
        iEnd = processMatrix(4, 3)
        call iper_thres_runoff(param(iStart : iEnd), sealedThresh1)
     case DEFAULT
-       call message()
-       call message('***ERROR: Process description for process "runoff_generation" does not exist! mo_multi_param_reg')
-       stop
+       call error_message('***ERROR: Process description for process "runoff_generation" does not exist! mo_multi_param_reg')
     end select
 
     ! ------------------------------------------------------------------
     ! potential evapotranspiration (PET)
     ! ------------------------------------------------------------------
     select case(processMatrix(5, 1))
     case(-1) ! LAI correction of input PET
@@ -700,67 +584,66 @@
        ! aerodynamic resistance is calculated inside LCscene loop
        iStart = processMatrix(5, 3) - processMatrix(5, 2) + 1
        iEnd = processMatrix(5, 3)
        call bulksurface_resistance(gridded_LAI0, param(iEnd), mask0, &
             nodata_dp, Id0, n_subcells1, upper_bound1, lower_bound1, left_bound1, right_bound1, &
             surfResist1(:, :, 1))
     case default
-       call message()
-       call message('***ERROR: Process description for process "pet correction" does not exist! mo_multi_param_reg')
-       stop
+       call error_message('***ERROR: Process description for process "pet correction" does not exist! mo_multi_param_reg')
     end select
     ! ------------------------------------------------------------------
     ! baseflow recession parameter
     ! ------------------------------------------------------------------
     select case(processMatrix(9, 1))
-    case(1)
-
-       ! the number of process parameters, so the number in processMatrix(9,2) has
-       ! to be equal to the size of geo_unit_list
-       iStart = processMatrix(9, 3) - processMatrix(9, 2) + 1
-       iEnd = processMatrix(9, 3)
-
-       call baseflow_param(param(iStart : iEnd), &
-            geoUnit0, k2_0)
-       !
-       ! Upscale by arithmetic mean
-       kBaseFlow1(:, 1, 1) = upscale_arithmetic_mean(n_subcells1, upper_bound1, lower_bound1, &
+      case(1)
+        ! the number of process parameters, so the number in processMatrix(9,2) has
+        ! to be equal to the size of geo_unit_list
+        iStart = processMatrix(9, 3) - processMatrix(9, 2) + 1
+        iEnd = processMatrix(9, 3)
+
+        call baseflow_param(param(iStart : iEnd), geoUnit0, k2_0)
+
+        ! Upscale by arithmetic mean
+        allocate(k2_1(size(kBaseFlow1, 1)))
+        k2_1 = upscale_arithmetic_mean(n_subcells1, upper_bound1, lower_bound1, &
             left_bound1, right_bound1, Id0, mask0, nodata_dp, k2_0)
-       !
-       ! correction and unit conversion
-       ! if percolation is ON: correct K2 such that it is at least k1
-       if (processMatrix(7, 1) .gt. 0) kBaseFlow1 = merge(kSlowFlow1, kBaseFlow1, kBaseFlow1 .lt. kSlowFlow1)
-       !
-    case DEFAULT
-       call message()
-       call message('***ERROR: Process description for process "baseflow Recession" does not exist! mo_multi_param_reg')
-       stop
+        ! loop over all LCover scenes
+        do iiLC = 1, size(LCover0, 2)
+          kBaseFlow1(:, 1, iiLC) = k2_1
+        end do
+        deallocate(k2_1)
+
+        ! correction and unit conversion
+        ! if percolation is ON: correct K2 such that it is at least k1
+        ! since kSlowFlow1 is LCover dependent, kBaseFlow1 is too
+        if (processMatrix(7, 1) .gt. 0) kBaseFlow1 = merge(kSlowFlow1, kBaseFlow1, kBaseFlow1 .lt. kSlowFlow1)
+
+      case DEFAULT
+        call error_message('***ERROR: Process description for process "baseflow Recession" does not exist! mo_multi_param_reg')
     end select
 
     ! ------------------------------------------------------------------
     ! Neutron count related parameters
     ! >> only N0 parameter - others are defined above in soil parameters
     ! ------------------------------------------------------------------
     select case(processMatrix(10, 1))
     case(0)
        ! do nothing
     case(1)
        ! the number of process parameters, so the number in processMatrix(9,2) has
        iStart = processMatrix(10, 3) - processMatrix(10, 2) + 1
        iEnd = processMatrix(10, 3)
-       No_Count1 = param(iStart)  !>> 1st parameter --> N0 parameter 
+       No_Count1 = param(iStart)  ! >> 1st parameter --> N0 parameter
     case(2)
        ! the number of process parameters, so the number in processMatrix(9,2) has
        iStart = processMatrix(10, 3) - processMatrix(10, 2) + 1
        iEnd = processMatrix(10, 3)
-       No_Count1 = param(iStart)  !>> 1st parameter --> N0 parameter
+       No_Count1 = param(iStart)  ! >> 1st parameter --> N0 parameter
     case DEFAULT
-       call message()
-       call message('***ERROR: Process description for process "Neutron count" does not exist! mo_multi_param_reg')
-       stop
+       call error_message('***ERROR: Process description for process "Neutron count" does not exist! mo_multi_param_reg')
     end select
 
 
     !-------------------------------------------------------------------
     ! call regionalization of parameters related to LAI
     ! it is now outside of mHM since LAI is now dynamic variable
     !-------------------------------------------------------------------
@@ -823,15 +706,15 @@
     integer(i4) :: ii
 
     ! geo unit
     integer(i4), dimension(1) :: gg
 
 
     if (size(param) .ne. size(geoUnitList)) &
-         stop ' mo_multi_param_reg: baseflow_param: size mismatch, subroutine baseflow parameters '
+          call error_message(' mo_multi_param_reg: baseflow_param: size mismatch, subroutine baseflow parameters ')
 
     k2_0 = nodata_dp
 
     !$OMP PARALLEL
     !$OMP DO PRIVATE(gg) SCHEDULE(STATIC)
     do ii = 1, size(k2_0)
        ! get parameter index in geoUnitList
@@ -1051,15 +934,15 @@
   !    HISTORY
   !>       \authors Rohini Kumar, Stephan Thober
 
   !>       \date Feb 2013
 
   ! Modifications:
   ! Stephan Thober Dec 2013 - changed intent(inout) to intent(out)
-  ! Stephan Thober Dec 2013 - changed intent(inout) to intent(out) 
+  ! Stephan Thober Dec 2013 - changed intent(inout) to intent(out)
   ! Robert Schweppe Jun 2018 - refactoring and reformatting
 
   subroutine karstic_layer(param, geoUnit0, mask0, SMs_FC0, KsVar_V0, Id0, n_subcells1, upper_bound1, lower_bound1, &
        left_bound1, right_bound1, karstLoss1, L1_Kp)
 
     use mo_mpr_global_variables, only : GeoUnitList, geoUnitKar
     use mo_upscaling_operators, only : L0_fractionalCover_in_Lx, upscale_arithmetic_mean
@@ -1189,15 +1072,14 @@
 
   ! Modifications:
   ! Robert Schweppe Jun 2018 - refactoring and reformatting
 
   subroutine canopy_intercept_param(processMatrix, param, LAI0, n_subcells1, upper_bound1, lower_bound1, left_bound1, &
        right_bound1, Id0, mask0, nodata, max_intercept1)
 
-    use mo_message, only : message
     use mo_string_utils, only : num2str
     use mo_upscaling_operators, only : upscale_arithmetic_mean
 
     implicit none
 
     ! indicate processes
     integer(i4), dimension(:, :), intent(in) :: processMatrix
@@ -1239,15 +1121,15 @@
 
     real(dp), dimension(:), allocatable :: max_intercept0
 
     real(dp), dimension(:), allocatable :: gamma_intercept
 
 
     ! ------------------------------------------------------------------
-    ! Maximum interception parameter 
+    ! Maximum interception parameter
     ! ------------------------------------------------------------------
     select case(processMatrix(1, 1))
     case(1)
        iStart = processMatrix(1, 3) - processMatrix(1, 2) + 1
        iEnd = processMatrix(1, 3)
 
        ! allocate space
@@ -1267,16 +1149,15 @@
                right_bound1, Id0, mask0, nodata, max_intercept0(:))
 
        end do
 
        deallocate(gamma_intercept)
        deallocate(max_intercept0)
     CASE DEFAULT
-       call message('mo_multi_param_reg: This processMatrix=', num2str(processMatrix(1, 1)), ' is not implemented!')
-       stop
+       call error_message('mo_multi_param_reg: This processMatrix=', num2str(processMatrix(1, 1)), ' is not implemented!')
     end select
 
   end subroutine canopy_intercept_param
 
 
   ! ----------------------------------------------------------------------------
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `mhm-5.12.1.dev21/src/MPR/mo_prepare_gridded_lai.f90` & `mhm-5.13.0/src/MPR/mo_prepare_gridded_lai.f90`

 * *Files 16% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-!>       \file mo_prepare_gridded_lai.f90
-
-!>       \brief Prepare daily LAI fields (e.g., MODIS data) for mHM
-
-!>       \details Prepare daily LAI fields(e.g., MODIS data) for mHM
-
-!>       \authors John Craven & Rohini Kumar
-
-!>       \date Aug 2013
-
-! Modifications:
-
+!> \file mo_prepare_gridded_lai.f90
+!> \brief \copybrief mo_prepare_gridded_lai
+!> \details \copydetails mo_prepare_gridded_lai
+
+!> \brief Prepare daily LAI fields (e.g., MODIS data) for mHM
+!> \details Prepare daily LAI fields(e.g., MODIS data) for mHM
+!> \authors John Craven & Rohini Kumar
+!> \date Aug 2013
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mpr
 MODULE mo_prepare_gridded_LAI
 
   ! This module provides routines to read daily gridded LAI data.
 
   ! Written  John Craven & Rohini Kumar, August 2013
   ! Modified from mo_meteo_forcings
 
   USE mo_kind, ONLY : i4, dp
+  use mo_message, only: error_message
 
   IMPLICIT NONE
 
   PRIVATE
 
   PUBLIC :: prepare_gridded_daily_LAI_data
   PUBLIC :: prepare_gridded_mean_monthly_LAI_data
@@ -57,16 +57,15 @@
   ! Modifications:
   ! Matthias Cuntz & Juliane Mai Nov 2014 - use meteo reading routines
   ! Robert Schweppe Jun 2018 - refactoring and reformatting
 
   subroutine prepare_gridded_daily_LAI_data(iDomain, nrows, ncols, mask, LAIPer_iDomain)
 
     use mo_append, only : append
-    use mo_common_variables, only : period
-    use mo_message, only : message
+    use mo_common_types, only: period
     use mo_mpr_global_variables, only : L0_gridded_LAI, dirgridded_LAI, inputFormat_gridded_LAI, &
             nLAI, LAIBoundaries, timeStep_LAI_input
     use mo_read_nc, only : read_nc
 
     implicit none
 
     ! domain Id
@@ -90,17 +89,15 @@
 
     ! netcdf file input option
     CASE('nc')
       CALL read_nc(dirgridded_LAI(iDomain), nRows, nCols, &
               'lai', mask, LAI0_3D, target_period = LAIPer_iDomain, &
               lower = 1.00E-10_dp, upper = 30.0_dp, nctimestep = timeStep_LAI_input)
     CASE DEFAULT
-      call message()
-      call message('***ERROR: No recognized input format')
-      stop 1
+      call error_message('***ERROR: No recognized input format')
 
     END SELECT
 
     ! pack variables
     nCells = count(mask)
     ! only set if not yet allocated (e.g. domain 1)
     if (.not. allocated(LAIBoundaries)) then
@@ -147,15 +144,14 @@
 
   ! Modifications:
   ! Robert Schweppe Jun 2018 - refactoring and reformatting
 
   subroutine prepare_gridded_mean_monthly_LAI_data(iDomain, nrows, ncols, mask)
 
     use mo_append, only : append
-    use mo_message, only : message
     use mo_mpr_global_variables, only : L0_gridded_LAI, dirgridded_LAI, nLAI, LAIBoundaries
     use mo_ncread, only : Get_NcDim, Get_NcVar, Get_NcVarAtt
     use mo_string_utils, only : num2str
     use mo_utils, only : eq
 
     implicit none
 
@@ -191,53 +187,50 @@
 
 
     fName = trim(dirgridded_LAI(iDomain)) // trim('lai.nc')
 
     ! get dimensions
     dimen = Get_NcDim(trim(fName), 'lai')
     if ((dimen(1) .ne. nRows) .or. (dimen(2) .ne. nCols)) then
-      stop '***ERROR: read_nc: mHM generated x and y are not matching NetCDF dimensions'
+       call error_message('***ERROR: read_nc: mHM generated x and y are not matching NetCDF dimensions')
     end if
     if (dimen(3) .ne. 12) then
-      stop '***ERROR: read_nc: the time dimenion of LAI NetCDF file under the option-1 is not 12'
+       call error_message('***ERROR: read_nc: the time dimenion of LAI NetCDF file under the option-1 is not 12')
     end if
 
     ! determine no data value
     call Get_NcVarAtt(trim(fName), 'lai', '_FillValue', AttValues, dtype = datatype)
     ! convert to number
     read(AttValues, *) nodata_value
 
     call Get_NcVar(trim(fName), 'lai', LAI0_3D)
 
     ! start checking values
     do t = 1, dimen(3)
       ! checking for nodata values if optional nocheck is given
       if (any(eq(LAI0_3D(:, :, t), nodata_value) .and. (mask))) then
-        call message('***ERROR: read_nc: nodata value within domain ')
-        call message('          boundary in variable: ', 'lai')
-        call message('          at timestep         : ', trim(num2str(t)))
-        stop
+        call error_message('***ERROR: read_nc: nodata value within domain ', raise=.false.)
+        call error_message('          boundary in variable: ', 'lai', raise=.false.)
+        call error_message('          at timestep         : ', trim(num2str(t)))
       end if
       ! optional check
       if (any((LAI0_3D(:, :, t) .lt. 0.0_dp) .AND. mask(:, :))) then
-        call message('***ERROR: read_nc: values in variable lai are lower than ', trim(num2str(0, '(F7.2)')))
-        call message('          at timestep  : ', trim(num2str(t)))
-        call message('File: ', trim(fName))
-        call message('Minval at timestep: ', trim(num2str(minval(LAI0_3D(:, :, t)), '(F7.2)')))
-        call message('Total minval: ', trim(num2str(minval(LAI0_3D(:, :, :)), '(F7.2)')))
-        stop
+        call error_message('***ERROR: read_nc: values in variable lai are lower than ', trim(num2str(0, '(F7.2)')), raise=.false.)
+        call error_message('          at timestep  : ', trim(num2str(t)), raise=.false.)
+        call error_message('File: ', trim(fName), raise=.false.)
+        call error_message('Minval at timestep: ', trim(num2str(minval(LAI0_3D(:, :, t)), '(F7.2)')), raise=.false.)
+        call error_message('Total minval: ', trim(num2str(minval(LAI0_3D(:, :, :)), '(F7.2)')))
       end if
 
       if (any((LAI0_3D(:, :, t) .gt. 30.0_dp) .AND. mask(:, :))) then
-        call message('***ERROR: read_nc: values in variable lai are greater than ', trim(num2str(30, '(F7.2)')))
-        call message('          at timestep  : ', trim(num2str(t)))
-        call message('File: ', trim(fName))
-        call message('Maxval at timestep: ', trim(num2str(maxval(LAI0_3D(:, :, t)), '(F7.2)')))
-        call message('Total maxval: ', trim(num2str(maxval(LAI0_3D(:, :, :)), '(F7.2)')))
-        stop
+        call error_message('***ERROR: read_nc: values in variable lai are greater than ', trim(num2str(30, '(F7.2)')), raise=.false.)
+        call error_message('          at timestep  : ', trim(num2str(t)), raise=.false.)
+        call error_message('File: ', trim(fName), raise=.false.)
+        call error_message('Maxval at timestep: ', trim(num2str(maxval(LAI0_3D(:, :, t)), '(F7.2)')), raise=.false.)
+        call error_message('Total maxval: ', trim(num2str(maxval(LAI0_3D(:, :, :)), '(F7.2)')))
       end if
     end do
 
     ! pack variables
     nCells = count(mask)
     ! only set if not yet allocated (e.g. domain 1)
     if (.not. allocated(LAIBoundaries)) then
```

### Comparing `mhm-5.12.1.dev21/src/MPR/mo_read_lut.f90` & `mhm-5.13.0/src/MPR/mo_read_lut.f90`

 * *Files 15% similar despite different names*

```diff
@@ -1,29 +1,28 @@
-!>       \file mo_read_lut.f90
-
-!>       \brief Routines reading lookup tables (lut).
-
-!>       \details This module contains routines reading various lookup tables (lut).
-!>       (1) LUT containing gauge information.
-!>       (2) LUT containing geological formation information.
-!>       (3) LUT containing LAI class information.
-
-!>       \authors Juliane Mai, Matthias Zink
-
-!>       \date Jan 2013
-
-! Modifications:
-
+!> \file mo_read_lut.f90
+!> \brief \copybrief mo_read_lut
+!> \details \copydetails mo_read_lut
+
+!> \brief Routines reading lookup tables (lut).
+!> \details This module contains routines reading various lookup tables (lut).
+!! 1. LUT containing gauge information.
+!! 2. LUT containing geological formation information.
+!! 3. LUT containing LAI class information.
+!> \authors Juliane Mai, Matthias Zink
+!> \date Jan 2013
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mpr
 MODULE mo_read_lut
 
   ! Written    Juliane Mai,    Jan 2013
   ! Modified   Matthias Zink,  Jan 2013 - add read_gauge_lut
 
   USE mo_kind, ONLY : i4, dp
-  USE mo_os, ONLY: path_isfile
+  USE mo_os, ONLY: check_path_isfile
   use mo_string_utils, ONLY: num2str
   use mo_message, ONLY: error_message
 
   IMPLICIT NONE
 
   PUBLIC :: read_geoformation_lut  ! Reads LUT containing geological formation information
   PUBLIC :: read_lai_lut           ! Reads LUT containing LAI class information
@@ -89,15 +88,15 @@
     integer(i4), dimension(:), allocatable, intent(out) :: geo_karstic
 
     integer(i4) :: i, ios
 
     character(256) :: dummy
 
     !checking whether the file exists
-    call path_isfile(path = filename, quiet_ = .true., throwError_ = .true.)
+    call check_path_isfile(path = filename, raise=.true.)
     open(fileunit, file = filename, action = 'read', status = 'old')
 
     ! read header
     read(fileunit, *) dummy, nGeo
     read(fileunit, *) dummy
     dummy = dummy // ''   ! only to avoid warning
 
@@ -176,15 +175,15 @@
     real(dp), dimension(:, :), allocatable, intent(out) :: LAI
 
     integer(i4) :: i, j, ios
 
     character(256) :: dummy
 
     !checking whether the file exists
-    call path_isfile(path = filename, quiet_ = .true., throwError_ = .true.)
+    call check_path_isfile(path = filename, raise=.true.)
     open(fileunit, file = filename, action = 'read')
 
     ! read header
     read(fileunit, *) dummy, nLAI
     read(fileunit, *) dummy
     dummy = dummy // ''   ! only to avoid warning
```

### Comparing `mhm-5.12.1.dev21/src/MPR/mo_read_wrapper.f90` & `mhm-5.13.0/src/MPR/mo_read_wrapper.f90`

 * *Files 2% similar despite different names*

```diff
@@ -1,24 +1,24 @@
-!>       \file mo_read_wrapper.f90
-
-!>       \brief Wrapper for all reading routines.
-
-!>       \details This module is to wrap up all reading routines.
-!>       The general written reading routines are used to store now the read data into global variables.
-
-!>       \authors Juliane Mai, Matthias Zink
-
-!>       \date Jan 2013
-
-! Modifications:
-
+!> \file mo_read_wrapper.f90
+!> \brief \copybrief mo_read_wrapper
+!> \details \copydetails mo_read_wrapper
+
+!> \brief Wrapper for all reading routines.
+!> \details This module is to wrap up all reading routines.
+!! The general written reading routines are used to store now the read data into global variables.
+!> \authors Juliane Mai, Matthias Zink
+!> \date Jan 2013
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mpr
 MODULE mo_read_wrapper
 
   USE mo_kind, ONLY : i4, dp
   use mo_common_constants, only : nodata_dp, nodata_i4
+  use mo_message, only: message, error_message
 
   IMPLICIT NONE
 
   PUBLIC :: read_data            ! reads all available data
 
 CONTAINS
 
@@ -62,17 +62,17 @@
   ! Robert Schweppe              Jun 2018 - refactoring and reformatting
 
   subroutine read_data(LAIPer)
 
     use mo_append, only : append, paste
     use mo_constants, only : YearMonths
     use mo_common_read_data, only : read_dem, read_lcover
-    use mo_common_variables, only : Grid, dirCommonFiles, dirMorpho, &
-                                    global_parameters, level0, domainMeta, period, processMatrix
-    use mo_message, only : message
+    use mo_common_types, only: period, Grid
+    use mo_common_variables, only : dirCommonFiles, dirMorpho, &
+                                    global_parameters, level0, domainMeta, processMatrix
     use mo_mpr_file, only : file_aspect, file_geolut, file_hydrogeoclass, &
                             file_laiclass, file_lailut, file_slope, file_soil_database, file_soil_database_1, &
                             file_soilclass, uaspect, ugeolut, uhydrogeoclass, ulaiclass, ulailut, uslope, usoilclass
     use mo_mpr_global_variables, only : GeoUnitKar, &
                                         GeoUnitList, L0_asp, L0_geoUnit, L0_gridded_LAI, L0_slope, L0_soilId, LAILUT, &
                                         LAIUnitList, iFlag_soilDB, nGeoUnits, nLAI, nLAIclass, nSoilHorizons_mHM, soilDB, &
                                         timeStep_LAI_input, LAIBoundaries
@@ -363,15 +363,14 @@
   !>       \date Nov 2016
 
   ! Modifications:
   ! Robert Schweppe Jun 2018 - refactoring and reformatting
 
   subroutine check_consistency_lut_map(data, lookuptable, filename, unique_values)
 
-    use mo_message, only : message, error_message
     use mo_orderpack, only : unista
     use mo_string_utils, only : num2str
 
     implicit none
 
     ! map of study domain
     integer(i4), dimension(:), intent(in) :: data
@@ -402,18 +401,16 @@
     do ielement = 1, n_unique_elements
       if ( temp(ielement) == nodata_i4 ) call error_message( &
         '***ERROR: Class ', trim(adjustl(num2str(temp(ielement)))), &
         ' was searched in ', trim(adjustl(filename)), &
         ' which indicates a masking problem!' &
       )
       if (.not. ANY(lookuptable .EQ. temp(ielement))) then
-        call message()
-        call message('***ERROR: Class ', trim(adjustl(num2str(temp(ielement)))), ' is missing')
-        call message('          in input file ', trim(adjustl(filename)), ' ...')
-        stop
+        call error_message('***ERROR: Class ', trim(adjustl(num2str(temp(ielement)))), ' is missing', raise=.false.)
+        call error_message('          in input file ', trim(adjustl(filename)), ' ...')
       end if
     end do
 
     ! pass unique values if optional argument unique_values is given
     if (present(unique_values)) then
       allocate(unique_values(n_unique_elements))
       unique_values(:) = temp(1 : n_unique_elements)
```

### Comparing `mhm-5.12.1.dev21/src/MPR/mo_soil_database.f90` & `mhm-5.13.0/src/MPR/mo_soil_database.f90`

 * *Files 12% similar despite different names*

```diff
@@ -1,32 +1,31 @@
-!>       \file mo_soil_database.f90
-
-!>       \brief Generating soil database from input file.
-
-!>       \details This module provides the routines for generating the soil database for mHM from an ASCII input file.
-!>       One routine \e read_soil_LUT reads a soil LookUpTable, performs some consistency checks and returns an initial
-!>       soil database.
-!>       The second routine \e generate_soil_database calculates based on the initial one the proper soil database.
-
-!>       \authors Juliane Mai
-
-!>       \date Dec 2012
-
-! Modifications:
-
+!> \file mo_soil_database.f90
+!> \brief \copybrief mo_soil_database
+!> \details \copydetails mo_soil_database
+
+!> \brief Generating soil database from input file.
+!> \details This module provides the routines for generating the soil database for mHM from an ASCII input file.
+!! One routine \e read_soil_LUT reads a soil LookUpTable, performs some consistency checks and returns an initial
+!! soil database.
+!! The second routine \e generate_soil_database calculates based on the initial one the proper soil database.
+!> \authors Juliane Mai
+!> \date Dec 2012
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mpr
 MODULE mo_soil_database
 
   ! This module to provide a soil database for mHM.
 
   ! Written  Juliane Mai, Dec 2012
 
   use mo_kind, only : i4, dp
-  use mo_message, only : message, error_message
+  use mo_message, only: message, error_message
   use mo_string_utils, only : num2str
-  use mo_os, only : path_isfile
+  use mo_os, only : check_path_isfile
 
   IMPLICIT NONE
 
   PRIVATE
 
   PUBLIC :: read_soil_LUT             ! Reads the soil LUT file
   PUBLIC :: generate_soil_database    ! Generates the soil database
@@ -91,15 +90,15 @@
 
 
     SELECT CASE (iFlag_soilDB)
       ! classical mHM soil database
     CASE(0)
       ios = 0_i4
       !checking whether the file exists
-      call path_isfile(path = filename, quiet_ = .true., throwError_ = .true.)
+      call check_path_isfile(path = filename, raise=.true.)
       open(usoil_database, file = filename, status = 'old', iostat = ios)
       read(usoil_database, *) dummy, nSoilTypes
       dummy = dummy // ''   ! only to avoid warning
 
       ! allocate space
       allocate(soilDB%Id(nSoilTypes))
       allocate(soilDB%nHorizons(nSoilTypes))
@@ -117,24 +116,22 @@
       nR = 0_i4
       read(usoil_database, *) dummy
       do while (.NOT. (ios .ne. 0))
         read(usoil_database, *, IOSTAT = ios) ii, jj, up, down, cly, snd, bd
 
         ! Checks
         if(up .ge. down) then
-          call message('read_soil_LUT: ERROR occurred: Mixed horizon depths in soil type', &
+          call error_message('read_soil_LUT: ERROR occurred: Mixed horizon depths in soil type', &
                   num2str(ii, '(I3)'), ' and horizon no.', num2str(jj, '(I3)'))
-          stop
         end if
         if(cly .lt. 0.0_dp .OR. cly .gt. 100.0_dp .OR. &
                 snd .lt. 0.0_dp .OR. snd .gt. 100.0_dp .OR. &
                 bd  .lt. 0.0_dp .OR. bd  .gt.   5.0_dp) then
-          call message('read_soil_LUT: ERROR occurred: Inappropriate soil properties in soil type', &
+          call error_message('read_soil_LUT: ERROR occurred: Inappropriate soil properties in soil type', &
                   num2str(ii, '(I3)'), ' and horizon no.', num2str(jj, '(I3)'))
-          stop
         end if
 
         ! initalise soil id
         if ( ii > size(soilDB%Id) ) call error_message( &
           "ERROR: nSoil_Types (", num2str(size(soilDB%Id)), &
           ") in soil_classdefinition.txt seems to be to low! Tried to read: ", num2str(ii) &
         )
@@ -153,19 +150,18 @@
       )
 
       ! initalise minimum root zone depth among all soil types
       dMin = minval(soilDB%RZdepth(:), soilDB%RZdepth(:) .gt. 0.0_dp)
 
       ! check the tillage depth...(if possible adjust it..)
       if(tillageDepth .gt. dMin) then
-        call message('read_soil_LUT: ERROR occurred: ')
-        call message('    Tillage depth is greater than overall minimum total soil depth ')
-        call message('    So tillage depth should be at least', num2str(dMin, '(F7.2)'))
-        call message('    Please adjust!')
-        stop
+        call error_message('read_soil_LUT: ERROR occurred: ', raise=.false.)
+        call error_message('    Tillage depth is greater than overall minimum total soil depth ', raise=.false.)
+        call error_message('    So tillage depth should be at least', num2str(dMin, '(F7.2)'), raise=.false.)
+        call error_message('    Please adjust!')
       end if
 
       ! insert a new tillage soil layer, only in those soil types, in which it is not present
       rewind(usoil_database)
       read(usoil_database, *) dummy
       read(usoil_database, *) dummy
 
@@ -274,18 +270,17 @@
         soilDB%depth(jj, nH) = soilDB%LD(jj, nH) - soilDB%UD(jj, nH)
         soilDB%clay(jj, nH) = cly
         soilDB%sand(jj, nH) = snd
         soilDB%dbM(jj, nH) = bd
 
         ! check for number of soil horizons...
         if(nH .gt. soilDB%nHorizons(jj)) then
-          call message('read_soil_LUT: ERROR occurred: ')
-          call message('    There is something wrong in allocating horizons in soil data base.')
-          call message('    Please check in code !')
-          STOP
+          call error_message('read_soil_LUT: ERROR occurred: ', raise=.false.)
+          call error_message('    There is something wrong in allocating horizons in soil data base.', raise=.false.)
+          call error_message('    Please check in code !')
         end if
 
         ! initalise the increment counter to zero
         if(nH .eq. soilDB%nHorizons(jj)) kk = 0_i4
 
       end do
       close(usoil_database)
@@ -305,15 +300,15 @@
       allocate(soilDB%thetaPW(1, 1))
       allocate(soilDB%Db(1, 1, 1))
       allocate(soilDB%Ks(1, 1, 1))
 
 
 
       !checking whether the file exists
-      call path_isfile(path = filename, quiet_ = .true., throwError_ = .true.)
+      call check_path_isfile(path = filename, raise=.true.)
       open(usoil_database, file = filename, status = 'old', action = 'read')
       read(usoil_database, *) dummy, nSoilTypes
       dummy = dummy // ''   ! only to avoid warning
       allocate(soilDB%Id  (nSoilTypes))
       allocate(soilDB%clay(nSoilTypes, 1))
       allocate(soilDB%sand(nSoilTypes, 1))
       allocate(soilDB%dbM (nSoilTypes, 1))
@@ -352,28 +347,24 @@
         end if
       end do
 
       ! check
       if(soilDB%nTillHorizons(1) .eq. -9) then
         ! rarely could happen *** since this is checked in reading of horizons depths only
         ! but is checked here for double confirmation
-        call message()
-        call message('***ERROR: specification of tillage depths is not confirming')
-        call message('          with given depths of soil horizons to be modeled.')
-        stop
+        call error_message('***ERROR: specification of tillage depths is not confirming', raise=.false.)
+        call error_message('          with given depths of soil horizons to be modeled.')
       else
         call message()
         call message('Tillage layers: the tillage horizons are modelled ')
         call message('                upto mHM layers: ', trim(num2str(soilDB%nTillHorizons(1))))
       end if
 
     CASE DEFAULT
-      call message()
-      call message('***ERROR: iFlag_soilDB option given does not exist. Only 0 and 1 is taken at the moment.')
-      stop
+      call error_message('***ERROR: iFlag_soilDB option given does not exist. Only 0 and 1 is taken at the moment.')
 
     END SELECT
 
   end subroutine read_soil_LUT
 
   ! ------------------------------------------------------------------
 
@@ -418,22 +409,21 @@
       ! classical mHM soil database
     CASE(0)
       ! initalise minimum root zone depth among all soil types
       dMin = minval(soilDB%RZdepth(:), soilDB%RZdepth(:) > 0.0_dp)
 
       ! check
       if (HorizonDepth_mHM(nSoilHorizons_mHM - 1) .ge. dMin) then
-        call message('generate_soil_database: ERROR occurred: ')
-        call message('    The depth of soil Horizons provided for modelling is not appropriate')
-        call message('    The global minimum of total soil horizon depth among all soil type is ', num2str(dMin, '(F7.2)'))
-        call message('    Adjust your modeling soil horizon depth in this range')
-        call message('    OR Increase the soil depth in data base for only those soil types')
-        call message('    whose total depth is smaller than your given modeling depth.')
-        STOP
-      end if
+        call error_message('generate_soil_database: ERROR occurred: ', raise=.false.)
+        call error_message('   The depth of soil Horizons provided for modelling is not appropriate', raise=.false.)
+        call error_message('   The global minimum of total soil horizon depth among all soil type is ', num2str(dMin, '(F7.2)'), raise=.false.)
+        call error_message('   Adjust your modeling soil horizon depth in this range', raise=.false.)
+        call error_message('   OR Increase the soil depth in data base for only those soil types', raise=.false.)
+        call error_message('   whose total depth is smaller than your given modeling depth.')
+     end if
 
       ! allocate and initalise depth weight
       allocate(soilDB%Wd(nSoilTypes, nSoilHorizons_mHM, maxval(soilDB%nHorizons(:))))
       soilDB%Wd(:, :, :) = 0.0_dp
 
       ! Process further to estimate weight of each horizons
       ! weightage according to soil depths
@@ -459,25 +449,23 @@
           do kk = 1, soilDB%nHorizons(ii)
             if(dpth_f .ge. soilDB%UD(ii, kk) .and. dpth_f .le. (soilDB%LD(ii, kk) - soil_dAccuracy)) layer_f = kk
             if(dpth_t .ge. soilDB%UD(ii, kk) .and. dpth_t .le. (soilDB%LD(ii, kk) - soil_dAccuracy)) layer_t = kk
           end do
 
           ! Check
           if(layer_f .le. 0_i4 .or. layer_t .le. 0_i4) then
-            call message('generate_soil_database: ERROR occurred: ')
-            call message('     Horizon depths to model do not lie in database for soil type', num2str(ii, '(I3)'))
-            call message('     Please check!')
-            STOP
+            call error_message('generate_soil_database: ERROR occurred: ', raise=.false.)
+            call error_message('     Horizon depths to model do not lie in database for soil type', num2str(ii, '(I3)'), raise=.false.)
+            call error_message('     Please check!')
           end if
           if(layer_f .gt. layer_t) then
-            call message('generate_soil_database: ERROR occurred: ')
-            call message('     Something is wrong in assignment of modeling soil horizons or')
-            call message('     database of soil type ', num2str(ii, '(I3)'))
-            call message('     Please check!')
-            STOP
+            call error_message('generate_soil_database: ERROR occurred: ', raise=.false.)
+            call error_message('     Something is wrong in assignment of modeling soil horizons or', raise=.false.)
+            call error_message('     database of soil type ', num2str(ii, '(I3)'), raise=.false.)
+            call error_message('     Please check!')
           end if
 
           ! iF modeling depth of a given horizon falls in a same soil layer
           if(layer_f .eq. layer_t) then
             soilDB%Wd(ii, jj, layer_f) = 1.0_dp
 
             ! else estimate depth weightage...
@@ -504,33 +492,29 @@
               soilDB%Wd(ii, jj, 1 : soilDB%nHorizons(ii)) = soilDB%Wd(ii, jj, 1 : soilDB%nHorizons(ii)) / &
                       HorizonDepth_mHM(jj)
             end if
 
             ! Check (small margin for numerical errors)
             if(sum(soilDB%Wd(ii, jj, :), soilDB%Wd(ii, jj, :) .gt. 0.0_dp) .le. 1.0_dp - small .or. &
                     sum(soilDB%Wd(ii, jj, :), soilDB%Wd(ii, jj, :) .gt. 0.0_dp) .ge. 1.0_dp + small) then
-              call message('generate_soil_database: ERROR occurred: ')
-              call message('     Weight assigned for each soil horizons are not correct.')
-              call message('     Please check!')
-              STOP
+              call error_message('generate_soil_database: ERROR occurred: ', raise=.false.)
+              call error_message('     Weight assigned for each soil horizons are not correct.', raise=.false.)
+              call error_message('     Please check!')
             end if
 
           end if
 
         end do
       end do
       ! soil database for the horizon specific case
     CASE(1)
       ! right now nothing is done here
       ! *** reserved for future changes
       allocate(soilDB%Wd(1,1,1))
 
     CASE DEFAULT
-      call message()
-      call message('***ERROR: iFlag_soilDB option given does not exist. Only 0 and 1 is taken at the moment.')
-      stop
-
+      call error_message('***ERROR: iFlag_soilDB option given does not exist. Only 0 and 1 is taken at the moment.')
     END SELECT
 
   end subroutine generate_soil_database
 
 END MODULE mo_soil_database
```

### Comparing `mhm-5.12.1.dev21/src/MPR/mo_upscaling_operators.f90` & `mhm-5.13.0/src/MPR/mo_upscaling_operators.f90`

 * *Files 1% similar despite different names*

```diff
@@ -1,19 +1,18 @@
-!>       \file mo_upscaling_operators.f90
-
-!>       \brief Module containing upscaling operators.
-
-!>       \details This module provides the routines for upscaling_operators.
-
-!>       \authors Giovanni Dalmasso, Rohini Kumar
-
-!>       \date Dec 2012
-
-! Modifications:
-
+!> \file mo_upscaling_operators.f90
+!> \brief \copybrief mo_upscaling_operators
+!> \details \copydetails mo_upscaling_operators
+
+!> \brief Module containing upscaling operators.
+!> \details This module provides the routines for upscaling_operators.
+!> \authors Giovanni Dalmasso, Rohini Kumar
+!> \date Dec 2012
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mpr
 module mo_upscaling_operators
 
   ! This module contains the functions for upscaling grid L0_fineScale_2D_data.
 
   ! Written  Giovanni Dalmasso, Rohini Kumar, Dec 2012
 
   use mo_kind, only : i4, dp
```

### Comparing `mhm-5.12.1.dev21/src/MPR/mpr_driver.F90` & `mhm-5.13.0/src/MPR/mpr_driver.F90`

 * *Files 21% similar despite different names*

```diff
@@ -1,65 +1,65 @@
-!>       \file mpr_driver.f90
-
-!>       \brief Distributed precipitation-runoff model mHM
-
-!>       \details This is the main driver of mHM, which calls
-!>       one instance of mHM for a multiple domains and a given period.
-!>       \image html  mhm5-logo.png "Typical mHM cell"
-!>       \image latex mhm5-logo.pdf "Typical mHM cell" width=10cm
-
-!>       \authors Luis Samaniego & Rohini Kumar (UFZ)
-
-!>       \date Dec 2015
-
-!>       \version 0.1
-
-!>       \copyright (c)2005-2019, Helmholtz-Zentrum fuer Umweltforschung GmbH - UFZ.
-!>       All rights reserved.
-
-!>       This code is a property of:
-
-!>       ----------------------------------------------------------
-
-!>       Helmholtz-Zentrum fuer Umweltforschung GmbH - UFZ
-!>       Registered Office: Leipzig
-!>       Registration Office: Amtsgericht Leipzig
-!>       Trade Register: Nr. B 4703
-!>       Chairman of the Supervisory Board: MinDirig Wilfried Kraus
-!>       Scientific Director: Prof. Dr. Georg Teutsch
-!>       Administrative Director: Dr. Heike Grassmann
-
-!>       ----------------------------------------------------------
-
-!>       NEITHER UFZ NOR THE DEVELOPERS MAKES ANY WARRANTY,
-!>       EXPRESS OR IMPLIED, OR ASSUMES ANY LIABILITY FOR THE USE
-!>       OF THIS SOFTWARE. If software is modified to produce
-!>       derivative works, such modified software should be
-!>       clearly marked, so as not to confuse it with the version
-!>       available from UFZ.  This code can be used for research
-!>       purposes ONLY provided that the following sources are
-!>       acknowledged:
-
-!>       Samaniego L., Kumar R., Attinger S. (2010): Multiscale
-!>       parameter regionalization of a grid-based hydrologic
-!>       model at the mesoscale.  Water Resour. Res., 46,
-!>       W05523, doi:10.1029/2008WR007327.
-
-!>       Kumar, R., L. Samaniego, and S. Attinger (2013), Implications
-!>       of distributed hydrologic model parameterization on water
-!>       fluxes at multiple scales and locations, Water Resour. Res.,
-!>       49, doi:10.1029/2012WR012195.
-
-!>       For commercial applications you have to consult the
-!>       authorities of the UFZ.
-
-! Modifications:
-! Robert Schweppe Jun 2018 - refactored from mhm codebase
-
+!> \file mpr_driver.f90
+!> \brief Distributed precipitation-runoff model mHM
 #ifdef MPR_STANDALONE
+!> \details \copydetails mpr_driver
+
+!> \brief Distributed precipitation-runoff model mHM
+!> \details This is the main driver of mHM, which calls
+!! one instance of mHM for a multiple domains and a given period.
+!! \image html  mhm5-logo.png "Typical mHM cell"
+!! \image latex mhm5-logo.pdf "Typical mHM cell" width=10cm
+!> \changelog
+!! - Robert Schweppe Jun 2018
+!!   - refactored from mhm codebase
+!> \authors Luis Samaniego & Rohini Kumar (UFZ)
+!> \date Dec 2015
+!> \version 0.1
+!> \copyright (c)2005-2019, Helmholtz-Zentrum fuer Umweltforschung GmbH - UFZ.
+!! All rights reserved.
+!!
+!! This code is a property of:
+!!
+!! ----------------------------------------------------------
+!!
+!! Helmholtz-Zentrum fuer Umweltforschung GmbH - UFZ
+!! Registered Office: Leipzig
+!! Registration Office: Amtsgericht Leipzig
+!! Trade Register: Nr. B 4703
+!! Chairman of the Supervisory Board: MinDirig Wilfried Kraus
+!! Scientific Director: Prof. Dr. Georg Teutsch
+!! Administrative Director: Dr. Heike Grassmann
+!!
+!! ----------------------------------------------------------
+!!
+!! NEITHER UFZ NOR THE DEVELOPERS MAKES ANY WARRANTY,
+!! EXPRESS OR IMPLIED, OR ASSUMES ANY LIABILITY FOR THE USE
+!! OF THIS SOFTWARE. If software is modified to produce
+!! derivative works, such modified software should be
+!! clearly marked, so as not to confuse it with the version
+!! available from UFZ.  This code can be used for research
+!! purposes ONLY provided that the following sources are
+!! acknowledged:
+!!
+!! Samaniego L., Kumar R., Attinger S. (2010): Multiscale
+!! parameter regionalization of a grid-based hydrologic
+!! model at the mesoscale.  Water Resour. Res., 46,
+!! W05523, doi:10.1029/2008WR007327.
+!!
+!! Kumar, R., L. Samaniego, and S. Attinger (2013), Implications
+!! of distributed hydrologic model parameterization on water
+!! fluxes at multiple scales and locations, Water Resour. Res.,
+!! 49, doi:10.1029/2012WR012195.
+!!
+!! For commercial applications you have to consult the
+!! authorities of the UFZ.
+!!
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mpr
 program mpr_driver
 
   use mo_message, only : message
   use mo_string_utils, only : separator
   use mo_mpr_eval, only : mpr_eval
   use mo_read_wrapper, only : read_data
   use mo_mpr_read_config, only : mpr_read_config
@@ -103,12 +103,13 @@
   ! FINISH UP
   ! --------------------------------------------------------------------------
   call message(separator)
   call message('MPR: Finished!')
   call message(separator)
 end program mpr_driver
 #else
-! dummy module such that this file is never empty for compilation
+
+!> \brief dummy module such that this file is never empty for compilation
 module dummy_mpr
   implicit none
 end module dummy_mpr
 #endif
```

### Comparing `mhm-5.12.1.dev21/src/common/mo_check.f90` & `mhm-5.13.0/src/common/mo_check.f90`

 * *Files 20% similar despite different names*

```diff
@@ -1,17 +1,21 @@
-!>       \file    mo_check.f90
-!>       \copydoc mo_check
-
-!>       \brief   Input checking routines
-!>       \details This module provides sanity checks for the input data.
-!>       \authors Sebastian Mueller
-!>       \date    Nov 2020
+!> \file    mo_check.f90
+!> \brief   \copybrief mo_check
+!> \details \copydetails mo_check
+
+!> \brief   Input checking routines
+!> \details This module provides sanity checks for the input data.
+!> \authors Sebastian Mueller
+!> \date    Nov 2020
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_common
 MODULE mo_check
 
-  USE mo_kind, ONLY : i4, dp
+  USE mo_kind, ONLY : i4
 
   IMPLICIT NONE
 
   PRIVATE
 
   PUBLIC :: check_dir
 
@@ -19,62 +23,75 @@
 
   !>       \brief   Check if a given directory exists.
   !>       \details Check if a given directory exists and write out a message about it.
   !!                Will also give potential information about prefixes given with the path
   !>       \authors Sebastian Mueller
   !>       \date    Nov 2020
 
-  subroutine check_dir(path, text_, throwError_, tab_, text_length_)
+  subroutine check_dir(path, text, raise, tab, text_length)
 
-    use mo_message, only : message
+    use mo_constants, ONLY : nout, nerr
+    use mo_message, only : message, show_msg, show_err
     use mo_os, only : path_split, path_isdir
 
     IMPLICIT NONE
 
-    CHARACTER(LEN=*), INTENT(IN)           :: path         !< input path to check
-    CHARACTER(LEN=*), INTENT(IN), OPTIONAL :: text_        !< text to write out
-    LOGICAL, INTENT(IN), OPTIONAL          :: throwError_  !< wheather to throw an error if folder not existing
-    integer(i4), INTENT(in), OPTIONAL      :: tab_         !< tab-depth
-    integer(i4), INTENT(in), OPTIONAL      :: text_length_ !< maximal text length (for aligning)
-
-    LOGICAL            :: throwError = .false.
-    integer(i4)        :: tab = 0
-    integer(i4)        :: text_length
-    LOGICAL            :: is_dir
-    CHARACTER(len=255) :: head, tail, info, prefix_info, ws, text
+    CHARACTER(LEN=*), INTENT(IN)           :: path        !< input path to check
+    CHARACTER(LEN=*), INTENT(IN), OPTIONAL :: text        !< text to write out
+    LOGICAL, INTENT(IN), OPTIONAL          :: raise       !< whether to throw an error if folder does not exist
+    integer(i4), INTENT(in), OPTIONAL      :: tab         !< tab-depth
+    integer(i4), INTENT(in), OPTIONAL      :: text_length !< maximal text length (for aligning)
+
+    LOGICAL            :: raise_
+    integer(i4)        :: tab_
+    integer(i4)        :: text_length_, uni
+    LOGICAL            :: is_dir, error, show
+    CHARACTER(len=255) :: head, tail, info, prefix_info, ws, text_
 
     ! set standard values
     prefix_info = ""
     ws = " " ! this should hold 255 whitespaces
-    text = "Directory:"
-    if (present(text_)) text = text_
-    if (present(throwError_)) throwError = throwError_
-    if (present(tab_)) tab = tab_
-    text_length = len_trim(text)
-    if (present(text_length_)) text_length = text_length_
+    text_ = "Directory:"
+    raise_ = .false.
+    tab_ = 0
+    if (present(text)) text_ = text
+    if (present(raise)) raise_ = raise
+    if (present(tab)) tab_ = tab
+    text_length_ = len_trim(text_)
+    if (present(text_length)) text_length_ = text_length
 
     ! split path to retrieve potential prefix to output files
     call path_split(path, head, tail)
     ! check if base directory exists
-    call path_isdir(head, quiet_=.true., result_=is_dir) ! allow file prefix as path tail
+    is_dir = path_isdir(head) ! allow file prefix as path tail
 
     if ( is_dir ) then
       info = trim(head) // " (found)"
     else
       info = trim(head) // " (not found)"
     end if
     if ( len_trim(tail) > 0 ) prefix_info = "added file prefix: " // trim(tail)
 
+    error = .not. is_dir .and. raise_
+    show = show_msg
+    uni = nout
+    if ( error ) then
+      show = show_err
+      uni = nerr
+    end if
+
     call message( &
-      ws(1:tab), &
-      trim(text), &
-      ws(1:max(0, text_length-len_trim(text))), &
+      ws(1:tab_), &
+      trim(text_), &
+      ws(1:max(0, text_length_-len_trim(text_))), &
       trim(info), &
       " ", &
-      trim(prefix_info) &
+      trim(prefix_info), &
+      show=show, &
+      uni=uni &
     )
     ! throw error if wanted
-    if (.not. is_dir .and. throwError) stop 1
+    if ( error ) stop 1
 
   end subroutine check_dir
 
 END MODULE mo_check
```

### Comparing `mhm-5.12.1.dev21/src/common/mo_clean_up.f90` & `mhm-5.13.0/src/common/mo_clean_up.f90`

 * *Files 1% similar despite different names*

```diff
@@ -1,51 +1,31 @@
 !> \file    mo_clean_up.f90
-!> \copydoc mo_clean_up
+!> \brief   \copybrief mo_clean_up
+!> \details \copydetails mo_clean_up
 
 !> \brief   Module to clean up after a mHM run.
 !> \version 0.1
 !> \authors Sebastian Mueller
 !> \date    May 2022
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_common
 module mo_clean_up
 
   implicit none
   private
   public :: deallocate_global_variables
 
   contains
 
   !> \brief Deallocate all global variables.
   subroutine deallocate_global_variables()
     use mo_common_run_variables, only : run_cfg
     use mo_global_variables, only : &
-      timeStep_model_inputs, &
-      dirPrecipitation, &
-      dirTemperature, &
-      dirMinTemperature, &
-      dirMaxTemperature, &
-      dirNetRadiation, &
-      dirabsVapPressure, &
-      dirwindspeed, &
-      dirReferenceET, &
-      dirRadiation, &
-      level2, &
-      L1_temp_weights, &
-      L1_pet_weights, &
-      L1_pre_weights, &
-      L1_pre, &
-      L1_temp, &
-      L1_pet, &
-      L1_tmin, &
-      L1_tmax, &
-      L1_netrad, &
-      L1_absvappress, &
-      L1_windspeed, &
-      L1_ssrd, &
-      L1_strd, &
-      L1_tann, &
+      meteo_handler, &
       L1_sm, &
       L1_sm_mask, &
       L1_neutronsdata, &
       L1_neutronsdata_mask, &
       L1_smObs, &
       L1_neutronsObs, &
       L1_etObs, &
@@ -150,15 +130,14 @@
       L1_COSMICL3
     use mo_mrm_global_variables, only : &
       dirGauges, &
       dirTotalRunoff, &
       dirBankfullRunoff, &
       level11, &
       l0_l11_remap, &
-      l1_l11_remap, &
       mRM_runoff, &
       domain_mrm, &
       L0_gaugeLoc, &
       L0_InflowGaugeLoc, &
       L0_fAcc, &
       L0_fDir, &
       L0_draSC, &
@@ -219,39 +198,14 @@
       simPer, &
       warmingDays, &
       LCyearId, &
       mhmFileRestartIn, &
       mrmFileRestartIn
 
     ! mo_global_variables
-    if ( allocated(timeStep_model_inputs) ) deallocate(timeStep_model_inputs)
-    if ( allocated(dirPrecipitation) ) deallocate(dirPrecipitation)
-    if ( allocated(dirTemperature) ) deallocate(dirTemperature)
-    if ( allocated(dirMinTemperature) ) deallocate(dirMinTemperature)
-    if ( allocated(dirMaxTemperature) ) deallocate(dirMaxTemperature)
-    if ( allocated(dirNetRadiation) ) deallocate(dirNetRadiation)
-    if ( allocated(dirabsVapPressure) ) deallocate(dirabsVapPressure)
-    if ( allocated(dirwindspeed) ) deallocate(dirwindspeed)
-    if ( allocated(dirReferenceET) ) deallocate(dirReferenceET)
-    if ( allocated(dirRadiation) ) deallocate(dirRadiation)
-    if ( allocated(level2) ) deallocate(level2)
-    if ( allocated(L1_temp_weights) ) deallocate(L1_temp_weights)
-    if ( allocated(L1_pet_weights) ) deallocate(L1_pet_weights)
-    if ( allocated(L1_pre_weights) ) deallocate(L1_pre_weights)
-    if ( allocated(L1_pre) ) deallocate(L1_pre)
-    if ( allocated(L1_temp) ) deallocate(L1_temp)
-    if ( allocated(L1_pet) ) deallocate(L1_pet)
-    if ( allocated(L1_tmin) ) deallocate(L1_tmin)
-    if ( allocated(L1_tmax) ) deallocate(L1_tmax)
-    if ( allocated(L1_netrad) ) deallocate(L1_netrad)
-    if ( allocated(L1_absvappress) ) deallocate(L1_absvappress)
-    if ( allocated(L1_windspeed) ) deallocate(L1_windspeed)
-    if ( allocated(L1_ssrd) ) deallocate(L1_ssrd)
-    if ( allocated(L1_strd) ) deallocate(L1_strd)
-    if ( allocated(L1_tann) ) deallocate(L1_tann)
     if ( allocated(L1_sm) ) deallocate(L1_sm)
     if ( allocated(L1_sm_mask) ) deallocate(L1_sm_mask)
     if ( allocated(L1_neutronsdata) ) deallocate(L1_neutronsdata)
     if ( allocated(L1_neutronsdata_mask) ) deallocate(L1_neutronsdata_mask)
     if ( allocated(L1_smObs) ) deallocate(L1_smObs)
     if ( allocated(L1_neutronsObs) ) deallocate(L1_neutronsObs)
     if ( allocated(L1_etObs) ) deallocate(L1_etObs)
@@ -379,15 +333,14 @@
 
     ! mo_mrm_global_variables
     if ( allocated(dirGauges) ) deallocate(dirGauges)
     if ( allocated(dirTotalRunoff) ) deallocate(dirTotalRunoff)
     if ( allocated(dirBankfullRunoff) ) deallocate(dirBankfullRunoff)
     if ( allocated(level11) ) deallocate(level11)
     if ( allocated(l0_l11_remap) ) deallocate(l0_l11_remap)
-    if ( allocated(l1_l11_remap) ) deallocate(l1_l11_remap)
     if ( allocated(mRM_runoff) ) deallocate(mRM_runoff)
     if ( allocated(domain_mrm) ) deallocate(domain_mrm)
     if ( allocated(L0_gaugeLoc) ) deallocate(L0_gaugeLoc)
     if ( allocated(L0_InflowGaugeLoc) ) deallocate(L0_InflowGaugeLoc)
     if ( allocated(L0_fAcc) ) deallocate(L0_fAcc)
     if ( allocated(L0_fDir) ) deallocate(L0_fDir)
     if ( allocated(L0_draSC) ) deallocate(L0_draSC)
@@ -458,10 +411,13 @@
     if ( allocated(LCyearId) ) deallocate(LCyearId)
     if ( allocated(mhmFileRestartIn) ) deallocate(mhmFileRestartIn)
     if ( allocated(mrmFileRestartIn) ) deallocate(mrmFileRestartIn)
 
     ! mo_common_run_variables
     call run_cfg%clean_up()
 
+    ! meteo handler clean up
+    call meteo_handler%clean_up()
+
   end subroutine deallocate_global_variables
 
 end module mo_clean_up
```

### Comparing `mhm-5.12.1.dev21/src/common/mo_common_MPI_tools.F90` & `mhm-5.13.0/src/common/mo_common_MPI_tools.F90`

 * *Files 7% similar despite different names*

```diff
@@ -1,22 +1,26 @@
 !> \file    mo_common_mpi_tools.f90
-!> \brief   tools for MPI communication that are mHM or mRM specific
+!> \brief   \copybrief mo_common_mpi_tools
 !> \details \copydetails mo_common_mpi_tools
 
 !> \brief   tools for MPI communication that are mHM or mRM specific
 !> \author  Maren Kaluza
 !> \author  Sebastian Mueller
 !> \date    2019-2021
 !> \details This module contains sending and receiving subroutines for
 !!          data that are specific for mHM or mRM
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_common
 MODULE mo_common_mpi_tools
 
-  use mo_kind, only : i4, dp
-
 #ifdef MPI
+  use mo_kind, only : i4, dp
+  use mo_message, only : message
+  use mo_string_utils, only : num2str
   use mo_common_variables, only: comm
   use mpi_f08
 #endif
 
   IMPLICIT NONE
 
   PRIVATE
@@ -77,15 +81,15 @@
     ! Initialize MPI
     call MPI_Init(ierror)
     call MPI_Comm_dup(MPI_COMM_WORLD, comm, ierror)
     ! find number of processes nproc
     call MPI_Comm_size(comm, nproc, ierror)
     ! find the number the process is referred to, called rank
     call MPI_Comm_rank(comm, rank, ierror)
-    write(*,*) 'MPI!, comm', rank, nproc
+    call message('MPI!, comm ', num2str(rank), num2str(nproc))
 #endif
 
   end subroutine mpi_tools_init
 
   !> \brief Finalize the MPI run of mHM.
   subroutine mpi_tools_finalize()
 
@@ -94,14 +98,14 @@
 #ifdef MPI
     integer             :: ierror
     integer(i4)         :: nproc, rank
 
     ! find number of processes nproc
     call MPI_Comm_size(comm, nproc, ierror)
     call MPI_Comm_rank(comm, rank, ierror)
-    write(*,*) 'MPI finished', rank, nproc
+    call message('MPI finished ', num2str(rank), num2str(nproc))
     call MPI_Finalize(ierror)
 #endif
 
   end subroutine mpi_tools_finalize
 
 END MODULE mo_common_mpi_tools
```

### Comparing `mhm-5.12.1.dev21/src/common/mo_common_datetime_type.f90` & `mhm-5.13.0/src/common/mo_common_datetime_type.f90`

 * *Files 14% similar despite different names*

```diff
@@ -1,22 +1,23 @@
 !> \file mo_common_datetime_type.f90
+!> \brief \copybrief mo_common_datetime_type
+!> \details \copydetails mo_common_datetime_type
 
-!< author: Maren Kaluza
-!< date: March 2019
-!< summary: type for date time information with an increment subroutine
-
-!< Contains a current day, month, year, hour matching newTime, aswell as
-!< previous day, month, year. Theses all get updated on increment
-!<
-!< also contains nTimestep, and tIndex_out for writing
-!<
-!< finally, contains iLAI and yId that are time dependent and updating routines
-!< for these, and a function returning a boolean for writeout, dependent on the
-!< timestep_model_input
-
+!> \brief type for date time information with an increment subroutine
+!> \details Contains a current day, month, year, hour matching newTime, aswell as
+!! previous day, month, year. Theses all get updated on increment
+!! also contains nTimestep, and tIndex_out for writing
+!! finally, contains iLAI and yId that are time dependent and updating routines
+!! for these, and a function returning a boolean for writeout, dependent on the
+!! timestep_model_input
+!> \author Maren Kaluza
+!> \date March 2019
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_common
 MODULE mo_common_datetime_type
   use mo_kind, only : i4, dp
 
   ! Written Maren Kaluza, March 2019
 
   IMPLICIT NONE
 
@@ -64,15 +65,15 @@
     ! function, returns boolean dependent on tIndex_out and is_new_{period}
     procedure :: writeout => datetimeinfo_writeout
   end type datetimeinfo
 
   contains
 
   subroutine datetimeinfo_init(this, iDomain)
-    use mo_common_mHM_mRM_variables, only : LCyearId, simPer, timeStep, nTstepDay
+    use mo_common_mHM_mRM_variables, only : LCyearId, simPer, nTstepDay
     use mo_julian, only : caldat
     class(datetimeinfo), intent(inout) :: this
     integer(i4),     intent(in)    :: iDomain
 
     ! calculate NtimeSteps for this basin
     this%nTimeSteps = (simPer(iDomain)%julEnd - simPer(iDomain)%julStart + 1) * nTstepDay
 
@@ -87,23 +88,23 @@
     ! initialize flags for period changes, they are true for first time step
     this%is_new_day   = .true.
     this%is_new_month = .true.
     this%is_new_year  = .true.
 
     ! initialize arrays and counters
     this%yId  = LCyearId(this%year, iDomain)
-    this%hour = -timestep
+    this%hour = 0
     this%iLAI = 0
 
     ! this has no relevance yet. it is only so the variables are initialized
     this%prev_day   = this%day
     this%prev_month = this%month
     this%prev_year  = this%year
 
-    this%tIndex_out = 1 ! tt if write out of warming period
+    this%tIndex_out = 0 ! tt if write out of warming period
   end subroutine datetimeinfo_init
 
   subroutine datetimeinfo_increment(this)
     use mo_julian, only : caldat, julday
     use mo_common_mHM_mRM_variables, only : timeStep
     class(datetimeinfo), intent(inout) :: this
 
@@ -114,17 +115,19 @@
     this%prev_year = this%year
     ! set the flags to false
     this%is_new_day   = .false.
     this%is_new_month = .false.
     this%is_new_year  = .false.
 
     ! increment of timestep
-    this%hour = mod(this%hour + timestep, 24)
-    this%newTime = julday(this%day, this%month, this%year)&
-            + real(this%hour + timestep, dp) / 24._dp
+    this%hour = this%hour + timestep
+    this%newTime = julday(this%day, this%month, this%year) + real(this%hour, dp) / 24._dp
+    ! get correct hour for current day
+    this%hour = mod(this%hour, 24)
+
     ! calculate new year, month and day
     call caldat(int(this%newTime), yy = this%year, mm = this%month, dd = this%day)
     ! update the flags
     if (this%prev_day   /= this%day) this%is_new_day = .true.
     if (this%prev_month /= this%month) this%is_new_month = .true.
     if (this%prev_year  /= this%year) this%is_new_year = .true.
   end subroutine datetimeinfo_increment
```

### Comparing `mhm-5.12.1.dev21/src/common/mo_common_file.f90` & `mhm-5.13.0/src/common/mo_common_file.f90`

 * *Files 15% similar despite different names*

```diff
@@ -1,21 +1,21 @@
-!>       \file mo_common_file.f90
-
-!>       \brief Provides file names and units for mRM
-
-!>       \details Provides all filenames as well as all units used for the multiscale Routing Model mRM.
-
-!>       \authors Matthias Cuntz, Stephan Thober
-
-!>       \date Aug 2015
-
-! Modifications:
-! Robert Schweppe Jun 2018 - refactoring and reformatting
-
-
+!> \file mo_common_file.f90
+!> \brief \copybrief mo_common_file
+!> \details \copydetails mo_common_file
+
+!> \brief Provides file names and units for mRM
+!> \details Provides all filenames as well as all units used for the multiscale Routing Model mRM.
+!> \changelog
+!!  - Robert Schweppe Jun 2018
+!!    - refactoring and reformatting
+!> \authors Matthias Cuntz, Stephan Thober
+!> \date Aug 2015
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_common
 MODULE mo_common_file
 
   IMPLICIT NONE
   !> DEM input data file
   CHARACTER(len=*), PARAMETER :: file_dem                = 'dem.asc'                     ! DEM
   !> Unit for  DEM input data file
   INTEGER,          PARAMETER :: udem                    = 53                            !
```

### Comparing `mhm-5.12.1.dev21/src/common/mo_common_functions.f90` & `mhm-5.13.0/src/common/mo_common_functions.f90`

 * *Files 18% similar despite different names*

```diff
@@ -1,20 +1,21 @@
-!>       \file mo_common_functions.f90
-
-!>       \brief Provides small utility functions used by multiple parts of the code (mHM, mRM, MPR)
-
-!>       \details Provides the functions in_bound used to check global_parameter ranges
-
-!>       \authors Robert Schweppe
-
-!>       \date Dec 2017
-
-! Modifications:
-! Robert Schweppe Dec 2017 - refactoring
-
+!> \file mo_common_functions.f90
+!> \brief \copybrief mo_common_functions
+!> \details \copydetails mo_common_functions
+
+!> \brief Provides small utility functions used by multiple parts of the code (mHM, mRM, MPR)
+!> \details Provides the functions in_bound used to check global_parameter ranges
+!> \changelog
+!!  - Robert Schweppe Dec 2017
+!!    - refactoring
+!> \authors Robert Schweppe
+!> \date Dec 2017
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_common
 module mo_common_functions
   use mo_kind, only : dp
 
   IMPLICIT NONE
 
   PRIVATE
```

### Comparing `mhm-5.12.1.dev21/src/common/mo_common_read_config.F90` & `mhm-5.13.0/src/common/mo_common_read_config.F90`

 * *Files 8% similar despite different names*

```diff
@@ -1,75 +1,62 @@
-!>       \file mo_common_read_config.f90
-
-!>       \brief Reading of main model configurations.
-
-!>       \details This routine reads the configurations of namelists commonly used by mHM, mRM and MPR
-
-!>       \authors Matthias Zink
-
-!>       \date Dec 2012
-
-! Modifications:
-
+!> \file mo_common_read_config.f90
+!> \brief   \copybrief mo_common_read_config
+!> \details \copydetails mo_common_read_config
+
+!> \brief Reading of main model configurations.
+!> \details This routine reads the configurations of namelists commonly used by mHM, mRM and MPR
+!> \authors Matthias Zink
+!> \date Dec 2012
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_common
 MODULE mo_common_read_config
 
   USE mo_kind, ONLY : i4, dp
+  use mo_message, only: error_message
 
   IMPLICIT NONE
 
   PRIVATE
 
   PUBLIC :: common_read_config, set_land_cover_scenes_id
 
   ! ------------------------------------------------------------------
 
 CONTAINS
 
-  ! ------------------------------------------------------------------
-
-  !    NAME
-  !        common_read_config
-
-  !    PURPOSE
-  !>       \brief Read main configurations commonly used by mHM, mRM and MPR
-
-  !>       \details Read the main configurations commonly used by mHM, mRM and MPR, namely:
-  !>       project_description, directories_general, mainconfig, processSelection, LCover
-
-  !    INTENT(IN)
-  !>       \param[in] "character(*) :: file_namelist" name of file
-  !>       \param[in] "integer :: unamelist"          id of file
-
-  !    HISTORY
-  !>       \authors Matthias Zink
-
-  !>       \date Dec 2012
-
-  ! Modifications:
-  ! Robert Schweppe Dec  2018 - refactoring and restructuring
 
+  !> \brief Read main configurations commonly used by mHM, mRM and MPR
+  !> \details Read the main configurations commonly used by mHM, mRM and MPR, namely:
+  !! project_description, directories_general, mainconfig, processSelection, LCover
+  !> \changelog
+  !! - Robert Schweppe Dec  2018
+  !!   - refactoring and restructuring
+  !! - Sebastian Mller Mar 2023
+  !!   - added check_L0Domain
+  !> \authors Matthias Zink
+  !> \date Dec 2012
   subroutine common_read_config(file_namelist, unamelist)
 
     use mo_common_constants, only : maxNLcovers, maxNoDomains
     use mo_common_variables, only : Conventions, LC_year_end, LC_year_start, LCfilename, contact, &
                                     dirCommonFiles, dirConfigOut, dirLCover, dirMorpho, dirOut, &
                                     mhmFileRestartOut, mrmFileRestartOut, &
                                     fileLatLon, history, iFlag_cordinate_sys, mHM_details, domainMeta, nLcoverScene, &
                                     nProcesses, nuniqueL0Domains, processMatrix, project_details, resolutionHydrology, &
                                     setup_description, simulation_type, write_restart
-    use mo_message, only : message
     use mo_nml, only : close_nml, open_nml, position_nml
     use mo_string_utils, only : num2str
 
     implicit none
 
-    ! name of file
+    !> name of file
     character(*), intent(in) :: file_namelist
 
-    ! id of file
+    !> id of file
     integer, intent(in) :: unamelist
 
     ! Choosen process description number
     integer(i4), dimension(nProcesses) :: processCase
 
     character(256), dimension(maxNoDomains) :: dir_Morpho
 
@@ -137,19 +124,19 @@
     !===============================================================
     call position_nml('mainconfig', unamelist)
     read(unamelist, nml = mainconfig)
 
     call init_domain_variable(nDomains, read_opt_domain_data(1:nDomains), domainMeta)
 
     if (nDomains .GT. maxNoDomains) then
-      call message()
-      call message('***ERROR: Number of domains is resticted to ', trim(num2str(maxNoDomains)), '!')
-      stop 1
+      call error_message('***ERROR: Number of domains is resticted to ', trim(num2str(maxNoDomains)), '!')
     end if
 
+    call check_L0Domain(L0Domain, nDomains)
+
     ! allocate patharray sizes
     allocate(resolutionHydrology(domainMeta%nDomains))
     allocate(dirMorpho(domainMeta%nDomains))
     allocate(mhmFileRestartOut(domainMeta%nDomains))
     allocate(mrmFileRestartOut(domainMeta%nDomains))
     allocate(dirLCover(domainMeta%nDomains))
     allocate(dirOut(domainMeta%nDomains))
@@ -175,17 +162,15 @@
         end if
       end do
       if (addCounter) nuniqueL0Domains = nuniqueL0Domains + 1_i4
     end do
 
     ! check for possible options
     if(.NOT. (iFlag_cordinate_sys == 0 .OR. iFlag_cordinate_sys == 1)) then
-      call message()
-      call message('***ERROR: coordinate system for the model run should be 0 or 1')
-      stop 1
+      call error_message('***ERROR: coordinate system for the model run should be 0 or 1')
     end if
 
     !===============================================================
     ! Read land cover
     !===============================================================
     call position_nml('LCover', unamelist)
     read(unamelist, nml = LCover)
@@ -237,70 +222,46 @@
       domainMeta%doRouting(:) = .TRUE.
     end if
 
     call close_nml(unamelist)
 
   end subroutine common_read_config
 
-    ! ------------------------------------------------------------------
-
-  !    NAME
-  !        set_land_cover_scenes_id
-
-  !    PURPOSE
-  !>       \brief Read main configurations commonly used by mHM, mRM and MPR
-
-  !>       \details Read the main configurations commonly used by mHM, mRM and MPR, namely:
-  !>       project_description, directories_general, mainconfig, processSelection, LCover
-
-  !    INTENT(IN)
-  !>       \param[in] "type(period), dimension(:) :: sim_Per"
-
-  !    INTENT(INOUT)
-  !>       \param[inout] "integer(i4), dimension(:, :) :: LCyear_Id"
-  !>       \param[inout] "character(256), dimension(:) :: LCfilename"
-
-  !    HISTORY
-  !>       \authors Matthias Zink
-
-  !>       \date Dec 2012
-
-  ! Modifications:
-  ! Robert Schweppe Dec  2018 - refactoring and restructuring
 
+  !> \brief Set land cover scenes IDs
+  !> \changelog
+  !! - Robert Schweppe Dec  2018
+  !!   - refactoring and restructuring
+  !> \authors Matthias Zink
+  !> \date Dec 2012
   subroutine set_land_cover_scenes_id(sim_Per, LCyear_Id)
 
     use mo_common_constants, only : nodata_i4
-    use mo_common_variables, only : LC_year_end, LC_year_start, domainMeta, nLcoverScene, period
-    use mo_message, only : message
+    use mo_common_types, only: period
+    use mo_common_variables, only : LC_year_end, LC_year_start, domainMeta, nLcoverScene
     use mo_string_utils, only : num2str
 
     implicit none
 
-    type(period), dimension(:), intent(in) :: sim_Per
-
-    integer(i4), dimension(:, :), allocatable, intent(inout) :: LCyear_Id
+    type(period), dimension(:), intent(in) :: sim_Per !< simulation period
+    integer(i4), dimension(:, :), allocatable, intent(inout) :: LCyear_Id !< land cover year ID
 
     integer(i4) :: ii, iDomain
 
 
     ! countercheck if land cover covers simulation period
     if (LC_year_start(1) .GT. minval(sim_Per(1 : domainMeta%nDomains)%yStart)) then
-      call message()
-      call message('***ERROR: Land cover for warming period is missing!')
-      call message('   SimStart   : ', trim(num2str(minval(sim_Per(1 : domainMeta%nDomains)%yStart))))
-      call message('   LCoverStart: ', trim(num2str(LC_year_start(1))))
-      stop 1
+      call error_message('***ERROR: Land cover for warming period is missing!', raise=.false.)
+      call error_message('   SimStart   : ', trim(num2str(minval(sim_Per(1 : domainMeta%nDomains)%yStart))), raise=.false.)
+      call error_message('   LCoverStart: ', trim(num2str(LC_year_start(1))))
     end if
     if (LC_year_end(nLCoverScene) .LT. maxval(sim_Per(1 : domainMeta%nDomains)%yEnd)) then
-      call message()
-      call message('***ERROR: Land cover period shorter than modelling period!')
-      call message('   SimEnd   : ', trim(num2str(maxval(sim_Per(1 : domainMeta%nDomains)%yEnd))))
-      call message('   LCoverEnd: ', trim(num2str(LC_year_end(nLCoverScene))))
-      stop 1
+      call error_message('***ERROR: Land cover period shorter than modelling period!', raise=.false.)
+      call error_message('   SimEnd   : ', trim(num2str(maxval(sim_Per(1 : domainMeta%nDomains)%yEnd))), raise=.false.)
+      call error_message('   LCoverEnd: ', trim(num2str(LC_year_end(nLCoverScene))))
     end if
     !
     allocate(LCyear_Id(minval(sim_Per(1 : domainMeta%nDomains)%yStart) : maxval(sim_Per(1 : domainMeta%nDomains)%yEnd), &
                    domainMeta%nDomains))
     LCyear_Id = nodata_i4
     do iDomain = 1, domainMeta%nDomains
       do ii = 1, nLCoverScene
@@ -327,62 +288,63 @@
         end if
       end do
     end do
 
 
   end subroutine set_land_cover_scenes_id
 
-!< author: Maren Kaluza
-!< date: September 2019
-!< summary: Initialization of the domain variable for all domain loops and if activated for parallelization
-
-!< In case of MPI parallelization domainMeta%overAllNumberOfDomains is a
-!< variable where the number of domains from the namelist is stored. By this
-!< every process knows the total number of domains. Then, in a loop the
-!< domains are distributed onto the processes. There is a master process
-!< and several subprocesses. The master process only reads the confings in the
-!< mHM driver.
-!<
-!< The subprocesses get a number of domains. domainMeta%nDomain refers
-!< to the number of domains assigned to a specific process. It is a local
-!< variable and therefore has a different value for each process.
-!<
-!< In case more domains are there than processes, currently the domains
-!< are distributed round robin, i.e. like cards in a card game.
-!<
-!< In case less domains than processes exist, all remaining processes
-!< are assigned to the routing domains round robin. In that case the
-!< local communicator is of interest: It is a group of processes assigned
-!< to a routing domain again with a master process
-!< (domainMeta%isMasterInComLocal) and subprocesses. This communicator can
-!< in future be passed to the routing parallelization.
+
+  !> \brief Initialization of the domain variables
+  !> \details Initialization of the domain variable for all domain loops and if activated for parallelization
+  !! In case of MPI parallelization domainMeta%overAllNumberOfDomains is a
+  !! variable where the number of domains from the namelist is stored. By this
+  !! every process knows the total number of domains. Then, in a loop the
+  !! domains are distributed onto the processes. There is a master process
+  !! and several subprocesses. The master process only reads the confings in the
+  !! mHM driver.
+  !!
+  !! The subprocesses get a number of domains. domainMeta%nDomain refers
+  !! to the number of domains assigned to a specific process. It is a local
+  !! variable and therefore has a different value for each process.
+  !!
+  !! In case more domains are there than processes, currently the domains
+  !! are distributed round robin, i.e. like cards in a card game.
+  !!
+  !! In case less domains than processes exist, all remaining processes
+  !! are assigned to the routing domains round robin. In that case the
+  !! local communicator is of interest: It is a group of processes assigned
+  !! to a routing domain again with a master process
+  !! (domainMeta%isMasterInComLocal) and subprocesses. This communicator can
+  !! in future be passed to the routing parallelization.
+  !> \author Maren Kaluza
+  !> \date Sep 2019
   subroutine init_domain_variable(nDomains, optiData, domainMeta)
-    use mo_common_variables, only: domain_meta
+    use mo_common_types, only: domain_meta
 #ifdef MPI
     use mo_common_variables, only: comm
     use mpi_f08
 #endif
-    integer(i4),       intent(in)    :: nDomains
-    integer(i4), dimension(:), intent(in) :: optiData
-    type(domain_meta), intent(inout) :: domainMeta
+    integer(i4),       intent(in)    :: nDomains !< number of domains
+    integer(i4), dimension(:), intent(in) :: optiData !< optimization data
+    type(domain_meta), intent(inout) :: domainMeta !< domain meta info
 
     integer             :: ierror
     integer(i4)         :: nproc
     integer(i4)         :: rank
     integer(i4)         :: iDomain
     integer(i4)         :: colDomain, colMasters
 
     domainMeta%overallNumberOfDomains = nDomains
 #ifdef MPI
     ! find number of processes nproc
     call MPI_Comm_size(comm, nproc, ierror)
     ! find the number the process is referred to, called rank
     call MPI_Comm_rank(comm, rank, ierror)
     if (nproc < 2) then
-      stop 'at least 2 processes are required'
+      call error_message('at least 2 processes are required')
     end if
     ! if there are more processes than domains
     if (nproc > domainMeta%overallNumberOfDomains + 1) then
       domainMeta%nDomains = 0
       ! master reads only metadata of all domains
       if (rank == 0) then
         call init_domain_variable_for_master(domainMeta, colMasters, colDomain)
@@ -429,15 +391,15 @@
     end do
 #endif
 
   end subroutine init_domain_variable
 
 #ifdef MPI
   subroutine init_domain_variable_for_master(domainMeta, colMasters, colDomain)
-    use mo_common_variables, only: domain_meta
+    use mo_common_types, only: domain_meta
     type(domain_meta), intent(inout) :: domainMeta
     integer(i4),       intent(out)   :: colMasters
     integer(i4),       intent(out)   :: colDomain
     !local
     integer(i4) :: iDomain
 
     domainMeta%nDomains = domainMeta%overallNumberOfDomains
@@ -447,17 +409,16 @@
     end do
     colMasters = 1
     colDomain = 0
     domainMeta%isMasterInComLocal = .true.
 
   end subroutine init_domain_variable_for_master
 
-
   subroutine distributeDomainsRoundRobin(nproc, rank, domainMeta)
-    use mo_common_variables, only: domain_meta
+    use mo_common_types, only: domain_meta
     integer(i4),       intent(in)    :: nproc
     integer(i4),       intent(in)    :: rank
     type(domain_meta), intent(inout) :: domainMeta
 
     integer(i4) :: iDomain, iProcDomain
 
     do iDomain = 1 , domainMeta%overallNumberOfDomains
@@ -473,15 +434,15 @@
         domainMeta%indices(iProcDomain) = iDomain
       end if
     end do
   end subroutine distributeDomainsRoundRobin
 
   subroutine distribute_processes_to_domains_according_to_role(optiData, rank, &
                                                domainMeta, colMasters, colDomain)
-    use mo_common_variables, only: domain_meta
+    use mo_common_types, only: domain_meta
     integer(i4), dimension(:), intent(in)    :: optiData
     integer(i4),               intent(in)    :: rank
     type(domain_meta),         intent(inout) :: domainMeta
     integer(i4),               intent(out)   :: colMasters
     integer(i4),               intent(out)   :: colDomain
 
     ! local
@@ -525,8 +486,45 @@
       ! or data corresponding to the master process
       domainMeta%indices(1) = 1
     end if
     deallocate(treeDomainList)
   end subroutine
 #endif
 
+  ! \brief check the L0Domain variable from the namelist
+  !> \authors Sebastian Mller
+  !> \date Mar 2023
+  subroutine check_L0Domain(L0Domain, nDomains)
+    use mo_common_constants, only : maxNoDomains
+    use mo_string_utils, only : num2str
+
+    integer(i4), dimension(maxNoDomains), intent(in) ::L0Domain !< given L0Domain variable
+    integer(i4), intent(in) :: nDomains !< number of domains
+
+    integer(i4) :: i
+
+    do i = 1, nDomains
+      if (L0Domain(i) < 0) call error_message( &
+        "L0Domain values need to be positive: ", &
+        "L0Domain(", trim(adjustl(num2str(i))), ") = ", trim(adjustl(num2str(L0Domain(i)))))
+      if (L0Domain(i) > i) call error_message( &
+        "L0Domain values need to be less or equal to the domain index: ", &
+        "L0Domain(", trim(adjustl(num2str(i))), ") = ", trim(adjustl(num2str(L0Domain(i)))))
+      ! check for increasing values
+      if (i > 1) then
+        if (L0Domain(i) < L0Domain(i-1)) call error_message( &
+          "L0Domain values need to be increasing: ", &
+          "L0Domain(", trim(adjustl(num2str(i-1))), ") = ", trim(adjustl(num2str(L0Domain(i-1)))), &
+          ", L0Domain(", trim(adjustl(num2str(i))), ") = ", trim(adjustl(num2str(L0Domain(i)))))
+      end if
+      ! if lower, check that the reference domain uses its own L0Data
+      if (L0Domain(i) < i) then
+        if (L0Domain(L0Domain(i)) /= L0Domain(i)) call error_message( &
+          "L0Domain values should be taken from a domain with its own L0 data: ", &
+          "L0Domain(", trim(adjustl(num2str(i))), ") = ", trim(adjustl(num2str(L0Domain(i)))), &
+          ", L0Domain(", trim(adjustl(num2str(L0Domain(i)))), ") = ", trim(adjustl(num2str(L0Domain(L0Domain(i))))))
+      end if
+    end do
+
+  end subroutine check_L0Domain
+
 END MODULE mo_common_read_config
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `mhm-5.12.1.dev21/src/common/mo_common_read_data.f90` & `mhm-5.13.0/src/common/mo_common_read_data.f90`

 * *Files 4% similar despite different names*

```diff
@@ -1,21 +1,21 @@
-!>       \file mo_common_read_data.f90
-
-!>       \brief TODO: add description
-
-!>       \details TODO: add description
-
-!>       \authors Robert Schweppe
-
-!>       \date Jun 2018
-
-! Modifications:
-
+!> \file mo_common_read_data.f90
+!> \brief   \copybrief mo_common_read_data
+!> \details \copydetails mo_common_read_data
+
+!> \brief Common reading routines
+!> \details Routines to read the DEM and landcover files.
+!> \authors Robert Schweppe
+!> \date Jun 2018
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_common
 module mo_common_read_data
   USE mo_kind, ONLY : i4, dp
+  use mo_message, only: message, error_message
 
   IMPLICIT NONE
 
   PRIVATE
 
   PUBLIC :: read_dem, read_lcover
 
@@ -39,18 +39,18 @@
   ! Modifications:
 
   subroutine read_dem
 
     use mo_append, only : append
     use mo_common_constants, only : nodata_dp
     use mo_common_file, only : file_dem, udem
-    use mo_common_variables, only : Grid,  L0_elev, dirMorpho, level0, domainMeta, &
+    use mo_common_types, only: Grid
+    use mo_common_variables, only : L0_elev, dirMorpho, level0, domainMeta, &
                                     resolutionHydrology
     use mo_grid, only : set_domain_indices
-    use mo_message, only : message
     use mo_read_spatial_data, only : read_header_ascii, read_spatial_data_ascii
     use mo_string_utils, only : num2str
 
     implicit none
 
     ! loop variables
     integer(i4) :: domainID, iDomain
@@ -94,18 +94,16 @@
       fName = trim(adjustl(dirMorpho(iDomain))) // trim(adjustl(file_dem))
       call read_header_ascii(trim(fName), udem, &
               level0_iDomain%nrows, level0_iDomain%ncols, level0_iDomain%xllcorner, &
               level0_iDomain%yllcorner, level0_iDomain%cellsize, level0_iDomain%nodata_value)
 
       ! check for L0 and L1 scale consistency
       if(resolutionHydrology(iDomain) .LT. level0_iDomain%cellsize) then
-        call message()
-        call message('***ERROR: resolutionHydrology (L1) should be smaller than the input data resolution (L0)')
-        call message('          check set-up (in mhm.nml) for domain: ', trim(adjustl(num2str(domainID))), ' ...')
-        stop
+        call error_message('***ERROR: resolutionHydrology (L1) should be smaller than the input data resolution (L0)', raise=.false.)
+        call error_message('          check set-up (in mhm.nml) for domain: ', trim(adjustl(num2str(domainID))), ' ...')
       end if
 
       ! DEM + overall mask creation
       fName = trim(adjustl(dirMorpho(iDomain))) // trim(adjustl(file_dem))
       call read_spatial_data_ascii(trim(fName), udem, &
               level0_iDomain%nrows, level0_iDomain%ncols, level0_iDomain%xllcorner, &
               level0_iDomain%yllcorner, level0_iDomain%cellsize, data_dp_2d, level0_iDomain%mask)
@@ -141,16 +139,16 @@
   ! Modifications:
 
   subroutine read_lcover
 
     use mo_append, only : append, paste
     use mo_common_constants, only : nodata_i4
     use mo_common_file, only : ulcoverclass
-    use mo_common_variables, only : Grid, L0_LCover, LCfilename, dirLCover, level0, domainMeta, nLCoverScene
-    use mo_message, only : message
+    use mo_common_types, only: Grid
+    use mo_common_variables, only : L0_LCover, LCfilename, dirLCover, level0, domainMeta, nLCoverScene
     use mo_read_spatial_data, only : read_spatial_data_ascii
     use mo_string_utils, only : num2str
 
     implicit none
 
     ! loop variables
     integer(i4) :: domainID, iDomain, iVar
```

### Comparing `mhm-5.12.1.dev21/src/common/mo_common_run_variables.f90` & `mhm-5.13.0/src/common/mo_common_run_variables.f90`

 * *Files 16% similar despite different names*

```diff
@@ -1,45 +1,51 @@
 !> \file mo_common_run_variables.f90
-!> \copydoc mo_common_run_variables
+!> \brief \copybrief mo_common_run_variables
+!> \details \copydetails mo_common_run_variables
 
 !> \brief Provides structures needed by mhm_eval to store current run config.
 !> \author Sebastian Mueller
 !> \date Jan 2022
 !> \version 0.1
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_common
 module mo_common_run_variables
 
   use mo_kind, only : i4, dp
   use mo_common_datetime_type, only : datetimeinfo
-  use mo_write_fluxes_states, only : OutputDataset
+  use mo_nc_output, only : OutputDataset
 
   implicit none
 
   !> \class   run_cfg_t
   !> \brief   This is a container to hold all information while running mHM.
   type run_cfg_t
     !> time step counter
     integer(i4) :: time_step
     !> currently selected domain
     integer(i4) :: selected_domain
     !> number of domains simulated in this mhm_eval run. Depends on opti_function
     integer(i4) :: nDomains
-    !> flag wether forcings are given at hourly timestep
-    logical :: is_hourly_forcing
     !> output runoff
     logical :: output_runoff = .false.
     !> output BFI
     logical :: output_BFI = .false.
     !> currently used parameter set
     real(dp), dimension(:), allocatable :: parameterset
     !> selected domains
     integer(i4), dimension(:), allocatable :: domain_indices
     !> fraction of NOT sealed area
     real(dp), dimension(:, :, :), allocatable :: L1_fNotSealed
-    !> output NetCDF object
-    type(OutputDataset) :: nc
+    !> output mHM NetCDF object
+    type(OutputDataset) :: nc_mhm
+    !> output mRM NetCDF object
+    type(OutputDataset) :: nc_mrm
+    !> output groundwater NetCDF object
+    type(OutputDataset) :: nc_gw
     !> No. of cells at level 1 for current Domain
     integer(i4) :: nCells
     !> start and end index at level 1 for current Domain
     integer(i4) :: s1, e1
     !> meteorological time step for process 5 (PET)
     integer(i4), dimension(6) :: iMeteo_p5
     !> process 5: start and end index of vectors
```

### Comparing `mhm-5.12.1.dev21/src/common/mo_common_variables.F90` & `mhm-5.13.0/src/meteo/mo_meteo_spatial_tools.f90`

 * *Files 24% similar despite different names*

```diff
@@ -1,217 +1,447 @@
-!>       \file mo_common_variables.f90
+!> \file mo_meteo_spatial_tools.f90
+!> \brief \copybrief mo_meteo_spatial_tools
+!> \details \copydetails mo_meteo_spatial_tools
+
+!> \brief Spatial aggegation or disaggregation of meteorological input data.
+!> \details This module contains two subroutines to upscale and downscale, respectively,
+!! the level-2 meterological inputs to a required Level-1 hydrological spatial resolution.
+!> \authors Rohini Kumar
+!> \date Jan 2013
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_meteo
+MODULE mo_meteo_spatial_tools
 
-!>       \brief Provides structures needed by mHM, mRM and/or mpr.
+  ! This module provides routines for spatial aggegation or disaggregation of meteorological input data.
 
-!>       \details Provides the global structure period that is used
-!>       by both mHM and mRM.
+  USE mo_kind, ONLY : i4, dp
 
-!>       \authors Stephan Thober
+  IMPLICIT NONE
 
-!>       \date Sep 2015
-
-! Modifications:
-! Stephan Thober  Nov 2016 - moved processdescription from mo_global_variables to here
-! Robert Schweppe Dec 2017 - merged more duplicated variables from mhm and mrm global variables
-! Robert Schweppe Jun 2018 - refactoring and reformatting
-
-
-module mo_common_variables
-
-  use mo_kind, only : i4, i8, dp
-#ifdef MPI
-  USE mpi_f08
-#endif
-  implicit none
-
-  integer(i4) :: itimer           ! Current timer number
-
-  ! -------------------------------------------------------------------
-  ! PROJECT DESCRIPTION for the NETCDF output file
-  ! -------------------------------------------------------------------
-  character(1024), public :: project_details            ! project including funding instituion., PI, etc.
-  character(1024), public :: setup_description          ! any specific description of simulation
-  character(1024), public :: simulation_type            ! e.g. seasonal forecast, climate projection, ...
-  character(256), public :: Conventions                ! convention used for dataset
-  character(1024), public :: contact                    ! contact details, incl. PI name
-  character(1024), public :: mHM_details                ! developing institution, specific mHM revision
-  character(1024), public :: history                    ! details on version/creation date
-
-  ! -------------------------------------------------------------------
-  ! INPUT variables for configuration of main part
-  ! -------------------------------------------------------------------
-  integer(i4), public :: iFlag_cordinate_sys        ! options model for the run cordinate system
-  real(dp), dimension(:), allocatable, public :: resolutionHydrology        ! [m or degree] resolution of hydrology - Level 1
-  integer(i4), dimension(:), allocatable, public :: L0_Domain
-  logical, public :: write_restart              ! flag
+  PUBLIC :: spatial_aggregation      ! Spatial aggregation or upscaling
+  PUBLIC :: spatial_disaggregation   ! Spatial disaggregation or downscaling
+
+
+  ! ------------------------------------------------------------------
+
+  !    NAME
+  !        spatial_aggregation
+
+  !    PURPOSE
+  !>       \brief Spatial aggregation of meterological variables
+
+  !>       \details Aggregate (or upscale) the given level-2 meteorological data to the
+  !>       required level-1 spatial resolution for the mHM run.
+
+  !    HISTORY
+  !>       \authors Rohini Kumar
+
+  !>       \date Jan 2013
+
+  ! Modifications:
+  ! Rohini Kumar Nov 2013 - data1 changed from intent(inout) to intent(out)
+  ! RK, MZ, DS   May 2014 - added mask2
+  ! Robert Schweppe Jun 2018 - refactoring and reformatting
+
+
+  INTERFACE spatial_aggregation
+    MODULE PROCEDURE spatial_aggregation_3d, spatial_aggregation_4d
+  END INTERFACE spatial_aggregation
+
+  ! ------------------------------------------------------------------
+
+  !    NAME
+  !        spatial_disaggregation
+
+  !    PURPOSE
+  !>       \brief Spatial disaggregation of meterological variables
+
+  !>       \details Disaggregate (or downscale) the given level-2 meteorological data to the
+  !>       required level-1 spatial resolution for the mHM run.
+
+  !    INTENT(IN)
+  !>       \param[in] "real(dp), dimension(:, :, :) :: data2" Level-2 data
+  !>       \param[in] "real(dp) :: cellsize2"                 Level-2 resolution
+  !>       \param[in] "real(dp) :: cellsize1"                 Level-1 resolution
+  !>       \param[in] "logical, dimension(:, :) :: mask1"     Level-1 mask
+  !>       \param[in] "logical, dimension(:, :) :: mask2"     Level-2 mask
+
+  !    INTENT(OUT)
+  !>       \param[out] "real(dp), dimension(:, :, :) :: data1" Level-1 data
+
+  !    HISTORY
+  !>       \authors Rohini Kumar
+
+  !>       \date Jan 2013
+
+  ! Modifications:
+  ! Rohini Kumar Nov 2013 - data1 changed from intent(inout) to intent(out)
+  ! RK, MZ, DS   May 2014 - added mask2
+
+
+  INTERFACE spatial_disaggregation
+    MODULE PROCEDURE spatial_disaggregation_3d, spatial_disaggregation_4d
+  end INTERFACE spatial_disaggregation
 
   ! ------------------------------------------------------------------
-  ! DIRECTORIES
+
+  PRIVATE
+
   ! ------------------------------------------------------------------
-  ! has the dimension of nDomains
-  character(256), dimension(:), allocatable, public :: mhmFileRestartOut ! Directory where output of restart is written
-  character(256), dimension(:), allocatable, public :: mrmFileRestartOut ! Directory where output of restart is written
-  character(256), public :: dirConfigOut
-  character(256), public :: dirCommonFiles ! directory where common input files should be located
-  character(256), dimension(:), allocatable, public :: dirMorpho ! Directory where morphological files are located
-  character(256), dimension(:), allocatable, public :: dirLCover ! Directory where land cover files are located
-  character(256), dimension(:), allocatable, public :: dirOut ! Directory where output is written to
-  character(256), dimension(:), allocatable, public :: fileLatLon ! Directory where the Lat Lon Files are located
-
-  ! -------------------------------------------------------------------
-  ! PERIOD description
-  ! -------------------------------------------------------------------
-  type period
-    integer(i4) :: dStart      ! first day
-    integer(i4) :: mStart      ! first month
-    integer(i4) :: yStart      ! first year
-    integer(i4) :: dEnd        ! last  day
-    integer(i4) :: mEnd        ! last  month
-    integer(i4) :: yEnd        ! last  year
-    integer(i4) :: julStart    ! first julian day
-    integer(i4) :: julEnd      ! last  julian day
-    integer(i4) :: nObs        ! total number of observations
-  end type period
-
-  ! -------------------------------------------------------------------
-  ! GRID description
-  ! -------------------------------------------------------------------
-  type Grid
-    ! general domain information
-    integer(i4) :: ncols     ! Number of columns
-    integer(i4) :: nrows     ! Number of rows
-    integer(i4) :: nCells    ! Number of cells in mask
-    real(dp) :: xllcorner    ! x coordinate of the lowerleft corner
-    real(dp) :: yllcorner    ! y coordinate of the lowerleft corner
-    real(dp) :: cellsize     ! Cellsize x = cellsize y
-    real(dp) :: nodata_value ! Code to define the mask
-    real(dp), dimension(:, :), allocatable :: x  ! 2d longitude array (unmasked version is needed for output anyway)
-    real(dp), dimension(:, :), allocatable :: y  ! 2d latitude  array (unmasked version is needed for output anyway)
-    logical, dimension(:, :), allocatable :: mask  ! the mask for valid cells in the original grid (nrows*ncols)
-    ! for referencing values in the nValidCells vector
-    integer(i4) :: iStart          ! Starting cell index of a given domain
-    integer(i4) :: iEnd            ! Ending cell index of a given domain
-    ! dimension(nCells, (x,y) )
-    integer(i4), dimension(:, :), allocatable :: CellCoor  ! this is only used for mRM
-    real(dp), dimension(:), allocatable :: CellArea  ! area of the cell in sq m
-    integer(i4), dimension(:), allocatable :: Id
-
-  end type Grid
-
-  type(Grid), dimension(:), target, allocatable, public :: level0 ! grid information at morphological level (e.g., dem, fDir)
-  type(Grid), dimension(:), target, allocatable, public :: level1 ! grid information at hydrologic level
-
-  type GridRemapper
-    type(Grid), pointer :: high_res_grid
-    type(Grid), pointer :: low_res_grid
-
-    ! dimension nCells
-    integer(i4), dimension(:), allocatable :: lower_bound  ! 1d index of lower side subgrid
-    integer(i4), dimension(:), allocatable :: upper_bound  ! 1d index of upper side subgrid
-    integer(i4), dimension(:), allocatable :: left_bound  ! 1d index of left side subgrid
-    integer(i4), dimension(:), allocatable :: right_bound  ! 1d index of right side subgrid
-    integer(i4), dimension(:), allocatable :: n_subcells   ! 1d numberof valid subgrid cells
-    integer(i4), dimension(:, :), allocatable :: lowres_id_on_highres   ! 2d index array of lowres id
-
-  end type GridRemapper
-
-  type(GridRemapper), dimension(:), allocatable, public :: l0_l1_remap  ! grid information at morphological level (e.g., dem, fDir)
-
-  ! -------------------------------------------------------------------
-  ! L0 DOMAIN description -> <only domain>
-  ! -------------------------------------------------------------------
-  ! dim1 = number grid cells
-  ! input data - morphological variables
-  real(dp), public, dimension(:), allocatable :: L0_elev    ! [m]      Elevation (sinks removed)
-  !          target variable for coupling to mRM
-  integer(i4), public, dimension(:, :), allocatable :: L0_LCover      ! Classic mHM landcover class (upto 3 classes)
-  !                                                                          ! dim1=number grid cells, dim2=Number of land cover scenes
-  !                                                                          ! target variable for coupling to mRM
-
-#ifdef MPI
-  ! -------------------------------------------------------------------
-  ! MPI variables
-  type(MPI_Comm)      :: comm                ! MPI communicator
-#endif
-  ! -------------------------------------------------------------------
-  !
-  ! -------------------------------------------------------------------
-  ! DOMAIN general description
-  ! -------------------------------------------------------------------
-  type domain_meta
-    integer(i4)                            :: nDomains
-    integer(i4)                            :: overallNumberOfDomains  ! Number of domains for multi-domain optimization
-    integer(i4), dimension(:), allocatable :: indices
-    integer(i4), dimension(:), allocatable :: L0DataFrom
-    ! optidata saves for each domain which optional data is assigned to it
-    ! (0) default: the program decides. If you are confused, choose 0
-    ! (1) runoff
-    ! (2) sm
-    ! (3) tws
-    ! (4) neutons
-    ! (5) et
-    ! (6) et & tws
-    integer(i4), dimension(:), allocatable :: optidata
-    logical,     dimension(:), allocatable :: doRouting
-#ifdef MPI
-    logical                                :: isMasterInComLocal  ! true if the process is master proc in comLocal
-    type(MPI_Comm)                         :: comMaster ! the communicater the domains are using to send messages to each other
-                                                        ! here are all processes wich have rank 0 in comLocal
-    type(MPI_Comm)                         :: comLocal  ! the communicater the domain internal communication takes place
-#endif
-  end type domain_meta
-
-  type(domain_meta), public :: domainMeta
-  integer(i4), public :: nuniqueL0Domains ! Number of unique domains for L0
-
-  ! -----------------------------------------------------------------
-  ! LAND COVER DATA
-  ! -----------------------------------------------------------------
-  ! Land cover information
-  integer(i4), public :: nLCoverScene        ! Number of land cover scene (lcs)
-  character(256), dimension(:), allocatable, public :: LCfilename          ! file names for the different lcs
-  integer(i4), dimension(:), allocatable, public :: LC_year_start       ! vector of start years for lcs
-  integer(i4), dimension(:), allocatable, public :: LC_year_end         ! vector of end years for lcs
-
-  ! -------------------------------------------------------------------
-  ! PROCESSES description
-  ! -------------------------------------------------------------------
-  integer(i4), parameter, public :: nProcesses = 11 ! Number of possible processes to consider
-  !                                                                !   process 1 :: interception
-  !                                                                !   process 2 :: snow
-  !                                                                !   process 3 :: soilmoisture
-  !                                                                !   process 4 :: sealed area direct runoff
-  !                                                                !   process 5 :: potential evapotranspiration
-  !                                                                !   process 6 :: interflow
-  !                                                                !   process 7 :: percolation
-  !                                                                !   process 8 :: routing
-  !                                                                !   process 9 :: baseflow
-  !                                                                !   process 10:: neutrons
-  !                                                                !   process 11:: river temperature routing
-  integer(i4), dimension(nProcesses, 3), public :: processMatrix   ! Info about which process runs in which option and
-  !                                                                ! number of parameters necessary for this option
-  !                                                                !   col1: process_switch
-  !                                                                !   col2: no. of parameters
-  !                                                                !   col3: cum. no. of parameters
-
-  ! -------------------------------------------------------------------
-  ! PARAMETERS
-  ! -------------------------------------------------------------------
-  real(dp), dimension(:, :), allocatable, public, target :: global_parameters
-  !                                                               ! Matrix of global parameters (former: gamma)
-  !                                                               !   col1: min,  col2: max, col3: initial,
-  !                                                               !   col4: flag, col5: scaling
-  character(256), dimension(:), allocatable, public :: global_parameters_name
-  !                                                               ! Matrix of global parameters (former: gamma)
-  !                                                               !   col1: names
-  ! -------------------------------------------------------------------
-  ! ALMA convention
-  ! -------------------------------------------------------------------
-  ! TODO: this is currently used only be mRM, but could be useful for MPR and mHM also, ...
-  ! so it is already in common_variables
-  logical :: ALMA_convention ! flag for ALMA convention
-  !                          ! see http://www.lmd.jussieu.fr/~polcher/ALMA/convention_3.html
-  !                          ! .True.: ALMA convention is used for Input/Output
-  !                          ! .False.: default mHM units are used
-  !                          ! CAUTION: only Qall is considered at the moment
 
-end module mo_common_variables
+CONTAINS
+
+  subroutine spatial_aggregation_3d(data2, cellsize2, cellsize1, mask1, mask2, data1)
+
+    use mo_common_constants, only : nodata_dp
+
+    implicit none
+
+    ! Level-2 data
+    real(dp), dimension(:, :, :), intent(in) :: data2
+
+    ! Level-2 resolution
+    real(dp), intent(in) :: cellsize2
+
+    ! Level-1 resolution
+    real(dp), intent(in) :: cellsize1
+
+    ! Level-1 mask
+    logical, dimension(:, :), intent(in) :: mask1
+
+    ! Level-2 mask
+    logical, dimension(:, :), intent(in) :: mask2
+
+    ! Level-1 data
+    real(dp), dimension(:, :, :), allocatable, intent(out) :: data1
+
+    ! No. of rows and cols at Level-1
+    integer(i4) :: nr2, nc2
+
+    ! No. of rows and cols at Level-1
+    integer(i4) :: nr1, nc1
+
+    real(dp) :: cellFactor
+
+    integer(i4), dimension(:, :), allocatable :: nTCells
+
+    integer(i4) :: nTimeSteps
+
+    integer(i4) :: i, j, ic, jc, t
+
+
+    ! get number of rows and cols at level-2 from mask2
+    ! and the total time steps
+    nr2 = size(data2, 1)
+    nc2 = size(data2, 2)
+    nTimeSteps = size(data2, 3)
+
+    ! get number of rows and cols at level-1 from mask1
+    nr1 = size(mask1, 1)
+    nc1 = size(mask1, 2)
+
+    !-----------------------------------------------------------------------
+    ! Allocate and initalize nTCells which comprises
+    ! of number of L2 cells that belongs to a given L1 cell
+    ! NOTE:: 1) cell size of L1 > L2 (see CellFactor)
+    !        2) nTCells is estimated over the valid masked domain only
+    !-----------------------------------------------------------------------
+
+    ! cellFactor = level-1 resolution (hydro) / level-2 resolution (meteo)
+    cellFactor = cellsize1 / cellsize2
+
+    ! nTCells calculations
+    allocate(nTCells(nr1, nc1))
+    nTCells(:, :) = 0
+
+    do j = 1, nc2
+      jc = ceiling(real(j, dp) / cellFactor)
+      do i = 1, nr2
+        ic = ceiling(real(i, dp) / cellFactor)
+        if(.not. mask2(i, j)) cycle
+        nTCells(ic, jc) = nTcells(ic, jc) + 1
+      end do
+    end do
+
+
+    ! allocate and initalize L1_data
+    allocate(data1(nr1, nc1, nTimeSteps))
+    data1(:, :, :) = 0.0_dp
+
+    ! time loop
+    do t = 1, nTimeSteps
+
+      ! perform spatial aggregation
+      do j = 1, nc2
+        jc = ceiling(real(j, dp) / cellFactor)
+        do i = 1, nr2
+          ic = ceiling(real(i, dp) / cellFactor)
+
+          ! only in valid masked area
+          if(.not. mask2(i, j)) cycle
+          data1(ic, jc, t) = data1(ic, jc, t) + data2(i, j, t)
+
+        end do
+      end do
+
+      ! perform spatial average only over valid masked domain
+      ! out of the masked domain nTCells(:,:) = 0
+      where(mask1)
+        data1(:, :, t) = data1(:, :, t) / real(nTcells(:, :), dp)
+      elsewhere
+        data1(:, :, t) = nodata_dp
+      endwhere
+
+    end do
+
+    ! free space
+    deallocate(nTCells)
+
+  end subroutine spatial_aggregation_3d
+
+  subroutine spatial_aggregation_4d(data2, cellsize2, cellsize1, mask1, mask2, data1)
+
+    use mo_common_constants, only : nodata_dp
+
+    implicit none
+
+    ! Level-2 data
+    real(dp), dimension(:, :, :, :), intent(in) :: data2
+
+    ! Level-2 resolution
+    real(dp), intent(in) :: cellsize2
+
+    ! Level-1 resolution
+    real(dp), intent(in) :: cellsize1
+
+    ! Level-1 mask
+    logical, dimension(:, :), intent(in) :: mask1
+
+    ! Level-2 mask
+    logical, dimension(:, :), intent(in) :: mask2
+
+    ! Level-1 data
+    real(dp), dimension(:, :, :, :), allocatable, intent(out) :: data1
+
+    ! No. of rows and cols at Level-1
+    integer(i4) :: nr2, nc2
+
+    ! No. of rows and cols at Level-1
+    integer(i4) :: nr1, nc1
+
+    real(dp) :: cellFactor
+
+    integer(i4), dimension(:, :), allocatable :: nTCells
+
+    integer(i4) :: nMonths, nHours
+
+    integer(i4) :: i, j, ic, jc, t, h
+
+
+    ! get number of rows and cols at level-2 from mask2
+    ! and the total time steps
+    nr2 = size(data2, 1)
+    nc2 = size(data2, 2)
+    nMonths = size(data2, 3)
+    nHours = size(data2, 4)
+
+    ! get number of rows and cols at level-1 from mask1
+    nr1 = size(mask1, 1)
+    nc1 = size(mask1, 2)
+
+    !-----------------------------------------------------------------------
+    ! Allocate and initalize nTCells which comprises
+    ! of number of L2 cells that belongs to a given L1 cell
+    ! NOTE:: 1) cell size of L1 > L2 (see CellFactor)
+    !        2) nTCells is estimated over the valid masked domain only
+    !-----------------------------------------------------------------------
+
+    ! cellFactor = level-1 resolution (hydro) / level-2 resolution (meteo)
+    cellFactor = cellsize1 / cellsize2
+
+    ! nTCells calculations
+    allocate(nTCells(nr1, nc1))
+    nTCells(:, :) = 0
+
+    do j = 1, nc2
+      jc = ceiling(real(j, dp) / cellFactor)
+      do i = 1, nr2
+        ic = ceiling(real(i, dp) / cellFactor)
+        if(.not. mask2(i, j)) cycle
+        nTCells(ic, jc) = nTcells(ic, jc) + 1
+      end do
+    end do
+
+
+    ! allocate and initalize L1_data
+    allocate(data1(nr1, nc1, nMonths, nHours))
+    data1(:, :, :, :) = 0.0_dp
+
+    ! time loop
+    do t = 1, nMonths
+      do h = 1, nHours
+
+        ! perform spatial aggregation
+        do j = 1, nc2
+          jc = ceiling(real(j, dp) / cellFactor)
+          do i = 1, nr2
+            ic = ceiling(real(i, dp) / cellFactor)
+
+            ! only in valid masked area
+            if(.not. mask2(i, j)) cycle
+            data1(ic, jc, t, h) = data1(ic, jc, t, h) + data2(i, j, t, h)
+
+          end do
+        end do
+
+        ! perform spatial average only over valid masked domain
+        ! out of the masked domain nTCells(:,:) = 0
+        where(mask1)
+          data1(:, :, t, h) = data1(:, :, t, h) / real(nTcells(:, :), dp)
+        elsewhere
+          data1(:, :, t, h) = nodata_dp
+        endwhere
+
+      end do
+    end do
+
+    ! free space
+    deallocate(nTCells)
+
+  end subroutine spatial_aggregation_4d
+
+  subroutine spatial_disaggregation_3d(data2, cellsize2, cellsize1, mask1, mask2, data1)
+
+    use mo_common_constants, only : nodata_dp
+
+    implicit none
+
+    ! Level-2 data
+    real(dp), dimension(:, :, :), intent(in) :: data2
+
+    ! Level-2 resolution
+    real(dp), intent(in) :: cellsize2
+
+    ! Level-1 resolution
+    real(dp), intent(in) :: cellsize1
+
+    ! Level-1 mask
+    logical, dimension(:, :), intent(in) :: mask1
+
+    ! Level-2 mask
+    logical, dimension(:, :), intent(in) :: mask2
+
+    ! Level-1 data
+    real(dp), dimension(:, :, :), allocatable, intent(out) :: data1
+
+    ! No. of rows and cols at Level-1
+    integer(i4) :: nr1, nc1
+
+    real(dp) :: cellFactor
+
+    integer(i4) :: nTimeSteps
+
+    integer(i4) :: i, j, t, ic, jc
+
+
+    ! get number of rows and cols at level-2 from mask2
+    nr1 = size(mask1, 1)
+    nc1 = size(mask1, 2)
+
+    ! cellFactor = level-2 resolution (meteo) / level-1 resolution (hydro)
+    cellFactor = cellsize2 / cellsize1
+
+    ! total time steps
+    nTimeSteps = size(data2, 3)
+
+    ! allocate and initalize L1_data
+    allocate(data1(nr1, nc1, nTimeSteps))
+    data1(:, :, :) = nodata_dp
+
+    ! over the time loop
+    do t = 1, nTimeSteps
+
+      ! spatial disaggregation
+      do j = 1, nc1
+        jc = ceiling(real(j, dp) / cellFactor)
+        do i = 1, nr1
+          ic = ceiling(real(i, dp) / cellFactor)
+          ! only over the valid masked area
+          if(.not. mask2(ic, jc)) cycle
+          data1(i, j, t) = data2(ic, jc, t)
+        end do
+      end do
+
+    end do
+
+  end subroutine spatial_disaggregation_3d
+
+  subroutine spatial_disaggregation_4d(data2, cellsize2, cellsize1, mask1, mask2, data1)
+
+    use mo_common_constants, only : nodata_dp
+
+    implicit none
+
+    ! Level-2 data
+    real(dp), dimension(:, :, :, :), intent(in) :: data2
+
+    ! Level-2 resolution
+    real(dp), intent(in) :: cellsize2
+
+    ! Level-1 resolution
+    real(dp), intent(in) :: cellsize1
+
+    ! Level-1 mask
+    logical, dimension(:, :), intent(in) :: mask1
+
+    ! Level-2 mask
+    logical, dimension(:, :), intent(in) :: mask2
+
+    ! Level-1 data
+    real(dp), dimension(:, :, :, :), allocatable, intent(out) :: data1
+
+    ! No. of rows and cols at Level-1
+    integer(i4) :: nr1, nc1
+
+    real(dp) :: cellFactor
+
+    integer(i4) :: nMonths, nHours
+
+    integer(i4) :: i, j, t, ic, jc, h
+
+
+    ! get number of rows and cols at level-2 from mask2
+    nr1 = size(mask1, 1)
+    nc1 = size(mask1, 2)
+
+    ! cellFactor = level-2 resolution (meteo) / level-1 resolution (hydro)
+    cellFactor = cellsize2 / cellsize1
+
+    ! time axis
+    nMonths = size(data2, 3)
+    nHours = size(data2, 4)
+
+    ! allocate and initalize L1_data
+    allocate(data1(nr1, nc1, nMonths, nHours))
+    data1(:, :, :, :) = nodata_dp
+
+    ! over the time loop
+    do t = 1, nMonths
+      do h = 1, nHours
+
+        ! spatial disaggregation
+        do j = 1, nc1
+          jc = ceiling(real(j, dp) / cellFactor)
+          do i = 1, nr1
+            ic = ceiling(real(i, dp) / cellFactor)
+            ! only over the valid masked area
+            if(.not. mask2(ic, jc)) cycle
+            data1(i, j, t, h) = data2(ic, jc, t, h)
+          end do
+        end do
+      end do
+    end do
+
+  end subroutine spatial_disaggregation_4d
+
+END MODULE mo_meteo_spatial_tools
```

### Comparing `mhm-5.12.1.dev21/src/common/mo_grid.f90` & `mhm-5.13.0/src/common/mo_grid.f90`

 * *Files 3% similar despite different names*

```diff
@@ -1,19 +1,18 @@
-!>       \file mo_grid.f90
-
-!>       \brief TODO: add description
-
-!>       \details TODO: add description
-
-!>       \authors Robert Schweppe
-
-!>       \date Jun 2018
-
-! Modifications:
-
+!> \file mo_grid.f90
+!> \brief \copybrief mo_grid
+!> \details \copydetails mo_grid
+
+!> \brief gridding tools
+!> \details Common tools to deal with grids in mHM.
+!> \authors Robert Schweppe
+!> \date Jun 2018
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_common
 module mo_grid
   use mo_kind, only : dp, i4
 
   IMPLICIT NONE
 
   PRIVATE
 
@@ -55,15 +54,15 @@
 
   ! Modifications:
   ! Robert Schweppe Jun 2018 - refactoring and reformatting
 
   subroutine init_lowres_level(highres, target_resolution, lowres, highres_lowres_remap)
 
     use mo_common_constants, only : nodata_dp, nodata_i4
-    use mo_common_variables, only : Grid, GridRemapper
+    use mo_common_types, only : Grid, GridRemapper
 
     implicit none
 
     type(Grid), target, intent(in) :: highres
 
     real(dp), intent(in) :: target_resolution
 
@@ -200,15 +199,15 @@
   !>       \date Jun 2018
 
   ! Modifications:
   !        Stephan Thober, Aug 2019 - added optional indices for L0 data because L0 data can be shared among domains
 
   subroutine set_domain_indices(grids, indices)
 
-    use mo_common_variables, only : Grid
+    use mo_common_types, only: Grid
 
     implicit none
 
     type(Grid), intent(inout), dimension(:) :: grids
     integer(i4),   intent(in), dimension(:), optional :: indices
 
     integer(i4) :: iDomain
@@ -263,15 +262,16 @@
   ! Matthias Cuntz                 May 2014 - changed empirical distribution function so that doubles get the same value
   ! Matthias Zink & Matthias Cuntz Feb 2016 - code speed up due to reformulation of CDF calculation
   ! Rohini Kumar                   Mar 2016 - changes for handling multiple soil database options
   ! Robert Schweppe                Jun 2018 - refactoring and reformatting
 
   subroutine L0_grid_setup(new_grid)
 
-    use mo_common_variables, only : Grid, iFlag_cordinate_sys
+    use mo_common_types, only: Grid
+    use mo_common_variables, only : iFlag_cordinate_sys
     use mo_constants, only : RadiusEarth_dp, TWOPI_dp
 
     implicit none
 
     type(Grid), intent(inout) :: new_grid
 
     real(dp), dimension(:, :), allocatable :: areaCell_2D
@@ -365,15 +365,15 @@
   ! Stephan Thober Nov 2013 - removed fproj dependency
   ! David Schaefer Jun 2015 - refactored the former subroutine CoordSystem
   ! Robert Schweppe Jun 2018 - refactoring and reformatting
 
 
   subroutine mapCoordinates(level, y, x)
 
-    use mo_common_variables, only : Grid
+    use mo_common_types, only: Grid
 
     implicit none
 
     ! -> grid reference
     type(Grid), intent(in) :: level
 
     real(dp), intent(out), allocatable, dimension(:) :: x, y
@@ -428,15 +428,15 @@
   ! David Schaefer  Jun 2015 - refactored the former subroutine CoordSystem
   ! Stephan Thober  Sep 2015 - using mask to unpack coordinates
   ! Stephan Thober  Oct 2015 - writing full lat/lon again
   ! Robert Schweppe Jun 2018 - refactoring and reformatting
 
   subroutine geoCoordinates(level, lat, lon)
 
-    use mo_common_variables, only : Grid
+    use mo_common_types, only: Grid
 
     implicit none
 
     ! -> grid reference
     type(Grid), intent(in) :: level
 
     real(dp), intent(out), allocatable, dimension(:, :) :: lat, lon
@@ -485,15 +485,15 @@
   ! Modifications:
   ! R. Kumar        Sep 2013 - documentation added according to the template
   ! Robert Schweppe Jun 2018 - refactoring and reformatting
 
   subroutine calculate_grid_properties(nrowsIn, ncolsIn, xllcornerIn, yllcornerIn, cellsizeIn, aimingResolution, &
                                       nrowsOut, ncolsOut, xllcornerOut, yllcornerOut, cellsizeOut)
 
-    use mo_message, only : message
+    use mo_message, only : error_message
     use mo_string_utils, only : num2str
 
     implicit none
 
     ! no. of rows at an input level
     integer(i4), intent(in) :: nrowsIn
 
@@ -531,30 +531,28 @@
     integer(i4) :: rounded_int
 
 
     cellFactor = aimingResolution / cellsizeIn
     rounded = anint(cellFactor)
     rounded_int = nint(cellFactor)
 
-    if (abs(rounded - cellFactor) > 1.e-9_dp) then
-      call message()
-      call message('***ERROR: Two resolutions size do not confirm: ', &
-              trim(adjustl(num2str(nint(AimingResolution)))), &
-              trim(adjustl(num2str(nint(cellsizeIn)))))
-      stop 1
+    if (abs(rounded - cellFactor) > 1.e-7_dp) then
+      call error_message( &
+        '***ERROR: Two resolutions size do not confirm: ', &
+        trim(adjustl(num2str(nint(AimingResolution)))), &
+        trim(adjustl(num2str(nint(cellsizeIn)))))
     end if
 
-    cellsizeOut = cellsizeIn * rounded
+    cellsizeOut = aimingResolution
     ncolsOut = nint(real(ncolsIn, dp) / cellFactor)
     nrowsOut = nint(real(nrowsIn, dp) / cellFactor)
 
     ! if we rounded down, but now we would miss cells, add rows and/or cols
     if ( ncolsOut * rounded_int < ncolsIn ) ncolsOut = ncolsOut + 1_i4
     if ( nrowsOut * rounded_int < nrowsIn ) nrowsOut = nrowsOut + 1_i4
 
-    xllcornerOut = xllcornerIn + real(ncolsIn, dp) * cellsizeIn - real(ncolsOut, dp) * cellsizeOut
-    yllcornerOut = yllcornerIn + real(nrowsIn, dp) * cellsizeIn - real(nrowsOut, dp) * cellsizeOut
+    xllcornerOut = xllcornerIn + real(ncolsIn, dp) * aimingResolution / rounded - real(ncolsOut, dp) * cellsizeOut
+    yllcornerOut = yllcornerIn + real(nrowsIn, dp) * aimingResolution / rounded - real(nrowsOut, dp) * cellsizeOut
 
   end subroutine calculate_grid_properties
 
 end module mo_grid
-
```

### Comparing `mhm-5.12.1.dev21/src/common/mo_read_latlon.f90` & `mhm-5.13.0/src/common/mo_read_latlon.f90`

 * *Files 9% similar despite different names*

```diff
@@ -1,27 +1,23 @@
-!>       \file mo_read_latlon.f90
-
-!>       \brief reading latitude and longitude coordinates for each domain
-
-!>       \details TODO: add description
-
-!>       \authors Stephan Thober
-
-!>       \date Nov 2013
-
-! Modifications:
-
+!> \file mo_read_latlon.f90
+!> \brief \copybrief mo_read_latlon
+!> \details \copydetails mo_read_latlon
+
+!> \brief reading latitude and longitude coordinates for each domain
+!> \details This module provides routines for reading latitude and longitude coordinates from file.
+!> \authors Stephan Thober
+!> \date Nov 2013
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_common
 MODULE mo_read_latlon
 
-  ! This module provides routines for reading latitude and longitude coordinates
-  ! from file.
-
-  ! Written  Stephan Thober, Nov 2013
-
   USE mo_kind, ONLY : i4, dp
+  use mo_message, only: error_message
+  use mo_string_utils, only : num2str
 
   ! Of course
   IMPLICIT NONE
 
   PUBLIC :: read_latlon
 
   PRIVATE
@@ -60,18 +56,17 @@
   ! Stephan Thober, Oct 2015 - added L1_rect_latitude and L1_rect_longitude
   ! David Schaefer, May 2016 - removed ncread dependency
   ! Robert Schweppe, Mar 2018 - major rewrite
   ! Robert Schweppe Jun 2018 - refactoring and reformatting
 
   subroutine read_latlon(ii, lon_var_name, lat_var_name, level_name, level)
 
-    use mo_common_variables, only : Grid, fileLatLon
-    use mo_message, only : message
+    use mo_common_types, only: Grid
+    use mo_common_variables, only : fileLatLon
     use mo_netcdf, only : NcDataset, NcVariable
-    use mo_string_utils, only : num2str
 
     implicit none
 
     ! domain indexFile name of the domains must be xxx_latlon.nc, wherexxx is the domain id. Variable names in the netcdf
     ! filehave to be 'lat' for latitude and 'lon' for longitude.
     integer(i4), intent(in) :: ii
 
@@ -103,36 +98,34 @@
     ! READ LEVEL LATITUDE / LONGITUDE
     ! -------------------------------------------------------------------------
     var = nc%getVariable(trim(lat_var_name))
     call var%getData(dummy)
     ! consistency check
     if ((size(dummy, dim = 1) .NE. level%nrows) .or. &
             (size(dummy, dim = 2) .NE. level%ncols)) then
-      call message('   ***ERROR: subroutine mo_read_latlon: size mismatch in latlon file for ', trim(level_name), &
-              ' in domain ', trim(adjustl(num2str(ii))), '!')
-      call message('  Latitude expected to have following dimensions ... rows:', &
-              trim(adjustl(num2str(level%nrows))), ', cols:', trim(adjustl(num2str(level%ncols))))
-      call message('  Latitude provided ... rows:', &
+      call error_message('   ***ERROR: subroutine mo_read_latlon: size mismatch in latlon file for ', trim(level_name), &
+              ' in domain ', trim(adjustl(num2str(ii))), '!', raise=.false.)
+      call error_message('  Latitude expected to have following dimensions ... rows:', &
+              trim(adjustl(num2str(level%nrows))), ', cols:', trim(adjustl(num2str(level%ncols))), raise=.false.)
+      call error_message('  Latitude provided ... rows:', &
               trim(adjustl(num2str(size(dummy, dim = 1)))), ', cols:', trim(adjustl(num2str(size(dummy, dim = 2)))))
-      stop 1
     end if
     level%y = dummy
 
     var = nc%getVariable(trim(lon_var_name))
     call var%getData(dummy)
     ! consistency check
     if ((size(dummy, dim = 1) .NE. level%nrows) .or. &
             (size(dummy, dim = 2) .NE. level%ncols)) then
-      call message('   ***ERROR: subroutine mo_read_latlon: size mismatch in latlon file for ', trim(level_name), &
-              ' in domain ', trim(adjustl(num2str(ii))), '!')
-      call message('  Longitude expected to have following dimensions ... rows:', &
-              trim(adjustl(num2str(level%nrows))), ', cols:', trim(adjustl(num2str(level%ncols))))
-      call message('  Longitude provided ... rows:', &
+      call error_message('   ***ERROR: subroutine mo_read_latlon: size mismatch in latlon file for ', trim(level_name), &
+              ' in domain ', trim(adjustl(num2str(ii))), '!', raise=.false.)
+      call error_message('  Longitude expected to have following dimensions ... rows:', &
+              trim(adjustl(num2str(level%nrows))), ', cols:', trim(adjustl(num2str(level%ncols))), raise=.false.)
+      call error_message('  Longitude provided ... rows:', &
               trim(adjustl(num2str(size(dummy, dim = 1)))), ', cols:', trim(adjustl(num2str(size(dummy, dim = 2)))))
-      stop 1
     end if
     level%x = dummy
 
     call nc%close()
 
   end subroutine read_latlon
```

### Comparing `mhm-5.12.1.dev21/src/common/mo_read_nc.f90` & `mhm-5.13.0/forces/src/mo_dds.F90`

 * *Files 20% similar despite different names*

```diff
@@ -1,835 +1,655 @@
-!>       \file mo_read_nc.f90
+!> \file mo_dds.f90
+!> \brief \copybrief mo_dds
+!> \details \copydetails mo_dds
+
+!> \brief Dynamically Dimensioned Search (DDS)
+!> \details This module provides routines for Dynamically Dimensioned Search (DDS)
+!! of Tolson and Shoemaker (2007). It searches the minimum or maximum of a user-specified function,
+!! using an n-dimensional continuous global optimization algorithm (DDS).
+!> \authors Bryan Tolson, modified by Rohini Kumar, Matthias Cuntz and Juliane Mai.
+!> \date Jul 2012
+!> \copyright Copyright 2005-\today, the CHS Developers, Sabine Attinger: All rights reserved.
+!! FORCES is released under the LGPLv3+ license \license_note
+module mo_dds
 
-!>       \brief Reads forcing input data.
+  IMPLICIT NONE
 
-!>       \details This module is to read forcing input data contained in netcdf files, e.g. temperature, precipitation,
-!>       total_runoff, lai. Timesteps can be hourly, daily, monthly, and annual. The module provides a subroutine
-!>       for NetCDF files only. First, the dimensions given are cross-checked with header.txt information. Second,
-!>       the data of the specified period are read from the specified directory.
-!>       If the optional lower and/or upper bound for the data values is given, the read data are checked for validity.
-!>       The program is stopped if any value lies out of range.
-
-!>       \authors Juliane Mai
-
-!>       \date Dec 2012
-
-! Modifications:
-! Stephan Thober  Sep 2015 - separated routines for netcdf files from routines for binary files
-! Stephan Thober  Jan 2017 - added reading weights for disaggregation of daily meteorological values to hourly ones
-! Robert Schweppe Nov 2017 - switched to mo_netcdf library and restuctured routines
-! Robert Schweppe Jun 2018 - refactoring and reformatting
-
-module mo_read_nc
-  implicit none
-  public :: read_nc
-  public :: read_const_nc
-  public :: read_weights_nc
-  private
-  !
-contains
+  PRIVATE
 
+  PUBLIC :: DDS    ! Dynamically Dimensioned Search (DDS)
+  PUBLIC :: MDDS   ! Modified Dynamically Dimensioned Search (DDS)
 
   ! ------------------------------------------------------------------
 
-  !    NAME
-  !        read_nc
+CONTAINS
 
-  !    PURPOSE
-  !>       \brief Reads forcing input in NetCDF file format.
-
-  !>       \details Reads netCDF forcing files.
-  !>       First, the dimensions given are cross-checked with header.txt information. Second, the data of the
-  !>       specified period are read from the specified directory.
-  !>       If the optional lower and/or upper bound for the data values is given, the read data are checked for
-  !>       validity.
-  !>       The program is stopped if any value lies out of range.
-  !>       If the optinal argument nocheck is true, the data are not checked for coverage with the input mask.
-  !>       Additionally in this case an mask of vild data points can be received from the routine in maskout.
-
-  !    INTENT(IN)
-  !>       \param[in] "character(len = *) :: folder"     Name of the folder where data are stored
-  !>       \param[in] "integer(i4) :: nRows"             Number of datapoints in longitudinal direction
-  !>       \param[in] "integer(i4) :: nCols"             Number of datapoints in latitudinal  direction
-  !>       \param[in] "character(len = *) :: varName"    Name of variable name to read
-  !>       \param[in] "logical, dimension(:, :) :: mask" mask of valid data fields
-
-  !    INTENT(OUT)
-  !>       \param[out] "real(dp), dimension(:, :, :) :: data" Data matrixdim_1 = longitude, dim_2 = latitude, dim_3 =
-  !>       time
-
-  !    INTENT(IN), OPTIONAL
-  !>       \param[in] "type(period), optional :: target_period" Period the data are needed for
-  !>       \param[in] "real(dp), optional :: lower"             Lower bound for check of validity of data values
-  !>       \param[in] "real(dp), optional :: upper"             Upper bound for check of validity of data values
-  !>       \param[in] "integer(i4), optional :: nctimestep"     timestep in netcdf file
-  !>       \param[in] "character(256), optional :: fileName"    name of file, defaults to varName
-  !>       \param[in] "logical, optional :: nocheck"            .TRUE. if check for nodata values deactivateddefault =
-  !>       .FALSE. - check is done
-
-  !    INTENT(OUT), OPTIONAL
-  !>       \param[out] "logical, dimension(:, :, :), optional :: maskout" ! mask of validdata points
-
-  !    HISTORY
-  !>       \authors Matthias Zink
-
-  !>       \date May 2013
-
-  ! Modifications:
-  !       Stephan Thober     Nov 2013 - only read required chunk from nc file
-  !       Matthias Cuntz & Juliane Mai Nov 2014 - read daily, monthly or yearly files
-  !       Matthias Zink      Mar 2014 - added optional nocheck flag and optional maskout
-  !       Stephan Thober     Sep 2015 - added read for hourly data
-  !       Robert Schweppe    Nov 2017 - switched to mo_netcdf library and restuctured routines
-  !       Robert Schweppe    Jun 2018 - refactoring and reformatting
-
-  subroutine read_nc(folder, nRows, nCols, varName, mask, data, target_period, lower, upper, nctimestep, &
-                            fileName, nocheck, maskout, is_meteo)
-
-    use mo_constants, only : nodata_i4
-    use mo_common_variables, only : period
-    use mo_common_mHM_mRM_variables, only : nTstepForcingDay
-    use mo_kind, only : dp, i4
-    use mo_message, only : message
-    use mo_netcdf, only : NcDataset, NcVariable
-    use mo_string_utils, only : num2str
-    use mo_utils, only : eq, ne
-
-    implicit none
-
-    ! Name of the folder where data are stored
-    character(len = *), intent(in) :: folder
-
-    ! Number of datapoints in longitudinal direction
-    integer(i4), intent(in) :: nRows
-
-    ! Number of datapoints in latitudinal  direction
-    integer(i4), intent(in) :: nCols
-
-    ! Name of variable name to read
-    character(len = *), intent(in) :: varName
-
-    ! mask of valid data fields
-    logical, dimension(:, :), intent(in) :: mask
-
-    ! Period the data are needed for
-    type(period), optional, intent(in) :: target_period
-
-    ! Lower bound for check of validity of data values
-    real(dp), optional, intent(in) :: lower
-
-    ! Upper bound for check of validity of data values
-    real(dp), optional, intent(in) :: upper
-
-    ! timestep in netcdf file
-    integer(i4), optional, intent(in) :: nctimestep
-
-    ! name of file, defaults to varName
-    character(256), optional, intent(in) :: fileName
-
-    ! .TRUE. if check for nodata values deactivateddefault = .FALSE. - check is done
-    logical, optional, intent(in) :: nocheck
-
-    ! Data matrixdim_1 = longitude, dim_2 = latitude, dim_3 = time
-    real(dp), dimension(:, :, :), allocatable, intent(out) :: data
-
-    ! ! mask of validdata points
-    logical, dimension(:, :, :), allocatable, optional, intent(out) :: maskout
-
-    ! logical whether meteorology is currently read
-    logical, optional, intent(in) :: is_meteo
-
-    ! netcdf file
-    type(NcDataset) :: nc
-
-    ! variables for data and time form netcdf
-    type(NcVariable) :: var, time_var
-
-    ! shape of NetCDF variable
-    integer(i4), allocatable, dimension(:) :: var_shape
-
-    ! index for selecting time vector
-    integer(i4) :: time_start
-
-    ! length of vector of selected time values
-    integer(i4) :: time_cnt
-
-    ! name of NetCDF file
-    character(256) :: fName
-
-    ! loop variable
-    integer(i4) :: i
+  ! ------------------------------------------------------------------
 
-    ! data nodata value
-    real(dp) :: nodata_value
+  !>        \brief DDS
 
-    ! check if model domain is covered by data
-    logical :: checking
+  !>        \details Searches Minimum or Maximum of a user-specified function using
+  !!        Dynamically Dimensioned Search (DDS).\n
+  !!        DDS is an n-dimensional continuous global optimization algorithm.
+  !!        It is coded as a minimizer but one can give maxit=True in a maximization problem,
+  !!        so that the algorithm minimizes the negative of the objective function F=(-1*F).
+  !!
+  !!        The function to be minimized is the first argument of DDS and must be defined as \n
+  !!        \code{.f90}
+  !!        function func(p)
+  !!          use mo_kind, only: dp
+  !!          implicit none
+  !!          real(dp), dimension(:), intent(in) :: p
+  !!          real(dp) :: func
+  !!        end function func
+  !!        \endcode
+  !!
+  !!        \b Example
+  !!
+  !!        \code{.f90}
+  !!        dv_range(:,1) = (/ -600.0, -600.0, -600.0, -600.0, -600.0, -600.0, -600.0, -600.0, -600.0, -600.0 /)
+  !!        dv_range(:,2) = (/ 600.0, 600.0, 600.0, 600.0, 600.0, 600.0, 600.0, 600.0, 600.0, 600.0 /)
+  !!        dv_ini        = (/ -.226265E+01, -.130187E+01, -.151219E+01, 0.133983E+00, 0.988159E+00, &
+  !!                           -.495074E+01, -.126574E+02, 0.572684E+00, 0.303864E+01, 0.343031E+01 /)
+  !!        dv_opt = DDS(griewank, dv_ini, dv_range)
+  !!        \endcode
+  !!
+  !!        See also example in test directory.
+  !!
+  !!        \b Literature
+  !!        1. Tolson, B. A., and C. A. Shoemaker (2007)
+  !!            _Dynamically dimensioned search algorithm for computationally efficient watershed
+  !!            model calibration_, Water Resour. Res., 43, W01413, doi:10.1029/2005WR004723.
+  !!
+  !>        \param[in] "real(dp) :: obj_func(p)"             Function on which to search the minimum
+  !>        \param[in] "real(dp) :: pini(:)"                 inital value of decision variables
+  !>        \param[in] "real(dp) :: prange(size(pini),2)"    Min/max range of decision variables
+  !>        \param[in] "real(dp), optional           :: r"                 DDS perturbation parameter\n
+  !!                                                                       (default: 0.2)
+  !>        \param[in] "integer(i8), optional        :: seed"              User seed to initialise the random number generator
+  !!                                                                       (default: None)
+  !>        \param[in] "integer(i8), optional        :: maxiter"           Maximum number of iteration or function evaluation
+  !!                                                                       (default: 1000)
+  !>        \param[in] "logical, optional            :: maxit"             Maximization (.True.) or
+  !!                                                                       minimization (.False.) of function
+  !!                                                                       (default: .False.)
+  !>        \param[in] "logical, optional            :: mask(size(pini))"  parameter to be optimized (true or false)
+  !!                                                                       (default: .True.)
+  !>        \param[in]  "character(len=*) , optional :: tmp_file"          file with temporal output
+  !>        \param[out] "real(dp), optional              :: funcbest"    the best value of the function.
+  !>        \param[out] "real(dp), optional, allocatable :: history(:)"  the history of best function values,
+  !!                                                                     history(maxiter)=funcbest\n
+  !!                                          allocatable only to be in correspondance with other optimization routines
+  !>        \retval "real(dp) :: DDS"   The parameters of the point which is estimated to minimize the function.
+
+  !>        \author Bryan Tolson
+  !>        \date Feb 2007
+
+  !>        \author Rohini Kumar
+  !>        \date Feb 2008
+
+  !>        \author Matthias Cuntz & Juliane Mai
+  !>        \date Jul 2012
+  !!          - module
+
+  !>        \author Juliane Mai
+  !>        \date Aug 2012
+  !!          - optional argument funcbest added
+  !>        \date Nov 2012
+  !!          - masked parameter
+  !>        \date Dec 2012
+  !!          - history output
+
+#ifdef MPI
+  function DDS(eval, obj_func, pini, prange, r, seed, maxiter, maxit, mask, tmp_file, comm, funcbest, history)
+#else
+  function DDS(eval, obj_func, pini, prange, r, seed, maxiter, maxit, mask, tmp_file, funcbest, history)
+#endif
+
+    use mo_kind, only : i4, i8, dp
+    use mo_xor4096, only : xor4096, xor4096g
+    use mo_optimization_utils, only : eval_interface, objective_interface
+#ifdef MPI
+    use mpi_f08
+#endif
 
-    ! check if model domain is covered by data
-    integer(i4) :: inctimestep
+    implicit none
 
-    ! default value for performing checks on read input
-    checking = .TRUE.
-    if (present(nocheck)) checking = .NOT. nocheck
+    procedure(eval_interface), INTENT(IN), POINTER :: eval
+    procedure(objective_interface), intent(in), pointer :: obj_func
 
-    ! default: fName = varname + '.nc'
-    ! optional: fName = filename + '.nc'
-    fName = varName
-    if (present(fileName)) then
-      fName = trim(folder) // trim(fileName) // '.nc'
+    real(dp), dimension(:), intent(in) :: pini     ! inital value of decision variables
+    real(dp), dimension(:, :), intent(in) :: prange   ! Min/max values of decision variables
+    real(dp), optional, intent(in) :: r        ! DDS perturbation parameter (-> 0.2 by default)
+    integer(i8), optional, intent(in) :: seed     ! User seed to initialise the random number generator
+    integer(i8), optional, intent(in) :: maxiter  ! Maximum number of iteration or function evaluation
+    logical, optional, intent(in) :: maxit    ! Maximization or minimization of function
+    logical, dimension(:), optional, intent(in) :: mask     ! parameter to be optimized (true or false)
+    character(len = *), optional, intent(in) :: tmp_file    ! file for temporal output
+#ifdef MPI
+    type(MPI_Comm), optional, intent(in)  :: comm                ! MPI communicator
+#endif
+    real(dp), optional, intent(out) :: funcbest ! Best value of the function.
+    real(dp), dimension(:), optional, intent(out), &
+            allocatable :: history  ! History of objective function values
+    real(dp), dimension(size(pini)) :: DDS      ! Best value of decision variables
+
+    ! Local variables
+    integer(i4) :: pnum                   ! Total number of decision variables
+    integer(i8) :: iseed                  ! User given seed
+    integer(i8) :: imaxiter               ! Maximum number of iteration or function evaluation
+    real(dp) :: ir                     ! DDS perturbation parameter
+    real(dp) :: imaxit                 ! Maximization or minimization of function
+    real(dp) :: of_new, of_best        ! intermediate results
+    real(dp) :: Pn, new_value          ! intermediate results
+    real(dp), dimension(size(pini)) :: pnew                   ! Test value of decision variables
+    real(dp) :: ranval                 ! random value
+    integer(i8) :: i                      ! maxiter=i8
+    integer(i4) :: j, dvn_count, dv       ! pnum=i4
+    integer(i4) :: idummy                 ! dummy vaiable
+    integer, dimension(8) :: sdate                  ! date_and_time return
+    logical, dimension(size(pini)) :: maske                  ! parameter to be optimized (true or false)
+    integer(i4), dimension(:), allocatable :: truepara               ! parameter to be optimized (their indexes)
+#ifdef MPI
+    integer(i4) :: ierror
+    logical :: do_obj_loop
+    integer(i4) :: iproc, nproc
+#endif
+
+    ! Check input
+    pnum = size(pini)
+    if (size(prange, 1) /= pnum) stop 'Error DDS: size(prange,1) /= size(pini)'
+    if (size(prange, 2) /= 2)    stop 'Error DDS: size(prange,2) /= 2'
+    ! r Perturbation parameter
+    ir = 0.2_dp
+    if (present(r)) ir = r
+    if (ir <= 0.0_dp .or. ir > 1.0_dp) stop 'Error DDS: DDS perturbation parameter (0.0, 1.0]'
+    ! max. iteration
+    imaxiter = 1000
+    if (present(maxiter)) imaxiter = maxiter
+    if (imaxiter < 6) stop 'Error DDS: max function evals must be minimum 6'
+    ! history output
+    if (present(history)) then
+      allocate(history(imaxiter))
+    end if
+    ! Min or max objective function
+    imaxit = 1.0_dp
+    if (present(maxit)) then
+      if (maxit) imaxit = -1.0_dp
+    end if
+    ! Given seed
+    iseed = 0
+    if (present(seed)) iseed = seed
+    iseed = max(iseed, 0_i8)
+
+    if (present(mask)) then
+      if (count(mask) .eq. 0_i4) then
+        stop 'Input argument mask: At least one element has to be true'
+      else
+        maske = mask
+      end if
     else
-      fName = trim(folder) // trim(fName) // '.nc'
+      maske = .true.
     end if
 
-    ! read the Dataset
-    nc = NcDataset(fname, "r")
-    ! get the variable
-    var = nc%getVariable(trim(varName))
-
-    ! get dimensions and check if plane is correct
-    var_shape = var%getShape()
-    if ((var_shape(1) .ne. nRows) .or. (var_shape(2) .ne. nCols)) then
-      stop '***ERROR: read_nc: mHM generated x and y are not matching NetCDF dimensions'
-    end if
+    allocate (truepara(count(maske)))
+    idummy = 0_i4
+    do j = 1, size(pini, 1)
+      if (maske(j)) then
+        idummy = idummy + 1_i4
+        truepara(idummy) = j
+      end if
+    end do
 
-    ! determine no data value, use _FillValue first, fall back to missing_value
-    if (var%hasAttribute("_FillValue")) then
-      call var%getAttribute('_FillValue', nodata_value)
-    else if (var%hasAttribute("missing_value")) then
-      call var%getAttribute('missing_value', nodata_value)
+    ! Seed random numbers
+    if (iseed == 0) then
+      call date_and_time(values = sdate)
+      iseed = sdate(1) * 31536000000_i8 + sdate(2) * 2592000000_i8 + sdate(3) * 86400000_i8 + &
+              sdate(5) * 3600000_i8 + sdate(6) * 60000_i8 + sdate(7) * 1000_i8 + sdate(8)
+      call xor4096(iseed, ranval)
+      call xor4096g(iseed, ranval)
     else
-      stop '***ERROR: read_nc: there must be either the attribute "missing_value" or "_FillValue"'
+      call xor4096(iseed, ranval)
+      call xor4096g(iseed, ranval)
     end if
 
-    ! get time variable
-    time_var = nc%getVariable('time')
-    ! read the time vector and get start index and count of selection
-    call get_time_vector_and_select(time_var, fname, inctimestep, time_start, time_cnt, target_period)
-
-    if (present(is_meteo)) then
-       if (is_meteo) then
-          select case(inctimestep)
-          case(-1) ! daily
-             if (nTstepForcingDay .eq. nodata_i4) then
-                nTstepForcingDay = 1_i4
-             else if (nTstepForcingDay .ne. 1_i4) then
-                call message('***ERROR: read_forcing_nc: expected daily input forcing, but read something else. ' // &
-                     'Ensure all input time steps have the same units across all input files')
-                stop 1
-             end if
-          case(-4) ! hourly
-             if (nTstepForcingDay .eq. nodata_i4) then
-                nTstepForcingDay = 24_i4
-             else if (nTstepForcingDay .ne. 24_i4) then
-                call message('***ERROR: read_forcing_nc: expected hourly input forcing, but read something else. ' // &
-                     'Ensure all input time steps have the same units across all input files')
-                stop 1
-             end if
-          case default ! no output at all
-             call message('***ERROR: read_nc: unknown nctimestep switch.')
-             stop
-          end select
-       end if
-    end if
-
-    ! check optional nctimestep
-    if (present(nctimestep)) then
-       if (inctimestep .ne. nctimestep) then
-          call message('***ERROR: provided timestep ' // num2str(nctimestep) //&
-                       ' does not match with the one in file ' // num2str(inctimestep))
-          call message('File: ' // trim(fname))
-          stop 1
-       end if
-    end if
-
-    ! extract data and select time slice
-    call var%getData(data, start = (/1, 1, time_start/), cnt = (/nRows, nCols, time_cnt/))
-
-    ! save output mask if optional maskout is given
-    if (present(maskout)) then
-      allocate(maskout(var_shape(1), var_shape(2), var_shape(3)))
-      maskout = ne(data(:, :, :), nodata_value)
-    end if
-
-    ! start checking values
-    do i = 1, size(data, dim = 3)
-      ! neglect checking for nodata values if optional nocheck is given
-      if (checking) then
-        if (any(eq(data(:, :, i), nodata_value) .and. (mask))) then
-          call message('***ERROR: read_nc: nodata value within domain ')
-          call message('          boundary in variable: ', trim(varName))
-          call message('          at timestep         : ', trim(num2str(i)))
-          stop
-        end if
+    ! Temporal file writing
+    if(present(tmp_file)) then
+      open(unit = 999, file = trim(adjustl(tmp_file)), action = 'write', status = 'unknown')
+      write(999, *) '# settings :: general'
+      write(999, *) '# nIterations    iseed'
+      write(999, *) imaxiter, iseed
+      write(999, *) '# settings :: dds specific'
+      write(999, *) '# dds_r'
+      write(999, *) ir
+      write(999, *) '# iter   bestf   (bestx(j),j=1,nopt)'
+      close(999)
+    end if
+
+    ! Evaluate initial solution and return objective function value
+    ! and Initialise the other variables (e.g. of_best)
+    ! imaxit is 1.0 for MIN problems, -1 for MAX problems
+    DDS = pini
+    print *, imaxit
+#ifdef MPI
+    call MPI_Comm_size(comm, nproc, ierror)
+    do iproc = 1, nproc-1
+      do_obj_loop = .true.
+      call MPI_Send(do_obj_loop,1, MPI_LOGICAL,iproc,0,comm,ierror)
+    end do
+#endif
+    of_new = imaxit * obj_func(pini, eval)
+    of_best = of_new
+    if (present(history)) history(1) = of_new
+
+    file_write : if (present(tmp_file)) then
+      open(unit = 999, file = trim(adjustl(tmp_file)), action = 'write', position = 'append', recl = (pnum + 2) * 30)
+      if (imaxit .lt. 0.0_dp) then
+        ! Maximize
+        write(999, *) '0', -of_best, pini
+      else
+        ! Minimize
+        write(999, *) '0', of_best, pini
       end if
-      ! optional check
-      if (present(lower)) then
-        if (any((data(:, :, i) .lt. lower) .AND. mask(:, :))) then
-          call message('***ERROR: read_nc: values in variable "', &
-                  trim(varName), &
-                  '" are lower than ', trim(num2str(lower, '(F7.2)')))
-          call message('          at timestep  : ', trim(num2str(i)))
-          call message('File: ', trim(fName))
-          call message('Minval at timestep: ', trim(num2str(minval(data(:, :, i)))))
-          call message('Total minval: ', trim(num2str(minval(data(:, :, :)))))
-          stop
+      close(999)
+    end if file_write
+
+    ! Code below is now the DDS algorithm as presented in Figure 1 of Tolson and Shoemaker (2007)
+
+    do i = 1, imaxiter - 1
+      ! Determine Decision Variable (DV) selected for perturbation:
+      Pn = 1.0_dp - log(real(i, dp)) / log(real(imaxiter - 1, dp)) ! probability each DV selected
+      dvn_count = 0                                                 ! counter for how many DVs selected for perturbation
+      pnew = DDS                                               ! define pnew initially as best current solution
+
+      ! Step 3 of Fig 1 of Tolson and Shoemaker (2007)
+      do j = 1, size(truepara) !pnum
+        call xor4096(0_i8, ranval)                           ! selects next uniform random number in sequence
+        ! Step 4 of Fig 1 of Tolson and Shoemaker (2007)
+        if (ranval < Pn) then                               ! jth DV selected for perturbation
+          dvn_count = dvn_count + 1
+          ! call 1-D perturbation function to get new DV value (new_value)
+          call neigh_value(DDS(truepara(j)), prange(truepara(j), 1), prange(truepara(j), 2), ir, new_value)
+          pnew(truepara(j)) = new_value
         end if
+      end do
+
+      ! Step 3 of Fig 1 of Tolson and Shoemaker (2007) in case {N} empty
+      if (dvn_count == 0) then                               ! no DVs selected at random, so select one
+        call xor4096(0_i8, ranval)                           ! selects next uniform random number in sequence
+        dv = truepara(int((ranval * real(size(truepara), dp)) + 1.0_dp, i4))  ! index for one DV
+        ! call 1-D perturbation function to get new DV value (new_value):
+        call neigh_value(DDS(dv), prange(dv, 1), prange(dv, 2), ir, new_value)
+        pnew(dv) = new_value                                ! change relevant DV value in stest
       end if
 
-      if (present(upper)) then
-        if (any((data(:, :, i) .gt. upper) .AND. mask(:, :))) then
-          call message('***ERROR: read_nc: values in variable "', &
-                  trim(varName), &
-                  '" are greater than ', trim(num2str(upper, '(F7.2)')))
-          call message('          at timestep  : ', trim(num2str(i)))
-          call message('File: ', trim(fName))
-          call message('Maxval at timestep: ', trim(num2str(maxval(data(:, :, i)))))
-          call message('Total maxval: ', trim(num2str(maxval(data(:, :, :)))))
-          print*, data(:, :, i)
-          stop
-        end if
+      ! Step 5 of Fig 1 of Tolson and Shoemaker (2007)
+      ! Evaluate obj function value for test
+#ifdef MPI
+      call MPI_Comm_size(comm, nproc, ierror)
+      do iproc = 1, nproc-1
+        do_obj_loop = .true.
+        call MPI_Send(do_obj_loop,1, MPI_LOGICAL,iproc,0,comm,ierror)
+      end do
+#endif
+      of_new = imaxit * obj_func(pnew, eval)                       ! imaxit handles min(=1) and max(=-1) problems
+      ! update current best solution
+      if (of_new <= of_best) then
+        of_best = of_new
+        DDS = pnew
       end if
+      if (present(history)) history(i + 1) = of_best
+
+      file_write2 : if (present(tmp_file)) then
+        open(unit = 999, file = trim(adjustl(tmp_file)), action = 'write', position = 'append', recl = (pnum + 2) * 30)
+        if (imaxit .lt. 0.0_dp) then
+          ! Maximize
+          write(999, *) i, -of_best, dds
+        else
+          ! Minimize
+          write(999, *) i, of_best, dds
+        end if
+        close(999)
+      end if file_write2
 
     end do
+    if (present(funcbest)) funcbest = of_best
+#ifdef MPI
+    call MPI_Comm_size(comm, nproc, ierror)
+    do iproc = 1, nproc-1
+      do_obj_loop = .false.
+      call MPI_Send(do_obj_loop,1, MPI_LOGICAL,iproc,0,comm,ierror)
+    end do
+#endif
 
-  end subroutine read_nc
+  end function DDS
 
   ! ------------------------------------------------------------------
 
-  !     NAME
-  !         read_const_nc
+  !>        \brief MDDS
 
-  !     PURPOSE
-  !>        \brief Reads time independent forcing input in NetCDF file format.
 
-  !>        \details Reads time independent netCDF forcing files.  \n
-  !>        First, the dimensions given are cross-checked with header.txt information. Second, the data of the
-  !>        specified period are read from the specified directory.
-  !>        If the optional lower and/or upper bound for the data values is given, the read data are checked for validity.
-  !>        The program is stopped if any value lies out of range.\n
-  !>        If the optinal argument nocheck is true, the data are not checked for coverage with the input mask.
-  !>        Additionally in this case an mask of vild data points can be received from the routine in maskout.
-
-  !     INTENT(IN)
-  !>        \param[in] "character(len=*) :: folder"        Name of the folder where data are stored
-  !>        \param[in] "integer(i4)      :: nRows"         Number of datapoints in longitudinal direction
-  !>        \param[in] "integer(i4)      :: nCols"         Number of datapoints in latitudinal  direction
-  !>        \param[in] "character(len=*) :: varName"       Name of variable name to read
-  !>        \param[in] "logical, dimension(:,:) :: mask"   mask of valid data fields
-
-  !     INTENT(INOUT)
-  !         None
-
-  !     INTENT(OUT)
-  !>        \param[out] "real(dp), dimension(:,:,:) :: data"     Data matrix
-  !>                                                             dim_1 = longitude, dim_2 = latitude
-
-  !     INTENT(IN), OPTIONAL
-  !>       \param[in] "character(256), optional :: fileName"    name of file, defaults to varName
-
-  !     INTENT(INOUT), OPTIONAL
-  !         None
-
-  !     INTENT(OUT), OPTIONAL
-  !         None
-  !>                                                                                                  data points
-
-  !     RETURN
-  !         None
-
-  !     RESTRICTIONS
-  !>        \note Files have to be called like defined in mo_files. Furthermore the variable names have to be called
-  !>              like they are defined in the declaration of this subroutine. The NetCDF file has to have 2 dimensions:
-  !>              1. x, 2. y, It is expected that the variables (especially)within the NetCDF files contain an
-  !>              unit attribute. The timestep has to be equidistant.
-
-  !     EXAMPLE
-
-  !     LITERATURE
-  !         None
-
-  !     HISTORY
-  !>        \author Lennart Schueler, heavily influenced by read_nc
-  !>        \date May 2018
-
-  subroutine read_const_nc(folder, nRows, nCols, varName, data, fileName)
-
-    use mo_kind,             only: i4, dp
-    use mo_message,          only: message
-    use mo_netcdf,           only: NcDataset, NcVariable, NcDimension
-    use mo_string_utils,     only: num2str
-    use mo_utils,            only: eq, ne
+  !>        \details Searches Minimum or Maximum of a user-specified function using the
+  !!        Modified Dynamically Dimensioned Search (DDS).\n
+  !!        DDS is an n-dimensional continuous global optimization algorithm.
+  !!        It is coded as a minimizer but one can give maxit=True in a maximization problem,
+  !!        so that the algorithm minimizes the negative of the objective function F=(-1*F).\n
+  !!        The function to be minimized is the first argument of DDS and must be defined as
+  !!        \code
+  !!            function func(p)
+  !!              use mo_kind, only: dp
+  !!              implicit none
+  !!              real(dp), dimension(:), intent(in) :: p
+  !!              real(dp) :: func
+  !!            end function func
+  !!        \endcode
+  !!
+  !!       MDDS extents normal DDS by a continuous reduction of the DDS pertubation parameter r from 0.3 to 0.05,
+  !!       and by allowing a larger function value with a certain probablity.
+
+  !>        \param[in] "real(dp) :: obj_func(p)"             Function on which to search the minimum
+  !>        \param[in] "real(dp) :: pini(:)"                 inital value of decision variables
+  !>        \param[in] "real(dp) :: prange(size(pini),2)"    Min/max range of decision variables
+  !>        \param[in] "integer(i8), optional        :: seed"              User seed to initialise the random number generator
+  !!                                                                       (default: None)
+  !>        \param[in] "integer(i8), optional        :: maxiter"           Maximum number of iteration or function evaluation
+  !!                                                                       (default: 1000)
+  !>        \param[in] "logical, optional            :: maxit"             Maximization (.True.) or
+  !!                                                                       minimization (.False.) of function
+  !!                                                                       (default: .False.)
+  !>        \param[in] "logical, optional            :: mask(size(pini))"  parameter to be optimized (true or false)
+  !!                                                                       (default: .True.)
+  !>        \param[in]  "character(len=*) , optional :: tmp_file"          file with temporal output
+  !>        \param[out] "real(dp), optional              :: funcbest"    the best value of the function.
+  !>        \param[out] "real(dp), optional, allocatable :: history(:)"  the history of best function values,
+  !!                                                                      history(maxiter)=funcbest\n
+  !!                                          allocatable only to be in correspondance with other optimization routines
+  !>        \return real(dp) :: MDDS  &mdash;  The parameters of the point which is estimated to minimize the function.
+
+  !>     ## Restrictions
+  !!         None.
+
+  !>     ## Example
+  !!
+  !!         dv_range(:,1) = (/ -600.0, -600.0, -600.0, -600.0, -600.0, -600.0, -600.0, -600.0, -600.0, -600.0 /)
+  !!         dv_range(:,2) = (/ 600.0, 600.0, 600.0, 600.0, 600.0, 600.0, 600.0, 600.0, 600.0, 600.0 /)
+  !!         dv_ini        = (/ -.226265E+01, -.130187E+01, -.151219E+01, 0.133983E+00, 0.988159E+00, &
+  !!                            -.495074E+01, -.126574E+02, 0.572684E+00, 0.303864E+01, 0.343031E+01 /)
+  !!         dv_opt = MDDS(griewank, dv_ini, dv_range)
+  !!
+  !!     See also example in test directory.
+
+  !>     ## Literature
+  !!
+  !!     1. Tolson, B. A., and C. A. Shoemaker (2007),
+  !!         _Dynamically dimensioned search algorithm for computationally efficient watershed
+  !!         model calibration_, Water Resour. Res., 43, W01413, doi:10.1029/2005WR004723.
+  !!     2. Huang X-L and Xiong J (2010),
+  !!         _Parameter Optimization of Multi-tank Model with Modified Dynamically Dimensioned
+  !!         Search Algorithm_, Proceedings of the Third International Symposium on Computer
+  !!         Science and Computational Technology(ISCSCT ''10), Jiaozuo, P. R. China,
+  !!         14-15 August 2010, pp. 283-288\n
+
+  !>        \author Written Matthias Cuntz and Juliane Mai
+  !>        \date Aug 2012
+  !         Modified, Juliane Mai,                  Nov 2012 - masked parameter
+  !                   Juliane Mai,                  Dec 2012 - history output
+
+  function MDDS(eval, obj_func, pini, prange, seed, maxiter, maxit, mask, tmp_file, funcbest, history)
+
+    use mo_kind, only : i4, i8, dp
+    use mo_xor4096, only : xor4096, xor4096g
+    use mo_optimization_utils, only : eval_interface, objective_interface
 
     implicit none
 
-    character(len=*),                      intent(in)  :: folder  ! folder where data are stored
-    integer(i4),                           intent(in)  :: nRows   ! number of rows of data fields:
-    integer(i4),                           intent(in)  :: nCols   ! number of columns of data fields:
-    character(len=*),                      intent(in)  :: varName ! name of NetCDF variable
-    real(dp), dimension(:,:), allocatable, intent(out) :: data    ! data read in
-    ! name of file, defaults to varName
-    character(256), optional, intent(in) :: fileName
-
-    ! local variables
-    type(NcDataset)                        :: nc           ! netcdf file
-    type(NcVariable)                       :: var          ! variables for data form netcdf
-    integer(i4), allocatable, dimension(:) :: var_shape    ! shape of NetCDF variable
-
-    character(256)                         :: fName        ! name of NetCDF file
-    real(dp)                               :: nodata_value ! data nodata value
-
-    fName = varName
-    if (present(fileName)) then
-      fName = trim(folder) // trim(fileName) // '.nc'
+    procedure(eval_interface), INTENT(IN), POINTER :: eval
+    procedure(objective_interface), intent(in), pointer :: obj_func
+    real(dp), dimension(:), intent(in) :: pini     ! inital value of decision variables
+    real(dp), dimension(:, :), intent(in) :: prange   ! Min/max values of decision variables
+    integer(i8), optional, intent(in) :: seed     ! User seed to initialise the random number generator
+    integer(i8), optional, intent(in) :: maxiter  ! Maximum number of iteration or function evaluation
+    logical, optional, intent(in) :: maxit    ! Maximization or minimization of function
+    logical, dimension(:), optional, intent(in) :: mask     ! parameter to be optimized (true or false)
+    character(len = *), optional, intent(in) :: tmp_file ! file for temporal output
+    real(dp), optional, intent(out) :: funcbest ! Best value of the function.
+    real(dp), dimension(:), optional, intent(out), &
+            allocatable :: history  ! History of objective function values
+    real(dp), dimension(size(pini)) :: MDDS     ! Best value of decision variables
+
+    ! Local variables
+    integer(i4) :: pnum                   ! Total number of decision variables
+    integer(i8) :: iseed                  ! User given seed
+    integer(i8) :: imaxiter               ! Maximum number of iteration or function evaluation
+    real(dp) :: ir                     ! MDDS perturbation parameter
+    real(dp) :: imaxit                 ! Maximization or minimization of function
+    real(dp) :: of_new, of_best        ! intermediate results
+    real(dp) :: Pn, new_value          ! intermediate results
+    real(dp), dimension(size(pini)) :: pnew                   ! Test value of decision variables
+    real(dp) :: ranval                 ! random value
+    integer(i8) :: i                      ! maxiter=i8
+    integer(i4) :: j, dvn_count, dv       ! pnum=i4
+    integer(i4) :: idummy                 ! dummy vaiable
+    integer, dimension(8) :: sdate                  ! date_and_time return
+    logical, dimension(size(pini)) :: maske                  ! parameter to be optimized (true or false)
+    integer(i4), dimension(:), allocatable :: truepara               ! parameter to be optimized (their indexes)
+
+
+    ! Check input
+    pnum = size(pini)
+    if (size(prange, 1) /= pnum) stop 'Error MDDS: size(prange,1) /= size(pini)'
+    if (size(prange, 2) /= 2)    stop 'Error MDDS: size(prange,2) /= 2'
+    ! max. iteration
+    imaxiter = 1000
+    if (present(maxiter)) imaxiter = maxiter
+    if (imaxiter < 6) stop 'Error MDDS: max function evals must be minimum 6'
+    ! history output
+    if (present(history)) then
+      allocate(history(imaxiter))
+    end if
+    ! Min or max objective function
+    imaxit = 1.0_dp
+    if (present(maxit)) then
+      if (maxit) imaxit = -1.0_dp
+    end if
+    ! Given seed
+    iseed = 0
+    if (present(seed)) iseed = seed
+    iseed = max(iseed, 0_i8)
+
+    ! Seed random numbers
+    if (iseed == 0) then
+      call date_and_time(values = sdate)
+      iseed = sdate(1) * 31536000000_i8 + sdate(2) * 2592000000_i8 + sdate(3) * 86400000_i8 + &
+              sdate(5) * 3600000_i8 + sdate(6) * 60000_i8 + sdate(7) * 1000_i8 + sdate(8)
+      call xor4096(iseed, ranval)
+      call xor4096g(iseed, ranval)
     else
-      fName = trim(folder) // trim(fName) // '.nc'
+      call xor4096(iseed, ranval)
+      call xor4096g(iseed, ranval)
     end if
 
-    ! read the Dataset
-    nc = NcDataset(fname, "r")
-    ! get the variable
-    var = nc%getVariable(trim(varName))
-
-    ! get dimensions and check if plane is correct
-    var_shape = var%getShape()
-    if ( (var_shape(1) .ne. nRows) .or. (var_shape(2) .ne. nCols) ) then
-       stop '***ERROR: read_const_nc: mHM generated x and y are not matching NetCDF dimensions'
-    end if
-
-    ! determine no data value, use _FillValue first, fall back to missing_value
-    if (var%hasAttribute("_FillValue")) then
-      call var%getAttribute('_FillValue', nodata_value)
-    else if (var%hasAttribute("missing_value")) then
-      call var%getAttribute('missing_value', nodata_value)
-    else
-      stop '***ERROR: read_const_nc: there must be either the attribute "missing_value" or "_FillValue"'
-    end if
-
-    ! extract data and select time slice
-    call var%getData(data, start=(/1,1/), cnt=(/nRows,nCols/))
-
-  end subroutine read_const_nc
-
-  ! ------------------------------------------------------------------
-
-  !    NAME
-  !        read_weights_nc
-
-  !    PURPOSE
-  !>       \brief Reads weights for meteo forcings input in NetCDF file format.
-
-  !>       \details Reads netCDF weight files.
-  !>       First, the dimensions given are cross-checked with header.txt information. If the optional lower
-  !>       and/or upper bound for the data values is given, the read data are checked for validity.
-  !>       The program is stopped if any value lies out of range.
-  !>       If the optinal argument nocheck is true, the data are not checked for coverage with the input mask.
-  !>       Additionally in this case an mask of vild data points can be received from the routine in maskout.
-
-  !    INTENT(IN)
-  !>       \param[in] "character(len = *) :: folder"     Name of the folder where data are stored
-  !>       \param[in] "integer(i4) :: nRows"             Number of datapoints in longitudinal direction
-  !>       \param[in] "integer(i4) :: nCols"             Number of datapoints in latitudinal  direction
-  !>       \param[in] "character(len = *) :: varName"    Name of variable name to read
-  !>       \param[in] "logical, dimension(:, :) :: mask" mask of valid data fields
-
-  !    INTENT(OUT)
-  !>       \param[out] "real(dp), dimension(:, :, :, :) :: data" Data matrixdim_1 = longitude, dim_2 = latitude, dim_3 =
-  !>       months, dim_4 = hours
-
-  !    INTENT(IN), OPTIONAL
-  !>       \param[in] "real(dp), optional :: lower"          Lower bound for check of validity of data values
-  !>       \param[in] "real(dp), optional :: upper"          Upper bound for check of validity of data values
-  !>       \param[in] "logical, optional :: nocheck"         .TRUE. if check for nodata values deactivateddefault =
-  !>       .FALSE. - check is done
-  !>       \param[in] "character(256), optional :: fileName" name of variable, defaults to fileName
-
-  !    INTENT(OUT), OPTIONAL
-  !>       \param[out] "logical, dimension(:, :, :, :), optional :: maskout" ! mask of validdata points
-
-  !    HISTORY
-  !>       \authors Stephan Thober & Matthias Zink
-
-  !>       \date Jan 2017
-
-  ! Modifications:
-  ! Robert Schweppe    Nov 2017 - switched to mo_netcdf library and restuctured routine
-  ! Robert Schweppe Jun 2018 - refactoring and reformatting
-
-
-  subroutine read_weights_nc(folder, nRows, nCols, varName, data, mask, lower, upper, nocheck, maskout, fileName)
-
-    use mo_kind, only : dp, i4
-    use mo_message, only : message
-    use mo_netcdf, only : NcDataset, NcVariable
-    use mo_string_utils, only : num2str
-    use mo_utils, only : eq, ne
-
-    implicit none
-
-    ! Name of the folder where data are stored
-    character(len = *), intent(in) :: folder
-
-    ! Number of datapoints in longitudinal direction
-    integer(i4), intent(in) :: nRows
-
-    ! Number of datapoints in latitudinal  direction
-    integer(i4), intent(in) :: nCols
-
-    ! Name of variable name to read
-    character(len = *), intent(in) :: varName
-
-    ! mask of valid data fields
-    logical, dimension(:, :), intent(in) :: mask
-
-    ! Lower bound for check of validity of data values
-    real(dp), optional, intent(in) :: lower
-
-    ! Upper bound for check of validity of data values
-    real(dp), optional, intent(in) :: upper
-
-    ! .TRUE. if check for nodata values deactivateddefault = .FALSE. - check is done
-    logical, optional, intent(in) :: nocheck
-
-    ! name of variable, defaults to fileName
-    character(256), optional, intent(in) :: fileName
-
-    ! Data matrixdim_1 = longitude, dim_2 = latitude, dim_3 = months, dim_4 = hours
-    real(dp), dimension(:, :, :, :), allocatable, intent(out) :: data
-
-    ! ! mask of validdata points
-    logical, dimension(:, :, :, :), allocatable, optional, intent(out) :: maskout
-
-    ! name of NetCDF file
-    character(256) :: fName
-
-    ! loop variable
-    integer(i4) :: i
-
-    ! loop variable
-    integer(i4) :: j
-
-    ! data nodata value
-    real(dp) :: nodata_value
-
-    ! check if model domain is covered by data
-    logical :: checking
-
-    ! container for Netcdf data
-    type(NcDataset) :: nc
-
-    ! container for Netcdf variable
-    type(NcVariable) :: var
-
-    ! shape of NetCDF variable
-    integer(i4), allocatable, dimension(:) :: var_shape
-
-
-    checking = .TRUE.
-    if (present(nocheck)) checking = .NOT. nocheck
-
-    fName = varName
-    if (present(fileName)) then
-      fName = trim(folder) // fileName
+    ! Masked parameters
+    if (present(mask)) then
+      if (count(mask) .eq. 0_i4) then
+        stop 'Input argument mask: At least one element has to be true'
+      else
+        maske = mask
+      end if
     else
-      fName = trim(folder) // trim(fName) // '.nc'
+      maske = .true.
     end if
 
-    nc = NcDataset(fname, "r")
-    var = nc%getVariable(trim(varName))
+    allocate (truepara(count(maske)))
+    idummy = 0_i4
+    do j = 1, size(pini, 1)
+      if (maske(j)) then
+        idummy = idummy + 1_i4
+        truepara(idummy) = j
+      end if
+    end do
 
-    ! get dimensions
-    var_shape = var%getShape()
-    if ((var_shape(1) .ne. nRows) .or. (var_shape(2) .ne. nCols)) then
-      stop '***ERROR: read_nc: mHM generated x and y are not matching NetCDF dimensions'
-    end if
+    ! Temporal file writing
+    if(present(tmp_file)) then
+      open(unit = 999, file = trim(adjustl(tmp_file)), action = 'write', status = 'unknown')
+      write(999, *) '# settings :: general'
+      write(999, *) '# nIterations    iseed'
+      write(999, *) imaxiter, iseed
+      write(999, *) '# settings :: mdds specific'
+      write(999, *) '# None'
+      write(999, *) ''
+      write(999, *) '# iter   bestf   (bestx(j),j=1,nopt)'
+      close(999)
+    end if
+
+    ! Evaluate initial solution and return objective function value
+    ! and Initialise the other variables (e.g. of_best)
+    ! imaxit is 1.0 for MIN problems, -1 for MAX problems
+    MDDS = pini
+    of_new = imaxit * obj_func(pini, eval)
+    of_best = of_new
+    if (present(history)) history(1) = of_new
+
+    file_write : if (present(tmp_file)) then
+      open(unit = 999, file = trim(adjustl(tmp_file)), action = 'write', position = 'append', recl = (pnum + 2) * 30)
+      if (imaxit .lt. 0.0_dp) then
+        ! Maximize
+        write(999, *) '0', -of_best, mdds
+      else
+        ! Minimize
+        write(999, *) '0', of_best, mdds
+      end if
+      close(999)
+    end if file_write
 
-    ! determine no data value
-    call var%getAttribute('missing_value', nodata_value)
+    ! Code below is now the MDDS algorithm as presented in Figure 1 of Tolson and Shoemaker (2007)
 
-    ! extract data
-    call var%getData(data)
+    do i = 1, imaxiter - 1
+      ! Determine Decision Variable (DV) selected for perturbation:
+      Pn = 1.0_dp - log(real(i, dp)) / log(real(imaxiter - 1, dp)) ! probability each DV selected
+      dvn_count = 0                                                 ! counter for how many DVs selected for perturbation
+      pnew = MDDS                                               ! define pnew initially as best current solution
+      ! Modifications by Huang et al. (2010)
+      Pn = max(Pn, 0.05_dp)
+      ir = max(min(0.3_dp, Pn), 0.05_dp)
+
+      ! Step 3 of Fig 1 of Tolson and Shoemaker (2007)
+      do j = 1, pnum
+        call xor4096(0_i8, ranval)                           ! selects next uniform random number in sequence
+        ! Step 4 of Fig 1 of Tolson and Shoemaker (2007)
+        if (ranval < Pn) then                               ! jth DV selected for perturbation
+          dvn_count = dvn_count + 1
+          ! call 1-D perturbation function to get new DV value (new_value)
+          call neigh_value(MDDS(truepara(j)), prange(truepara(j), 1), prange(truepara(j), 2), ir, new_value)
+          pnew(truepara(j)) = new_value
+        end if
+      end do
 
-    ! save output mask if optional maskout is given
-    if (present(maskout)) then
-      allocate(maskout(var_shape(1), var_shape(2), var_shape(3), var_shape(4)))
-      maskout = ne(data(:, :, :, :), nodata_value)
-    end if
+      ! Step 3 of Fig 1 of Tolson and Shoemaker (2007) in case {N} empty
+      if (dvn_count == 0) then                               ! no DVs selected at random, so select one
+        call xor4096(0_i8, ranval)                           ! selects next uniform random number in sequence
+        dv = truepara(int((ranval * real(size(truepara), dp)) + 1.0_dp, i4))  ! index for one DV
+        ! call 1-D perturbation function to get new DV value (new_value):
+        call neigh_value(MDDS(dv), prange(dv, 1), prange(dv, 2), ir, new_value)
+        pnew(dv) = new_value                                ! change relevant DV value in stest
+      end if
 
-    ! start checking values
-    do i = 1, var_shape(3)
-      do j = 1, var_shape(4)
-        ! neglect checking for naodata values if optional nocheck is given
-        if (checking) then
-          if (any(eq(data(:, :, i, j), nodata_value) .and. (mask))) then
-            call message('***ERROR: read_nc: nodata value within domain ')
-            call message('          boundary in variable: ', trim(varName))
-            call message('          at hour         : ', trim(num2str(i)))
-            stop
-          end if
+      ! Step 5 of Fig 1 of Tolson and Shoemaker (2007)
+      ! Evaluate obj function value for test
+      of_new = imaxit * obj_func(pnew, eval)                       ! imaxit handles min(=1) and max(=-1) problems
+      ! update current best solution
+      if (of_new <= of_best) then
+        of_best = of_new
+        MDDS = pnew
+      else ! Modifications by Huang et al. (2010)
+        call xor4096(0_i8, ranval)
+        if (exp(-(of_new - of_best) / of_best) > (1.0_dp - ranval * Pn)) then
+          of_best = of_new
+          MDDS = pnew
         end if
-        ! optional check
-        if (present(lower)) then
-          if (any((data(:, :, i, j) .lt. lower) .AND. mask(:, :))) then
-            call message('***ERROR: read_nc: values in variable "', &
-                    trim(varName), &
-                    '" are lower than ', trim(num2str(lower, '(F7.2)')))
-            call message('          at hour  : ', trim(num2str(i)))
-            call message('File: ', trim(fName))
-            call message('Minval at hour: ', trim(num2str(minval(data(:, :, i, j)), '(F7.2)')))
-            call message('Total minval: ', trim(num2str(minval(data(:, :, :, :)), '(F7.2)')))
-            stop
+      end if
+      if (present(history)) then
+        if (present(maxit)) then
+          if (maxit) then
+            history(i + 1) = max(history(i), of_best)
+          else
+            history(i + 1) = min(history(i), of_best)
           end if
+        else
+          history(i + 1) = min(history(i), of_best)
         end if
+      end if
 
-        if (present(upper)) then
-          if (any((data(:, :, i, j) .gt. upper) .AND. mask(:, :))) then
-            call message('***ERROR: read_nc: values in variable "', &
-                    trim(varName), &
-                    '" are greater than ', trim(num2str(upper, '(F7.2)')))
-            call message('          at hour  : ', trim(num2str(i)))
-            call message('File: ', trim(fName))
-            call message('Maxval at hour: ', trim(num2str(maxval(data(:, :, i, j)), '(F7.2)')))
-            call message('Total maxval: ', trim(num2str(maxval(data(:, :, :, :)), '(F7.2)')))
-            stop
-          end if
+      file_write2 : if (present(tmp_file)) then
+        open(unit = 999, file = trim(adjustl(tmp_file)), action = 'write', position = 'append', recl = (pnum + 2) * 30)
+        if (imaxit .lt. 0.0_dp) then
+          ! Maximize
+          write(999, *) i, -of_best, mdds
+        else
+          ! Minimize
+          write(999, *) i, of_best, mdds
         end if
+        close(999)
+      end if file_write2
 
-      end do
     end do
+    if (present(funcbest)) funcbest = of_best
 
-  end subroutine read_weights_nc
+  end function MDDS
 
   ! ------------------------------------------------------------------
 
-  !    NAME
-  !        get_time_vector_and_select
-
-  !    PURPOSE
-  !>       \brief TODO: add description
-
-  !>       \details TODO: add description
-
-  !>       ADDITIONAL INFORMATION
-  !>       get_time_vector_and_select
-  !>       Extract time vector in unit julian hours and get supposed time step in hours
-
-  !    INTENT(IN)
-  !>       \param[in] "type(NcVariable) :: var"    variable of interest
-  !>       \param[in] "character(256) :: fname"    fname of ncfile for error message
-
-  !    INTENT(OUT)
-  !>       \param[out] "integer(i4) :: time_start" time_start index of time selection
-  !>       \param[out] "integer(i4) :: time_cnt"   time_count of indexes of time selection
-  !>       \param[out] "integer(i4) :: inctimestep" flag for requested time step
-
-  !    INTENT(IN), OPTIONAL
-  !>       \param[in] "type(period), optional :: target_period" reference period
-
-
-  !    HISTORY
-  !>       \authors Matthias Zink
-
-  !>       \date Oct 2012
-
-  ! Modifications:
-  ! Matthias Cuntz & Juliane Mai Nov 2014 - time int or double
-  ! Stephan Thober               Sep 2015 - added read for hourly data
-  ! Robert Schweppe              Nov 2017 - restructured routine, reads vector now
-  ! Maren Kaluza                 May 2018 - fixed bug in time reading
-  ! Stephan Thober               Aug 2020 - fixed hourly reading
-  ! Stephan Thober               Jan 2022 - deactivated monthly and annual reading added nTstepForcingDay for hourly reading
+  ! Purpose is to generate a neighboring decision variable value for a single
+  !  decision variable value being perturbed by the DDS optimization algorithm.
+  !  New DV value respects the upper and lower DV bounds.
+  !  Coded by Bryan Tolson, Nov 2005.
+
+  ! I/O variable definitions:
+  !  x_cur     - current decision variable (DV) value
+  !  x_min     - min DV value
+  !  x_max     - max DV value
+  !  r         - the neighborhood perturbation factor
+  !  new_value - new DV variable value (within specified min and max)
 
-  subroutine get_time_vector_and_select(var, fname, inctimestep, time_start, time_cnt, target_period)
+  subroutine neigh_value(x_cur, x_min, x_max, r, new_value)
 
-    use mo_common_variables, only : period
-    use mo_constants, only : DayHours, DaySecs, YearDays
-    use mo_julian, only : caldat, dec2date, julday
-    use mo_kind, only : dp, i4, i8
-    use mo_message, only : message
-    use mo_netcdf, only : NcVariable
-    use mo_string_utils, only : DIVIDE_STRING
+    use mo_kind, only : i8, dp
+    use mo_xor4096, only : xor4096g
 
     implicit none
 
-    ! variable of interest
-    type(NcVariable), intent(in) :: var
-
-    ! fname of ncfile for error message
-    character(256), intent(in) :: fname
-
-    ! flag for requested time step
-    integer(i4), intent(out) :: inctimestep
-
-    ! time_start index of time selection
-    integer(i4), intent(out) :: time_start
-
-    ! time_count of indexes of time selection
-    integer(i4), intent(out) :: time_cnt
-
-    ! reference period
-    type(period), intent(in), optional :: target_period
-
-    ! reference time of NetCDF
-    integer(i4) :: yRef, dRef, mRef, hRef, jRef
-
-    ! netcdf attribute values
-    character(256) :: AttValues
-
-    ! dummies for netcdf attribute handling
-    character(256), dimension(:), allocatable :: strArr, date, time
-
-    ! native time step converter in ncfile
-    integer(i8) :: time_step_seconds
-
-    ! time vector
-    integer(i8), allocatable, dimension(:) :: time_data
-    integer(i8), allocatable, dimension(:) :: time_diff
-
-    ! period of ncfile, for clipping
-    type(period) :: nc_period, clip_period
-
-    integer(i4) :: ncJulSta1, dd, n_time
-
-    integer(i4) :: mmcalstart, mmcalend, yycalstart, yycalend
-
-    integer(i4) :: mmncstart, yyncstart
-
-    ! helper variable for error output
-    integer(i4) :: hstart_int, hend_int
-
-    ! helper variable for error output
-    character(256) :: error_msg
-
-
-    call var%getAttribute('units', AttValues)
-    ! AttValues looks like "<unit> since YYYY-MM-DD[ HH:MM:SS]"
-    ! split at space
-    call DIVIDE_STRING(trim(AttValues), ' ', strArr)
-
-    ! determine reference time at '-' and convert to integer
-    call DIVIDE_STRING(trim(strArr(3)), '-', date)
-    read(date(1), *) yRef
-    read(date(2), *) mRef
-    read(date(3), *) dRef
-
-    jRef = julday(dd = dRef, mm = mRef, yy = yRef)
-
-    ! if existing also read in the time (only hour so far)
-    hRef = 0
-    if(size(strArr) .gt. 3) then
-      call DIVIDE_STRING(trim(strArr(4)), ':', time)
-      read(time(1), *) hRef
-    end if
-
-    ! determine the step_size
-    if (strArr(1) .EQ. 'days') then
-      time_step_seconds = int(DaySecs)
-    else if (strArr(1) .eq. 'hours') then
-      time_step_seconds = int(DaySecs / DayHours)
-    else if (strArr(1) .eq. 'minutes') then
-      time_step_seconds = int(DaySecs / DayHours / 60._dp)
-    else if (strArr(1) .eq. 'seconds') then
-      time_step_seconds = 1_i8
-    else
-      call message('***ERROR: Please provide the input data in (days, hours, minutes, seconds) ', &
-              'since YYYY-MM-DD[ HH:MM:SS] in the netcdf file. Found: ', trim(AttValues))
-      stop
-    end if
-
-    ! get the time vector
-    call var%getData(time_data)
-    ! convert array from units since to seconds
-    time_data = time_data * time_step_seconds
-
-    ! check for length of time vector, needs to be at least of length 2, otherwise step width check fails
-    if (size(time_data) .le. 1) then
-      call message('***ERROR: length of time dimension needs to be at least 2 in file: ' // trim(fname))
-      stop
-    end if
-
-    ! check for equal timesteps and timestep must not be multiple of native timestep
-    error_msg = '***ERROR: time_steps are not equal over all times in file and/or do not conform to' // &
-            ' requested timestep in file (' // trim(fname) // ') : '
-
-    ! compare the read period from ncfile to the period required
-    ! convert julian second information back to date via conversion to float
-    ! the 0.5_dp is for the different reference of fractional julian days, hours are truncated
-    n_time = size(time_data)
-    call dec2date(time_data(1) / DaySecs - 0.5_dp + jRef + hRef / 24._dp, nc_period%dStart, nc_period%mStart, &
-            nc_period%yStart, hstart_int)
-    nc_period%julStart = int(time_data(1) / DaySecs + jRef + hRef / 24._dp)
-    call dec2date(time_data(n_time) / DaySecs - 0.5_dp + jRef + hRef / 24._dp, nc_period%dEnd, nc_period%mEnd, &
-            nc_period%yEnd, hend_int)
-    nc_period%julEnd = int(time_data(n_time) / DaySecs + jRef + hRef / 24._dp)
-
-    ! if no target period is present, use the whole time period
-    if (present(target_period)) then
-      clip_period = target_period
-    else
-      clip_period = nc_period
-    end if
-
-    ! calculate input resolution
-    allocate(time_diff(n_time - 1))
-    time_diff = (time_data(2 : n_time) - time_data(1 : n_time - 1)) / int(DaySecs, i8)
-    ! difference must be 1 day
-    if (all(abs(time_diff - 1._dp) .lt. 1._dp)) then
-       inctimestep = -1 ! daily
-    ! difference must be between 28 and 31 days
-    else if (all(abs(time_diff) .lt. 32._dp) .and. all(abs(time_diff) .gt. 27._dp)) then
-       inctimestep = -2 ! monthly
-    ! difference must be between 365 and 366 days
-    else if ((all(abs(time_diff) .lt. YearDays + 2)) .and. (all(abs(time_diff) .gt. YearDays - 1._dp))) then
-       inctimestep = -3 ! yearly
-    ! difference must be 1 hour
-    else if (all(abs((time_data(2 : n_time) - time_data(1 : n_time - 1)) / 3600._dp - 1._dp) .lt. 1.e-6)) then
-       inctimestep = -4 ! hourly
-    else
-       call message('***ERROR: read_forcing_nc: unknown nctimestep switch.')
-       stop 1
-    end if
-
-    ! prepare the selection and check for required time_step
-    select case(inctimestep)
-    case(-1) ! daily
-      ncJulSta1 = nc_period%julStart
-      time_start = clip_period%julStart - ncJulSta1 + 1_i4
-      time_cnt = clip_period%julEnd - clip_period%julStart + 1_i4
-    case(-2) ! monthly
-      call caldat(clip_period%julStart, dd, mmcalstart, yycalstart)
-      call caldat(nc_period%julStart, dd, mmncstart, yyncstart)
-      ! monthly timesteps are usually set by month end, so for beginning, we need 1st of month
-      ncJulSta1 = julday(1, mmncstart, yyncstart)
-      call caldat(clip_period%julEnd, dd, mmcalend, yycalend)
-      time_start = (yycalstart * 12 + mmcalstart) - (yyncstart * 12 + mmncstart) + 1_i4
-      time_cnt = (yycalend * 12 + mmcalend) - (yycalstart * 12 + mmcalstart) + 1_i4
-    case(-3) ! yearly
-      call caldat(clip_period%julStart, dd, mmcalstart, yycalstart)
-      call caldat(nc_period%julStart, dd, mmncstart, yyncstart)
-      ! yearly timesteps are usually set by year end, so for beginning, we need 1st of year
-      ncJulSta1 = julday(1, 1, yyncstart)
-      call caldat(clip_period%julEnd, dd, mmcalend, yycalend)
-      time_start = yycalstart - yyncstart + 1_i4
-      time_cnt = yycalend - yycalstart + 1_i4
-    case(-4) ! hourly
-      ncJulSta1 = nc_period%julStart
-      time_start = (clip_period%julStart - ncJulSta1) * 24_i4 + 1_i4 ! convert to hours; always starts at one
-      time_cnt = (clip_period%julEnd - clip_period%julStart + 1_i4) * 24_i4 ! convert to hours
-    case default ! no output at all
-      call message('***ERROR: read_nc: unknown nctimestep switch.')
-      stop
-    end select
-
-    ! Check if time steps in file cover simulation period
-    if (.not. ((ncJulSta1 .LE. clip_period%julStart) .AND. (nc_period%julEnd .GE. clip_period%julEnd))) then
-      call message('***ERROR: read_nc: time period of input data: ', trim(fname), &
-              '          is not matching modelling period.')
-      stop
+    real(dp), intent(in) :: x_cur, x_min, x_max, r
+    real(dp), intent(out) :: new_value
+    real(dp) :: x_range
+    real(dp) :: zvalue
+
+    x_range = x_max - x_min
+
+    ! generate a standard normal random variate (zvalue)
+    call xor4096g(0_i8, zvalue)
+
+    ! calculate new decision variable value:
+    new_value = x_cur + zvalue * r * x_range
+
+    !  check new value is within bounds. If not, bounds are reflecting.
+    if (new_value < x_min) then
+      new_value = x_min + (x_min - new_value)
+      if (new_value > x_max) then
+        ! if reflection goes past x_max then value should be x_min since
+        ! without reflection the approach goes way past lower bound.
+        ! This keeps x close to lower bound when x_cur is close to lower bound
+        ! Practically speaking, this should never happen with r values <0.3.
+        new_value = x_min
+      end if
+    else if (new_value > x_max) then
+      new_value = x_max - (new_value - x_max)
+      if (new_value < x_min) then
+        ! if reflection goes past x_min then value should be x_max for same reasons as above.
+        new_value = x_max
+      end if
     end if
 
-    ! free memory
-    deallocate(time_diff)
+  end subroutine neigh_value
 
-  end subroutine get_time_vector_and_select
+  ! ------------------------------------------------------------------
 
-end module mo_read_nc
+end module mo_dds
```

### Comparing `mhm-5.12.1.dev21/src/common/mo_read_spatial_data.f90` & `mhm-5.13.0/src/common/mo_read_spatial_data.f90`

 * *Files 4% similar despite different names*

```diff
@@ -1,31 +1,31 @@
-!>       \file mo_read_spatial_data.f90
-
-!>       \brief Reads spatial input data.
-
-!>       \details This module is to read spatial input data, e.g. dem, aspect, flow direction.
-!>       The module provides a subroutine for ASCII files.
-!>       (Subroutine for NetCDF files will come with release 5.1).
-!>       The data are read from the specified directory.
-
-!>       \authors Juliane Mai
-
-!>       \date Dec 2012
-
-! Modifications:
-
+!> \file mo_read_spatial_data.f90
+!> \brief \copybrief mo_read_spatial_data
+!> \details \copydetails mo_read_spatial_data
+
+!> \brief Reads spatial input data.
+!> \details This module is to read spatial input data, e.g. dem, aspect, flow direction.
+!! The module provides a subroutine for ASCII files.
+!! (Subroutine for NetCDF files will come with release 5.1).
+!! The data are read from the specified directory.
+!> \authors Juliane Mai
+!> \date Dec 2012
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_common
 MODULE mo_read_spatial_data
 
   ! This module provides routines to read spatial data.
 
   ! Written  Juliane Mai, Jan 2013
-  ! Modified 
+  ! Modified
 
   USE mo_kind, ONLY : i4, dp
-  USE mo_os, ONLY : path_isfile
+  USE mo_os, ONLY : check_path_isfile
+  use mo_message, only: error_message
 
   IMPLICIT NONE
 
   PUBLIC :: read_header_ascii           ! Reads header of ASCII files
   PUBLIC :: read_spatial_data_ascii     ! Read ASCII  files
   ! PUBLIC :: read_spatial_data_nc      ! Read netCDF files -> will be implemented in release 5.1
 
@@ -150,33 +150,33 @@
 
 
     ! compare headers always with reference header (intent in)
     call read_header_ascii(filename, fileunit, &
             file_ncols, file_nrows, &
             file_xllcorner, file_yllcorner, file_cellsize, file_nodata)
     if ((file_ncols .ne. header_ncols)) &
-            stop 'read_spatial_data_ascii: header not matching with reference header: ncols'
+             call error_message('read_spatial_data_ascii: header not matching with reference header: ncols')
     if ((file_nrows .ne. header_nrows)) &
-            stop 'read_spatial_data_ascii: header not matching with reference header: nrows'
+             call error_message('read_spatial_data_ascii: header not matching with reference header: nrows')
     if ((abs(file_xllcorner - header_xllcorner) .gt. tiny(1.0_dp))) &
-            stop 'read_spatial_data_ascii: header not matching with reference header: xllcorner'
+             call error_message('read_spatial_data_ascii: header not matching with reference header: xllcorner')
     if ((abs(file_yllcorner - header_yllcorner) .gt. tiny(1.0_dp))) &
-            stop 'read_spatial_data_ascii: header not matching with reference header: yllcorner'
+             call error_message('read_spatial_data_ascii: header not matching with reference header: yllcorner')
     if ((abs(file_cellsize - header_cellsize)   .gt. tiny(1.0_dp))) &
-            stop 'read_spatial_data_ascii: header not matching with reference header: cellsize'
+             call error_message('read_spatial_data_ascii: header not matching with reference header: cellsize')
 
     ! allocation and initialization of matrices
     allocate(tmp_data(file_nrows, file_ncols))
     tmp_data = file_nodata
     allocate(tmp_mask(file_nrows, file_ncols))
     tmp_mask = .true.
 
-    
+
     !checking whether the file exists
-    call path_isfile(path = filename, quiet_ = .true., throwError_ = .true.)
+    call check_path_isfile(path = filename, raise=.true.)
     ! read in
     ! recl is only a rough estimate on bytes per line in the ascii
     ! default for nag: recl=1024(byte) which is not enough for 100s of columns
     open (unit = fileunit, file = filename, action = 'read', status = 'old', recl = 48 * file_ncols)
     ! (a) skip header
     do i = 1, 6
       read(fileunit, *)
@@ -290,32 +290,32 @@
 
 
     ! compare headers always with reference header (intent in)
     call read_header_ascii(filename, fileunit, &
             file_ncols, file_nrows, &
             file_xllcorner, file_yllcorner, file_cellsize, file_nodata)
     if ((file_ncols .ne. header_ncols)) &
-            stop 'read_spatial_data_ascii: header not matching with reference header: ncols'
+             call error_message('read_spatial_data_ascii: header not matching with reference header: ncols')
     if ((file_nrows .ne. header_nrows)) &
-            stop 'read_spatial_data_ascii: header not matching with reference header: nrows'
+             call error_message('read_spatial_data_ascii: header not matching with reference header: nrows')
     if ((abs(file_xllcorner - header_xllcorner) .gt. tiny(1.0_dp))) &
-            stop 'read_spatial_data_ascii: header not matching with reference header: xllcorner'
+             call error_message('read_spatial_data_ascii: header not matching with reference header: xllcorner')
     if ((abs(file_yllcorner - header_yllcorner) .gt. tiny(1.0_dp))) &
-            stop 'read_spatial_data_ascii: header not matching with reference header: yllcorner'
+             call error_message('read_spatial_data_ascii: header not matching with reference header: yllcorner')
     if ((abs(file_cellsize - header_cellsize)   .gt. tiny(1.0_dp))) &
-            stop 'read_spatial_data_ascii: header not matching with reference header: cellsize'
+             call error_message('read_spatial_data_ascii: header not matching with reference header: cellsize')
 
     ! allocation and initialization of matrices
     allocate(tmp_data(file_nrows, file_ncols))
     tmp_data = int(file_nodata, i4)
     allocate(tmp_mask(file_nrows, file_ncols))
     tmp_mask = .true.
 
     !checking whether the file exists
-    call path_isfile(path = filename, quiet_ = .true., throwError_ = .true.)
+    call check_path_isfile(path = filename, raise=.true.)
     ! read in
     ! recl is only a rough estimate on bytes per line in the ascii
     ! default for nag: recl=1024(byte) which is not enough for 100s of columns
     open (unit = fileunit, file = filename, action = 'read', status = 'old', recl = 48 * file_ncols)
     ! (a) skip header
     do i = 1, 6
       read(fileunit, *)
@@ -370,14 +370,15 @@
   !>       \date Jan 2013
 
   ! Modifications:
   ! Robert Schweppe Jun 2018 - refactoring and reformatting
 
   subroutine read_header_ascii(filename, fileunit, header_ncols, header_nrows, header_xllcorner, header_yllcorner, &
                               header_cellsize, header_nodata)
+    use mo_common_constants, only : nodata_dp
     implicit none
 
     ! Name of file and its location
     character(len = *), intent(in) :: filename
 
     ! File unit for open file
     integer(i4), intent(in) :: fileunit
@@ -397,25 +398,27 @@
     ! Reference cell size [m]
     real(dp), intent(out) :: header_cellsize
 
     ! Reference nodata value
     real(dp), intent(out) :: header_nodata
 
     character(5) :: dummy
-
+    integer(i4) :: io
 
     !checking whether the file exists
-    call path_isfile(path = filename, quiet_ = .true., throwError_ = .true.)
+    call check_path_isfile(path = filename, raise=.true.)
     ! reading header from a file
     open (unit = fileunit, file = filename, status = 'old')
     read (fileunit, *) dummy, header_nCols
     read (fileunit, *) dummy, header_nRows
     read (fileunit, *) dummy, header_xllcorner
     read (fileunit, *) dummy, header_yllcorner
     read (fileunit, *) dummy, header_cellsize
-    read (fileunit, *) dummy, header_nodata
+    read (fileunit, *, iostat=io) dummy, header_nodata
+    ! EOF reached (nodata not present, use default value)
+    if (io < 0) header_nodata = nodata_dp
     close(fileunit)
     dummy = dummy // ''   ! only to avoid warning
 
   end subroutine read_header_ascii
 
 END MODULE mo_read_spatial_data
```

### Comparing `mhm-5.12.1.dev21/src/common/mo_read_timeseries.f90` & `mhm-5.13.0/src/common/mo_read_timeseries.f90`

 * *Files 6% similar despite different names*

```diff
@@ -1,24 +1,23 @@
-!>       \file mo_read_timeseries.f90
-
-!>       \brief Routines to read files containing timeseries data.
-
-!>       \details This routine is reading time series input data for a particular time period. The files need to have a
-!>       specific header specified in the different routines.
-
-!>       \authors Matthias Zink, Juliane Mai
-
-!>       \date Jan 2013
-
-! Modifications:
-
+!> \file mo_read_timeseries.f90
+!> \brief \copybrief mo_read_timeseries
+!> \details \copydetails mo_read_timeseries
+
+!> \brief Routines to read files containing timeseries data.
+!> \details This routine is reading time series input data for a particular time period. The files need to have a
+!! specific header specified in the different routines.
+!> \authors Matthias Zink, Juliane Mai
+!> \date Jan 2013
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_common
 MODULE mo_read_timeseries
 
   USE mo_kind, ONLY : i4, dp
-  USE mo_os, ONLY : path_isfile
+  USE mo_os, ONLY : check_path_isfile
 
   IMPLICIT NONE
 
   PUBLIC :: read_timeseries
 
 CONTAINS
 
@@ -70,15 +69,15 @@
   ! MatthiasZink               Mar 2014 - : enable    read in of nodata periods, e.g. forecast mode
   ! Matthias Zink, Juliane Mai Jan 2015 - : corrected read in of nodata periods, e.g. forecast mode
 
   subroutine read_timeseries(filename, fileunit, periodStart, periodEnd, optimize, opti_function, data, mask, &
                             nMeasPerDay)
 
     use mo_julian, only : julday
-    use mo_message, only : message, error_message
+    use mo_message, only : error_message
     use mo_string_utils, only : num2str
 
     implicit none
 
     ! File name
     character(len = *), intent(in) :: filename
 
@@ -157,43 +156,41 @@
     real(dp), dimension(:), allocatable :: data_file
 
     ! dummy for char read in
     character(256) :: dummy
 
 
     !checking whether the file exists
-    call path_isfile(path = filename, quiet_ = .true., throwError_ = .true.)
+    call check_path_isfile(path = filename, raise=.true.)
     open(unit = fileunit, file = filename, action = 'read', status = 'old')
     ! read header
     read(fileunit, '(a256)') dummy
     read(fileunit, *)        dummy, nodata_file
     read(fileunit, *)        dummy, timestep_file
     read(fileunit, *)        dummy, (periodStart_file(i), i = 1, 3)
     read(fileunit, *)        dummy, (periodEnd_file(i), i = 1, 3)
     dummy = dummy // ''   ! only to avoid warning
     if ((timestep_file .lt. 1_i4) .or. (timestep_file .gt. 1440_i4)) then
-      call message('***ERROR: Number of measurements per day has to be between 1 (daily) and 1440 (every minute)! ', &
+      call error_message('***ERROR: Number of measurements per day has to be between 1 (daily) and 1440 (every minute)! ', &
               trim(filename))
-      stop
     end if
 
     ! checking if period is covered by data in file
     startJul_period = julday(periodStart(3), periodStart(2), periodStart(1))
     endJul_period = julday(periodEnd(3), periodEnd(2), periodEnd(1))
     startJul_file = julday(periodStart_file(3), periodStart_file(2), periodStart_file(1))
     endJul_file = julday(periodEnd_file(3), periodEnd_file(2), periodEnd_file(1))
 
     if (((startJul_period < startJul_file) .OR. (endJul_period > endJul_file)) &
             .AND. optimize .and. ((opti_function .le. 9_i4) .or. &
             (opti_function .eq. 14_i4) .or. &
             (opti_function .eq. 31_i4) .or. &
             (opti_function .eq. 33_i4))) then
       ! adjust this whenever a new opti function on discharge is added to mhm!
-      call message('***ERROR: Simulation period is not covered by observations! ', trim(filename))
-      stop
+      call error_message('***ERROR: Simulation period is not covered by observations! ', trim(filename))
     end if
 
     ! allocation of arrays
     allocate(data     ((endJul_period - startJul_period + 1_i4) * timestep_file))
     data = nodata_file
     allocate(data_file((endJul_file - startJul_file + 1_i4) * timestep_file))
     data_file = nodata_file
```

### Comparing `mhm-5.12.1.dev21/src/common_mHM_mRM/mo_common_mHM_mRM_read_config.f90` & `mhm-5.13.0/src/common/mo_common_mHM_mRM_read_config.f90`

 * *Files 6% similar despite different names*

```diff
@@ -1,77 +1,61 @@
-!>       \file mo_common_mHM_mRM_read_config.f90
-
-!>       \brief Reading of main model configurations.
-
-!>       \details This routine reads the configurations of common program parts
-
-!>       \authors Matthias Zink
-
-!>       \date Dec 2012
-
-! Modifications:
-
+!> \file mo_common_mHM_mRM_read_config.f90
+!> \brief \copybrief mo_common_mhm_mrm_read_config
+!> \details \copydetails mo_common_mhm_mrm_read_config
+
+!> \brief Reading of main model configurations.
+!> \details This routine reads the configurations of common program parts
+!> \authors Matthias Zink
+!> \date Dec 2012
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_common
 MODULE mo_common_mHM_mRM_read_config
 
-  USE mo_kind, ONLY : i4, dp
+  use mo_kind, only : i4, dp
+  use mo_message, only : message, error_message
 
   IMPLICIT NONE
 
   PRIVATE
 
   PUBLIC :: common_mHM_mRM_read_config, common_check_resolution, check_optimization_settings
 
-  ! ------------------------------------------------------------------
-
 CONTAINS
 
-  ! ------------------------------------------------------------------
-
-  !    NAME
-  !        common_mHM_mRM_read_config
-
-  !    PURPOSE
-  !>       \brief Read main configurations for common parts
-
-  !>       \details TODO: add description
-
-  !    INTENT(IN)
-  !>       \param[in] "character(*) :: file_namelist"
-  !>       \param[in] "integer :: unamelist"
-
-  !    HISTORY
-  !>       \authors Matthias Zink
-
-  !>       \date Dec 2012
-
-  ! Modifications:
-  ! Robert Schweppe Dec  2017 - based on mhm_read_config
-  ! Stephan Thober Jan 2022 - added nTStepForcingDay
 
+  !> \brief Read main configurations for common parts
+  !> \changelog
+  !! - Robert Schweppe Dec  2017
+  !!   - based on mhm_read_config
+  !! - Stephan Thober Jan 2022
+  !!   - added nTStepForcingDay
+  !> \authors Matthias Zink
+  !> \date Dec 2012
   subroutine common_mHM_mRM_read_config(file_namelist, unamelist)
 
     use mo_common_constants, only : maxNoDomains, nodata_i4
     use mo_common_mHM_mRM_variables, only : LCyearId, dds_r, mhmFileRestartIn, mrmFileRestartIn, evalPer,&
                                             mcmc_error_params, mcmc_opti, nIterations, &
-                                            nTStepDay, nTStepForcingDay, opti_function, opti_method, optimize, optimize_restart, &
+                                            nTStepDay, opti_function, opti_method, optimize, optimize_restart, &
                                             read_restart, mrm_read_river_network, resolutionRouting, sa_temp, &
                                             sce_ngs, sce_npg, sce_nps, seed, &
-                                            simPer, timestep, warmPer, warmingDays, read_old_style_restart_bounds
+                                            simPer, timestep, warmPer, warmingDays, read_old_style_restart_bounds, &
+                                            restart_reset_fluxes_states
     use mo_common_read_config, only : set_land_cover_scenes_id
-    use mo_common_variables, only : LCfilename, domainMeta, period, processMatrix
+    use mo_common_types, only: period
+    use mo_common_variables, only : LCfilename, domainMeta, processMatrix
     use mo_julian, only : caldat, julday
-    use mo_message, only : message
     use mo_nml, only : close_nml, open_nml, position_nml
     use mo_string_utils, only : num2str
 
     implicit none
 
-    character(*), intent(in) :: file_namelist
-
-    integer, intent(in) :: unamelist
+    character(*), intent(in) :: file_namelist !< namelist file name
+    integer, intent(in) :: unamelist !< unit to open namelist file
 
     integer(i4) :: jday
 
     integer(i4) :: domainID, iDomain
 
     integer(i4), dimension(maxNoDomains) :: warming_Days
 
@@ -82,25 +66,26 @@
     character(256), dimension(maxNoDomains) :: mhm_file_RestartIn
     character(256), dimension(maxNoDomains) :: mrm_file_RestartIn
 
 
     ! namelist spatial & temporal resolution, otmization information
     namelist /mainconfig_mhm_mrm/ timestep, resolution_Routing, optimize, &
             optimize_restart, opti_method, opti_function, &
-            read_restart, mrm_read_river_network, read_old_style_restart_bounds, &
+            read_restart, mrm_read_river_network, read_old_style_restart_bounds, restart_reset_fluxes_states, &
             mhm_file_RestartIn, mrm_file_RestartIn
     ! namelist for optimization settings
     namelist /Optimization/ nIterations, seed, dds_r, sa_temp, sce_ngs, &
             sce_npg, sce_nps, mcmc_opti, mcmc_error_params
     ! namelist for time settings
     namelist /time_periods/ warming_Days, eval_Per
 
     ! set default values for optional arguments
     mrm_read_river_network = .false.
     read_old_style_restart_bounds = .false.
+    restart_reset_fluxes_states = .false.
 
     !===============================================================
     !  Read namelist main directories
     !===============================================================
     call open_nml(file_namelist, unamelist, quiet = .true.)
 
     !===============================================================
@@ -125,16 +110,15 @@
       mrmFileRestartIn(iDomain) = mrm_file_RestartIn(domainID)
       resolutionRouting(iDomain) = resolution_Routing(domainID)
     end do
 
     ! check for optimize and read restart
     if ((read_restart) .and. (optimize)) then
       call message()
-      call message('***ERROR: cannot read states from restart file when optimizing')
-      stop 1
+      call error_message('***ERROR: cannot read states from restart file when optimizing')
     end if
 
     do iDomain = 1, domainMeta%nDomains
       domainID = domainMeta%indices(iDomain)
       if (processMatrix(8, 1) > 0 .and. domainMeta%optidata(iDomain) > 1 .and. optimize) then
         domainMeta%doRouting(iDomain) = .FALSE.
         call message('Warning: although defined in namelist, routing is switched off for domain', trim(num2str(domainID)))
@@ -143,19 +127,17 @@
     end do
 
     !===============================================================
     !  INIT !!! (merged from mo_startup and mo_mrm_read_config)
     !===============================================================
     ! transformation of time units & constants
     if (mod(24, timeStep) > 0) then
-      call message('mo_startup: timeStep must be a divisor of 24: ', num2str(timeStep))
-      stop 1
+      call error_message('mo_startup: timeStep must be a divisor of 24: ', num2str(timeStep))
     end if
     nTStepDay = 24_i4 / timeStep            ! # of time steps per day
-    nTStepForcingDay = nodata_i4            ! # init of number of forcing timesteps, will be set when reading forcings
 
     ! allocate time periods
     allocate(simPer(domainMeta%nDomains))
     allocate(evalPer(domainMeta%nDomains))
     allocate(warmingDays(domainMeta%nDomains))
     allocate(warmPer(domainMeta%nDomains))
 
@@ -215,102 +197,69 @@
     read(unamelist, nml = Optimization)
     ! checking of settings and default value initialization moved to new subroutine
     ! because global_parameters need to be set, which is not the case right now
     call close_nml(unamelist)
 
   end subroutine common_mHM_mRM_read_config
 
-  !    NAME
-  !        check_optimization_settings
-
-  !    PURPOSE
-  !>       \brief TODO: add description
-
-  !>       \details TODO: add description
-
-  !    HISTORY
-  !>       \authors Robert Schweppe
-
-  !>       \date Jun 2018
-
-  ! Modifications:
 
+  !> \brief check optimization settings
+  !> \authors Robert Schweppe
+  !> \date Jun 2018
   subroutine check_optimization_settings
 
     use mo_common_mHM_mRM_variables, only : dds_r, nIterations, sce_ngs, sce_npg, sce_nps
     use mo_common_variables, only : global_parameters
-    use mo_message, only : message
 
     implicit none
 
     integer(i4) :: n_true_pars
 
 
     ! check and set default values
     if (nIterations .le. 0_i4) then
-      call message('Number of iterations for Optimization (nIterations) must be greater than zero')
-      stop 1
+      call error_message('Number of iterations for Optimization (nIterations) must be greater than zero')
     end if
     if (dds_r .lt. 0.0_dp .or. dds_r .gt. 1.0_dp) then
-      call message('dds_r must be between 0.0 and 1.0')
-      stop 1
+      call error_message('dds_r must be between 0.0 and 1.0')
     end if
     if (sce_ngs .lt. 1_i4) then
-      call message ('number of complexes in SCE (sce_ngs) must be at least 1')
-      stop 1
+      call error_message('number of complexes in SCE (sce_ngs) must be at least 1')
     end if
     ! number of points in each complex: default = 2n+1
     if (sce_npg .lt. 0_i4) then
       n_true_pars = count(nint(global_parameters(:, 4)) .eq. 1)
       sce_npg = 2 * n_true_pars + 1_i4
     end if
     ! number of points in each sub-complex: default = n+1
     if (sce_nps .lt. 0_i4) then
       n_true_pars = count(nint(global_parameters(:, 4)) .eq. 1)
       sce_nps = n_true_pars + 1_i4
     end if
     if (sce_npg .lt. sce_nps) then
-      call message ('number of points per complex (sce_npg) must be greater or')
-      call message ('equal number of points per sub-complex (sce_nps)')
-      stop 1
+      call error_message('number of points per complex (sce_npg) must be greater or', raise=.false.)
+      call error_message('equal number of points per sub-complex (sce_nps)')
     end if
 
   end subroutine check_optimization_settings
 
-  !    NAME
-  !        common_check_resolution
-
-  !    PURPOSE
-  !>       \brief TODO: add description
-
-  !>       \details TODO: add description
-
-  !    INTENT(IN)
-  !>       \param[in] "logical :: do_message"
-  !>       \param[in] "logical :: allow_subgrid_routing"
-
-  !    HISTORY
-  !>       \authors Robert Schweppe
-
-  !>       \date Jun 2018
-
-  ! Modifications:
 
+  !> \brief check resolution
+  !> \authors Robert Schweppe
+  !> \date Jun 2018
   subroutine common_check_resolution(do_message, allow_subgrid_routing)
 
     use mo_common_mHM_mRM_variables, only : resolutionRouting
     use mo_common_variables, only : domainMeta, resolutionHydrology
-    use mo_message, only : message
     use mo_string_utils, only : num2str
 
     implicit none
 
-    logical, intent(in) :: do_message
-
-    logical, intent(in) :: allow_subgrid_routing
+    logical, intent(in) :: do_message !< flag to print messages
+    logical, intent(in) :: allow_subgrid_routing !< flag to allow subgrid routing
 
     integer(i4) :: iDomain, domainID
 
     ! conversion factor L11 to L1
     real(dp) :: cellFactorRbyH
 
 
@@ -333,42 +282,43 @@
         if (do_message) then
           call message()
           call message('Resolution of routing and hydrological modeling are equal!')
         end if
 
       else if ((nint(cellFactorRbyH * 100.0_dp) .gt. 100) .and. .not.allow_subgrid_routing) then
         if(nint(mod(cellFactorRbyH, 2.0_dp) * 100.0_dp) .ne. 0) then
-          call message()
-          call message('***ERROR: Resolution of routing is not a multiple of hydrological model resolution!')
-          call message('   FILE: mhm.nml, namelist: mainconfig, variable: resolutionRouting')
-          STOP
+          call error_message('***ERROR: Resolution of routing is not a multiple of hydrological model resolution!', raise=.false.)
+          call error_message('   FILE: mhm.nml, namelist: mainconfig, variable: resolutionRouting')
         end if
         !
         if (do_message) then
           call message()
           call message('Resolution of routing is bigger than hydrological model resolution by ', &
                   trim(adjustl(num2str(nint(cellFactorRbyH)))), ' times !')
         end if
       end if
       !
     end do
 
   end subroutine common_check_resolution
 
+
   ! ToDo: make this a procedure of period
+  !> \brief copy period data
   subroutine period_copy_period_data(toPeriod, fromPeriod)
-    use mo_common_variables, only : period
-    type(period), intent(inout) :: toPeriod
-    type(period), intent(in)    :: fromPeriod
+    use mo_common_types, only: period
+    type(period), intent(inout) :: toPeriod !< copy to this period
+    type(period), intent(in)    :: fromPeriod !< copy from this period
 
     toPeriod%dStart   = fromPeriod%dStart    ! first day
     toPeriod%mStart   = fromPeriod%mStart    ! first month
     toPeriod%yStart   = fromPeriod%yStart    ! first year
     toPeriod%dEnd     = fromPeriod%dEnd      ! last  day
     toPeriod%mEnd     = fromPeriod%mEnd      ! last  month
     toPeriod%yEnd     = fromPeriod%yEnd      ! last  year
     toPeriod%julStart = 0 ! first julian day
     toPeriod%julEnd   = 0 ! last  julian day
     toPeriod%nObs     = 0 ! total number of observations
 
   end subroutine period_copy_period_data
+
 END MODULE mo_common_mHM_mRM_read_config
```

### Comparing `mhm-5.12.1.dev21/src/common_mHM_mRM/mo_common_mHM_mRM_variables.f90` & `mhm-5.13.0/src/common/mo_common_mHM_mRM_variables.f90`

 * *Files 6% similar despite different names*

```diff
@@ -1,27 +1,29 @@
-!>       \file mo_common_mHM_mRM_variables.f90
-
-!>       \brief Provides structures needed by mHM, mRM and/or mpr.
-
-!>       \details Provides the global structure period that is used
-!>       by both mHM and mRM.
-
-!>       \authors Stephan Thober
-
-!>       \date Sep 2015
-
-! Modifications:
-! Stephan Thober  Nov 2016 - moved processdescription from mo_global_variables to here
-! Robert Schweppe Dec 2017 - merged more duplicated variables from mhm and mrm global variables
-! Robert Schweppe Jun 2018 - refactoring and reformatting
-
+!> \file mo_common_mHM_mRM_variables.f90
+!> \brief \copybrief mo_common_mhm_mrm_variables
+!> \details \copydetails mo_common_mhm_mrm_variables
+
+!> \brief Provides structures needed by mHM, mRM and/or mpr.
+!> \details Provides the global structure period that is used by both mHM and mRM.
+!> \changelog
+!! - Stephan Thober  Nov 2016
+!!   - moved processdescription from mo_global_variables to here
+!! - Robert Schweppe Dec 2017
+!!   - merged more duplicated variables from mhm and mrm global variables
+!! - Robert Schweppe Jun 2018
+!!   - refactoring and reformatting
+!> \authors Stephan Thober
+!> \date Sep 2015
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_common
 module mo_common_mHM_mRM_variables
 
   use mo_kind, only : i4, i8, dp
-  use mo_common_variables, only : period
+  use mo_common_types, only: period
   implicit none
 
   ! -------------------------------------------------------------------
   ! INPUT variables for configuration of main part
   ! -------------------------------------------------------------------
   integer(i4) :: mrm_coupling_mode !-1 = no mrm (mHM only)
   !                                ! 0 = stand alone (mRM only)
@@ -30,28 +32,27 @@
 
   integer(i4), public :: timeStep                   ! [h] simulation time step (= TS) in [h]
   real(dp), public :: c2TSTu            !       Unit transformation = timeStep/24
   real(dp), dimension(:), allocatable, public :: resolutionRouting          ! [m or degree] resolution of routing - Level 11
   logical, public :: read_restart               ! flag
   logical, public :: mrm_read_river_network     ! flag
   logical, public :: read_old_style_restart_bounds     ! flag
-  
+  logical, public :: restart_reset_fluxes_states     !< flag to reset fluxes and states read from restart to default values
+
 
   type(period), dimension(:), allocatable, public :: warmPer     ! time period for warming
   type(period), dimension(:), allocatable, public :: evalPer     ! time period for model evaluation
   type(period), dimension(:), allocatable, public :: simPer      ! warmPer + evalPer
-  type(period), public :: readPer     ! start and end dates of read period
   integer(i4), dimension(:), allocatable, public :: warmingDays ! number of days for warm up period
   integer(i4), dimension(:, :), allocatable, public :: LCyearId            ! Mapping of landcover scenes (1, 2,..) for each domain
 
   ! ------------------------------------------------------------------
   ! CONSTANT
   ! ------------------------------------------------------------------
   integer(i4), public :: nTstepDay          !       Number of time intervals per day
-  integer(i4), public :: nTstepForcingDay   !       Number of forcing intervals per day
 
   ! ------------------------------------------------------------------
   ! DIRECTORIES
   ! ------------------------------------------------------------------
   ! has the dimension of nDomains
   character(256), dimension(:), allocatable, public :: mhmFileRestartIn! Directory where input of restart is read from
   character(256), dimension(:), allocatable, public :: mrmFileRestartIn! Directory where input of restart is read from
```

### Comparing `mhm-5.12.1.dev21/src/common_mHM_mRM/mo_optimization.F90` & `mhm-5.13.0/src/common/mo_optimization.F90`

 * *Files 2% similar despite different names*

```diff
@@ -1,20 +1,18 @@
-!>       \file mo_optimization.f90
-
-!>       \brief Wrapper subroutine for optimization against runoff and sm.
-
-!>       \details This module provides a wrapper subroutine for optimization of mRM/mHM
-!>       against runoff or soil moisture.
-
-!>       \authors Stephan Thober
-
-!>       \date Oct 2015
-
-! Modifications:
-
+!> \file mo_optimization.f90
+!> \brief \copybrief mo_optimization
+!> \details \copydetails mo_optimization
+
+!> \brief Wrapper subroutine for optimization against runoff and sm.
+!> \details This module provides a wrapper subroutine for optimization of mRM/mHM against runoff or soil moisture.
+!> \authors Stephan Thober
+!> \date Oct 2015
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_common
 module mo_optimization
   use mo_kind, only : i4, i8, dp
   use mo_optimization_utils, only : eval_interface, objective_interface
   implicit none
   private
   public :: optimization
 
@@ -188,35 +186,32 @@
                 ParaSelectMode_in = 2_i4, tmp_file = tFile, &
                 maskpara_in = local_maskpara, &
                 restart = optimize_restart, restart_file = 'mo_mcmc.restart', &
                 ! stepsize_in=step,                                                                                         &
                 seed_in = iseed, loglike_in = .true., printflag_in = .true.)
       case (4)
         if (optimize_restart) then
-          call message('ERROR: A restart of this optimization method is not implemented yet!')
-          stop 1
+          call error_message('ERROR: A restart of this optimization method is not implemented yet!')
         end if
         call message('    Use MCMC_STDDEV')
         call mcmc_stddev(eval, objective, local_parameters(:, 3), local_parameters(:, 1 : 2), mcmc_paras, burnin_paras, &
                 ParaSelectMode_in = 2_i4, tmp_file = tFile, &
                 maskpara_in = local_maskpara, &
                 seed_in = iseed, loglike_in = .true., printflag_in = .true.)
       case default
-        call message("Error objective: This opti_function is either not implemented yet.")
-        stop 1
+        call error_message("Error objective: This opti_function is either not implemented yet.")
       end select
 
     case (1)
       call message('    Use DDS')
 
       tFile = trim(adjustl(dirConfigOut)) // 'dds_results.out'
 
       if (optimize_restart) then
-        call message('ERROR: A restart of this optimization method is not implemented yet!')
-        stop 1
+        call error_message('ERROR: A restart of this optimization method is not implemented yet!')
       end if
       ! use fixed user-defined seed
 #ifdef MPI
       local_parameters(:, 3) = dds(eval, objective, local_parameters(:, 3), local_parameters(:, 1 : 2), &
               maxiter = int(nIterations, i8), r = dds_r, seed = iseed, &
               tmp_file = tFile, comm = domainMeta%comMaster, mask = local_maskpara, &
               funcbest = funcbest)
@@ -229,16 +224,15 @@
 
     case (2)
       call message('    Use Simulated Annealing')
 
       tFile = trim(adjustl(dirConfigOut)) // 'anneal_results.out'
 
       if (optimize_restart) then
-        call message('ERROR: A restart of this optimization method is not implemented yet!')
-        stop 1
+        call error_message('ERROR: A restart of this optimization method is not implemented yet!')
       end if
 
       if (sa_temp .gt. 0.0_dp) then
         ! use fixed user-defined seed and user-defined initial temperature
         local_parameters(:, 3) = anneal(eval, objective, local_parameters(:, 3), local_parameters(:, 1 : 2), &
                 temp = sa_temp, seeds = (/iseed, iseed + 1000_i8, iseed + 2000_i8/), nITERmax = nIterations, &
                 tmp_file = tFile, maskpara = local_maskpara, &
```

### Comparing `mhm-5.12.1.dev21/src/mHM/mo_canopy_interc.f90` & `mhm-5.13.0/src/mHM/mo_canopy_interc.f90`

 * *Files 12% similar despite different names*

```diff
@@ -1,20 +1,21 @@
-!>       \file mo_canopy_interc.f90
-
-!>       \brief Canopy interception.
-
-!>       \details This module deals with processes related to canopy interception, evaporation and throughfall.
-
-!>       \authors Vladyslav Prykhodko
-
-!>       \date Dec 2012
-
-! Modifications:
-! RK Sep 2013 - Documentation updated (formula and a short description added)
-
+!> \file mo_canopy_interc.f90
+!> \brief \copybrief mo_canopy_interc
+!> \details \copydetails mo_canopy_interc
+
+!> \brief Canopy interception.
+!> \details This module deals with processes related to canopy interception, evaporation and throughfall.
+!> \changelog
+!! - RK Sep 2013
+!!   - Documentation updated (formula and a short description added)
+!> \authors Vladyslav Prykhodko
+!> \date Dec 2012
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mhm
 MODULE mo_canopy_interc
 
   USE mo_kind, ONLY : dp
   USE mo_common_constants, ONLY : eps_dp
   USE mo_constants, ONLY : twothird_dp
 
   IMPLICIT NONE
```

### Comparing `mhm-5.12.1.dev21/src/mHM/mo_file.F90` & `mhm-5.13.0/src/mHM/mo_file.F90`

 * *Files 14% similar despite different names*

```diff
@@ -1,36 +1,38 @@
-!>       \file mo_file.f90
-
-!>       \brief Provides file names and units for mHM
-
-!>       \details Provides all filenames as well as all units used for the hydrologic model mHM.
-!!                The \c version parameter will be set during compilation to
-!!                \"\htmlinclude version.txt \latexinclude version.txt\".
-!!                The \c version_date parameter will be set during compilation to
-!!                \"\htmlinclude version_date.txt \latexinclude version_date.txt\",
-!!                if it is a release version, otherwise it will be the current date.
-
-!>       \authors Matthias Cuntz
-!>       \authors Sebastian Mueller
-
-!>       \date Jan 2012
-
-! Modifications:
-! Robert Schweppe Jun 2018 - refactoring and reformatting
-! Sebastian Mueller Sep 2020 - setting version with pre-processor from version file
-
 #ifndef MHMVERSION
 #define MHMVERSION "0.0.0-dev0"
 #endif
 #ifndef MHMDATE
 #define MHMDATE __DATE__
 #endif
 #define set_version(x) CHARACTER(len = *), PARAMETER :: version = x
 #define set_date(x) CHARACTER(len = *), PARAMETER :: version_date = x
 
+!> \file mo_file.F90
+!> \brief \copybrief mo_file
+!> \details \copydetails mo_file
+
+!> \brief Provides file names and units for mHM
+!> \details Provides all filenames as well as all units used for the hydrologic model mHM.
+!! The \c version parameter will be set during compilation to
+!! \"\htmlinclude version.txt \latexinclude version.txt\".
+!! The \c version_date parameter will be set during compilation to
+!! \"\htmlinclude version_date.txt \latexinclude version_date.txt\",
+!! if it is a release version, otherwise it will be the current date.
+!> \changelog
+!! - Robert Schweppe Jun 2018
+!!   - refactoring and reformatting
+!! - Sebastian Mueller Sep 2020
+!!   - setting version with pre-processor from version file
+!> \authors Matthias Cuntz
+!> \authors Sebastian Mueller
+!> \date Jan 2012
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mhm
 MODULE mo_file
 
   IMPLICIT NONE
 
   set_version(MHMVERSION)
   !< Current mHM model version (will be set to \htmlinclude version.txt \latexinclude version.txt)
 
@@ -47,9 +49,11 @@
   character(:), allocatable :: file_namelist_mhm_param ! = 'mhm_parameter.nml'
   !> Unit for namelist
   INTEGER, PARAMETER :: unamelist_mhm_param = 31
   !> file defining mHM's outputs
   character(:), allocatable :: file_defOutput ! = 'mhm_outputs.nml'
   !> Unit for file defining mHM's outputs
   INTEGER, PARAMETER :: udefOutput = 67
+  !> file containing mhm output
+  character(len = *), PARAMETER :: file_mhm_output = 'mHM_Fluxes_States.nc'
 
 END MODULE mo_file
```

### Comparing `mhm-5.12.1.dev21/src/mHM/mo_global_variables.f90` & `mhm-5.13.0/src/mRM/mo_mrm_global_variables.f90`

 * *Files 17% similar despite different names*

```diff
@@ -1,199 +1,240 @@
-!>       \file mo_global_variables.f90
+!> \dir mRM
+!> \brief \copybrief f_mrm
+!> \details \copydetails f_mrm
+
+!> \defgroup   f_mrm mRM - Fortran modules
+!> \brief      Core modules of mRM.
+!> \details    These modules provide the core components of mRM.
+
+!> \file mo_mrm_global_variables.f90
+!> \brief \copybrief mo_mrm_global_variables
+!> \details \copydetails mo_mrm_global_variables
+
+!> \brief Global variables for mRM only
+!> \details Global variables used to run mRM for mHM.
+!> \changelog
+!! - Robert Schweppe Dec 2017
+!!   - merged duplicated variables with mhm into common variables
+!! - Robert Schweppe Jun 2018
+!!   - refactoring and reformatting
+!> \authors Luis Samaniego, Stephan Thober
+!> \date Aug 2015
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mrm
+module mo_mrm_global_variables
+
+  use mo_kind, only : i4, i8, dp
+  use mo_mrm_constants, only : nOutFlxState
+  use mo_common_types, only : Grid, GridRemapper
+  use mo_mrm_riv_temp_class, only : riv_temp_type
 
-!>       \brief Global variables ONLY used in reading, writing and startup.
+  implicit none
 
-!>       \details TODO: add description
+  PUBLIC :: gaugingStation
 
-!>       \authors Luis Samaniego
-
-!>       \date Dec 2012
-
-! Modifications:
-! Robert Schweppe Jun 2018 - refactoring and reformatting
-
-
-MODULE mo_global_variables
-
-  ! This module provides
-
-  !
-  ! Written   Luis Samaniego,     Dec 2005
-  ! Modified  Luis Samaniego,     Feb 2013 - new variable names, new modules, units
-  !           Rohini Kumar,       Jul 2013 - fraction of perfectly sealed area within city added
-  !           Rohini Kumar,       Aug 2013 - name changed "inputFormat" to "inputFormat_meteo_forcings"
-  !           Rohini Kumar,       Aug 2013 - name changed from "L0_LAI" to "L0_LCover_LAI"
-  !           Rohini Kumar,       Aug 2013 - added dirSoil_LUT and dirGeology_LUT
-  !           Luis Samaniego,     Nov 2013 - documentation of dimensions
-  !           Matthias Zink,      Nov 2013 - added "InflowGauge" and inflow gauge variabels in Domain
-  !           Rohini Kumar,       May 2014 - added options for the model run cordinate system
-  !           Stephan Thober,     Jun 2014 - added timeStep_model_inputs and readPer
-  !           Stephan Thober,     Jun 2014 - added perform_mpr, updated restart flags
-  !           Cuntz M. & Mai J.,  Nov 2014 - LAI input from daily, monthly or yearly files
-  !           Matthias Zink,      Dec 2014 - adopted inflow gauges to ignore headwater cells
-  !           Matthias Zink,      Mar 2015 - added optional soil mositure readin: dirSoil_moisture, L1_sm
-  !           Stephan Thober,     Aug 2015 - moved routing related variables to mRM
-  !           Oldrich Rakovec,    Oct 2015 - added definition of Domain averaged TWS data
-  !           Rohini Kumar,       Mar 2016 - new variables for handling different soil databases
-  !           Johann Brenner,     Feb 2017 - added optional evapotranspiration readin: dirEvapotranspiration, L1_et
-  !           Zink M. Demirel C., Mar 2017 - added Jarvis soil water stress variable for SM process(3)
-  !           Demirel M.C.        May 2017 - added L1_petLAIcorFactor for PET correction
-  !           O. Rakovec, R.Kumar Nov 2017 - added project description for the netcdf outputs
-  !           Robert Schweppe,    Dec 2017 - expanded dimensions of effective parameters
-  !           Robert Schweppe,    Dec 2017 - merged duplicated variables with mrm into common variables
-
-  USE mo_kind, ONLY : i4, dp
-  USE mo_constants, ONLY : YearMonths
-  USE mo_mhm_constants, ONLY : nOutFlxState
-  USE mo_optimization_types, ONLY : optidata
-  use mo_common_variables, only : Grid
-
-  IMPLICIT NONE
+  ! -------------------------------------------------------------------
+  ! General variables
+  ! -------------------------------------------------------------------
+  logical :: is_start              ! flag for first timestep for mpr
 
   ! -------------------------------------------------------------------
   ! DEFINE OUTPUTS
   ! -------------------------------------------------------------------
-  integer(i4) :: output_deflate_level   !< deflate level in nc files
-  logical :: output_double_precision    !< output precision in nc files
-  integer(i4) :: timeStep_model_outputs !< timestep for writing model outputs
-  logical, dimension(nOutFlxState) :: outputFlxState         !< Define model outputs see "mhm_outputs.nml"
-                                                             !< dim1 = number of output variables to be written
-  ! -------------------------------------------------------------------
-  ! INPUT variables for configuration of mHM
-  ! -------------------------------------------------------------------
-  integer(i4), dimension(:), allocatable, public :: timeStep_model_inputs !< frequency for reading meteo input
-  logical, public :: read_meteo_weights                                   !< read weights for tavg and pet
-  character(256), public :: inputFormat_meteo_forcings                    !< format of meteo input data (nc)
-  ! Optional data
+  !
+  integer(i4) :: output_deflate_level_mrm !< compression of output nc files
+  integer(i4) :: output_time_reference_mrm !< time reference point location in output nc files
+  logical :: output_double_precision_mrm !< float precision in output nc files
+  integer(i4) :: timeStep_model_outputs_mrm !< timestep for writing model outputs
+  logical, dimension(nOutFlxState) :: outputFlxState_mrm         !< Define model outputs see "mhm_outputs.nml"
+  !                                                            dim1 = number of output variables to be written
+  logical :: readLatLon
+
   ! ------------------------------------------------------------------
   ! DIRECTORIES
   ! ------------------------------------------------------------------
   ! has the dimension of nDomains
-  character(256), dimension(:), allocatable, public :: dirPrecipitation   !< Directory where precipitation files are located
-  character(256), dimension(:), allocatable, public :: dirTemperature     !< Directory where temperature files are located
-  character(256), dimension(:), allocatable, public :: dirMinTemperature  !< Directory where minimum temp. files are located
-  character(256), dimension(:), allocatable, public :: dirMaxTemperature  !< Directory where maximum temp. files are located
-  character(256), dimension(:), allocatable, public :: dirNetRadiation    !< Directory where abs. vap. pressure files are located
-  character(256), dimension(:), allocatable, public :: dirabsVapPressure  !< Directory where abs. vap. pressure files are located
-  character(256), dimension(:), allocatable, public :: dirwindspeed       !< Directory where windspeed files are located
-  character(256), dimension(:), allocatable, public :: dirReferenceET     !< Directory where reference-ET files are located
-  ! riv-temp releated
-  character(256), dimension(:), allocatable, public :: dirRadiation       !< Directory where short/long-wave rad. files are located
+  character(256), dimension(:), allocatable, public :: dirGauges ! Directory where discharge files are located
+  character(256), dimension(:), allocatable, public :: dirTotalRunoff ! Directory where simulated total runoff files are located
+  character(256), public :: filenameTotalRunoff ! Filename of simulated total runoff file
+  character(256), public :: varnameTotalRunoff ! variable name of total runoff
+  character(256), dimension(:), allocatable, public :: dirBankfullRunoff ! Dir. where simulated bankfull runoff files are located
 
   ! ------------------------------------------------------------------
   ! CONSTANT
   ! ------------------------------------------------------------------
-  integer(i4), public, parameter :: routingStates = 2  !< [-]   Routing states (2=current, 1=past)
+  integer(i4), public :: nTstepDay ! Number of time intervals per day
+  !                                ! (was previously NAGG)
 
   ! -------------------------------------------------------------------
   ! GRID description
   ! -------------------------------------------------------------------
-  type(Grid), dimension(:), allocatable, public :: level2       !< Reference of the metereological variables
+  type(Grid), dimension(:), allocatable, target, public :: level11 ! Reference of the routing variables
+  type(GridRemapper), dimension(:), allocatable, public :: l0_l11_remap ! grid information at runoff level
+
+
+  ! -----------------------------------------------------------------
+  ! RUNOFF variable
+  ! -----------------------------------------------------------------
+  real(dp), dimension(:, :), allocatable, public :: mRM_runoff ! variable containing runoff for each domain and gauge
+
+  ! -----------------------------------------------------------------
+  ! GAUGED station data
+  ! -----------------------------------------------------------------
+  integer(i4), public :: nGaugesTotal ! Number of evaluation gauges for all domains
+  integer(i4), public :: nGaugesLocal ! Number of evaluation gauges for all domains on a subprocess
+  integer(i4), public :: nInflowGaugesTotal ! Number of evaluation gauges for all domains
+  integer(i4), public :: nMeasPerDay ! Number of observations per day,
+  !                                  ! e.g. 24 -> hourly discharge, 1 -> daily discharge
+  type gaugingStation
+    integer(i4), dimension(:), allocatable :: domainId ! domain Id
+    integer(i4), dimension(:), allocatable :: gaugeId ! Gauge Id (e.g. 0000444)
+    character(256), dimension(:), allocatable :: fname ! Name runoff file
+    real(dp), dimension(:, :), allocatable :: Q ! [m3 s-1] observed daily mean discharge (simPer)
+    !                                          ! dim1=number observations, dim2=number of gauges
+    real(dp), dimension(:, :), allocatable :: T ! [K] observed daily mean temperature (simPer)
+  end type gaugingStation
+  type(gaugingStation), public :: gauge ! Gauging station information
+  type(gaugingStation), public :: InflowGauge ! inflow gauge information
+
+  ! -------------------------------------------------------------------
+  ! DOMAIN general description
+  ! -------------------------------------------------------------------
+  type domainInfo_mRM
+    ! dim1 = maximum number of gauges in a given domain
+    ! discharge measurement gauges
+    integer(i4) :: nGauges        ! Number of gauges within a domain
+    integer(i4), dimension(:), allocatable :: gaugeIdList    ! Gauge Id list (e.g. 0000444 0000445)
+    integer(i4), dimension(:), allocatable :: gaugeIndexList ! Gauge index list (e.g. 1 for 00444, 2 for 00445)
+    integer(i4), dimension(:), allocatable :: gaugeNodeList  ! Gauge node list at L11
+
+    ! discharge inflow gauges (e.g if headwar bsins are missing)
+    integer(i4) :: nInflowGauges        ! Number of gauges within a domain
+    integer(i4), dimension(:), allocatable :: InflowGaugeIdList    ! Gauge Id list (e.g. 0000444 0000445)
+    integer(i4), dimension(:), allocatable :: InflowGaugeIndexList ! Gauge index list (e.g. 1 for 00444, 2 for 00445)
+    integer(i4), dimension(:), allocatable :: InflowGaugeNodeList  ! Gauge node list at L11
+    logical, dimension(:), allocatable :: InflowGaugeHeadwater ! if headwater cells of inflow gauge will be considered
+
+    ! domain outlet
+    ! TODO: move this out of here since it is mrm_net_startup relevant only for domain0
+    integer(i4) :: L0_Noutlet
+    integer(i4), dimension(:), allocatable :: L0_rowOutlet   ! Outlet locations in L0
+    integer(i4), dimension(:), allocatable :: L0_colOutlet   ! Outlet locations in L0
+  end type domainInfo_mRM
+
+  ! dim1 = domainId
+  type(domainInfo_mRM), dimension(:), allocatable, public, target :: domain_mrm ! domain structure
+  ! -------------------------------------------------------------------
+  ! L0 DOMAIN description -> those are needed within the mrm_net_startup routines only
+  ! TODO: deallocate when net_startup is done
+  ! -------------------------------------------------------------------
+  ! dim1 = number grid cells
+  ! input data - morphological variables
+  integer(i4), public, dimension(:), allocatable :: L0_gaugeLoc ! Location of gauges within the catchment
+  integer(i4), public, dimension(:), allocatable :: L0_InflowGaugeLoc ! Location of inflow gauges within catchment
+  integer(i4), public, dimension(:), allocatable :: L0_fAcc ! Flow accumulation
+  integer(i4), public, dimension(:), allocatable :: L0_fDir ! Flow direction (standard ArcGIS)
+  !
+  ! mRM derived variables
+  ! dim1 = number grid cells L0
+  integer(i4), public, dimension(:), allocatable :: L0_draSC      ! Index of draining cell of each sub catchment
+  !                                                               ! i.e. a routing cell L11
+  integer(i4), public, dimension(:), allocatable :: L0_draCell    ! Draining cell id at L11 of ith cell of L0
+  integer(i4), public, dimension(:), allocatable :: L0_streamNet  ! Stream network
+  integer(i4), public, dimension(:), allocatable :: L0_floodPlain ! Floodplains of stream i
+  integer(i4), public, dimension(:), allocatable :: L0_noutlet    ! number of river outlets at level 0
+  real(dp),    public, dimension(:), allocatable :: L0_celerity   ! celerity at level 0
 
   ! -------------------------------------------------------------------
   ! L1 DOMAIN description
   ! -------------------------------------------------------------------
-  ! Forcings
   ! dim1 = number grid cells L1
-  ! dim2 = number of meteorological time steps
-  real(dp), public, dimension(:, :, :), allocatable :: L1_temp_weights  !< hourly temperature weights for daily values
-  real(dp), public, dimension(:, :, :), allocatable :: L1_pet_weights   !< hourly pet weights for daily values
-  real(dp), public, dimension(:, :, :), allocatable :: L1_pre_weights   !< hourly pre weights for daily values
-  real(dp), public, dimension(:, :), allocatable :: L1_pre           !< [mm]    Precipitation
-  real(dp), public, dimension(:, :), allocatable :: L1_temp          !< [degC]  Air temperature
-  real(dp), public, dimension(:, :), allocatable :: L1_pet           !< [mm TS-1] Potential evapotranspiration
-  real(dp), public, dimension(:, :), allocatable :: L1_tmin          !< [degC]  minimum daily air temperature
-  real(dp), public, dimension(:, :), allocatable :: L1_tmax          !< [degC]  maximum daily air temperature
-  real(dp), public, dimension(:, :), allocatable :: L1_netrad        !< [W m2]  net radiation
-  real(dp), public, dimension(:, :), allocatable :: L1_absvappress   !< [Pa]    absolute vapour pressure
-  real(dp), public, dimension(:, :), allocatable :: L1_windspeed     !< [m s-1] windspeed
-  ! riv-temp related
-  real(dp), public, dimension(:, :), allocatable :: L1_ssrd          !< [W m2]  short wave radiation
-  real(dp), public, dimension(:, :), allocatable :: L1_strd          !< [W m2]  long wave radiation
-  real(dp), public, dimension(:, :), allocatable :: L1_tann          !< [degC]  annual mean air temperature
-
-
-  ! soil moisture
-  real(dp), public, dimension(:, :), allocatable :: L1_sm                  !< [-] soil moisture input for optimization
-  logical, public, dimension(:, :), allocatable :: L1_sm_mask             !< [-] mask for valid data in L1_sm
-  ! neutrons
-  real(dp), public, dimension(:, :), allocatable :: L1_neutronsdata            !< [cph] ground albedo neutrons input
-  logical, public, dimension(:, :), allocatable :: L1_neutronsdata_mask       !< [cph] mask for valid data in L1_neutrons
-
-  ! soil moisture
-  integer(i4) :: nSoilHorizons_sm_input ! No. of mhm soil horizons equivalent to sm input
-
-  type(optidata), public, dimension(:), allocatable :: L1_smObs
-  ! neutrons
-  type(optidata), public, dimension(:), allocatable :: L1_neutronsObs
-  ! evapotranspiration
-  type(optidata), public, dimension(:), allocatable :: L1_etObs
-  ! tws
-  type(optidata), public, dimension(:), allocatable :: L1_twsaObs !< this stores L1_tws, the mask, the directory of the
-                                                              !< observerd data, and the
-                                                              !< timestepInput of the simulated data
-                                                              ! ToDo: add unit
-  logical, public                             :: BFI_calc     !< calculate observed BFI from gauges with Eckhardt filter
-  real(dp), public, dimension(:), allocatable :: BFI_obs      !< given base-flow index per domain
-  real(dp), public, dimension(:), allocatable :: BFI_qBF_sum  !< q2 weighted sum for each domain
-  real(dp), public, dimension(:), allocatable :: BFI_qT_sum   !< q2 weighted sum for each domain
-
-  ! State variables
+  integer(i4), public, dimension(:), allocatable :: L11_L1_ID  ! Mapping of L11 Id on L1
+  ! -------------------------------------------------------------------
+  ! L1 variables
+  ! -------------------------------------------------------------------
   ! dim1 = number grid cells L1
-  ! dim2 = number model soil horizons
-  real(dp), public, dimension(:), allocatable :: L1_inter        !< [mm]  Interception
-  real(dp), public, dimension(:), allocatable :: L1_snowPack     !< [mm]  Snowpack
-  real(dp), public, dimension(:), allocatable :: L1_sealSTW      !< [mm]  Retention storage of impervious areas
-  real(dp), public, dimension(:, :), allocatable :: L1_soilMoist !< [mm]  Soil moisture of each horizon
-  real(dp), public, dimension(:), allocatable :: L1_unsatSTW     !< [mm]  upper soil storage
-  real(dp), public, dimension(:), allocatable :: L1_satSTW       !< [mm]  groundwater storage
-  real(dp), public, dimension(:), allocatable :: L1_neutrons     !< [mm]  Ground Albedo Neutrons
+  ! dim2 = number of timesteps
+  real(dp), public, dimension(:, :), allocatable :: L1_total_runoff_in
 
+  ! -------------------------------------------------------------------
+  ! L11 DOMAIN description
+  ! -------------------------------------------------------------------
+  ! dim1 = number grid cells L11
+  ! dim2 = 2
+  integer(i4), public, dimension(:,:), allocatable :: L11_cellCoor ! Cell coordinates (row,col)
+  !                                                                ! -> <only domain> Routing
+  integer(i4), public, dimension(:), allocatable :: L1_L11_ID  ! Mapping of L1 Id on L11
+  real(dp),    public, dimension(:), allocatable :: L11_areaCell ! [km2] Effective area of cell at this level
+  real(dp),    public, dimension(:), allocatable :: L11_fAcc ! [km2] flow Accumulation of cell at this level
+  integer(i4), public, dimension(:), allocatable :: L11_fDir ! Flow direction (standard notation)
+  integer(i4), public, dimension(:), allocatable :: L11_nOutlets
+  real(dp),    public, dimension(:), allocatable :: L11_celerity ! [m/s] celerity per grid-cell, only for
+                                                                 ! routing-case = 3
+  real(dp),    public, dimension(:), allocatable :: L11_meandering ! Proxy: L11_length/Lopt
+                                                                   ! Lopt := shortest possible way of stream
+  real(dp),    public, dimension(:), allocatable :: L11_LinkIn_fAcc ! fAcc inflow per Link
+
+  ! Constants
+  ! dim1 = number grid cells L11
+  integer(i4), public, dimension(:), allocatable :: L11_rowOut ! Grid vertical location of the Outlet
+  integer(i4), public, dimension(:), allocatable :: L11_colOut ! Grid horizontal location  of the Outlet
 
+  ! -------------------------------------------------------------------
+  ! L11 NETWORK description
+  ! -------------------------------------------------------------------
   ! Fluxes
-  ! dim1 = number grid cells L1
-  ! dim2 = number model soil horizons
-  real(dp), public, dimension(:), allocatable :: L1_pet_calc     !< [mm TS-1] estimated/corrected potential evapotranspiration
-  real(dp), public, dimension(:), allocatable :: L1_temp_calc    !< [degC] temperature for current time step
-  real(dp), public, dimension(:), allocatable :: L1_prec_calc    !< [mm TS-1] precipitation for current time step
-  real(dp), public, dimension(:, :), allocatable :: L1_aETSoil   !< [mm TS-1] Actual ET from soil layers
-  real(dp), public, dimension(:), allocatable :: L1_aETCanopy    !< [mm TS-1] Real evaporation intensity from canopy
-  real(dp), public, dimension(:), allocatable :: L1_aETSealed    !< [mm TS-1] Real evap. from free water surfaces
-  real(dp), public, dimension(:), allocatable :: L1_baseflow     !< [mm TS-1] Baseflow
-  real(dp), public, dimension(:, :), allocatable :: L1_infilSoil !< [mm TS-1] Infiltration intensity each soil horizon
-  real(dp), public, dimension(:), allocatable :: L1_fastRunoff   !< [mm TS-1] Fast runoff component
-  real(dp), public, dimension(:), allocatable :: L1_melt         !< [mm TS-1] Melting snow depth.
-  real(dp), public, dimension(:), allocatable :: L1_percol       !< [mm TS-1] Percolation.
-  real(dp), public, dimension(:), allocatable :: L1_preEffect    !< [mm TS-1] Effective precip. depth (snow melt + rain)
-  real(dp), public, dimension(:), allocatable :: L1_rain         !< [mm TS-1] Rain precipitation depth
-  real(dp), public, dimension(:), allocatable :: L1_runoffSeal   !< [mm TS-1] Direct runoff from impervious areas
-  real(dp), public, dimension(:), allocatable :: L1_slowRunoff   !< [mm TS-1] Slow runoff component
-  real(dp), public, dimension(:), allocatable :: L1_snow         !< [mm TS-1] Snow precipitation depth
-  real(dp), public, dimension(:), allocatable :: L1_Throughfall  !< [mm TS-1] Throughfall.
-  real(dp), public, dimension(:), allocatable :: L1_total_runoff !< [m3 TS-1] Generated runoff
-
-  ! -------------------------------------------------------------------
-  ! Monthly day/night variation of Meteorological variables
-  ! for temporal disaggregation
-  ! -------------------------------------------------------------------
-  ! dim1 = number of months in a year
-  real(dp), public, dimension(int(YearMonths, i4)) :: evap_coeff     !< [-] Evap. coef. for free-water surfaces
-  real(dp), public, dimension(int(YearMonths, i4)) :: fday_prec      !< [-] Day ratio precipitation < 1
-  real(dp), public, dimension(int(YearMonths, i4)) :: fnight_prec    !< [-] Night ratio precipitation < 1
-  real(dp), public, dimension(int(YearMonths, i4)) :: fday_pet       !< [-] Day ratio PET  < 1
-  real(dp), public, dimension(int(YearMonths, i4)) :: fnight_pet     !< [-] Night ratio PET  < 1
-  real(dp), public, dimension(int(YearMonths, i4)) :: fday_temp      !< [-] Day factor mean temp
-  real(dp), public, dimension(int(YearMonths, i4)) :: fnight_temp    !< [-] Night factor mean temp
-  real(dp), public, dimension(int(YearMonths, i4)) :: fday_ssrd      !< [-] Day factor short-wave rad.
-  real(dp), public, dimension(int(YearMonths, i4)) :: fnight_ssrd    !< [-] Night factor short-wave rad.
-  real(dp), public, dimension(int(YearMonths, i4)) :: fday_strd      !< [-] Day factor long-wave rad.
-  real(dp), public, dimension(int(YearMonths, i4)) :: fnight_strd    !< [-] Night factor long-wave rad.
+  ! dim1 = number grid cells L11
+  ! dim2 = 2
+  real(dp), public, dimension(:), allocatable :: L11_Qmod        ! [m3 s-1] Simulated discharge
+  real(dp), public, dimension(:), allocatable :: L11_qOUT        ! [m3 s-1] Total outflow from cells L11 at time tt
+  real(dp), public, dimension(:, :), allocatable :: L11_qTIN        !          Total discharge inputs at t-1 and t
+  real(dp), public, dimension(:, :), allocatable :: L11_qTR         !          Routed outflow leaving a node
+
+  integer(i4), public, dimension(:), allocatable :: L11_fromN       !         From node (sinks are at the end)
+  integer(i4), public, dimension(:), allocatable :: L11_toN         !         To node (sinks are at the end)
+  integer(i4), public, dimension(:), allocatable :: L11_netPerm     !         Routing sequence (permutation of L11_rOrder)
+  integer(i4), public, dimension(:), allocatable :: L11_fRow        !         From row in L0 grid
+  integer(i4), public, dimension(:), allocatable :: L11_fCol        !         From col in L0 grid
+  integer(i4), public, dimension(:), allocatable :: L11_tRow        !         To row in L0 grid
+  integer(i4), public, dimension(:), allocatable :: L11_tCol        !         To col in L0 grid
+  integer(i4), public, dimension(:), allocatable :: L11_rOrder      !         Network routing order
+  integer(i4), public, dimension(:), allocatable :: L11_label       !         Label Id [0='', 1=HeadWater, 2=Sink]
+  logical, public, dimension(:), allocatable :: L11_sink        !         .true. if sink node reached
+  real(dp), public, dimension(:), allocatable :: L11_length      ! [m]     Total length of river link
+  real(dp), public, dimension(:), allocatable, target :: L11_aFloodPlain ! [m2]    Area of the flood plain
+  !                                                                  !         impervious cover
+  real(dp), public, dimension(:), allocatable :: L11_slope       ! [1]     Average slope of river link
+
+  ! Parameters
+  ! dim1 = number grid cells L11
+  real(dp), public, dimension(:, :), allocatable :: L11_nLinkFracFPimp  !     fraction of impervious lcover at the floodplain
+  !         dims: nLink, LCYearID
+
+  real(dp), public, dimension(:), allocatable :: L11_K           ! [d]     kappa: Muskingum travel time parameter.
+  real(dp), public, dimension(:), allocatable :: L11_xi          ! [1]     xi:    Muskingum diffusion parameter
+  !                                                                  !                (attenuation).
+  real(dp), public, dimension(:), allocatable :: L11_tsRout      ! [s]     Routing timestep
+  real(dp), public, dimension(:), allocatable :: L11_C1          ! [-]     Routing parameter C1=f(K,xi, DT) (Chow, 25-41)
+  real(dp), public, dimension(:), allocatable :: L11_C2          ! [-]     Routing parameter C2 (")
 
   ! -------------------------------------------------------------------
-  ! AUXILIARY VARIABLES
+  ! GROUNDWATER COUPLING VARIABLES
   ! -------------------------------------------------------------------
-  !
-
-  real(dp), public, dimension(:), allocatable :: neutron_integral_AFast !< pre-calculated integrand for
-  ! vertical projection of isotropic neutron flux
+  ! TODO this must be read from nml
+  logical :: gw_coupling
+  ! dim1 = number grid cells L1
+  real(dp), public, dimension(:), allocatable :: L11_bankfull_runoff_in
+  ! dim2 = number grid cells L0
+  real(dp), public, dimension(:), allocatable :: L0_channel_depth
+  real(dp), public, dimension(:), allocatable :: L0_channel_elevation
+  ! the cumulated river heads, for monthly average
+  real(dp), public, dimension(:), allocatable :: L0_river_head_mon_sum
+  real(dp), public, dimension(:), allocatable :: L0_slope
 
-END MODULE mo_global_variables
+  ! -------------------------------------------------------------------
+  ! RIVER TEMPERATURE VARIABLES
+  ! -------------------------------------------------------------------
+  !> This is a container for the river temperature routing process (pcs)
+  type(riv_temp_type), public :: riv_temp_pcs
+end module mo_mrm_global_variables
```

### Comparing `mhm-5.12.1.dev21/src/mHM/mo_init_states.f90` & `mhm-5.13.0/src/mHM/mo_init_states.f90`

 * *Files 6% similar despite different names*

```diff
@@ -1,68 +1,55 @@
-!>       \file mo_init_states.f90
-
-!>       \brief Initialization of all state variables of mHM.
-
-!>       \details This module initializes all state variables required to run mHM.
-!>       Two options are provided:
-!>       - (1) default values
-!>       - (2) from nc file
-
-!>       \authors Luis Samaniego & Rohini Kumar
-
-!>       \date Dec 2012
-
-! Modifications:
-
+!> \file mo_init_states.f90
+!> \brief \copybrief mo_init_states
+!> \details \copydetails mo_init_states
+
+!> \brief Initialization of all state variables of mHM.
+!> \details This module initializes all state variables required to run mHM.
+!!
+!!       Two options are provided:
+!!       - (1) default values
+!!       - (2) from nc file
+!> \authors Luis Samaniego & Rohini Kumar
+!> \date Dec 2012
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mhm
 MODULE mo_init_states
 
-  ! This module provides the startup routines for mHM.
-
-  ! Written Luis Samaniego & Rohini Kumar, Dec 2012
-
   USE mo_kind, ONLY : i4, dp
 
   IMPLICIT NONE
 
   PRIVATE
 
   PUBLIC :: variables_alloc                 ! allocation of space for state variables/fluxes/effective parameters
   PUBLIC :: variables_default_init          ! initialization for state variables/fluxes/effective parameters
+  PUBLIC :: fluxes_states_default_init      ! initialization for state/fluxes variables
 
 CONTAINS
 
-  ! ------------------------------------------------------------------
-
-  !    NAME
-  !        variables_alloc
-
-  !    PURPOSE
-  !>       \brief Allocation of space for mHM related L1 and L11 variables.
-
-  !>       \details Allocation of space for mHM related L1 and L11 variables (e.g., states,
-  !>       fluxes, and parameters) for a given domain. Variables allocated here is
-  !>       defined in them mo_global_variables.f90 file. After allocating any variable
-  !>       in this routine, initalize them in the following variables_default_init
-  !>       subroutine:
-
-  !    INTENT(IN)
-  !>       \param[in] "integer(i4) :: ncells1"
-
-  !    HISTORY
-  !>       \authors Rohini Kumar
-
-  !>       \date Jan 2013
-
-  ! Modifications:
-  ! R. Kumar           Sep 2013 - documentation added according to the template
-  ! S. Thober          Aug 2015 - removed routing related variables
-  ! Zink M. Demirel C. Mar 2017 - Init Jarvis soil water stress variable at SM process(3)
-  ! Robert Schweppe    Dec 2017 - restructured allocation in variables_alloc, expanded dimensions of effective parameters
-  ! Robert Schweppe Jun 2018 - refactoring and reformatting
 
+  !> \brief Allocation of space for mHM related L1 and L11 variables.
+  !> \details Allocation of space for mHM related L1 and L11 variables (e.g., states,
+  !! fluxes, and parameters) for a given domain. Variables allocated here is
+  !! defined in them mo_global_variables.f90 file. After allocating any variable
+  !! in this routine, initalize them in the following variables_default_init subroutine.
+  !> \changelog
+  !! - R. Kumar           Sep 2013
+  !!   - documentation added according to the template
+  !! - S. Thober          Aug 2015
+  !!   - removed routing related variables
+  !! - Zink M. Demirel C. Mar 2017
+  !!   - Init Jarvis soil water stress variable at SM process(3)
+  !! - Robert Schweppe    Dec 2017
+  !!   - restructured allocation in variables_alloc, expanded dimensions of effective parameters
+  !! - Robert Schweppe Jun 2018
+  !!   - refactoring and reformatting
+  !> \authors Rohini Kumar
+  !> \date Jan 2013
   subroutine variables_alloc(ncells1)
 
     use mo_append, only : append
     use mo_common_constants, only : P1_InitStateFluxes
     use mo_global_variables, only : L1_Throughfall, L1_aETCanopy, L1_aETSealed, L1_aETSoil, L1_baseflow, &
                                     L1_fastRunoff, L1_infilSoil, L1_inter, L1_melt, L1_neutrons, L1_percol, &
                                     L1_pet_calc, L1_temp_calc, L1_prec_calc, &
@@ -70,15 +57,15 @@
                                     L1_slowRunoff, L1_snow, L1_snowPack, L1_soilMoist, L1_total_runoff, L1_unsatSTW
     use mo_mpr_constants, only : C1_InitStateSM, P2_InitStateFluxes, P3_InitStateFluxes, &
                                  P4_InitStateFluxes, P5_InitStateFluxes
     use mo_mpr_global_variables, only : HorizonDepth_mHM, nSoilHorizons_mHM
 
     implicit none
 
-    integer(i4), intent(in) :: ncells1
+    integer(i4), intent(in) :: ncells1 !< number of level-1 cells
 
     integer(i4) :: i
 
     real(dp), dimension(:), allocatable :: dummy_1D
 
     real(dp), dimension(:, :), allocatable :: dummy_2D
 
@@ -163,73 +150,140 @@
     ! free space
     if (allocated(dummy_1D)) deallocate(dummy_1D)
     if (allocated(dummy_2D)) deallocate(dummy_2D)
 
   end subroutine variables_alloc
 
 
-  ! ------------------------------------------------------------------
+  !> \brief Default initalization mHM related L1 variables
+  !> \details Default initalization of mHM related L1 variables (e.g., states,
+  !! fluxes, and parameters) as per given constant values given in mo_mhm_constants.
+  !! Variables initalized here is defined in the mo_global_variables.f90 file.
+  !! Only Variables that are defined in the variables_alloc subroutine are
+  !! intialized here.
+  !! If a variable is added or removed here, then it also has to be added or removed
+  !! in the subroutine state_variables_set in the module mo_restart and in the
+  !! subroutine set_state in the module mo_set_netcdf_restart.
+  !> \changelog
+  !! - R. Kumar       Sep 2013
+  !!   - documentation added according to the template
+  !! - Stephan Thober Aug 2015
+  !!   - moved routing variables to mRM
+  !! - Robert Schweppe Jun 2018
+  !!   - refactoring and reformatting
+  !! - Sebastian Mller Mar 2023
+  !!   - added separate fluxes_states_default_init
+  !> \authors R. Kumar & J. Mai
+  !> \date Sep 2013
+  subroutine variables_default_init
 
-  !    NAME
-  !        variables_default_init
+    use mo_common_constants, only : P1_InitStateFluxes
+    use mo_mpr_global_variables, only : L1_HarSamCoeff, L1_PrieTayAlpha, &
+                                        L1_aeroResist, L1_alpha, L1_degDay, L1_degDayInc, L1_degDayMax,&
+                                        L1_degDayNoPre, L1_fAsp, L1_fRoots, L1_fSealed, L1_jarvis_thresh_c1, &
+                                        L1_kBaseFlow, L1_kPerco, L1_kSlowFlow, L1_karstLoss, L1_kfastFlow, &
+                                        L1_maxInter, L1_petLAIcorFactor, L1_sealedThresh, L1_soilMoistExp, &
+                                        L1_soilMoistFC, L1_soilMoistSat, L1_surfResist, L1_tempThresh, &
+                                        L1_unsatThresh, L1_wiltingPoint
 
-  !    PURPOSE
-  !>       \brief Default initalization mHM related L1 variables
+    implicit none
 
-  !>       \details Default initalization of mHM related L1 variables (e.g., states,
-  !>       fluxes, and parameters) as per given constant values given in mo_mhm_constants.
-  !>       Variables initalized here is defined in the mo_global_variables.f90 file.
-  !>       Only Variables that are defined in the variables_alloc subroutine are
-  !>       intialized here.
-  !>       If a variable is added or removed here, then it also has to be added or removed
-  !>       in the subroutine state_variables_set in the module mo_restart and in the
-  !>       subroutine set_state in the module mo_set_netcdf_restart.
-
-  !    HISTORY
-  !>       \authors R. Kumar & J. Mai
-
-  !>       \date Sep 2013
-
-  ! Modifications:
-  ! R. Kumar       Sep 2013 - documentation added according to the template
-  ! Stephan Thober Aug 2015 - moved routing variables to mRM
-  ! Robert Schweppe Jun 2018 - refactoring and reformatting
+    ! init fluxes and states
+    call fluxes_states_default_init()
 
-  subroutine variables_default_init
+    !-------------------------------------------
+    ! EFFECTIVE PARAMETERS
+    !-------------------------------------------
+
+    ! sealed fraction of LCover
+    L1_fSealed = P1_InitStateFluxes
+    ! exponent for the upper reservoir
+    L1_alpha = P1_InitStateFluxes
+    ! increase of the Degree-day factor per mm of increase in precipitation
+    L1_degDayInc = P1_InitStateFluxes
+    ! maximum degree-day factor
+    L1_degDayMax = P1_InitStateFluxes
+    ! degree-day factor with no precipitation
+    L1_degDayNoPre = P1_InitStateFluxes
+    ! degree-day factor
+    L1_degDay = P1_InitStateFluxes
+    ! Karstic percolation loss
+    L1_karstLoss = P1_InitStateFluxes
+    ! PET correction factor due to LAI
+    L1_petLAIcorFactor = P1_InitStateFluxes
+    ! PET correction factor due to terrain aspect
+    L1_fAsp = P1_InitStateFluxes
+    ! PET Hargreaves Samani Coefficient
+    L1_HarSamCoeff = P1_InitStateFluxes
+    ! PET Priestley Taylor coefficient
+    L1_PrieTayAlpha = P1_InitStateFluxes
+    ! PET aerodynamical resistance
+    L1_aeroResist = P1_InitStateFluxes
+    ! PET bulk surface resistance
+    L1_surfResist = P1_InitStateFluxes
+    ! Fraction of roots in soil horizons
+    L1_fRoots = P1_InitStateFluxes
+    ! Maximum interception
+    L1_maxInter = P1_InitStateFluxes
+    ! fast interflow recession coefficient
+    L1_kfastFlow = P1_InitStateFluxes
+    ! slow interflow recession coefficient
+    L1_kSlowFlow = P1_InitStateFluxes
+    ! baseflow recession coefficient
+    L1_kBaseFlow = P1_InitStateFluxes
+    ! percolation coefficient
+    L1_kPerco = P1_InitStateFluxes
+    ! Soil moisture below which actual ET is reduced linearly till PWP
+    L1_soilMoistFC = P1_InitStateFluxes
+    ! Saturation soil moisture for each horizon [mm]
+    L1_soilMoistSat = P1_InitStateFluxes
+    ! Exponential parameter to how non-linear is the soil water retention
+    L1_soilMoistExp = P1_InitStateFluxes
+    ! jarvis critical value for normalized soil water content
+    L1_jarvis_thresh_c1 = P1_InitStateFluxes
+    ! Threshold temperature for snow/rain
+    L1_tempThresh = P1_InitStateFluxes
+    ! Threshhold water depth controlling fast interflow
+    L1_unsatThresh = P1_InitStateFluxes
+    ! Threshhold water depth for surface runoff in sealed surfaces
+    L1_sealedThresh = P1_InitStateFluxes
+    ! Permanent wilting point
+    L1_wiltingPoint = P1_InitStateFluxes
+
+  end subroutine variables_default_init
+
+
+  !> \brief initialize fluxes and states with default values
+  !> \authors Sebastian Mller
+  !> \date Mar 2023
+  subroutine fluxes_states_default_init
 
     use mo_common_constants, only : P1_InitStateFluxes
+    use mo_mpr_constants, only : C1_InitStateSM, P2_InitStateFluxes, P3_InitStateFluxes, &
+                                 P4_InitStateFluxes, P5_InitStateFluxes
     use mo_global_variables, only : L1_Throughfall, L1_aETCanopy, L1_aETSealed, L1_aETSoil, L1_baseflow, &
                                     L1_fastRunoff, L1_infilSoil, &
                                     L1_inter, L1_melt, L1_neutrons, L1_percol, L1_pet_calc, L1_temp_calc, L1_prec_calc, &
                                     L1_preEffect, L1_rain, &
                                     L1_runoffSeal, L1_satSTW, L1_sealSTW, L1_slowRunoff, L1_snow, L1_snowPack, &
                                     L1_soilMoist, L1_total_runoff, L1_unsatSTW
-    use mo_mpr_constants, only : C1_InitStateSM, P2_InitStateFluxes, P3_InitStateFluxes, &
-                                 P4_InitStateFluxes, P5_InitStateFluxes
-    use mo_mpr_global_variables, only : HorizonDepth_mHM, L1_HarSamCoeff, L1_PrieTayAlpha, &
-                                        L1_aeroResist, L1_alpha, L1_degDay, L1_degDayInc, L1_degDayMax,&
-                                        L1_degDayNoPre, L1_fAsp, L1_fRoots, L1_fSealed, L1_jarvis_thresh_c1, &
-                                        L1_kBaseFlow, L1_kPerco, L1_kSlowFlow, L1_karstLoss, L1_kfastFlow, &
-                                        L1_maxInter, L1_petLAIcorFactor, L1_sealedThresh, L1_soilMoistExp, &
-                                        L1_soilMoistFC, L1_soilMoistSat, L1_surfResist, L1_tempThresh, &
-                                        L1_unsatThresh, L1_wiltingPoint, nSoilHorizons_mHM
+    use mo_mpr_global_variables, only : HorizonDepth_mHM, nSoilHorizons_mHM
 
     implicit none
 
     integer(i4) :: i
 
     !-------------------------------------------
     ! STATE VARIABLES
     !-------------------------------------------
+
     ! Interception
     L1_inter = P1_InitStateFluxes
-
     !Snowpack
     L1_snowPack = P2_InitStateFluxes
-
     !Retention storage of impervious areas
     L1_sealSTW = P1_InitStateFluxes
 
     ! Soil moisture of each horizon
     do i = 1, nSoilHorizons_mHM - 1
       if (i .eq. 1) then
         L1_soilMoist(:, i) = HorizonDepth_mHM(i) * C1_InitStateSM
@@ -238,160 +292,56 @@
       end if
     end do
     L1_soilMoist(:, nSoilHorizons_mHM) = (P5_InitStateFluxes - &
             HorizonDepth_mHM(nSoilHorizons_mHM - 1)) * C1_InitStateSM
 
     ! upper soil storage
     L1_unsatSTW = P3_InitStateFluxes
-
     ! groundwater storage
     L1_satSTW = P4_InitStateFluxes
-
     ! ground albedo neutrons, initially zero
     L1_neutrons = P1_InitStateFluxes
 
     !-------------------------------------------
     ! FLUXES
     !-------------------------------------------
 
     ! corrected / calculated potential ET
     L1_pet_calc = P1_InitStateFluxes
-
     ! temperature for current time step
     L1_temp_calc = P1_InitStateFluxes
-
     ! precipitation for current time step
     L1_prec_calc = P1_InitStateFluxes
-
     !  soil actual ET
     L1_aETSoil = P1_InitStateFluxes
-
     ! canopy actual ET
     L1_aETCanopy = P1_InitStateFluxes
-
     ! sealed area actual ET
     L1_aETSealed = P1_InitStateFluxes
-
     ! baseflow
     L1_baseflow = P1_InitStateFluxes
-
     !  soil in-exfiltration
     L1_infilSoil = P1_InitStateFluxes
-
     ! fast runoff
     L1_fastRunoff = P1_InitStateFluxes
-
     ! snow melt
     L1_melt = P1_InitStateFluxes
-
     ! percolation
     L1_percol = P1_InitStateFluxes
-
     ! effective precip. depth (snow melt + rain)
     L1_preEffect = P1_InitStateFluxes
-
     ! rain (liquid water)
     L1_rain = P1_InitStateFluxes
-
     ! runoff from impervious area
     L1_runoffSeal = P1_InitStateFluxes
-
     ! slow runoff
     L1_slowRunoff = P1_InitStateFluxes
-
     ! snow (solid water)
     L1_snow = P1_InitStateFluxes
-
     ! throughfall
     L1_Throughfall = P1_InitStateFluxes
-
-    ! throughfall
+    ! total runoff
     L1_total_runoff = P1_InitStateFluxes
 
-    !-------------------------------------------
-    ! EFFECTIVE PARAMETERS
-    !-------------------------------------------
-    ! sealed fraction of LCover
-    L1_fSealed = P1_InitStateFluxes
-
-    ! exponent for the upper reservoir
-    L1_alpha = P1_InitStateFluxes
-
-    ! increase of the Degree-day factor per mm of increase in precipitation
-    L1_degDayInc = P1_InitStateFluxes
-
-    ! maximum degree-day factor
-    L1_degDayMax = P1_InitStateFluxes
-
-    ! degree-day factor with no precipitation
-    L1_degDayNoPre = P1_InitStateFluxes
-
-    ! degree-day factor
-    L1_degDay = P1_InitStateFluxes
-
-    ! Karstic percolation loss
-    L1_karstLoss = P1_InitStateFluxes
-
-    ! PET correction factor due to LAI
-    L1_petLAIcorFactor = P1_InitStateFluxes
-
-    ! PET correction factor due to terrain aspect
-    L1_fAsp = P1_InitStateFluxes
-
-    ! PET Hargreaves Samani Coefficient
-    L1_HarSamCoeff = P1_InitStateFluxes
-
-    ! PET Priestley Taylor coefficient
-    L1_PrieTayAlpha = P1_InitStateFluxes
-
-    ! PET aerodynamical resistance
-    L1_aeroResist = P1_InitStateFluxes
-
-    ! PET bulk surface resistance
-    L1_surfResist = P1_InitStateFluxes
-
-
-    ! Fraction of roots in soil horizons
-    L1_fRoots = P1_InitStateFluxes
-
-    ! Maximum interception
-    L1_maxInter = P1_InitStateFluxes
-
-    ! fast interflow recession coefficient
-    L1_kfastFlow = P1_InitStateFluxes
-
-    ! slow interflow recession coefficient
-    L1_kSlowFlow = P1_InitStateFluxes
-
-    ! baseflow recession coefficient
-    L1_kBaseFlow = P1_InitStateFluxes
-
-    ! percolation coefficient
-    L1_kPerco = P1_InitStateFluxes
-
-    ! Soil moisture below which actual ET is reduced linearly till PWP
-    L1_soilMoistFC = P1_InitStateFluxes
-
-    ! Saturation soil moisture for each horizon [mm]
-    L1_soilMoistSat = P1_InitStateFluxes
-
-    ! Exponential parameter to how non-linear is the soil water retention
-    L1_soilMoistExp = P1_InitStateFluxes
-
-    ! jarvis critical value for normalized soil water content
-    L1_jarvis_thresh_c1 = P1_InitStateFluxes
-
-    ! Threshold temperature for snow/rain
-    L1_tempThresh = P1_InitStateFluxes
-
-    ! Threshhold water depth controlling fast interflow
-    L1_unsatThresh = P1_InitStateFluxes
-
-    ! Threshhold water depth for surface runoff in sealed surfaces
-    L1_sealedThresh = P1_InitStateFluxes
-
-    ! Permanent wilting point
-    L1_wiltingPoint = P1_InitStateFluxes
-
-  end subroutine variables_default_init
+  end subroutine fluxes_states_default_init
 
 END MODULE mo_init_states
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `mhm-5.12.1.dev21/src/mHM/mo_mhm.f90` & `mhm-5.13.0/src/mHM/mo_mhm.f90`

 * *Files 14% similar despite different names*

```diff
@@ -1,45 +1,99 @@
-!>       \file mo_mhm.f90
-
-!>       \brief Call all main processes of mHM.
-
-!>       \details This module calls all processes of mHM for a given configuration.
-!>       The configuration of the model is stored in the a process matrix.
-!>       This configuration is specified in the namelist mhm.nml.
-
-!>       The processes are executed in ascending order. At the moment only
-!>       process 5 and 8 have options.
-
-!>       Currently the following processes are implemented:
-
-!>       Process    | Name                      | Flag  | Description
-!>       ---------- | ------------------------- | ----- | ------------------------------------------
-!>       1          | interception              |   1   | Maximum interception
-!>       2          | snow and melting          |   1   | Degree-day
-!>       3          | soil moisture             |   1   | Feddes equation for ET reduction, Brooks-Corey like
-!>       3          | soil moisture             |   2   | Jarvis equation for ET reduction, Brooks-Corey like
-!>       3          | soil moisture             |   3   | Jarvis eq. for ET red. + FC dependency on root frac. coef.
-!>       4          | direct runoff             |   1   | Linear reservoir exceedance
-!>       5          | PET                       |  -1   | PET is input, LAI based correction, dynamic scaling func.
-!>       5          | PET                       |   0   | PET is input, Aspect based correction
-!>       5          | PET                       |   1   | Hargreaves-Samani
-!>       5          | PET                       |   2   | Priestley-Taylor
-!>       5          | PET                       |   3   | Penman-Monteith
-!>       6          | interflow                 |   1   | Nonlinear reservoir with saturation excess
-!>       7          | percolation and base flow |   1   | GW linear reservoir
-!>       8          | routing                   |   0   | no routing
-!>       8          | routing                   |   1   | use mRM i.e. Muskingum
-!>       8          | routing                   |   2   | use mRM i.e. adaptive timestep
-
-!>       \authors Luis Samaniego
-
-!>       \date Dec 2012
-
-! Modifications:
-
+!> \file mo_mhm.f90
+!> \brief   \copybrief mo_mhm
+!> \details \copydetails mo_mhm
+
+!> \brief Call all main processes of mHM.
+!> \details This module calls all processes of mHM for a given configuration.
+!!       The configuration of the model is stored in the a process matrix.
+!!       This configuration is specified in the namelist mhm.nml.
+!!
+!!       The processes are executed in ascending order. At the moment only
+!!       process 5 and 8 have options.
+!!
+!!       Currently the following processes are implemented:
+!!
+!!       Process    | Name                      | Flag  | Description
+!!       ---------- | ------------------------- | ----- | ------------------------------------------
+!!       1          | interception              |   1   | Maximum interception
+!!       2          | snow and melting          |   1   | Degree-day
+!!       3          | soil moisture             |   1   | Feddes equation for ET reduction, Brooks-Corey like
+!!       3          | soil moisture             |   2   | Jarvis equation for ET reduction, Brooks-Corey like
+!!       3          | soil moisture             |   3   | Jarvis eq. for ET red. + FC dependency on root frac. coef.
+!!       4          | direct runoff             |   1   | Linear reservoir exceedance
+!!       5          | PET                       |  -1   | PET is input, LAI based correction, dynamic scaling func.
+!!       5          | PET                       |   0   | PET is input, Aspect based correction
+!!       5          | PET                       |   1   | Hargreaves-Samani
+!!       5          | PET                       |   2   | Priestley-Taylor
+!!       5          | PET                       |   3   | Penman-Monteith
+!!       6          | interflow                 |   1   | Nonlinear reservoir with saturation excess
+!!       7          | percolation and base flow |   1   | GW linear reservoir
+!!       8          | routing                   |   0   | no routing
+!!       8          | routing                   |   1   | use mRM i.e. Muskingum
+!!       8          | routing                   |   2   | use mRM i.e. adaptive timestep
+!> \changelog
+!! - Luis Samaniego, Rohini Kumar    Dec 2012
+!!   - modularization
+!! - Luis Samaniego                  Feb 2013
+!!   - call routine
+!! - Rohini Kumar                    Feb 2013
+!!   - MPR call and other pre-requisite variables for this call
+!! - Rohini Kumar                    May 2013
+!!   - Error checks
+!! - Rohini Kumar                    Jun 2013
+!!   - sealed area correction in total runoff
+!!   - initalization of soil moist. at first timestep
+!! - Rohini Kumar                    Aug 2013
+!!   - dynamic LAI option included, and changed within the code made accordingly (e.g., canopy intecpt.)
+!!   - max. canopy interception is estimated outside of MPR call
+!! - Matthias Zink                   Feb 2014
+!!   - added PET calculation: Hargreaves-Samani (Process 5)
+!! - Matthias Zink                   Mar 2014
+!!   - added inflow from upstream areas
+!! - Matthias Zink                   Apr 2014
+!!   - added PET calculation: Priestley-Taylor and Penman-Monteith and its parameterization (Process 5)
+!! - Rohini Kumar                    Apr 2014
+!!   - mHM run with a single L0 grid cell, also in the routing mode
+!! - Stephan Thober                  Jun 2014
+!!   - added flag for switching of MPR
+!! - Matthias Cuntz & Juliane Mai    Nov 2014
+!!   - LAI input from daily, monthly or yearly files
+!! - Matthias Zink                   Dec 2014
+!!   - adopted inflow gauges to ignore headwater cells
+!! - Stephan Thober                  Aug 2015
+!!   - moved routing to mRM
+!! - Rohini Kumar                    Mar 2016
+!!   - changes for handling multiple soil database options
+!! - Rohini Kumar                    Dec 2016
+!!   - changes for reading gridded mean monthly LAI fields
+!! - Stephan Thober                  Jan 2017
+!!   - added prescribed weights for tavg and pet
+!! - Zink M. Demirel C.              Mar 2017
+!!   - added Jarvis soil water stress function at SM process(3)
+!! - M.Cuneyd Demirel & Simon Stisen May 2017
+!!   - added FC dependency on root fraction coef. at SM process(3)
+!! - M.Cuneyd Demirel & Simon Stisen Jun 2017
+!!   - added PET correction based on LAI at PET process(5)
+!! - Robert Schweppe, Stephan Thober Nov 2017
+!!   - moved call to MPR to mhm_eval
+!! - Robert Schweppe                 Jun 2018
+!!   - refactoring and reformatting
+!! - Robert Schweppe                 Nov 2018
+!!   - added c2TSTu for unit conversion (moved here from MPR)
+!! - Rohini Kumar                    Oct 2021
+!!   - Neutron count module to mHM integrate into develop branch (5.11.2)
+!! - Stephan Thober                  Jan 2022
+!!   - added is_hourly_forcing
+!! - Sebastian Mueller               May 2022
+!!   - added temp_calc and prec_calc for coupling to other models
+!> \authors Luis Samaniego
+!> \date Dec 2012
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mhm
 MODULE mo_mHM
 
   use mo_kind, only : i4, dp
   use mo_message, only : message
   !$ USE omp_lib
 
   IMPLICIT NONE
@@ -168,86 +222,41 @@
   !>       \param[inout] "real(dp), dimension(:, :) :: COSMICL3"
 
 
   !    HISTORY
   !>       \authors Luis Samaniego & Rohini Kumar
 
   !>       \date Dec 2012
-
-  ! Modifications:
-  ! Luis Samaniego, Rohini Kumar    Dec 2012 - modularization
-  ! Luis Samaniego                  Feb 2013 - call routine
-  ! Rohini Kumar                    Feb 2013 - MPR call and other pre-requisite variables for this call
-  ! Rohini Kumar                    May 2013 - Error checks
-  ! Rohini Kumar                    Jun 2013 - sealed area correction in total runoff
-  !                                          - initalization of soil moist. at first timestep
-  ! Rohini Kumar                    Aug 2013 - dynamic LAI option included, and changed within the code
-  !                                            made accordingly (e.g., canopy intecpt.)
-  !                                          - max. canopy interception is estimated outside of MPR call
-  ! Matthias Zink                   Feb 2014 - added PET calculation: Hargreaves-Samani (Process 5)
-  ! Matthias Zink                   Mar 2014 - added inflow from upstream areas
-  ! Matthias Zink                   Apr 2014 - added PET calculation: Priestley-Taylor and Penman-Monteith
-  !                                            and its parameterization (Process 5)
-  ! Rohini Kumar                    Apr 2014 - mHM run with a single L0 grid cell, also in the routing mode
-  ! Stephan Thober                  Jun 2014 - added flag for switching of MPR
-  ! Matthias Cuntz & Juliane Mai    Nov 2014 - LAI input from daily, monthly or yearly files
-  ! Matthias Zink                   Dec 2014 - adopted inflow gauges to ignore headwater cells
-  ! Stephan Thober                  Aug 2015 - moved routing to mRM
-  ! Rohini Kumar                    Mar 2016 - changes for handling multiple soil database options
-  ! Rohini Kumar                    Dec 2016 - changes for reading gridded mean monthly LAI fields
-  ! Stephan Thober                  Jan 2017 - added prescribed weights for tavg and pet
-  ! Zink M. Demirel C.              Mar 2017 - added Jarvis soil water stress function at SM process(3)
-  ! M.Cuneyd Demirel & Simon Stisen May 2017 - added FC dependency on root fraction coef. at SM process(3)
-  ! M.Cuneyd Demirel & Simon Stisen Jun 2017 - added PET correction based on LAI at PET process(5)
-  ! Robert Schweppe, Stephan Thober Nov 2017 - moved call to MPR to mhm_eval
-  ! Robert Schweppe                 Jun 2018 - refactoring and reformatting
-  ! Robert Schweppe                 Nov 2018 - added c2TSTu for unit conversion (moved here from MPR)
-  ! Rohini Kumar                    Oct 2021 - Neutron count module to mHM integrate into develop branch (5.11.2)
-  ! Stephan Thober                  Jan 2022 - added is_hourly_forcing
-  ! Sebastian Mueller               May 2022 - added temp_calc and prec_calc for coupling to other models
-
-  subroutine mHM(read_states, is_hourly_forcing, tt, time, processMatrix, horizon_depth, nCells1, nHorizons_mHM, ntimesteps_day, &
+  subroutine mHM(read_states, tt, time, processMatrix, horizon_depth, nCells1, nHorizons_mHM, &
                 c2TSTu, neutron_integral_AFast, &
-                latitude, evap_coeff, fday_prec, fnight_prec, fday_pet, &
-                fnight_pet, fday_temp, fnight_temp, temp_weights, pet_weights, pre_weights, read_meteo_weights, pet_in, &
-                tmin_in, tmax_in, netrad_in, absvappres_in, windspeed_in, prec_in, temp_in, fSealed1, interc, snowpack, &
-                sealedStorage, soilMoisture, unsatStorage, satStorage, neutrons, pet_calc, temp_calc, prec_calc, &
+                evap_coeff, &
+                fSealed1, interc, snowpack, &
+                sealedStorage, soilMoisture, unsatStorage, satStorage, neutrons, &
+                pet_calc, temp_calc, prec_calc, &
                 aet_soil, aet_canopy, &
                 aet_sealed, baseflow, infiltration, fast_interflow, melt, perc, prec_effect, rain, runoff_sealed, &
-                slow_interflow, snow, throughfall, total_runoff, alpha, deg_day_incr, deg_day_max, deg_day_noprec, &
-                deg_day, fAsp, petLAIcorFactorL1, HarSamCoeff, PrieTayAlpha, aeroResist, surfResist, frac_roots, &
+                slow_interflow, snow, throughfall, total_runoff, &
+                alpha, deg_day_incr, deg_day_max, deg_day_noprec, &
+                deg_day, frac_roots, &
                 interc_max, karst_loss, k0, k1, k2, kp, soil_moist_FC, soil_moist_sat, soil_moist_exponen, &
                 jarvis_thresh_c1, temp_thresh, unsat_thresh, water_thresh_sealed, wilting_point, &
                 No_count, bulkDens, latticeWater, COSMICL3)
 
-    ! subroutines required to estimate variables prior to the MPR call
-    use mo_upscaling_operators,     only: L0_fractionalCover_in_Lx         ! land cover fraction
-    use mo_multi_param_reg,         only: mpr,canopy_intercept_param       ! reg. and scaling
-    use mo_pet,                     only: pet_hargreaves, pet_priestly,  & ! calc. of pot. evapotranspiration
-                                          pet_penman
-
-    use mo_Temporal_Disagg_Forcing, only : Temporal_Disagg_Forcing
+    use mo_julian, only : dec2date
     use mo_canopy_interc, only : canopy_interc
-    use mo_julian, only : date2dec, dec2date
-    use mo_mhm_constants, only : HarSamConst
     use mo_neutrons, only : COSMIC, DesiletsN0
-    use mo_pet, only : pet_hargreaves, pet_penman, pet_priestly
     use mo_runoff, only : L1_total_runoff, runoff_sat_zone, runoff_unsat_zone
     use mo_snow_accum_melt, only : snow_accum_melt
     use mo_soil_moisture, only : soil_moisture
-    use mo_string_utils, only : num2str
 
     implicit none
 
     !> indicated whether states have been read from file
     logical, intent(in) :: read_states
 
-    !> indicate whether forcing is hourly timestep
-    logical, intent(in) :: is_hourly_forcing
-
     !> simulation time step
     integer(i4), intent(in) :: tt
 
     !> current decimal Julian day
     real(dp), intent(in) :: time
 
     !> mHM process configuration matrix
@@ -258,85 +267,25 @@
 
     !> number of cells in a given domain at level L1
     integer(i4), intent(in) :: nCells1
 
     !> Number of Horizons in mHM
     integer(i4), intent(in) :: nHorizons_mHM
 
-    !> number of time intervals per day, transformed in dp
-    real(dp), intent(in) :: ntimesteps_day
-
     !> unit conversion
     real(dp), intent(in) :: c2TSTu
 
     !> tabular for neutron flux approximation
     real(dp), dimension(:), intent(in) :: neutron_integral_AFast
 
-    !> latitude on level 1
-    real(dp), dimension(:), intent(in) :: latitude
-
     !> Evaporation coefficent for free-water surface of that current month
     real(dp), dimension(:), intent(in) :: evap_coeff
 
-    !> [-] day ratio precipitation < 1
-    real(dp), dimension(:), intent(in) :: fday_prec
-
-    !> [-] night ratio precipitation < 1
-    real(dp), dimension(:), intent(in) :: fnight_prec
-
-    !> [-] day ratio PET  < 1
-    real(dp), dimension(:), intent(in) :: fday_pet
-
-    !> [-] night ratio PET  < 1
-    real(dp), dimension(:), intent(in) :: fnight_pet
-
-    !> [-] day factor mean temp
-    real(dp), dimension(:), intent(in) :: fday_temp
-
-    !> [-] night factor mean temp
-    real(dp), dimension(:), intent(in) :: fnight_temp
-
-    !> multiplicative weights for temperature (deg K)
-    real(dp), dimension(:, :, :), intent(in) :: temp_weights
-
-    !> multiplicative weights for potential evapotranspiration
-    real(dp), dimension(:, :, :), intent(in) :: pet_weights
-
-    !> multiplicative weights for precipitation
-    real(dp), dimension(:, :, :), intent(in) :: pre_weights
-
-    !> flag whether weights for tavg and pet have read and should be used
-    logical, intent(in) :: read_meteo_weights
-
-    !> [mm d-1] Daily potential evapotranspiration (input)
-    real(dp), dimension(:), intent(in) :: pet_in
-
-    !> [degc]   Daily minimum temperature
-    real(dp), dimension(:), intent(in) :: tmin_in
-
-    !> [degc]   Daily maxumum temperature
-    real(dp), dimension(:), intent(in) :: tmax_in
-
-    !> [w m2]   Daily average net radiation
-    real(dp), dimension(:), intent(in) :: netrad_in
-
-    !> [Pa]     Daily average absolute vapour pressure
-    real(dp), dimension(:), intent(in) :: absvappres_in
-
-    !> [m s-1]  Daily average wind speed
-    real(dp), dimension(:), intent(in) :: windspeed_in
-
-    !> [mm d-1] Daily mean precipitation
-    real(dp), dimension(:), intent(in) :: prec_in
-
-    !> [degc]   Daily average temperature
-    real(dp), dimension(:), intent(in) :: temp_in
-
     !> fraction of sealed area at scale L1
-    real(dp), dimension(:), intent(inout) :: fSealed1
+    real(dp), dimension(:), intent(in) :: fSealed1
 
     !> Interception
     real(dp), dimension(:), intent(inout) :: interc
 
     !> Snowpack
     real(dp), dimension(:), intent(inout) :: snowpack
 
@@ -420,32 +369,14 @@
 
     !> Degree-day factor with no precipitation
     real(dp), dimension(:), intent(inout) :: deg_day_noprec
 
     !> Degree-day factor
     real(dp), dimension(:), intent(inout) :: deg_day
 
-    !> [1]     PET correction for Aspect at level 1
-    real(dp), dimension(:), intent(inout) :: fAsp
-
-    !> PET correction factor based on LAI at level 1
-    real(dp), dimension(:), intent(inout) :: petLAIcorFactorL1
-
-    !> [1]     PET Hargreaves Samani coefficient at level 1
-    real(dp), dimension(:), intent(inout) :: HarSamCoeff
-
-    !> [1]     PET Priestley Taylor coefficient at level 1
-    real(dp), dimension(:), intent(inout) :: PrieTayAlpha
-
-    !> [s m-1] PET aerodynamical resitance at level 1
-    real(dp), dimension(:), intent(inout) :: aeroResist
-
-    !> [s m-1] PET bulk surface resitance at level 1
-    real(dp), dimension(:), intent(inout) :: surfResist
-
     !> Fraction of Roots in soil horizon
     real(dp), dimension(:, :), intent(inout) :: frac_roots
 
     !> Maximum interception
     real(dp), dimension(:), intent(inout) :: interc_max
 
     !> Karstic percolation loss
@@ -490,114 +421,46 @@
     ! neutron count
     real(dp), dimension(:), intent(inout)   ::  No_count
     real(dp), dimension(:,:), intent(inout) ::  bulkDens
     real(dp), dimension(:,:), intent(inout) ::  latticeWater
     real(dp), dimension(:,:), intent(inout) ::  COSMICL3
 
 
-    ! is day or night
-    logical :: isday
-
-    ! current hour of a given day
-    integer(i4) :: hour
-
-    ! day of the month     [1-28 or 1-29 or 1-30 or 1-31]
-    integer(i4) :: day
-
     ! Month of current day [1-12]
     integer(i4) :: month
-
-    ! year
-    integer(i4) :: year
-
-    ! doy of the year [1-365 or 1-366]
-    integer(i4) :: doy
-
     ! cell index
     integer(i4) :: k
-    ! pet in [mm d-1]
-    real(dp) :: pet
 
     real(dp), dimension(size(infiltration, 2)) :: tmp_infiltration
-
     real(dp), dimension(size(soilMoisture, 2)) :: tmp_soilMoisture
-
     real(dp), dimension(size(aet_soil, 2)) :: tmp_aet_soil
 
-
     !-------------------------------------------------------------------
     ! date and month of this timestep
     !-------------------------------------------------------------------
-    call dec2date(time, yy = year, mm = month, dd = day, hh = hour)
+    call dec2date(time, mm = month)
 
     !-------------------------------------------------------------------
     ! Update the inital states of soil water content for the first time
     ! step and when perform_mpr = FALSE
     ! based on the half of the derived values of Field capacity
     ! other states are kept at their inital values
     !-------------------------------------------------------------------
     if((tt .EQ. 1) .AND. (.not. read_states)) then
       soilMoisture(:, :) = 0.5_dp * soil_moist_FC(:, :)
     end if
 
     !-------------------------------------------------------------------
-    ! flag for day or night depending on hours of the day
-    !-------------------------------------------------------------------
-    isday = (hour .gt. 6) .AND. (hour .le. 18)
-
-    !-------------------------------------------------------------------
     ! HYDROLOGICAL PROCESSES at L1-LEVEL
     !-------------------------------------------------------------------
     !$OMP parallel default(shared) &
-    !$OMP private(k, pet, tmp_soilmoisture, tmp_infiltration, tmp_aet_soil)
+    !$OMP private(k, tmp_soilmoisture, tmp_infiltration, tmp_aet_soil)
     !$OMP do SCHEDULE(STATIC)
     do k = 1, nCells1
 
-      ! PET calculation
-      select case (processMatrix(5, 1))
-      case(-1) ! PET is input ! correct pet for every day only once at the first time step
-        pet = petLAIcorFactorL1(k) * pet_in(k)
-
-      case(0) ! PET is input ! correct pet for every day only once at the first time step
-        pet = fAsp(k) * pet_in(k)
-
-      case(1) ! Hargreaves-Samani
-        ! estimate day of the year (doy) for approximation of the extraterrestrial radiation
-        doy = nint(date2dec(day, month, year, 12) - date2dec(1, 1, year, 12)) + 1
-
-        if (tmax_in(k) .lt. tmin_in(k)) call message('WARNING: tmax smaller than tmin at doy ', &
-                num2str(doy), ' in year ', num2str(year), ' at cell', num2str(k), '!')
-
-        pet = fAsp(k) * pet_hargreaves(HarSamCoeff(k), HarSamConst, temp_in(k), tmax_in(k), &
-                tmin_in(k), latitude(k), doy)
-
-      case(2) ! Priestley-Taylor
-
-        ! Priestley Taylor is not defined for values netrad < 0.0_dp
-        pet = pet_priestly(PrieTayAlpha(k), max(netrad_in(k), 0.0_dp), temp_in(k))
-
-      case(3) ! Penman-Monteith
-        pet = pet_penman  (max(netrad_in(k), 0.0_dp), temp_in(k), absvappres_in(k) / 1000.0_dp, &
-                aeroResist(k) / windspeed_in(k), surfResist(k), 1.0_dp, 1.0_dp)
-
-      end select
-      ! temporal disaggreagtion of forcing variables
-      if (is_hourly_forcing) then
-         prec_calc(k) = prec_in(k)
-         pet_calc(k) = pet
-         temp_calc(k) = temp_in(k)
-      else
-         call temporal_disagg_forcing(isday, ntimesteps_day, prec_in(k), & ! Intent IN
-              pet, temp_in(k), fday_prec(month), fday_pet(month), & ! Intent IN
-              fday_temp(month), fnight_prec(month), fnight_pet(month), fnight_temp(month), & ! Intent IN
-              temp_weights(k, month, hour + 1), pet_weights(k, month, hour + 1), & ! Intent IN
-              pre_weights(k, month, hour + 1), & ! Intent IN
-              read_meteo_weights, & ! Intent IN
-              prec_calc(k), pet_calc(k), temp_calc(k))                                                            ! Intent OUT
-      end if
       call canopy_interc(pet_calc(k), interc_max(k), prec_calc(k), & ! Intent IN
               interc(k), & ! Intent INOUT
               throughfall(k), aet_canopy(k))                                                      ! Intent OUT
       call snow_accum_melt(deg_day_incr(k), deg_day_max(k) * c2TSTu, & ! Intent IN
               deg_day_noprec(k) * c2TSTu, prec_calc(k), temp_calc(k), temp_thresh(k), throughfall(k), & ! Intent IN
               snowpack(k), & ! Intent INOUT
               deg_day(k), & ! Intent OUT
```

### Comparing `mhm-5.12.1.dev21/src/mHM/mo_mhm_bfi.f90` & `mhm-5.13.0/src/mHM/mo_mhm_bfi.f90`

 * *Files 10% similar despite different names*

```diff
@@ -1,14 +1,18 @@
 !> \file    mo_mhm_bfi.f90
-!> \copydoc mo_mhm_bfi
+!> \brief   \copybrief mo_mhm_bfi
+!> \details \copydetails mo_mhm_bfi
 
 !> \brief   Module to calculate BFI form gauging stations in mHM.
 !> \version 0.1
 !> \authors Sebastian Mueller
 !> \date    Apr 2022
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mhm
 module mo_mhm_bfi
 
   use mo_kind,       only: i4, dp
 
   implicit none
   private
   public :: calculate_BFI
```

### Comparing `mhm-5.12.1.dev21/src/mHM/mo_mhm_constants.f90` & `mhm-5.13.0/src/mHM/mo_mhm_constants.f90`

 * *Files 16% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-!>       \file mo_mhm_constants.f90
-
-!>       \brief Provides mHM specific constants
-
-!>       \details Provides mHM specific constants such as flood plain elevation.
-
-!>       \authors Matthias Cuntz
-
-!>       \date Nov 2011
+!> \file mo_mhm_constants.f90
+!> \brief   \copybrief mo_mhm_constants
+!> \details \copydetails mo_mhm_constants
 
+!> \brief Provides mHM specific constants
+!> \details Provides mHM specific constants such as flood plain elevation.
 ! Modifications:
 ! Robert Schweppe Jun 2018 - refactoring and reformatting
-
+!> \authors Matthias Cuntz
+!> \date Nov 2011
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mhm
 MODULE mo_mhm_constants
 
   USE mo_kind, ONLY : i4, dp
 
   IMPLICIT NONE
 
   PRIVATE
@@ -42,22 +42,22 @@
 
   !> Tetens's formula to calculate saturated vapour pressure
   real(dp), public, parameter :: tetens_c1 = 0.6108_dp
   real(dp), public, parameter :: tetens_c2 = 17.270_dp
   real(dp), public, parameter :: tetens_c3 = 237.30_dp
   !> calculation of the slope of the saturation vapour pressure curve following Tetens
   real(dp), public, parameter :: satpressureslope1 = 4098.0_dp
- 
+
   !> Neutrons and moisture: N0 formula, Desilets et al. 2010
   real(dp), public, parameter :: Desilets_a0 = 0.0808_dp
   real(dp), public, parameter :: Desilets_a1 = 0.372_dp
   real(dp), public, parameter :: Desilets_a2 = 0.115_dp
 
   !> Neutrons and moisture: COSMIC, Shuttleworth et al. 2013
   real(dp), public, parameter :: COSMIC_N = 348.33_dp           ! High energy neutron flux (cph), original was 510.51737902_dp
   real(dp), public, parameter :: COSMIC_alpha = 0.2392421548_dp ! Ratio of Fast Neutron Creation Factor (Soil to Water)
   real(dp), public, parameter :: COSMIC_L1 = 161.98621864_dp    ! High Energy Soil Attenuation Length (g/cm2)
   real(dp), public, parameter :: COSMIC_L2 = 129.14558985_dp    ! High Energy Water Attenuation Length (g/cm2)
   real(dp), public, parameter :: COSMIC_L3 = 107.82204562_dp    ! Fast Neutron Soil Attenuation Length (g/cm2)
   real(dp), public, parameter :: COSMIC_L4 = 3.1627190566_dp    ! Fast Neutron Water Attenuation Length (g/cm2)
-  
+
 END MODULE mo_mhm_constants
```

### Comparing `mhm-5.12.1.dev21/src/mHM/mo_mhm_eval.f90` & `mhm-5.13.0/src/mHM/mo_mhm_eval.f90`

 * *Files 3% similar despite different names*

```diff
@@ -1,14 +1,18 @@
-!>       \file mo_mhm_eval.f90
-!>       \copydoc mo_mhm_eval
+!> \file mo_mhm_eval.f90
+!> \brief   \copybrief mo_mhm_eval
+!> \details \copydetails mo_mhm_eval
 
-!>       \brief Runs mhm with a specific parameter set and returns required variables, e.g. runoff.
-!>       \details Runs mhm with a specific parameter set and returns required variables, e.g. runoff.
-!>       \authors Juliane Mai, Rohini Kumar
-!>       \date Feb 2013
+!> \brief Runs mhm with a specific parameter set and returns required variables, e.g. runoff.
+!> \details Runs mhm with a specific parameter set and returns required variables, e.g. runoff.
+!> \authors Juliane Mai, Rohini Kumar
+!> \date Feb 2013
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mhm
 MODULE mo_mhm_eval
 
   use mo_kind, only : i4, dp
   use mo_optimization_types, only : optidata_sim
   use mo_mhm_interface_run, only : &
     mhm_interface_run_prepare, &
     mhm_interface_run_get_ndomains, &
```

### Comparing `mhm-5.12.1.dev21/src/mHM/mo_mhm_interface.F90` & `mhm-5.13.0/src/mHM/mo_mhm_interface.F90`

 * *Files 4% similar despite different names*

```diff
@@ -1,16 +1,19 @@
 !> \file    mo_mhm_interface.f90
-!> \brief   Module providing interfaces for mHM.
+!> \brief   \copybrief mo_mhm_interface
 !> \details \copydetails mo_mhm_interface
 
 !> \brief   Module providing interfaces for mHM.
-!> \version 0.1
+!> \details Interfaces to control the mHM workflow from outside (init, run, get infos, etc.).
 !> \authors Sebastian Mueller
+!> \version 0.1
 !> \date    Oct 2021
-!> \details Interfaces to control the mHM workflow from outside (init, run, get infos, etc.).
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mhm
 module mo_mhm_interface
 
   use mo_kind, only: i4, dp
   use mo_message, only: message, error_message
   use mo_string_utils, only: num2str
 
 #ifdef MPI
@@ -47,49 +50,49 @@
     use mo_mpr_read_config, only: mpr_read_config
     use mo_mhm_read_config, only: mhm_read_config
     use mo_read_wrapper, only : read_data
     use mo_mrm_init, only: &
       mrm_init, &
       mrm_configuration
     use mo_common_variables, only: &
+      level0, &
+      level1, &
       itimer, &
       domainMeta, &
       processMatrix
     use mo_common_mHM_mRM_variables, only : &
+      timeStep, &
       simPer, &
       optimize, &
       opti_function, &
-      mrm_coupling_mode
+      mrm_coupling_mode, &
+      read_restart
     use mo_mhm_messages, only: &
       startup_message, &
       domain_dir_check_message
     use mo_timer, only: &
       timers_init, &
       timer_start, &
       timer_stop, &
       timer_get
     use mo_startup, only: mhm_initialize
     use mo_file, only: &
       unamelist_mhm, &
       unamelist_mhm_param
     use mo_global_variables, only: &
-      timestep_model_inputs, &
+      meteo_handler, &
       L1_twsaObs, &
       L1_etObs, &
       L1_neutronsObs, &
       L1_smObs, &
       BFI_calc
-    use mo_meteo_forcings, only: prepare_meteo_forcings_data
     use mo_read_optional_data, only: readOptidataObs
     use mo_write_ascii, only: write_configfile
     use mo_mhm_bfi, only: calculate_BFI
-
-#ifdef NAG
-    use f90_unix_dir, only: chdir
-#endif
+    use mo_os, only: change_dir
 
     implicit none
 
     character(*), optional, intent(in) :: namelist_mhm !< path to mHM configuration namelist
     character(*), optional, intent(in) :: namelist_mhm_param !< path to mHM parameter namelist
     character(*), optional, intent(in) :: namelist_mhm_output !< path to mHM output namelist
     character(*), optional, intent(in) :: namelist_mrm_output !< path to mRM output namelist
@@ -104,24 +107,25 @@
 
     ! reset nml paths if wanted
     if (present(namelist_mhm)) file_namelist_mhm = namelist_mhm
     if (present(namelist_mhm_param)) file_namelist_mhm_param = namelist_mhm_param
     if (present(namelist_mhm_output)) file_defOutput = namelist_mhm_output
     if (present(namelist_mrm_output)) mrm_file_defOutput = namelist_mrm_output
     ! change working directory
-    if (present(cwd)) call chdir(cwd)
+    if (present(cwd)) call change_dir(cwd)
 
     ! startup message
     call startup_message()
 
     ! read configs
     call common_read_config(file_namelist_mhm, unamelist_mhm)
     call mpr_read_config(file_namelist_mhm, unamelist_mhm, file_namelist_mhm_param, unamelist_mhm_param)
     call common_mHM_mRM_read_config(file_namelist_mhm, unamelist_mhm)
     call mhm_read_config(file_namelist_mhm, unamelist_mhm)
+    call meteo_handler%config(file_namelist_mhm, unamelist_mhm, optimize, domainMeta, processMatrix, timestep)
     mrm_coupling_mode = 2_i4
     call mrm_configuration(file_namelist_mhm, unamelist_mhm, file_namelist_mhm_param, unamelist_mhm_param)
     call check_optimization_settings()
 
     ! Message about input directories
     call domain_dir_check_message()
 
@@ -140,43 +144,43 @@
     ! domain, with a master and subprocesses. Only the master processes of these
     ! groups need to read the data. The master process with rank 0 only
     ! coordinates the other processes and does not need to read the data.
     if (rank > 0 .and. domainMeta%isMasterInComLocal) then
 #endif
     call message()
 
-    call message('  Read data ...')
-    call timer_start(itimer)
-    ! for DEM, slope, ... define nGvar local
-    ! read_data has a domain loop inside
-    call read_data(simPer)
-    call timer_stop(itimer)
-    call message('    in ', trim(num2str(timer_get(itimer), '(F9.3)')), ' seconds.')
+    if (.not. read_restart) then
+      call message('  Read data ...')
+      call timer_start(itimer)
+      ! for DEM, slope, ... define nGvar local
+      ! read_data has a domain loop inside
+      call read_data(simPer)
+      call timer_stop(itimer)
+      call message('    in ', trim(num2str(timer_get(itimer), '(F9.3)')), ' seconds.')
+    end if
 
     ! read data for every domain
     itimer = itimer + 1
     call message('  Initialize domains ...')
     call timer_start(itimer)
     call mhm_initialize()
+    call meteo_handler%initialize(level0)
     call timer_stop(itimer)
     call message('  in ', trim(num2str(timer_get(itimer), '(F9.3)')), ' seconds.')
     if (processMatrix(8, 1) > 0) &
         call mrm_init(file_namelist_mhm, unamelist_mhm, file_namelist_mhm_param, unamelist_mhm_param)
 
     itimer = itimer + 1
     call message('  Read forcing and optional data ...')
     call timer_start(itimer)
 
     do iDomain = 1, domainMeta%nDomains
       domainID = domainMeta%indices(iDomain)
-      ! read meteorology now, if optimization is switched on
-      ! meteorological forcings (reading, upscaling or downscaling)
-      if (timestep_model_inputs(iDomain) .eq. 0_i4) then
-        call prepare_meteo_forcings_data(iDomain, domainID, 1)
-      end if
+      ! read meteorology now, if it should be loaded in one go
+      if (meteo_handler%single_read(iDomain)) call meteo_handler%prepare_data(1, iDomain, level1, simPer)
 
       ! read optional optional data if necessary
       if (optimize) then
         select case (opti_function)
           case(10 : 13, 28)
             ! read optional spatio-temporal soil mositure data
             call readOptidataObs(iDomain, domainID, L1_smObs(iDomain))
@@ -207,15 +211,15 @@
     ! calculate observed BFI if wanted
     if ( optimize .and. opti_function==34 .and. BFI_calc ) call calculate_BFI()
 
     call timer_stop(itimer)
     call message('    in ', trim(num2str(timer_get(itimer), '(F9.3)')), ' seconds.')
 
     !this call may be moved to another position as it writes the master config out file for all domains
-    call write_configfile()
+    call write_configfile(meteo_handler%dirPrecipitation, meteo_handler%dirReferenceET, meteo_handler%dirTemperature)
 
 #ifdef MPI
     end if
 #endif
 
   end subroutine mhm_interface_init
```

### Comparing `mhm-5.12.1.dev21/src/mHM/mo_mhm_interface_run.f90` & `mhm-5.13.0/src/mHM/mo_mhm_interface_run.f90`

 * *Files 9% similar despite different names*

```diff
@@ -1,15 +1,19 @@
 !> \file    mo_mhm_interface_run.f90
-!> \copydoc mo_mhm_interface_run
+!> \brief   \copybrief mo_mhm_interface_run
+!> \details \copydetails mo_mhm_interface_run
 
 !> \brief   Module providing interfaces for running preconfigured mHM.
-!> \version 0.1
+!> \details Interfaces to control the mHM run from outside (prepare domain, do timestep, ...).
 !> \authors Sebastian Mueller, Matthias Kelbling
+!> \version 0.1
 !> \date    Jan 2022
-!> \details Interfaces to control the mHM run from outside (prepare domain, do timestep, ...).
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mhm
 module mo_mhm_interface_run
 
   ! forces
   use mo_kind, only: i4, dp
   use mo_message, only: message, error_message
   use mo_string_utils, only : num2str
   ! mhm
@@ -18,98 +22,72 @@
   use mo_common_datetime_type, only : datetimeinfo
   use mo_common_mHM_mRM_variables, only : &
     resolutionRouting, &
     LCyearId, &
     mhmFileRestartIn, &
     mrmFileRestartIn, &
     nTstepDay, &
-    nTstepForcingDay, &
     optimize, &
-    readPer, &
     read_restart, &
     simPer, &
     timeStep, &
     warmingDays, &
-    c2TSTu
+    c2TSTu, &
+    restart_reset_fluxes_states
   use mo_common_variables, only : &
     global_parameters, &
+    level0, &
     level1, &
     domainMeta, &
     processMatrix
   use mo_global_variables, only : &
+    meteo_handler, &
     L1_Throughfall, &
     L1_aETCanopy, &
     L1_aETSealed, &
     L1_aETSoil, &
-    L1_absvappress, &
     L1_baseflow, &
     L1_fastRunoff, &
     L1_infilSoil, &
     L1_inter, &
     L1_melt, &
-    L1_netrad, &
     L1_neutrons, &
     L1_percol, &
-    L1_pet, &
     L1_pet_calc, &
     L1_temp_calc, &
     L1_prec_calc, &
-    L1_pet_weights, &
-    L1_pre, &
     L1_preEffect, &
-    L1_pre_weights, &
     L1_rain, &
     L1_runoffSeal, &
     L1_satSTW, &
     L1_sealSTW, &
     L1_slowRunoff, &
     L1_snow, &
     L1_snowPack, &
     L1_soilMoist, &
-    L1_temp, &
-    L1_temp_weights, &
-    L1_tmax, &
-    L1_tmin, &
     L1_total_runoff, &
     L1_unsatSTW, &
-    L1_windspeed, &
     L1_twsaObs, &
     L1_etObs, &
     L1_smObs, &
     L1_neutronsObs, &
-    L1_tann, &
-    L1_ssrd, &
-    L1_strd, &
     evap_coeff, &
-    fday_pet, &
-    fday_prec, &
-    fday_temp, &
-    fnight_pet, &
-    fnight_prec, &
-    fnight_temp, &
     nSoilHorizons_sm_input, &
     neutron_integral_AFast, &
     outputFlxState, &
-    read_meteo_weights, &
-    timeStep_model_inputs, &
     timeStep_model_outputs, &
-    fday_ssrd, &
-    fnight_ssrd, &
-    fday_strd, &
-    fnight_strd, &
     BFI_qBF_sum, &
     BFI_qT_sum
-  use mo_init_states, only : variables_default_init
+  use mo_init_states, only : variables_default_init, fluxes_states_default_init
   use mo_julian, only : caldat, julday
-  use mo_message, only : error_message
   use mo_string_utils, only : num2str
-  use mo_meteo_forcings, only : prepare_meteo_forcings_data
   use mo_mhm, only : mhm
   use mo_restart, only : read_restart_states
-  use mo_write_fluxes_states, only : OutputDataset
+  use mo_write_fluxes_states, only : mHM_updateDataset, mHM_OutputDataset
+  use mo_mrm_write_fluxes_states, only : mRM_updateDataset, mRM_OutputDataset, GW_OutputDataset, GW_updateDataset
   use mo_constants, only : HourSecs
   use mo_common_variables, only : resolutionHydrology
   use mo_mrm_global_variables, only : &
     InflowGauge, &
     L11_C1, &
     L11_C2, &
     L11_L1_Id, &
@@ -164,21 +142,20 @@
     L1_wiltingPoint, &
     L1_No_Count, &
     L1_bulkDens, &
     L1_latticeWater, &
     L1_COSMICL3, &
     HorizonDepth_mHM, &
     nSoilHorizons_mHM
-  use mo_mrm_init, only : variables_default_init_routing
+  use mo_mrm_init, only : variables_default_init_routing, fluxes_states_default_init_routing
   use mo_mrm_mpr, only : mrm_update_param
   use mo_mrm_restart, only : mrm_read_restart_states
   use mo_mrm_routing, only : mrm_routing
-  use mo_mrm_write, only : mrm_write_output_fluxes
   use mo_utils, only : ge
-  use mo_mrm_river_head, only: calc_river_head, avg_and_write_timestep
+  use mo_mrm_river_head, only: calc_river_head
   use mo_mpr_eval, only : mpr_eval
 
 contains
 
   !> \brief prepare single run of mHM
   subroutine mhm_interface_run_prepare(parameterset, opti_domain_indices, runoff_present, BFI_present)
     implicit none
@@ -215,16 +192,14 @@
       run_cfg%domain_indices = opti_domain_indices
     else
       run_cfg%nDomains = domainMeta%nDomains
       allocate(run_cfg%domain_indices(run_cfg%nDomains))
       run_cfg%domain_indices = [(i, i=1, run_cfg%nDomains)]
     end if
 
-    run_cfg%is_hourly_forcing = (nTstepForcingDay .eq. 24_i4)
-
     !----------------------------------------------------------
     ! Check optionals and initialize
     !----------------------------------------------------------
     if (run_cfg%output_runoff) then
       do i = 1, run_cfg%nDomains
         iDomain = run_cfg%get_domain_index(i)
         domainID = domainMeta%indices(iDomain)
@@ -246,29 +221,33 @@
     if (read_restart) then
       do i = 1, run_cfg%nDomains
         iDomain = run_cfg%get_domain_index(i)
         domainID = domainMeta%indices(iDomain)
         ! this reads the eff. parameters and optionally the states and fluxes
         call read_restart_states(iDomain, domainID, mhmFileRestartIn(iDomain))
       end do
+      if (restart_reset_fluxes_states) then
+        call message('    Resetting mHM states and fluxes from restart files ...')
+        call fluxes_states_default_init()
+      end if
     else
       call variables_default_init()
       call mpr_eval(run_cfg%parameterset)
       if (processMatrix(8, 1) > 0) call variables_default_init_routing()
     end if
 
     allocate(run_cfg%L1_fNotSealed(size(L1_fSealed, 1), size(L1_fSealed, 2), size(L1_fSealed, 3)))
     run_cfg%L1_fNotSealed = 1.0_dp - L1_fSealed
 
   end subroutine mhm_interface_run_prepare
 
   !> \brief get number of domains for looping
   subroutine mhm_interface_run_get_ndomains(ndomains)
     implicit none
-    integer(i4), intent(inout) :: ndomains
+    integer(i4), intent(inout) :: ndomains !< number of domains
     ndomains = run_cfg%nDomains
   end subroutine mhm_interface_run_get_ndomains
 
   !> \brief prepare single domain to run mHM on
   subroutine mhm_interface_run_prepare_domain(domain, etOptiSim, twsOptiSim, neutronsOptiSim, smOptiSim)
     implicit none
     !> domain loop counter
@@ -310,16 +289,21 @@
       ! initialize factor between routing resolution and hydrologic model resolution
       ! ----------------------------------------
       run_cfg%tsRoutFactor = 1_i4
       allocate(run_cfg%InflowDischarge(size(InflowGauge%Q, dim = 2)))
       run_cfg%InflowDischarge = 0._dp
 
       ! read states from restart
-      if (read_restart) call mrm_read_restart_states(iDomain, domainID, mrmFileRestartIn(iDomain))
-
+      if (read_restart) then
+        call mrm_read_restart_states(iDomain, domainID, mrmFileRestartIn(iDomain))
+        if (restart_reset_fluxes_states) then
+          call message('    Resetting mRM states and fluxes from restart files for domain ', num2str(iDomain), ' ...')
+          call fluxes_states_default_init_routing(iDomain)
+        end if
+      end if
       ! get Domain information at L11 if routing is activated
       run_cfg%s11 = level11(iDomain)%iStart
       run_cfg%e11 = level11(iDomain)%iEnd
       run_cfg%mask11 => level11(iDomain)%mask
 
       ! initialize routing parameters (has to be called for routing option 2)
       if ((processMatrix(8, 1) .eq. 2) .or. (processMatrix(8, 1) .eq. 3)) &
@@ -345,87 +329,58 @@
     run_cfg%time_step = 0_i4
 
   end subroutine mhm_interface_run_prepare_domain
 
   !> \brief check if current time loop is finished
   subroutine mhm_interface_run_finished(time_loop_finished)
     implicit none
-    logical, intent(inout) :: time_loop_finished
+    logical, intent(inout) :: time_loop_finished !< flag to indicate end of timeloop
     time_loop_finished = run_cfg%time_step == run_cfg%domainDateTime%nTimeSteps
   end subroutine mhm_interface_run_finished
 
   !> \brief do one time-step on current domain
   subroutine mhm_interface_run_do_time_step()
     implicit none
 
-    integer(i4) :: iDomain, domainID, tt, jj
+    integer(i4) :: iDomain, domainID, tt, jj, s1, e1
 
     ! increment time step count (first input is 0)
     run_cfg%time_step = run_cfg%time_step + 1_i4
+    ! current time counter and domain indices
     tt = run_cfg%time_step
-
-    ! get domain index
+    s1 = run_cfg%s1
+    e1 = run_cfg%e1
     iDomain = run_cfg%get_domain_index(run_cfg%selected_domain)
     domainID = domainMeta%indices(iDomain)
 
-    ! time increment is done right after call to mrm (and initially before looping)
-    if (timeStep_model_inputs(iDomain) .eq. 0_i4) then
-      ! whole meteorology is already read
-
-      ! set start and end of meteo position
-      run_cfg%s_meteo = run_cfg%s1
-      run_cfg%e_meteo = run_cfg%e1
-      ! time step for meteorological variable (daily values)
-      ! iMeteoTS = ceiling(real(tt, dp) / real(nTstepDay, dp))
-      run_cfg%iMeteoTS = ceiling(real(tt, dp) / real(nint( 24._dp / real(nTstepForcingDay, dp)), dp))
-    else
-      ! read chunk of meteorological forcings data (reading, upscaling/downscaling)
-      call prepare_meteo_forcings_data(iDomain, domainID, tt)
-      ! set start and end of meteo position
-      run_cfg%s_meteo = 1
-      run_cfg%e_meteo = run_cfg%e1 - run_cfg%s1 + 1
-      ! time step for meteorological variable (daily values)
-      run_cfg%iMeteoTS = &
-        ceiling(real(tt, dp) / real(nint( 24._dp / real(nTstepForcingDay, dp)), dp)) &
-        - (readPer%julStart - simPer(iDomain)%julStart)
-    end if
-
-    ! preapare vector length specifications depending on the process case
-    ! process 5 - PET
-    select case (processMatrix(5, 1))
-      !      [pet,        tmax,    tmin,  netrad, absVapP,windspeed]
-      case(-1 : 0) ! PET is input
-        run_cfg%s_p5 = [run_cfg%s_meteo, 1, 1, 1, 1, 1]
-        run_cfg%e_p5 = [run_cfg%e_meteo, 1, 1, 1, 1, 1]
-      case(1) ! Hargreaves-Samani
-        run_cfg%s_p5 = [run_cfg%s_meteo, run_cfg%s_meteo, run_cfg%s_meteo, 1, 1, 1]
-        run_cfg%e_p5 = [run_cfg%e_meteo, run_cfg%e_meteo, run_cfg%e_meteo, 1, 1, 1]
-      case(2) ! Priestely-Taylor
-        run_cfg%s_p5 = [run_cfg%s_meteo, 1, 1, run_cfg%s_meteo, 1, 1]
-        run_cfg%e_p5 = [run_cfg%e_meteo, 1, 1, run_cfg%e_meteo, 1, 1]
-      case(3) ! Penman-Monteith
-        run_cfg%s_p5 = [run_cfg%s_meteo, 1, 1, run_cfg%s_meteo, run_cfg%s_meteo, run_cfg%s_meteo]
-        run_cfg%e_p5 = [run_cfg%e_meteo, 1, 1, run_cfg%e_meteo, run_cfg%e_meteo, run_cfg%e_meteo]
-    end select
-
-    ! customize iMeteoTS for process 5 - PET
-    select case (processMatrix(5, 1))
-      !              [     pet,     tmin,     tmax,   netrad,  absVapP,windspeed ]
-      case(-1 : 0) ! PET is input
-        run_cfg%iMeteo_p5 = [run_cfg%iMeteoTS, 1, 1, 1, 1, 1 ]
-      case(1) ! Hargreaves-Samani
-        run_cfg%iMeteo_p5 = [run_cfg%iMeteoTS, run_cfg%iMeteoTS, run_cfg%iMeteoTS, 1, 1, 1 ]
-      case(2) ! Priestely-Taylor
-        run_cfg%iMeteo_p5 = [run_cfg%iMeteoTS, 1, 1, run_cfg%iMeteoTS, 1, 1 ]
-      case(3) ! Penman-Monteith
-        run_cfg%iMeteo_p5 = [run_cfg%iMeteoTS, 1, 1, run_cfg%iMeteoTS, run_cfg%iMeteoTS, run_cfg%iMeteoTS ]
-    end select
-
     call run_cfg%domainDateTime%update_LAI_timestep()
 
+    ! update the meteo-handler
+    call meteo_handler%update_timestep( &
+      tt=tt, &
+      time=run_cfg%domainDateTime%newTime - 0.5_dp, &
+      iDomain=iDomain, &
+      level1=level1, &
+      simPer=simPer)
+
+    ! get corrected pet
+    call meteo_handler%get_corrected_pet(pet_calc=L1_pet_calc(s1 : e1), &
+      ! pet calculation dependencies
+      petLAIcorFactorL1 = L1_petLAIcorFactor(s1 : e1, run_cfg%domainDateTime%iLAI, run_cfg%domainDateTime%yId), &
+      fAsp              = L1_fAsp(s1 : e1, 1, 1), &
+      HarSamCoeff       = L1_HarSamCoeff(s1 : e1, 1, 1), &
+      latitude          = pack(level1(iDomain)%y, level1(iDomain)%mask), &
+      PrieTayAlpha      = L1_PrieTayAlpha(s1 : e1, run_cfg%domainDateTime%iLAI, 1), &
+      aeroResist        = L1_aeroResist(s1 : e1, run_cfg%domainDateTime%iLAI, run_cfg%domainDateTime%yId), &
+      surfResist        = L1_surfResist(s1 : e1, run_cfg%domainDateTime%iLAI, 1))
+
+    ! get temperature and precipitation
+    call meteo_handler%get_temp(temp_calc=L1_temp_calc(s1 : e1))
+    call meteo_handler%get_prec(prec_calc=L1_prec_calc(s1 : e1))
+
     ! -------------------------------------------------------------------------
     ! ARGUMENT LIST KEY FOR mHM
     ! -------------------------------------------------------------------------
     !  C    CONFIGURATION
     !  F    FORCING DATA L2
     !  Q    INFLOW FROM UPSTREAM AREAS
     !  L0   MORPHOLOGIC DATA L0
@@ -433,92 +388,76 @@
     !  L11  MORPHOLOGIC DATA L11
     !  P    GLOBAL PARAMETERS
     !  E    EFFECTIVE PARAMETER FIELDS (L1, L11 levels)
     !  S    STATE VARIABLES L1
     !  X    FLUXES (L1, L11 levels)
     ! --------------------------------------------------------------------------
     call mhm( &
-      read_restart, run_cfg%is_hourly_forcing, & ! IN C
-      tt, run_cfg%domainDateTime%newTime - 0.5_dp, processMatrix, &
-      HorizonDepth_mHM, & ! IN C
-      run_cfg%nCells, nSoilHorizons_mHM, real(nTstepDay, dp), c2TSTu,  & ! IN C
-      neutron_integral_AFast, & ! IN C
-      pack(level1(iDomain)%y, level1(iDomain)%mask), & ! IN L1
-      evap_coeff, fday_prec, fnight_prec, fday_pet, fnight_pet, & ! IN F
-      fday_temp, fnight_temp, & ! IN F
-      L1_temp_weights(run_cfg%s1 : run_cfg%e1, :, :), & ! IN F
-      L1_pet_weights(run_cfg%s1 : run_cfg%e1, :, :), & ! IN F
-      L1_pre_weights(run_cfg%s1 : run_cfg%e1, :, :), & ! IN F
-      read_meteo_weights, & ! IN F
-      L1_pet(run_cfg%s_p5(1) : run_cfg%e_p5(1), run_cfg%iMeteo_p5(1)), & ! INOUT F:PET
-      L1_tmin(run_cfg%s_p5(2) : run_cfg%e_p5(2), run_cfg%iMeteo_p5(2)), & ! IN F:PET
-      L1_tmax(run_cfg%s_p5(3) : run_cfg%e_p5(3), run_cfg%iMeteo_p5(3)), & ! IN F:PET
-      L1_netrad(run_cfg%s_p5(4) : run_cfg%e_p5(4), run_cfg%iMeteo_p5(4)), & ! IN F:PET
-      L1_absvappress(run_cfg%s_p5(5) : run_cfg%e_p5(5), run_cfg%iMeteo_p5(5)), & ! IN F:PET
-      L1_windspeed(run_cfg%s_p5(6) : run_cfg%e_p5(6), run_cfg%iMeteo_p5(6)), & ! IN F:PET
-      L1_pre(run_cfg%s_meteo : run_cfg%e_meteo, run_cfg%iMeteoTS), & ! IN F:Pre
-      L1_temp(run_cfg%s_meteo : run_cfg%e_meteo, run_cfg%iMeteoTS), & ! IN F:Temp
-      L1_fSealed(run_cfg%s1 : run_cfg%e1, 1, run_cfg%domainDateTime%yId), & ! INOUT L1
-      L1_inter(run_cfg%s1 : run_cfg%e1), &
-      L1_snowPack(run_cfg%s1 : run_cfg%e1), &
-      L1_sealSTW(run_cfg%s1 : run_cfg%e1), & ! INOUT S
-      L1_soilMoist(run_cfg%s1 : run_cfg%e1, :), &
-      L1_unsatSTW(run_cfg%s1 : run_cfg%e1), &
-      L1_satSTW(run_cfg%s1 : run_cfg%e1), & ! INOUT S
-      L1_neutrons(run_cfg%s1 : run_cfg%e1), & ! INOUT S
-      L1_pet_calc(run_cfg%s1 : run_cfg%e1), & ! INOUT X
-      L1_temp_calc(run_cfg%s1 : run_cfg%e1), & ! INOUT X
-      L1_prec_calc(run_cfg%s1 : run_cfg%e1), & ! INOUT X
-      L1_aETSoil(run_cfg%s1 : run_cfg%e1, :), &
-      L1_aETCanopy(run_cfg%s1 : run_cfg%e1), &
-      L1_aETSealed(run_cfg%s1 : run_cfg%e1), & ! INOUT X
-      L1_baseflow(run_cfg%s1 : run_cfg%e1), &
-      L1_infilSoil(run_cfg%s1 : run_cfg%e1, :), &
-      L1_fastRunoff(run_cfg%s1 : run_cfg%e1), & ! INOUT X
-      L1_melt(run_cfg%s1 : run_cfg%e1), &
-      L1_percol(run_cfg%s1 : run_cfg%e1), &
-      L1_preEffect(run_cfg%s1 : run_cfg%e1), &
-      L1_rain(run_cfg%s1 : run_cfg%e1), & ! INOUT X
-      L1_runoffSeal(run_cfg%s1 : run_cfg%e1), &
-      L1_slowRunoff(run_cfg%s1 : run_cfg%e1), &
-      L1_snow(run_cfg%s1 : run_cfg%e1), & ! INOUT X
-      L1_Throughfall(run_cfg%s1 : run_cfg%e1), &
-      L1_total_runoff(run_cfg%s1 : run_cfg%e1), & ! INOUT X
+      read_states            = read_restart, & ! IN C
+      tt                     = tt, &
+      time                   = run_cfg%domainDateTime%newTime - 0.5_dp, &
+      processMatrix          = processMatrix, &
+      horizon_depth          = HorizonDepth_mHM, & ! IN C
+      nCells1                = run_cfg%nCells, &
+      nHorizons_mHM          = nSoilHorizons_mHM, &
+      c2TSTu                 = c2TSTu,  & ! IN C
+      neutron_integral_AFast = neutron_integral_AFast, & ! IN C
+      evap_coeff             = evap_coeff, &
+      fSealed1               = L1_fSealed(s1 : e1, 1, run_cfg%domainDateTime%yId), & ! INOUT L1
+      interc                 = L1_inter(s1 : e1), &
+      snowpack               = L1_snowPack(s1 : e1), &
+      sealedStorage          = L1_sealSTW(s1 : e1), & ! INOUT S
+      soilMoisture           = L1_soilMoist(s1 : e1, :), &
+      unsatStorage           = L1_unsatSTW(s1 : e1), &
+      satStorage             = L1_satSTW(s1 : e1), & ! INOUT S
+      neutrons               = L1_neutrons(s1 : e1), & ! INOUT S
+      pet_calc               = L1_pet_calc(s1 : e1), & ! INOUT X
+      temp_calc              = L1_temp_calc(s1 : e1), & ! INOUT X
+      prec_calc              = L1_prec_calc(s1 : e1), & ! INOUT X
+      aet_soil               = L1_aETSoil(s1 : e1, :), &
+      aet_canopy             = L1_aETCanopy(s1 : e1), &
+      aet_sealed             = L1_aETSealed(s1 : e1), & ! INOUT X
+      baseflow               = L1_baseflow(s1 : e1), &
+      infiltration           = L1_infilSoil(s1 : e1, :), &
+      fast_interflow         = L1_fastRunoff(s1 : e1), & ! INOUT X
+      melt                   = L1_melt(s1 : e1), &
+      perc                   = L1_percol(s1 : e1), &
+      prec_effect            = L1_preEffect(s1 : e1), &
+      rain                   = L1_rain(s1 : e1), & ! INOUT X
+      runoff_sealed          = L1_runoffSeal(s1 : e1), &
+      slow_interflow         = L1_slowRunoff(s1 : e1), &
+      snow                   = L1_snow(s1 : e1), & ! INOUT X
+      throughfall            = L1_Throughfall(s1 : e1), &
+      total_runoff           = L1_total_runoff(s1 : e1), & ! INOUT X
       ! MPR
-      L1_alpha(run_cfg%s1 : run_cfg%e1, 1, 1), &
-      L1_degDayInc(run_cfg%s1 : run_cfg%e1, 1, run_cfg%domainDateTime%yId), &
-      L1_degDayMax(run_cfg%s1 : run_cfg%e1, 1, run_cfg%domainDateTime%yId), & ! INOUT E1
-      L1_degDayNoPre(run_cfg%s1 : run_cfg%e1, 1, run_cfg%domainDateTime%yId), &
-      L1_degDay(run_cfg%s1 : run_cfg%e1, 1, 1), & ! INOUT E1
-      L1_fAsp(run_cfg%s1 : run_cfg%e1, 1, 1), & ! INOUT E1
-      L1_petLAIcorFactor(run_cfg%s1 : run_cfg%e1, run_cfg%domainDateTime%iLAI, run_cfg%domainDateTime%yId), & ! INOUT E1
-      L1_HarSamCoeff(run_cfg%s1 : run_cfg%e1, 1, 1), & ! INOUT E1
-      L1_PrieTayAlpha(run_cfg%s1 : run_cfg%e1, run_cfg%domainDateTime%iLAI, 1), & ! INOUT E1
-      L1_aeroResist(run_cfg%s1 : run_cfg%e1, run_cfg%domainDateTime%iLAI, run_cfg%domainDateTime%yId), & ! INOUT E1
-      L1_surfResist(run_cfg%s1 : run_cfg%e1, run_cfg%domainDateTime%iLAI, 1), &
-      L1_fRoots(run_cfg%s1 : run_cfg%e1, :, run_cfg%domainDateTime%yId), & ! INOUT E1
-      L1_maxInter(run_cfg%s1 : run_cfg%e1, run_cfg%domainDateTime%iLAI, 1), &
-      L1_karstLoss(run_cfg%s1 : run_cfg%e1, 1, 1), & ! INOUT E1
-      L1_kFastFlow(run_cfg%s1 : run_cfg%e1, 1, run_cfg%domainDateTime%yId), &
-      L1_kSlowFlow(run_cfg%s1 : run_cfg%e1, 1, 1), & ! INOUT E1
-      L1_kBaseFlow(run_cfg%s1 : run_cfg%e1, 1, 1), &
-      L1_kPerco(run_cfg%s1 : run_cfg%e1, 1, 1), & ! INOUT E1
-      L1_soilMoistFC(run_cfg%s1 : run_cfg%e1, :, run_cfg%domainDateTime%yId), & ! INOUT E1
-      L1_soilMoistSat(run_cfg%s1 : run_cfg%e1, :, run_cfg%domainDateTime%yId), & ! INOUT E1
-      L1_soilMoistExp(run_cfg%s1 : run_cfg%e1, :, run_cfg%domainDateTime%yId), &
-      L1_jarvis_thresh_c1(run_cfg%s1 : run_cfg%e1, 1, 1), & ! INOUT E1
-      L1_tempThresh(run_cfg%s1 : run_cfg%e1, 1, run_cfg%domainDateTime%yId), &
-      L1_unsatThresh(run_cfg%s1 : run_cfg%e1, 1, 1), & ! INOUT E1
-      L1_sealedThresh(run_cfg%s1 : run_cfg%e1, 1, 1), & ! INOUT E1
-      L1_wiltingPoint(run_cfg%s1 : run_cfg%e1, :, run_cfg%domainDateTime%yId), & ! INOUT E1
-      !>> neutron count
-      L1_No_Count(run_cfg%s1:run_cfg%e1, 1, 1),  &                     ! INOUT E1
-      L1_bulkDens(run_cfg%s1:run_cfg%e1,     :, run_cfg%domainDateTime%yId), & ! INOUT E1
-      L1_latticeWater(run_cfg%s1:run_cfg%e1, :, run_cfg%domainDateTime%yId), & ! INOUT E1
-      L1_COSMICL3(run_cfg%s1:run_cfg%e1,     :, run_cfg%domainDateTime%yId)  & ! INOUT E1
+      alpha                  = L1_alpha(s1 : e1, 1, run_cfg%domainDateTime%yId), &
+      deg_day_incr           = L1_degDayInc(s1 : e1, 1, run_cfg%domainDateTime%yId), &
+      deg_day_max            = L1_degDayMax(s1 : e1, 1, run_cfg%domainDateTime%yId), & ! INOUT E1
+      deg_day_noprec         = L1_degDayNoPre(s1 : e1, 1, run_cfg%domainDateTime%yId), &
+      deg_day                = L1_degDay(s1 : e1, 1, 1), & ! INOUT E1
+      frac_roots             = L1_fRoots(s1 : e1, :, run_cfg%domainDateTime%yId), & ! INOUT E1
+      interc_max             = L1_maxInter(s1 : e1, run_cfg%domainDateTime%iLAI, 1), &
+      karst_loss             = L1_karstLoss(s1 : e1, 1, 1), & ! INOUT E1
+      k0                     = L1_kFastFlow(s1 : e1, 1, run_cfg%domainDateTime%yId), &
+      k1                     = L1_kSlowFlow(s1 : e1, 1, run_cfg%domainDateTime%yId), & ! INOUT E1
+      k2                     = L1_kBaseFlow(s1 : e1, 1, run_cfg%domainDateTime%yId), &
+      kp                     = L1_kPerco(s1 : e1, 1, run_cfg%domainDateTime%yId), & ! INOUT E1
+      soil_moist_FC          = L1_soilMoistFC(s1 : e1, :, run_cfg%domainDateTime%yId), & ! INOUT E1
+      soil_moist_sat         = L1_soilMoistSat(s1 : e1, :, run_cfg%domainDateTime%yId), & ! INOUT E1
+      soil_moist_exponen     = L1_soilMoistExp(s1 : e1, :, run_cfg%domainDateTime%yId), &
+      jarvis_thresh_c1       = L1_jarvis_thresh_c1(s1 : e1, 1, 1), & ! INOUT E1
+      temp_thresh            = L1_tempThresh(s1 : e1, 1, run_cfg%domainDateTime%yId), &
+      unsat_thresh           = L1_unsatThresh(s1 : e1, 1, 1), & ! INOUT E1
+      water_thresh_sealed    = L1_sealedThresh(s1 : e1, 1, 1), & ! INOUT E1
+      wilting_point          = L1_wiltingPoint(s1 : e1, :, run_cfg%domainDateTime%yId), & ! INOUT E1
+      ! >> neutron count
+      No_count               = L1_No_Count(s1:e1, 1, 1),  &                     ! INOUT E1
+      bulkDens               = L1_bulkDens(s1:e1,     :, run_cfg%domainDateTime%yId), & ! INOUT E1
+      latticeWater           = L1_latticeWater(s1:e1, :, run_cfg%domainDateTime%yId), & ! INOUT E1
+      COSMICL3               = L1_COSMICL3(s1:e1,     :, run_cfg%domainDateTime%yId)  & ! INOUT E1
     )
 
     ! call mRM routing
     run_cfg%doRoute = .false.
     if (domainMeta%doRouting(iDomain)) then
       ! set discharge timestep
       run_cfg%iDischargeTS = ceiling(real(tt, dp) / real(nTstepDay, dp))
@@ -526,15 +465,15 @@
       if (processMatrix(8, 1) .eq. 1) then
         ! >>>
         ! >>> original Muskingum routing, executed every time
         ! >>>
         run_cfg%doRoute = .True.
         run_cfg%tsRoutFactorIn = 1._dp
         run_cfg%timestep_rout = timestep
-        run_cfg%RunToRout = L1_total_runoff(run_cfg%s1 : run_cfg%e1) ! runoff [mm TS-1] mm per timestep
+        run_cfg%RunToRout = L1_total_runoff(s1 : e1) ! runoff [mm TS-1] mm per timestep
         run_cfg%InflowDischarge = InflowGauge%Q(run_cfg%iDischargeTS, :) ! inflow discharge in [m3 s-1]
         !
       else if ((processMatrix(8, 1) .eq. 2) .or. &
                (processMatrix(8, 1) .eq. 3)) then
         ! >>>
         ! >>> adaptive timestep
         ! >>>
@@ -545,26 +484,26 @@
         ! prepare routing call
         if (run_cfg%tsRoutFactor .lt. 1._dp) then
           ! ----------------------------------------------------------------
           ! routing timesteps are shorter than hydrologic time steps
           ! ----------------------------------------------------------------
           ! set all input variables
           run_cfg%tsRoutFactorIn = run_cfg%tsRoutFactor
-          run_cfg%RunToRout = L1_total_runoff(run_cfg%s1 : run_cfg%e1) ! runoff [mm TS-1] mm per timestep
+          run_cfg%RunToRout = L1_total_runoff(s1 : e1) ! runoff [mm TS-1] mm per timestep
           run_cfg%InflowDischarge = InflowGauge%Q(run_cfg%iDischargeTS, :) ! inflow discharge in [m3 s-1]
           run_cfg%timestep_rout = timestep
           run_cfg%doRoute = .True.
         else
           ! ----------------------------------------------------------------
           ! routing timesteps are longer than hydrologic time steps
           ! ----------------------------------------------------------------
           ! set all input variables
           run_cfg%tsRoutFactorIn = run_cfg%tsRoutFactor
           ! Runoff is accumulated in [mm]
-          run_cfg%RunToRout = run_cfg%RunToRout + L1_total_runoff(run_cfg%s1 : run_cfg%e1)
+          run_cfg%RunToRout = run_cfg%RunToRout + L1_total_runoff(s1 : e1)
           run_cfg%InflowDischarge = run_cfg%InflowDischarge + InflowGauge%Q(run_cfg%iDischargeTS, :)
           ! reset tsRoutFactorIn if last period did not cover full period
           if ((tt == run_cfg%domainDateTime%nTimeSteps) .and. (mod(tt, nint(run_cfg%tsRoutFactorIn)) /= 0_i4)) &
             run_cfg%tsRoutFactorIn = mod(tt, nint(run_cfg%tsRoutFactorIn))
           if ((mod(tt, nint(run_cfg%tsRoutFactorIn)) .eq. 0_i4) .or. (tt .eq. run_cfg%domainDateTime%nTimeSteps)) then
             ! Inflow discharge is given as flow-rate and has to be converted to [m3]
             run_cfg%InflowDischarge = run_cfg%InflowDischarge / run_cfg%tsRoutFactorIn
@@ -573,68 +512,55 @@
           end if
         end if
       end if
       ! prepare temperature routing
       if ( riv_temp_pcs%active ) then
         ! init riv-temp from current air temp
         if ( tt .eq. 1_i4 ) call riv_temp_pcs%init_riv_temp( &
-          run_cfg%domainDateTime%newTime - 0.5_dp, &
-          real(nTstepDay, dp), &
-          L1_temp(run_cfg%s_meteo : run_cfg%e_meteo, run_cfg%iMeteoTS), &
-          read_meteo_weights, &
-          L1_temp_weights(run_cfg%s1 : run_cfg%e1, :, :), &
-          fday_temp, fnight_temp, &
-          ! mapping info
-          level1(iDomain)%CellArea * 1.E-6_dp, &
-          L1_L11_Id(run_cfg%s1 : run_cfg%e1), &
-          level11(iDomain)%CellArea * 1.E-6_dp, &
-          L11_L1_Id(run_cfg%s11 : run_cfg%e11), &
-          ! map_flag
-          ge(resolutionRouting(iDomain), resolutionHydrology(iDomain)) &
+          temp_air     = L1_temp_calc(s1 : e1), &
+          efecarea     = level1(iDomain)%CellArea * 1.E-6_dp, &
+          L1_L11_Id    = L1_L11_Id(s1 : e1), &
+          L11_areacell = level11(iDomain)%CellArea * 1.E-6_dp, &
+          L11_L1_Id    = L11_L1_Id(run_cfg%s11 : run_cfg%e11), &
+          map_flag     = ge(resolutionRouting(iDomain), resolutionHydrology(iDomain)) &
         )
+        ! get riv-temp specific meteo arrays
+        call meteo_handler%get_ssrd(riv_temp_pcs%L1_ssrd_calc)
+        call meteo_handler%get_strd(riv_temp_pcs%L1_strd_calc)
+        call meteo_handler%get_tann(riv_temp_pcs%L1_tann_calc)
         ! accumulate source Energy at L1 level
         call riv_temp_pcs%acc_source_E( &
-          run_cfg%domainDateTime%newTime - 0.5_dp, &
-          real(nTstepDay, dp), &
-          L1_fSealed(run_cfg%s1 : run_cfg%e1, 1, run_cfg%domainDateTime%yId), &
-          L1_fastRunoff(run_cfg%s1 : run_cfg%e1), &
-          L1_slowRunoff(run_cfg%s1 : run_cfg%e1), &
-          L1_baseflow(run_cfg%s1 : run_cfg%e1), &
-          L1_runoffSeal(run_cfg%s1 : run_cfg%e1), &
-          L1_temp(run_cfg%s_meteo : run_cfg%e_meteo, run_cfg%iMeteoTS), &
-          L1_tann(run_cfg%s_meteo : run_cfg%e_meteo, run_cfg%iMeteoTS), &
-          L1_ssrd(run_cfg%s_meteo : run_cfg%e_meteo, run_cfg%iMeteoTS), &
-          L1_strd(run_cfg%s_meteo : run_cfg%e_meteo, run_cfg%iMeteoTS), &
-          read_meteo_weights, &
-          L1_temp_weights(run_cfg%s1 : run_cfg%e1, :, :), &
-          fday_temp, fnight_temp, &
-          fday_ssrd, fnight_ssrd, &
-          fday_strd, fnight_strd  &
+          fSealed_area_fraction = L1_fSealed(s1 : e1, 1, run_cfg%domainDateTime%yId), &
+          fast_interflow        = L1_fastRunoff(s1 : e1), &
+          slow_interflow        = L1_slowRunoff(s1 : e1), &
+          baseflow              = L1_baseflow(s1 : e1), &
+          direct_runoff         = L1_runoffSeal(s1 : e1), &
+          temp_air              = L1_temp_calc(s1 : e1) &
         )
         ! if routing should be performed, scale source energy to L11 level
         if ( run_cfg%doRoute ) call riv_temp_pcs%finalize_source_E( &
-          level1(iDomain)%CellArea * 1.E-6_dp, &
-          L1_L11_Id(run_cfg%s1 : run_cfg%e1), &
-          level11(iDomain)%CellArea * 1.E-6_dp, &
-          L11_L1_Id(run_cfg%s11 : run_cfg%e11), &
-          run_cfg%timestep_rout, &
-          ge(resolutionRouting(iDomain), resolutionHydrology(iDomain)) &
+          efecarea     = level1(iDomain)%CellArea * 1.E-6_dp, &
+          L1_L11_Id    = L1_L11_Id(s1 : e1), &
+          L11_areacell = level11(iDomain)%CellArea * 1.E-6_dp, &
+          L11_L1_Id    = L11_L1_Id(run_cfg%s11 : run_cfg%e11), &
+          timestep     = run_cfg%timestep_rout, &
+          map_flag     = ge(resolutionRouting(iDomain), resolutionHydrology(iDomain)) &
         )
       end if
       ! -------------------------------------------------------------------
       ! execute routing
       ! -------------------------------------------------------------------
       if (run_cfg%doRoute) call mRM_routing(&
         ! general INPUT variables
         read_restart, &
         processMatrix(8, 1), & ! parse process Case to be used
         run_cfg%parameterset(processMatrix(8, 3) - processMatrix(8, 2) + 1 : processMatrix(8, 3)), & ! routing par.
         run_cfg%RunToRout, & ! runoff [mm TS-1] mm per timestep old: L1_total_runoff_in(run_cfg%s1:run_cfg%e1, tt), &
         level1(iDomain)%CellArea * 1.E-6_dp, &
-        L1_L11_Id(run_cfg%s1 : run_cfg%e1), &
+        L1_L11_Id(s1 : e1), &
         level11(iDomain)%CellArea * 1.E-6_dp, &
         L11_L1_Id(run_cfg%s11 : run_cfg%e11), &
         L11_netPerm(run_cfg%s11 : run_cfg%e11), & ! routing order at L11
         L11_fromN(run_cfg%s11 : run_cfg%e11), & ! link source at L11
         L11_toN(run_cfg%s11 : run_cfg%e11), & ! link target at L11
         L11_nOutlets(iDomain), & ! number of outlets
         run_cfg%timestep_rout, & ! timestep of runoff to rout [h]
@@ -662,18 +588,15 @@
         L11_qMod(run_cfg%s11 : run_cfg%e11), &
         mRM_runoff(tt, :) &
       )
       ! -------------------------------------------------------------------
       ! groundwater coupling
       ! -------------------------------------------------------------------
       if (gw_coupling) then
-          call calc_river_head(iDomain, L11_Qmod, L0_river_head_mon_sum)
-          if (run_cfg%domainDateTime%is_new_month .and. tt > 1) then
-              call avg_and_write_timestep(iDomain, tt, L0_river_head_mon_sum)
-          end if
+        call calc_river_head(iDomain, L11_Qmod, L0_river_head_mon_sum)
       end if
       ! -------------------------------------------------------------------
       ! reset variables
       ! -------------------------------------------------------------------
       if (processMatrix(8, 1) .eq. 1) then
         ! reset Input variables
         run_cfg%InflowDischarge = 0._dp
@@ -703,51 +626,85 @@
     if (run_cfg%domainDateTime%is_new_year .and. tt < run_cfg%domainDateTime%nTimeSteps) then
       run_cfg%domainDateTime%yId = LCyearId(run_cfg%domainDateTime%year, iDomain)
     end if
 
     ! calculate BFI releated after warming days if wanted
     if ( run_cfg%output_BFI .and. (run_cfg%domainDateTime%tIndex_out > 0_i4) ) then
       BFI_qBF_sum(iDomain) = BFI_qBF_sum(iDomain) &
-        + sum(L1_baseflow(run_cfg%s1 : run_cfg%e1) * level1(iDomain)%CellArea) / level1(iDomain)%nCells
+        + sum(L1_baseflow(s1 : e1) * level1(iDomain)%CellArea) / level1(iDomain)%nCells
       BFI_qT_sum(iDomain) = BFI_qT_sum(iDomain) &
-        + sum(L1_total_runoff(run_cfg%s1 : run_cfg%e1) * level1(iDomain)%CellArea) / level1(iDomain)%nCells
+        + sum(L1_total_runoff(s1 : e1) * level1(iDomain)%CellArea) / level1(iDomain)%nCells
     end if
 
   end subroutine mhm_interface_run_do_time_step
 
   !> \brief write output after current time-step
   subroutine mhm_interface_run_write_output()
     implicit none
-    integer(i4) :: iDomain, tt
+    integer(i4) :: iDomain, tt, s0, e0
 
     ! get time step
     tt = run_cfg%time_step
 
     ! get domain index
     iDomain = run_cfg%get_domain_index(run_cfg%selected_domain)
 
-    if ( .not. optimize ) then
+    if ( (.not. optimize) .and. (run_cfg%domainDateTime%tIndex_out > 0_i4)) then
       if (any(outputFlxState_mrm) .AND. (domainMeta%doRouting(iDomain))) then
-        call mrm_write_output_fluxes( &
-          iDomain, & ! Domain id
-          level11(iDomain)%nCells, & ! nCells in Domain
-          timeStep_model_outputs_mrm, & ! output specification
-          run_cfg%domainDateTime, tt, timestep, & ! time specification
-          run_cfg%mask11, & ! mask specification
-          L11_qmod(run_cfg%s11 : run_cfg%e11) & ! output variables
-        )
+
+        if (run_cfg%domainDateTime%tIndex_out == 1) then
+          run_cfg%nc_mrm = mRM_OutputDataset(iDomain, run_cfg%mask11)
+        end if
+
+        ! update Dataset (riv-temp as optional input)
+        if ( riv_temp_pcs%active ) then
+          call mRM_updateDataset(run_cfg%nc_mrm, &
+            L11_qmod(run_cfg%s11 : run_cfg%e11), riv_temp_pcs%river_temp(riv_temp_pcs%s11 : riv_temp_pcs%e11))
+        else
+          call mRM_updateDataset(run_cfg%nc_mrm, L11_qmod(run_cfg%s11 : run_cfg%e11))
+        end if
+
+        ! write data
+        if (run_cfg%domainDateTime%writeout(timeStep_model_outputs_mrm, tt)) then
+          call run_cfg%nc_mrm%writeTimestep(run_cfg%domainDateTime%tIndex_out * timestep)
+        end if
+
+        if(tt == run_cfg%domainDateTime%nTimeSteps) then
+          call run_cfg%nc_mrm%close()
+        end if
+
+        if ( gw_coupling ) then
+          ! create
+          if (run_cfg%domainDateTime%tIndex_out == 1) then
+            run_cfg%nc_gw = GW_OutputDataset(iDomain, level0(iDomain)%mask)
+          end if
+          ! add data
+          s0 = level0(iDomain)%iStart
+          e0 = level0(iDomain)%iEnd
+          call GW_updateDataset(run_cfg%nc_gw, L0_river_head_mon_sum(s0 : e0))
+          ! write
+          if (run_cfg%domainDateTime%writeout(-2, tt)) then ! -2 for monthly
+            call run_cfg%nc_gw%writeTimestep(run_cfg%domainDateTime%tIndex_out * timestep)
+          end if
+          ! close
+          if(tt == run_cfg%domainDateTime%nTimeSteps) then
+            call run_cfg%nc_gw%close()
+          end if
+        end if
+
       end if
 
-      if ((any(outputFlxState)) .and. (run_cfg%domainDateTime%tIndex_out > 0_i4)) then
+      if (any(outputFlxState)) then
 
         if (run_cfg%domainDateTime%tIndex_out == 1) then
-          run_cfg%nc = OutputDataset(iDomain, run_cfg%mask1, level1(iDomain)%nCells)
+          run_cfg%nc_mhm = mHM_OutputDataset(iDomain, run_cfg%mask1)
         end if
 
-        call run_cfg%nc%updateDataset(&
+        call mHM_updateDataset(&
+          run_cfg%nc_mhm, &
           run_cfg%s1, run_cfg%e1, &
           L1_fSealed(:, 1, run_cfg%domainDateTime%yId), &
           run_cfg%L1_fNotSealed(:, 1, run_cfg%domainDateTime%yId), &
           L1_inter, &
           L1_snowPack, &
           L1_soilMoist, &
           L1_soilMoistSat(:, :, run_cfg%domainDateTime%yId), &
@@ -768,19 +725,19 @@
           L1_infilSoil, &
           L1_preEffect, &
           L1_melt &
         )
 
         ! write data
         if (run_cfg%domainDateTime%writeout(timeStep_model_outputs, tt)) then
-          call run_cfg%nc%writeTimestep(run_cfg%domainDateTime%tIndex_out * timestep - 1)
+          call run_cfg%nc_mhm%writeTimestep(run_cfg%domainDateTime%tIndex_out * timestep)
         end if
 
         if(tt == run_cfg%domainDateTime%nTimeSteps) then
-          call run_cfg%nc%close()
+          call run_cfg%nc_mhm%close()
         end if
 
       end if
     end if ! <-- if (.not. optimize)
 
   end subroutine mhm_interface_run_write_output
```

### Comparing `mhm-5.12.1.dev21/src/mHM/mo_mhm_messages.F90` & `mhm-5.13.0/src/mHM/mo_mhm_messages.F90`

 * *Files 14% similar despite different names*

```diff
@@ -1,16 +1,19 @@
 !> \file    mo_mhm_messages.f90
-!> \brief   Module for mHM messages.
+!> \brief   \copybrief mo_mhm_messages
 !> \details \copydetails mo_mhm_messages
 
 !> \brief   Module for mHM messages.
-!> \version 0.1
+!> \details Write out messages of mHM (startup, checks, status, finish, ect.).
 !> \authors Sebastian Mueller
+!> \version 0.1
 !> \date    Oct 2021
-!> \details Write out messages of mHM (startup, checks, status, finish, ect.).
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mhm
 module mo_mhm_messages
 
     use mo_kind, only: i4
     use mo_message, only: message
     use mo_string_utils, only: num2str, separator
 
   implicit none
@@ -27,19 +30,16 @@
   subroutine startup_message()
     use mo_file, only: &
       version, &
       version_date, &
       file_namelist_mhm, &
       file_namelist_mhm_param, &
       file_defOutput
-    use mo_os, only: path_isfile
+    use mo_os, only: check_path_isfile, get_cwd
     !$ use omp_lib, only: OMP_GET_NUM_THREADS
-#ifdef NAG
-    use f90_unix_dir, only: GETCWD
-#endif
 
     implicit none
 
     character(4096) :: message_text
     integer(i4), dimension(8) :: datetime
     logical :: compiled_with_openmp = .false.
     character(len=255)  :: cur_work_dir
@@ -47,15 +47,15 @@
     !$ integer(i4) :: n_threads
 
 #ifdef MPI
     compiled_with_mpi = .true.
 #endif
 
     ! check for working dir (optional argument to the executable)
-    CALL getcwd(cur_work_dir)
+    CALL get_cwd(cur_work_dir)
 
     call message(separator)
     call message('              mHM-UFZ')
     call message()
     call message('    MULTISCALE HYDROLOGIC MODEL')
     call message('           Version: ', trim(version))
     call message('           Date:    ', trim(version_date))
@@ -91,32 +91,24 @@
     call message('Working directory: ', trim(cur_work_dir))
     call message('Using namelists:')
     call message('     ', trim(file_namelist_mhm))
     call message('     ', trim(file_namelist_mhm_param))
     call message('     ', trim(file_defOutput))
     call message()
 
-    call path_isfile(path = file_namelist_mhm, quiet_ = .true., throwError_ = .true.)
-    call path_isfile(path = file_namelist_mhm_param, quiet_ = .true., throwError_ = .true.)
-    call path_isfile(path = file_defOutput, quiet_ = .true., throwError_ = .true.)
+    call check_path_isfile(path = file_namelist_mhm, raise=.true.)
+    call check_path_isfile(path = file_namelist_mhm_param, raise=.true.)
+    call check_path_isfile(path = file_defOutput, raise=.true.)
 
   end subroutine startup_message
 
   !> \brief Check input directories for mHM.
   subroutine domain_dir_check_message()
     use mo_check, only: check_dir
-    use mo_global_variables, only: &
-      dirPrecipitation, &
-      dirTemperature, &
-      dirReferenceET, &
-      dirMinTemperature, &
-      dirMaxTemperature, &
-      dirNetRadiation, &
-      dirabsVapPressure, &
-      dirwindspeed
+    use mo_global_variables, only: meteo_handler
     use mo_common_variables, only: &
       dirMorpho, &
       dirLCover, &
       dirOut, &
       domainMeta, &
       processMatrix
 
@@ -131,28 +123,28 @@
     do iDomain = 1, domainMeta%nDomains
       domainID = domainMeta%indices(iDomain)
       call message('  --------------')
       call message('      DOMAIN                  ', num2str(domainID, '(I3)'))
       call message('  --------------')
       call check_dir(dirMorpho(iDomain), "Morphological directory:", .false., 4, 30)
       call check_dir(dirLCover(iDomain), "Land cover directory:", .false., 4, 30)
-      call check_dir(dirPrecipitation(iDomain), "Precipitation directory:", .false., 4, 30)
-      call check_dir(dirTemperature(iDomain), "Temperature directory:", .false., 4, 30)
+      call check_dir(meteo_handler%dirPrecipitation(iDomain), "Precipitation directory:", .false., 4, 30)
+      call check_dir(meteo_handler%dirTemperature(iDomain), "Temperature directory:", .false., 4, 30)
       select case (processMatrix(5, 1))
         case(-1 : 0) ! PET is input
-          call check_dir(dirReferenceET(iDomain), "PET directory:", .false., 4, 30)
+          call check_dir(meteo_handler%dirReferenceET(iDomain), "PET directory:", .false., 4, 30)
         case(1) ! Hargreaves-Samani
-          call check_dir(dirMinTemperature(iDomain), "Min. temperature directory:", .false., 4, 30)
-          call check_dir(dirMaxTemperature(iDomain), "Max. temperature directory:", .false., 4, 30)
+          call check_dir(meteo_handler%dirMinTemperature(iDomain), "Min. temperature directory:", .false., 4, 30)
+          call check_dir(meteo_handler%dirMaxTemperature(iDomain), "Max. temperature directory:", .false., 4, 30)
         case(2) ! Priestely-Taylor
-          call check_dir(dirNetRadiation(iDomain), "Net radiation directory:", .false., 4, 30)
+          call check_dir(meteo_handler%dirNetRadiation(iDomain), "Net radiation directory:", .false., 4, 30)
         case(3) ! Penman-Monteith
-          call check_dir(dirNetRadiation(iDomain), "Net radiation directory:", .false., 4, 30)
-          call check_dir(dirabsVapPressure(iDomain), "Abs. vap. press. directory:", .false., 4, 30)
-          call check_dir(dirwindspeed(iDomain), "Windspeed directory:", .false., 4, 30)
+          call check_dir(meteo_handler%dirNetRadiation(iDomain), "Net radiation directory:", .false., 4, 30)
+          call check_dir(meteo_handler%dirabsVapPressure(iDomain), "Abs. vap. press. directory:", .false., 4, 30)
+          call check_dir(meteo_handler%dirwindspeed(iDomain), "Windspeed directory:", .false., 4, 30)
       end select
       call check_dir(dirOut(iDomain), "Output directory:", .true., 4, 30)
       call message()
     end do
     call message()
 
   end subroutine domain_dir_check_message
```

### Comparing `mhm-5.12.1.dev21/src/mHM/mo_mhm_read_config.f90` & `mhm-5.13.0/src/mHM/mo_mhm_read_config.f90`

 * *Files 12% similar despite different names*

```diff
@@ -1,24 +1,24 @@
-!>       \file mo_mhm_read_config.f90
-
-!>       \brief Reading of main model configurations.
-
-!>       \details This routine reads the configurations of mHM including, input and
-!>       output directories, module usage specification, simulation time periods,
-!>       global parameters, ...
-
-!>       \authors Matthias Zink
-
-!>       \date Dec 2012
-
-! Modifications:
-
+!> \file mo_mhm_read_config.f90
+!> \brief   \copybrief mo_mhm_read_config
+!> \details \copydetails mo_mhm_read_config
+
+!> \brief Reading of main model configurations.
+!> \details This routine reads the configurations of mHM including, input and
+!!       output directories, module usage specification, simulation time periods,
+!!       global parameters, ...
+!> \authors Matthias Zink
+!> \date Dec 2012
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mhm
 MODULE mo_mhm_read_config
 
   USE mo_kind, ONLY : i4, dp
+  use mo_message, only: message, error_message
 
   IMPLICIT NONE
 
   PRIVATE
 
   PUBLIC :: mhm_read_config ! read main directories
 
@@ -91,59 +91,32 @@
     use mo_common_constants, only : maxNoDomains, nodata_i4
     use mo_common_mHM_mRM_read_config, only : common_check_resolution
     use mo_common_mhm_mrm_variables, only : opti_function, optimize
     use mo_common_variables, only : domainMeta, processMatrix
     use mo_file, only : file_defOutput, udefOutput
     use mo_global_variables, only : &
       L1_twsaObs, L1_etObs, L1_smObs, L1_neutronsObs, &
-      dirMaxTemperature, dirMinTemperature, dirNetRadiation, dirPrecipitation, &
-      dirReferenceET, dirTemperature, dirabsVapPressure, dirwindspeed, dirRadiation, &
       evap_coeff, &
-      fday_pet, fday_prec, fday_temp, fday_ssrd, fday_strd, &
-      fnight_pet, fnight_prec, fnight_temp, fnight_ssrd, fnight_strd, &
-      inputFormat_meteo_forcings, nSoilHorizons_sm_input, outputFlxState, &
-      read_meteo_weights, timeStep_model_outputs, &
-      timestep_model_inputs, &
-      output_deflate_level, output_double_precision, &
+      nSoilHorizons_sm_input, outputFlxState, &
+      timeStep_model_outputs, &
+      output_deflate_level, output_double_precision, output_time_reference, &
       BFI_calc, BFI_obs
-    use mo_message, only : message
     use mo_mpr_constants, only : maxNoSoilHorizons
     use mo_mpr_global_variables, only : nSoilHorizons_mHM
     use mo_nml, only : close_nml, open_nml, position_nml
     use mo_string_utils, only : num2str
 
     implicit none
 
     character(*), intent(in) :: file_namelist
 
     integer, intent(in) :: unamelist
 
     integer(i4) :: iDomain, domainID
 
-    integer(i4), dimension(maxNoDomains) :: time_step_model_inputs
-
-    character(256), dimension(maxNoDomains) :: dir_Precipitation
-
-    character(256), dimension(maxNoDomains) :: dir_Temperature
-
-    character(256), dimension(maxNoDomains) :: dir_MinTemperature
-
-    character(256), dimension(maxNoDomains) :: dir_MaxTemperature
-
-    character(256), dimension(maxNoDomains) :: dir_NetRadiation
-
-    character(256), dimension(maxNoDomains) :: dir_windspeed
-
-    character(256), dimension(maxNoDomains) :: dir_absVapPressure
-
-    character(256), dimension(maxNoDomains) :: dir_ReferenceET
-
-    ! riv-temp related
-    character(256), dimension(maxNoDomains) :: dir_Radiation
-
     ! soil moisture input
     character(256), dimension(maxNoDomains) :: dir_soil_moisture
 
     ! ground albedo neutron input
     character(256), dimension(maxNoDomains) :: dir_neutrons
 
     ! evapotranspiration input
@@ -155,115 +128,53 @@
     integer(i4) :: timeStep_tws_input         ! time step of optional data: tws
     integer(i4) :: timeStep_et_input          ! time step of optional data: et
     integer(i4) :: timeStep_sm_input          ! time step of optional data: sm
     integer(i4) :: timeStep_neutrons_input    ! time step of optional data: neutrons
 
 
     ! define namelists
-    ! namelist directories
-    namelist /directories_mHM/ &
-            inputFormat_meteo_forcings, &
-            dir_Precipitation, &
-            dir_Temperature, &
-            dir_ReferenceET, &
-            dir_MinTemperature, &
-            dir_MaxTemperature, &
-            dir_absVapPressure, &
-            dir_windspeed, &
-            dir_NetRadiation, &
-            dir_Radiation, &
-            time_step_model_inputs
     ! optional data used for optimization
     namelist /optional_data/ &
             dir_soil_moisture, &
             nSoilHorizons_sm_input, &
             dir_neutrons, &
             dir_evapotranspiration, &
             dir_TWS, &
             timeStep_sm_input, &
             timeStep_neutrons_input, &
             timeStep_et_input, &
             timeStep_tws_input
     ! namelist for pan evaporation
     namelist /panEvapo/evap_coeff
 
-    ! namelist for night-day ratio of precipitation, referenceET and temperature
-    namelist /nightDayRatio/ read_meteo_weights, &
-      fnight_prec, fnight_pet, fnight_temp, fnight_ssrd, fnight_strd
     ! name list regarding output
     namelist /NLoutputResults/ &
             output_deflate_level, &
             output_double_precision, &
+            output_time_reference, &
             timeStep_model_outputs, &
             outputFlxState
     ! namelist for baseflow index optimzation
     namelist /baseflow_config/ BFI_calc, BFI_obs
 
     !===============================================================
     !  Read namelist main directories
     !===============================================================
     call open_nml(file_namelist, unamelist, quiet = .true.)
 
-    allocate(dirPrecipitation(domainMeta%nDomains))
-    allocate(dirTemperature(domainMeta%nDomains))
-    allocate(dirwindspeed(domainMeta%nDomains))
-    allocate(dirabsVapPressure(domainMeta%nDomains))
-    allocate(dirReferenceET(domainMeta%nDomains))
-    allocate(dirMinTemperature(domainMeta%nDomains))
-    allocate(dirMaxTemperature(domainMeta%nDomains))
-    allocate(dirNetRadiation(domainMeta%nDomains))
-    allocate(dirRadiation(domainMeta%nDomains))
     allocate(L1_twsaObs(domainMeta%nDomains))
     allocate(L1_etObs(domainMeta%nDomains))
     allocate(L1_smObs(domainMeta%nDomains))
     allocate(L1_neutronsObs(domainMeta%nDomains))
-    ! allocate time periods
-    allocate(timestep_model_inputs(domainMeta%nDomains))
     ! observed baseflow indizes
     allocate(BFI_obs(domainMeta%nDomains))
     BFI_obs = -1.0_dp  ! negative value to flag missing values
     BFI_calc = .false.
 
     !===============================================================
-    !  Read namelist for mainpaths
-    !===============================================================
-    call position_nml('directories_mHM', unamelist)
-    read(unamelist, nml = directories_mHM)
-
-    do iDomain = 1, domainMeta%nDomains
-      domainID = domainMeta%indices(iDomain)
-
-      dirPrecipitation(iDomain) = dir_Precipitation(domainID)
-      dirTemperature(iDomain) = dir_Temperature(domainID)
-      dirReferenceET(iDomain) = dir_ReferenceET(domainID)
-      dirMinTemperature(iDomain) = dir_MinTemperature(domainID)
-      dirMaxTemperature(iDomain) = dir_MaxTemperature(domainID)
-      dirNetRadiation(iDomain) = dir_NetRadiation(domainID)
-      dirwindspeed(iDomain) = dir_windspeed(domainID)
-      dirabsVapPressure(iDomain) = dir_absVapPressure(domainID)
-      timestep_model_inputs(iDomain) = time_step_model_inputs(domainID)
-      ! riv-temp related
-      dirRadiation(iDomain) = dir_Radiation(domainID)
-    end do
-
-    ! consistency check for timestep_model_inputs
-    if (any(timestep_model_inputs .ne. 0) .and. &
-            .not. all(timestep_model_inputs .ne. 0)) then
-      call message()
-      call message('***ERROR: timestep_model_inputs either have to be all zero or all non-zero')
-      stop
-    end if
-    ! check for optimzation and timestep_model_inputs options
-    if (optimize .and. (any(timestep_model_inputs .ne. 0))) then
-      call message()
-      call message('***ERROR: optimize and chunk read is switched on! (set timestep_model_inputs to zero)')
-      stop
-    end if
-
-    !===============================================================
     !  Read namelist of optional input data
     !===============================================================
     ! read optional optional data if necessary
     if (optimize) then
       select case (opti_function)
         case(10 : 13, 28)
           ! soil moisture
@@ -272,18 +183,16 @@
           do iDomain = 1, domainMeta%nDomains
             domainID = domainMeta%indices(iDomain)
             L1_smObs(iDomain)%dir = dir_Soil_moisture(domainID)
             L1_smObs(iDomain)%timeStepInput = timeStep_sm_input
             L1_smObs(iDomain)%varname = 'sm'
           end do
           if (nSoilHorizons_sm_input .GT. nSoilHorizons_mHM) then
-            call message()
-            call message('***ERROR: Number of soil horizons representative for input soil moisture exceeded')
-            call message('          defined number of soil horizions: ', adjustl(trim(num2str(maxNoSoilHorizons))), '!')
-            stop
+            call error_message('***ERROR: Number of soil horizons representative for input soil moisture exceeded', raise=.false.)
+            call error_message('          defined number of soil horizions: ', adjustl(trim(num2str(maxNoSoilHorizons))), '!')
           end if
         case(17)
           ! neutrons
           call position_nml('optional_data', unamelist)
           read(unamelist, nml = optional_data)
           do iDomain = 1, domainMeta%nDomains
             domainID = domainMeta%indices(iDomain)
@@ -338,58 +247,52 @@
           call position_nml('baseflow_config', unamelist)
           read(unamelist, nml = baseflow_config)
 
       end select
     end if
 
     !===============================================================
-    ! Read night-day ratios and pan evaporation
+    ! Read pan evaporation
     !===============================================================
-    ! default values for long/shortwave rad.
-    fnight_ssrd = 0.0_dp
-    fnight_strd = 0.45_dp
     ! Evap. coef. for free-water surfaces
     call position_nml('panEvapo', unamelist)
     read(unamelist, nml = panEvapo)
-    ! namelist for night-day ratio of precipitation, referenceET and temperature
-    call position_nml('nightDayRatio', unamelist)
-    read(unamelist, nml = nightDayRatio)
-    !
-    fday_prec = 1.0_dp - fnight_prec
-    fday_pet = 1.0_dp - fnight_pet
-    fday_temp = -1.0_dp * fnight_temp
-    fday_ssrd = 1.0_dp - fnight_ssrd
-    fday_strd = 1.0_dp - fnight_strd
-
-    ! TODO-RIV-TEMP:
-    ! - add short- and long-wave raidiation weights (nc files)
 
     call common_check_resolution(.true., .false.)
 
     call close_nml(unamelist)
 
     !===============================================================
     ! Read output specifications for mHM
     !===============================================================
     call open_nml(file_defOutput, udefOutput, quiet = .true.)
     output_deflate_level = 6
+    output_time_reference = 0
     output_double_precision = .true.
     outputFlxState = .FALSE.
     call position_nml('NLoutputResults', udefOutput)
     read(udefOutput, nml = NLoutputResults)
     call close_nml(udefOutput)
 
     call message('')
     call message('Following output will be written:')
     call message('  NetCDF deflate level: ', adjustl(trim(num2str(output_deflate_level))))
     if ( output_double_precision ) then
       call message('  NetCDF output precision: double')
     else
       call message('  NetCDF output precision: single')
     end if
+    select case(output_time_reference)
+      case(0)
+        call message('    NetCDF output time reference point: start of time interval')
+      case(1)
+        call message('    NetCDF output time reference point: center of time interval')
+      case(2)
+        call message('    NetCDF output time reference point: end of time interval')
+    end select
     call message('  STATES:')
     if (outputFlxState(1)) then
       call message('    interceptional storage                          (L1_inter) [mm]')
     end if
     if (outputFlxState(2)) then
       call message('    height of snowpack                           (L1_snowpack) [mm]')
     end if
```

### Comparing `mhm-5.12.1.dev21/src/mHM/mo_neutrons.f90` & `mhm-5.13.0/src/mHM/mo_neutrons.f90`

 * *Files 2% similar despite different names*

```diff
@@ -1,56 +1,55 @@
 !> \file mo_neutrons.f90
-!> \brief Models to predict neutron intensities above soils
+!> \brief   \copybrief mo_neutrons
+!> \details \copydetails mo_neutrons
 
+!> \brief Models to predict neutron intensities above soils
 !> \details The number of neutrons above the ground is directly related to
-!> the number soil water content in the ground, air, vegetation and/or snow.
-!> This module forward-models neutron abundance as a state variable for each cell.
-
+!! the number soil water content in the ground, air, vegetation and/or snow.
+!! This module forward-models neutron abundance as a state variable for each cell.
 !> \authors Martin Schroen
 !> \date Mar 2015
-
-!> THIS MODULE IS WORK IN PROGRESS, DO NOT USE FOR RESEARCH.
-
-! TODO make it faster with pre-calculated horizons and variables
-! TODO use global parameters as linear model 
-
+!> \warning THIS MODULE IS WORK IN PROGRESS, DO NOT USE FOR RESEARCH.
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mhm
 MODULE mo_neutrons
 
-  ! Written  Martin Schroen, Mar 2015
-  ! Modified 
-  
+  ! TODO make it faster with pre-calculated horizons and variables
+  ! TODO use global parameters as linear model
+
   USE mo_kind, ONLY: i4, dp
   IMPLICIT NONE
 
   ! Neutron forward model using particle transport physics, see Shuttleworth et al. 2013
-  PUBLIC :: COSMIC     
-  
+  PUBLIC :: COSMIC
+
   ! inverse \theta(N) relation based on Desilets et al. 2010
-  PUBLIC :: DesiletsN0 
+  PUBLIC :: DesiletsN0
 
-  ! integration tabular for approximating the neutron flux integral 
+  ! integration tabular for approximating the neutron flux integral
   PUBLIC :: TabularIntegralAFast
-  
+
   PRIVATE
 
 CONTAINS
-  
+
   ! -----------------------------------------------------------------------------------
   !     NAME
   !         DesiletsN0
   !
   !     PURPOSE
   !>        \brief Calculate neutrons from soil moisture for effective soil layer
   !>        \details Using the N0-relation derived by Desilets, neutron
-  !>        counts above the ground (one value per cell in mHM) can be 
-  !>        derived by a semi-empirical, semi-physical relation. 
+  !>        counts above the ground (one value per cell in mHM) can be
+  !>        derived by a semi-empirical, semi-physical relation.
   !>        The result depends on N0, the neutron counts for 0% soil mositure.
   !>        This variable is site-specific and is a global parameter in mHM.
   !         ------------------------------------------------------------------
-  !         N0 formula based on Desilets et al. 2010                          
+  !         N0 formula based on Desilets et al. 2010
   !         ------------------------------------------------------------------
   !
   !     CALLING SEQUENCE
   !         call DesiletsN0( Moisture(cells,layers), Depths(layers), &
   !                          N0-parameter, output(cells) )
   !
   !     INTENT(IN)
@@ -91,31 +90,31 @@
   !         Nature's neutron probe: Land surface hydrology at an elusive scale
   !         with cosmic rays, WRR, 46, W11505, doi:10.1029/2009WR008726.
   !
   !     HISTORY
   !>        \author Martin Schroen
   !>        \date Mar 2015
   !>        Modified Rohini Kumar         Oct 2021 - Vertical weighting approach
-  !>                                      for the Neutron count module to mHM - develop branch 
+  !>                                      for the Neutron count module to mHM - develop branch
 
   subroutine DesiletsN0(SoilMoisture, Horizon_depth, Bd, latWater, N0, neutrons)
 
     use mo_mhm_constants, only: Desilets_a0, Desilets_a1, Desilets_a2
     use mo_moment,        only: average
     implicit none
-    
+
     real(dp), dimension(:),          intent(in)    :: SoilMoisture
     real(dp), dimension(:),          intent(in)    :: Horizon_depth
     real(dp), dimension(:),          intent(in)    :: Bd
     real(dp), dimension(:),          intent(in)    :: latWater
     real(dp),                        intent(in)    :: N0           ! from global parameters
     real(dp),                        intent(inout) :: neutrons
     ! local variables
     integer(i4)                                    :: nLayers, LL, nn, nIntervals
-    real(dp), dimension(:), allocatable            :: Layer_min, Layer_max, Layer_depth 
+    real(dp), dimension(:), allocatable            :: Layer_min, Layer_max, Layer_depth
     real(dp)                                       :: average_swc, average_bd
     real(dp)                                       :: D_86_in_cm,  D_86_in_mm
     real(dp), dimension(:), allocatable            :: cummulative_Layer_weight
     real(dp)                                       :: depth, weight_10mm_spacing, grav_swc
 
     ! get the # of soil hoizons
     nLayers = size(SoilMoisture)
@@ -128,97 +127,97 @@
     Layer_max(1) = Horizon_depth(1)
     ! rest layers
     do LL = 2, nLayers
        Layer_min(LL) = Layer_max(LL-1)
        Layer_max(LL) = Horizon_depth(LL)
     end do
 
-    ! estimate layer depth [mm] 
+    ! estimate layer depth [mm]
     Layer_depth(:) = Layer_max(:) - Layer_min(:)
-    
+
     ! average soil water content (volumetric ones) and Bulk density
     average_swc = average( SoilMoisture(:)/Layer_depth(:) )
-    average_bd  = average( Bd(:) ) 
+    average_bd  = average( Bd(:) )
 
-    ! estimate D86 [in cm and mm ] 
+    ! estimate D86 [in cm and mm ]
     D_86_in_cm = ( 1.0_dp/average_bd ) * &
          ( 8.321_dp + 0.14249_dp * (0.96655_dp + exp(-0.01_dp)) * (20.0_dp + average_swc)/(0.0429_dp + average_swc) )
     D_86_in_mm = D_86_in_cm * 10.0_dp  !# convert cm to mm
 
 
     ! initalise cummulative layer specific weight
     allocate( cummulative_Layer_weight(nLayers)  )
     cummulative_Layer_weight(:) = 0.0_dp
 
     !! only once to calculate weight at equal space at every 10 mm spacing
     nIntervals = nint( maxval(Horizon_depth(:))/10.0_dp )
-    
-    ! calculate 10 mm spacing and on fly the cummulative weights 
+
+    ! calculate 10 mm spacing and on fly the cummulative weights
     depth = 0.0_dp
     do nn = 1, nIntervals
        weight_10mm_spacing = exp(-2.0_dp * depth / D_86_in_mm )
- 
-       ! estimate the layer specific cummulative weights 
+
+       ! estimate the layer specific cummulative weights
        do LL = 1, nLayers
           if(  (depth .GE. Layer_min(LL))  .AND. (depth .LT. Layer_max(LL))  ) then
-             cummulative_Layer_weight(LL) = cummulative_Layer_weight(LL) + weight_10mm_spacing 
+             cummulative_Layer_weight(LL) = cummulative_Layer_weight(LL) + weight_10mm_spacing
           end if
        end do
        ! update depth
        depth = depth + 10.0_dp
     end do
 
 
     ! estimate weightage SWC
     ! here average_swc is gravemtric swc = vol.swc/Bulk density
     average_swc = 0.0_dp
     do LL = 1, nLayers
-       !!>> add here if organic water is coming !!>> SoilMoisture(LL) + latWater(LL) + organic_water(LL)...
-       grav_swc = ( SoilMoisture(LL) + latWater(LL) )/Layer_depth(LL)/Bd(LL)  
-       average_swc = average_swc + ( grav_swc * cummulative_Layer_weight(LL) ) 
+       !! >> add here if organic water is coming !! >> SoilMoisture(LL) + latWater(LL) + organic_water(LL)...
+       grav_swc = ( SoilMoisture(LL) + latWater(LL) )/Layer_depth(LL)/Bd(LL)
+       average_swc = average_swc + ( grav_swc * cummulative_Layer_weight(LL) )
     end do
     average_swc = average_swc / sum( cummulative_Layer_weighT(:) )
 
     ! calculate neutron count based on depth weighted SM of *D86*
-    neutrons = N0 * ( Desilets_a1 + Desilets_a0 / (average_swc + Desilets_a2) )    
+    neutrons = N0 * ( Desilets_a1 + Desilets_a0 / (average_swc + Desilets_a2) )
 
     !! deallocate variables
     deallocate(Layer_min, Layer_max, Layer_depth, cummulative_Layer_weight)
-    
+
   end subroutine DesiletsN0
   ! -----------------------------------------------------------------------------------
   !     NAME
   !         COSMIC
   !
   !     PURPOSE
   !>        \brief Calculate neutrons from soil moisture in all layers.
   !>        \details Neutron counts above the ground (one value per cell in mHM)
   !>        can be derived by a simplified physical neutron transport simulation.
   !>        Fast cosmic-Ray neutrons are generated in the soil and attenuated
-  !>        differently in water and soil. The remaining neutrons that reached 
+  !>        differently in water and soil. The remaining neutrons that reached
   !>        the surface relate to the profile of soil water content below.
   !>        Variables like N, alpha and L3 are site-specific and need to be calibrated.
   !         ------------------------------------------------------------------
-  !         COSMIC model based on Shuttleworth et al. 2013                    
+  !         COSMIC model based on Shuttleworth et al. 2013
   !         ------------------------------------------------------------------
   !
   !     CALLING SEQUENCE
   !         call COSMIC( Moisture(cells,layers), Depths(layers), &
   !                          COSMIC-parameterset, neutron_integral_AFast, output(cells) )
   !
   !     INTENT(IN)
   !>        \param[in] "real(dp), dimension(:)   :: SoilMoisture" Soil Moisture
   !>        \param[in] "real(dp), dimension(:)   :: Horizons" Horizon depths
   !>        \param[in] "real(dp), dimension(:)   :: neutron_integral_AFast" Tabular for Int Approx
-  !>        \param[in] "real(dp)                 :: interc" interception 
+  !>        \param[in] "real(dp)                 :: interc" interception
   !>        \param[in] "real(dp)                 :: snowpack" snowpack
   !>        \param[in] "real(dp)                 :: L1_No_count" L1_No_count
   !>        \param[in] "real(dp), dimension(:)   :: L1_bulkDens" Bulk Density
   !>        \param[in] "real(dp), dimension(:)   :: L1_latticeWater" Lattice Water
-  !>        \param[in] "real(dp), dimension(:)   :: L1_COSMICL3" L3 from the COSMIC module 
+  !>        \param[in] "real(dp), dimension(:)   :: L1_COSMICL3" L3 from the COSMIC module
 
   !
   !     INTENT(INOUT)
   !>        \param[inout] "real(dp)              :: neutrons" Neutron counts
   !
   !     INTENT(OUT)
   !         None
@@ -246,23 +245,23 @@
   !         The COsmic-ray Soil Moisture Interaction Code (COSMIC) for use in data assimilation,
   !         HESS, 17, 3205-3217, 2013, doi:10.5194/hess-17-3205-2013
   !         Support and Code: http://cosmos.hwr.arizona.edu/Software/cosmic.html
   !
   !     HISTORY
   !>        \author Martin Schroen, originally written by Rafael Rosolem
   !>        \date Mar 2015
-  !>         Rohini Kumar                  Oct 2021 - Neutron count module to mHM (5.11.2) - develop branch 
+  !>         Rohini Kumar                  Oct 2021 - Neutron count module to mHM (5.11.2) - develop branch
   subroutine COSMIC(SoilMoisture, Horizons, neutron_integral_AFast, &
        interc, snowpack, L1_N0, L1_bulkDens, L1_latticeWater, L1_COSMICL3, &
        neutrons )
-    
-    use mo_mhm_constants, only: H2Odens, COSMIC_N, COSMIC_alpha, COSMIC_L1, COSMIC_L2, COSMIC_L4
+
+    use mo_mhm_constants, only: H2Odens, COSMIC_alpha, COSMIC_L1, COSMIC_L2, COSMIC_L4 !, COSMIC_N
     use mo_constants,     only: PI_dp
     implicit none
-    
+
     real(dp), dimension(:),          intent(in)     :: SoilMoisture
     real(dp), dimension(:),          intent(in)     :: Horizons
     real(dp), dimension(:),          intent(in)     :: neutron_integral_AFast
     real(dp),                        intent(in)     :: interc
     real(dp),                        intent(in)     :: snowpack
     real(dp),                        intent(in)     :: L1_N0
     real(dp), dimension(:),          intent(in)     :: L1_bulkDens
@@ -285,26 +284,26 @@
     real(dp), dimension(:), allocatable     :: hiflux      ! High energy neutron flux
     real(dp), dimension(:), allocatable     :: xeff        ! Fast neutron source strength of layer
     real(dp), dimension(:), allocatable     :: h2oeffheight! "Effective" height of water in layer (g/cm3)
     real(dp), dimension(:), allocatable     :: h2oeffdens  ! "Effective" density of water in layer (g/cm3)
     real(dp), dimension(:), allocatable     :: fastflux    ! Contribution to above-ground neutron flux
 
     integer(i4)                             :: layers      ! Total number of soil layers
-    integer(i4)                             :: ll 
+    integer(i4)                             :: ll
 
 
     ! # of layers
     layers   = size(SoilMoisture) + 1 ! soil horizons + one additional snowpack and interception layer
-    
+
     ! allocate and initalize
     allocate(hiflux(layers),xeff(layers),&
              h2oeffdens(layers),h2oeffheight(layers),fastflux(layers),&
              isoimass(layers),iwatmass(layers))
-    
-    zthick(:)      = 0.0_dp 
+
+    zthick(:)      = 0.0_dp
     isoimass(:)    = 0.0_dp
     iwatmass(:)    = 0.0_dp
     hiflux(:)      = 0.0_dp
     xeff(:)        = 0.0_dp
     h2oeffdens(:)  = 0.0_dp
     h2oeffheight(:)= 0.0_dp
     fastflux(:)    = 0.0_dp
@@ -319,42 +318,42 @@
     ! switch of snowlayer+Intercept ON and off
     ! ON = 1; OFF = 0
     ! its hardocded here but can be later part of *.nml file
     iFlag_snowlayer_intecept = 0
 
     ! layer 1 is the surface layer. layer 2 up to layers are the usual layers
     do ll = 1,layers
-          
+
        ! High energy neutron downward flux
        ! The integration is now performed at the node of each layer (i.e., center of the layer)
 
        !ToDo: maybe put zthick into global constants, so it is an input paramter
        ! Soil Layers and Thicknesses are constant in mHM, they could be defined outside of this function
        ! except the top layer thickness, which is dependend on the snow for example
        ! zthick will be in cm, as all heigths are in cm in this module
        call layerThickness(ll,Horizons,interc,snowpack,zthick)
-       
+
        if( ( zthick(ll) .GT. 0.0_dp ) .AND. ( (iFlag_snowlayer_intecept .GT. 0 ) .OR. (ll.NE.1) ) ) then
-          
+
           call loopConstants(ll, SoilMoisture(:), L1_bulkDens(:), &
                L1_latticeWater(:), L1_COSMICL3(:), sm, bd, lw, L3)
 
           if (ll .EQ. 1) then
              h2oeffdens(ll) = H2Odens/1000.0_dp
           else
              ! calculate the effective height of water in each layer in cm
              ! because neutron standard measurements are in cm
              call layerWaterHeight(ll,sm,h2oeffheight)
              ! divided by the thickness of the layers,we get the effective density
-             h2oeffdens(ll) = (h2oeffheight(ll) + lw/10.0_dp)/zthick(ll)*H2Odens/1000.0_dp  
+             h2oeffdens(ll) = (h2oeffheight(ll) + lw/10.0_dp)/zthick(ll)*H2Odens/1000.0_dp
           endif
 
           ! Assuming an area of 1 cm2
           ! we integrate the bulkdensity/h2oeffdens down to the middle of the layer ll:
-          isoimass(ll) = bd*(0.5_dp*zthick(ll))*1.0_dp 
+          isoimass(ll) = bd*(0.5_dp*zthick(ll))*1.0_dp
           iwatmass(ll) = h2oeffdens(ll)*(0.5_dp*zthick(ll))*1.0_dp
           if ( ll .gt. 1 ) then
             isoimass(ll) = isoimass(ll)+isoimass(ll-1)+bd*(0.5_dp*zthick(ll-1))*1.0_dp
             iwatmass(ll) = iwatmass(ll)+iwatmass(ll-1)+h2oeffdens(ll-1)*(0.5_dp*zthick(ll-1))*1.0_dp
           endif
 
           lambdaHigh = isoimass(ll)/COSMIC_L1 + iwatmass(ll)/COSMIC_L2
@@ -368,30 +367,30 @@
           ! After contribution from all directions are taken into account,
           ! need to multiply fastflux by 2/pi
           fastflux(ll) = (2.0_dp/PI_dp) * fastflux(ll)
 
           ! Low energy (fast) neutron upward flux
           totflux = totflux + hiflux(ll) * xeff(ll) * fastflux(ll)
        endif
-       
+
     enddo
 
     !  neutrons=COSMIC_N*totflux
-    !!>> now based on global parameter given in mhm_paramater.nml
+    !! >> now based on global parameter given in mhm_paramater.nml
     neutrons = L1_N0*totflux
 
     !! free space
     deallocate( hiflux, xeff, h2oeffheight, h2oeffdens, fastflux, isoimass, iwatmass)
-           
+
   end subroutine COSMIC
 
 
 
-  
-  !>>> Loop constants
+
+  ! >>> Loop constants
   subroutine loopConstants(ll, SoilMoisture,L1_bulkDens,L1_latticeWater,&
        L1_COSMICL3,sm,bd,lw,L3 )
      implicit none
      integer(i4),            intent(in)  :: ll
      real(dp), dimension(:), intent(in)  :: SoilMoisture
      real(dp), dimension(:), intent(in)  :: L1_bulkDens
      real(dp), dimension(:), intent(in)  :: L1_latticeWater
@@ -411,43 +410,43 @@
        sm = SoilMoisture(ll-1)
        bd = L1_bulkDens(ll-1)
        lw = L1_latticeWater(ll-1)
        L3 = L1_COSMICL3(ll-1)
      endif
    end subroutine loopConstants
 
-   
 
-  !>> layer thickness
+
+  ! >> layer thickness
   subroutine layerThickness(ll,Horizons,interc,snowpack,zthick)
      implicit none
      integer(i4), intent(in)              :: ll
      real(dp),dimension(:),    intent(in) :: Horizons
      real(dp),                 intent(in) :: interc
      real(dp),                 intent(in) :: snowpack
      real(dp),dimension(:), intent(out)   :: zthick
-     
+
      if (ll.eq.1) then
         zthick(ll)=(snowpack+interc)/10.0_dp
      else if (ll.eq.2) then
         zthick(ll)=Horizons(ll-1)/10.0_dp
      else
         zthick(ll)=(Horizons(ll-1) - Horizons(ll-2))/10.0_dp
      endif
   end subroutine
 
 
-  !>> layer specific water height
+  ! >> layer specific water height
   subroutine layerWaterHeight(ll,sm,h2oeffheight)
      implicit none
      integer(i4),           intent(in)  :: ll
      real(dp),              intent(in)  :: sm
      real(dp),dimension(:), intent(out) :: h2oeffheight
     ! The effective water height in each layer in each profile:
-    ! ToDo:This should include in future: roots, soil organic matter 
+    ! ToDo:This should include in future: roots, soil organic matter
     h2oeffheight(ll) = sm/10.0_dp
   end subroutine
 
   ! integrade a monotonuous function f, dependend on two parameters c and phi
   ! xmin and xmax are the borders for the integration
   ! if the values for f(xmin) or f(xmax) are undefinde (like exp(-1/0)), they
   ! can be set with fxmin, fxmax.
@@ -473,15 +472,15 @@
      real(dp),                        optional    :: fxmax
 
      !locale variables
      real(dp)  :: epstemp
      integer(i4) :: stepstemp
      real(dp)  :: fxmintemp
      real(dp)  :: fxmaxtemp
-     
+
      ! init
      if (.not. present(eps)) then
         epstemp=0.001_dp
      else
         epstemp=eps
      endif
 
@@ -528,15 +527,15 @@
      !locale variables
      real(dp)  :: xm
      real(dp)  :: fxm
      real(dp)  :: err
 
      xm = (xmax+xmin)/2.0_dp
      fxm= f(c,xm)
-     
+
      err=abs((fxmax-fxm)*(xmax-xm))
      if ((err .gt. eps).and.(steps .gt. 1)) then
         call approx_mon_int_steps(res,f,c,xm,xmax,eps/2.0,steps-steps/2,fxm,fxmax)
      else
         res=res+(xmax-xm)*(fxmax+fxm)/2.0_dp
      endif
 
@@ -562,15 +561,15 @@
      !locale variables
      real(dp)  :: xm
      real(dp)  :: fxm
      real(dp)  :: err
 
      xm = (xmax+xmin)/2.0_dp
      fxm= f(c,xm)
-     
+
      err=abs((fxmax-fxm)*(xmax-xm))
      if (err .gt. eps) then
         call approx_mon_int_eps(res,f,c,xm,xmax,eps/2.0,fxm,fxmax)
      else
         res=res+(xmax-xm)*(fxmax+fxm)/2.0_dp
      endif
 
@@ -598,15 +597,15 @@
   !>            recursive approximation subroutine. That recursive subroutine
   !>            should not be used inside the time, cells and layer loops, because
   !>            it is slow.
   !>            Inside the loops in the module COSMIC the tabular is used to
   !>            estimate A_fast, if 0<c<maxC, otherwise the recursive
   !>            approximation is used.
   !         ------------------------------------------------------------------
-  !         TabularIntegralAFast: a tabular for calculations with splines                
+  !         TabularIntegralAFast: a tabular for calculations with splines
   !         ------------------------------------------------------------------
   !
   !     CALLING SEQUENCE
   !         call TabularIntegralAFast(neutron_integral_AFast,intsize,maxC)
   !
   !     INTENT(IN)
   !>        \param[in] "real(dp), dimension(:,:) :: SoilMoisture" Soil Moisture
@@ -705,15 +704,15 @@
      integer(i4) :: intsize
      real(dp)    :: maxC
 
      intsize=size(integral)-2
      maxC=integral(intsize+2)
      mu=c*real(intsize,dp)/maxC
      place=int(mu,i4)+1
-     if (place .gt. intsize) then 
+     if (place .gt. intsize) then
        !call approx_mon_int(res,intgrandFast,c,0.0_dp,PI_dp/2.0_dp,steps=1024,fxmax=0.0_dp)
        !write(*,*) 'Warning: Lambda_Fast is huge. Slow integration used.'
        res=(PI_dp/2.0_dp)*exp(-1.57406_dp*c**0.815488_dp)
      else
         mu=mu-real(place-1,dp)
         res=(1.0_dp-mu)*integral(place)+mu*integral(place+1)
         res=res
@@ -731,22 +730,22 @@
 
      !local variables
      integer(i4) :: place
      real(dp)    :: mu
 
      mu=c*real(intsize/2,dp)/maxC
      place=int(mu,i4)+1
-     if (place .gt. intsize) then 
+     if (place .gt. intsize) then
        !call approx_mon_int(res,intgrandFast,c,0.0_dp,PI_dp/2.0_dp,steps=1024,fxmax=0.0_dp)
        !write(*,*) 'Warning: Lambda_Fast is huge. Slow integration used.'
        res=(PI_dp/2.0_dp)*exp(-1.57406_dp*c**0.815488_dp)
      else
         mu=mu-real(place-1,dp)
         res=h00(mu)*integral(2*place-1)+h01(mu)*integral(2*place+1)+&
-            h10(mu)*integral(2*place  )+h11(mu)*integral(2*place+2)   
+            h10(mu)*integral(2*place  )+h11(mu)*integral(2*place+2)
      end if
   end subroutine
 
   !very bad approximation for the integral from the COSMIC paper. Maybe there is
   !some copying error? They claim, this function would have an error of less
   !then 1/1000 (which can not be true anyway, because the integral goes to zero
   !for c->\infty, and the last if case is a polynome with some coefficients
@@ -799,39 +798,39 @@
         a=0.0_dp
         b=0.00061_dp
         c=-1.04847_dp
         d=-0.96617_dp
         res=expPolynomDeg3(x,a,b,c,d)
       !  write(*,*) 'c6'
      endif
-     
+
   end subroutine
 
   subroutine oldIntegration(res,c)
      use mo_constants, only: PI_dp
      implicit none
      real(dp)                                     :: res
      real(dp),                        intent(in)  :: c
 
      ! local variables
-     real(dp) :: zdeg         
-     real(dp) :: zrad         
-     real(dp) :: costheta     
-     real(dp) :: dtheta       
+     real(dp) :: zdeg
+     real(dp) :: zrad
+     real(dp) :: costheta
+     real(dp) :: dtheta
 
      integer(i4) :: angle ! loop indices for an integration interval
      ! Angle distribution parameters (HARDWIRED)
      ! rr: Using 0.5 deg angle intervals appears to be sufficient
      ! rr: (smaller angles increase the computing time for COSMIC)
 
      dtheta = 0.5_dp*(PI_dp/180.0_dp)
 
      ! This second loop needs to be done for the distribution of angles for fast neutron release
      ! the intent is to loop from 0 to 89.5 by 0.5 degrees - or similar.
-     ! Because Fortran loop indices are integers, we have to divide the indices by 10 - you get the idea.  
+     ! Because Fortran loop indices are integers, we have to divide the indices by 10 - you get the idea.
      res = 0.0_dp
      do angle=0,179
         zdeg     = real(angle,dp)*0.5_dp
         zrad     = (zdeg*PI_dp)/180.0_dp
         costheta = cos(zrad)
         ! Angle-dependent low energy (fast) neutron upward flux
         res  = res + exp(-c/costheta)*dtheta
```

### Comparing `mhm-5.12.1.dev21/src/mHM/mo_objective_function.F90` & `mhm-5.13.0/src/mHM/mo_objective_function.F90`

 * *Files 2% similar despite different names*

```diff
@@ -1,6220 +1,6209 @@
-00000000: 213e 2020 2020 2020 205c 6669 6c65 206d  !>       \file m
-00000010: 6f5f 6f62 6a65 6374 6976 655f 6675 6e63  o_objective_func
-00000020: 7469 6f6e 2e66 3930 0a0a 213e 2020 2020  tion.f90..!>    
-00000030: 2020 205c 6272 6965 6620 4f62 6a65 6374     \brief Object
-00000040: 6976 6520 4675 6e63 7469 6f6e 7320 666f  ive Functions fo
-00000050: 7220 4f70 7469 6d69 7a61 7469 6f6e 206f  r Optimization o
-00000060: 6620 6d48 4d2e 0a0a 213e 2020 2020 2020  f mHM...!>      
-00000070: 205c 6465 7461 696c 7320 5468 6973 206d   \details This m
-00000080: 6f64 756c 6520 7072 6f76 6964 6573 2061  odule provides a
-00000090: 2077 7261 7070 6572 2066 6f72 2073 6576   wrapper for sev
-000000a0: 6572 616c 206f 626a 6563 7469 7665 2066  eral objective f
-000000b0: 756e 6374 696f 6e73 2075 7365 6420 746f  unctions used to
-000000c0: 206f 7074 696d 697a 6520 6d48 4d20 6167   optimize mHM ag
-000000d0: 6169 6e73 7420 7661 7269 6f75 730a 213e  ainst various.!>
-000000e0: 2020 2020 2020 2076 6172 6961 626c 6573         variables
-000000f0: 2e0a 213e 2020 2020 2020 2049 6620 7468  ..!>       If th
-00000100: 6520 6f62 6a65 6374 6976 6520 6973 206f  e objective is o
-00000110: 6e6c 7920 7265 6761 7264 696e 6720 7275  nly regarding ru
-00000120: 6e6f 6666 206d 6f76 6520 6974 2074 6f20  noff move it to 
-00000130: 6d52 4d2f 6d6f 5f6d 726d 5f6f 626a 6563  mRM/mo_mrm_objec
-00000140: 7469 7665 5f66 756e 6374 696f 6e5f 7275  tive_function_ru
-00000150: 6e6f 6666 2e66 3930 2e0a 213e 2020 2020  noff.f90..!>    
-00000160: 2020 2049 6620 6974 2063 6f6e 7461 696e     If it contain
-00000170: 7320 6265 7369 6465 7320 7275 6e6f 6666  s besides runoff
-00000180: 2061 6e6f 7468 6572 2076 6172 6961 626c   another variabl
-00000190: 6520 6c69 6b65 2054 5753 2069 6d70 6c65  e like TWS imple
-000001a0: 6d65 6e74 2069 7420 6865 7265 2e0a 0a21  ment it here...!
-000001b0: 3e20 2020 2020 2020 416c 6c20 7468 6520  >       All the 
-000001c0: 6f62 6a65 6374 6976 6520 6675 6e63 7469  objective functi
-000001d0: 6f6e 7320 6172 6520 7375 7070 6f73 6564  ons are supposed
-000001e0: 2074 6f20 6265 206d 696e 696d 697a 6564   to be minimized
-000001f0: 210a 213e 2020 2020 2020 2028 3130 2920  !.!>       (10) 
-00000200: 534f 3a20 534d 3a20 2020 2020 2020 312e  SO: SM:       1.
-00000210: 3020 2d20 4b47 4520 6f66 2063 6174 6368  0 - KGE of catch
-00000220: 6d65 6e74 2061 7665 7261 6765 2073 6f69  ment average soi
-00000230: 6c6d 6f69 7374 7572 650a 213e 2020 2020  lmoisture.!>    
-00000240: 2020 2028 3131 2920 534f 3a20 534d 3a20     (11) SO: SM: 
-00000250: 2020 2020 2020 312e 3020 2d20 5061 7474        1.0 - Patt
-00000260: 6572 6e20 6469 7373 696d 696c 6172 6974  ern dissimilarit
-00000270: 7920 2850 4429 206f 6620 7370 6174 6961  y (PD) of spatia
-00000280: 6c6c 7920 6469 7374 7269 6275 7465 6420  lly distributed 
-00000290: 736f 696c 206d 6f69 7374 7572 650a 213e  soil moisture.!>
-000002a0: 2020 2020 2020 2028 3132 2920 534f 3a20         (12) SO: 
-000002b0: 534d 3a20 2020 2020 2020 5375 6d20 6f66  SM:       Sum of
-000002c0: 2073 7175 6172 6564 2065 7272 6f72 7320   squared errors 
-000002d0: 2853 5345 2920 6f66 2073 7061 7469 616c  (SSE) of spatial
-000002e0: 6c79 2064 6973 7472 6962 7574 6564 2073  ly distributed s
-000002f0: 7461 6e64 6172 6420 7363 6f72 6520 286e  tandard score (n
-00000300: 6f72 6d61 6c69 7a61 7469 6f6e 290a 213e  ormalization).!>
-00000310: 2020 2020 2020 206f 6620 736f 696c 206d         of soil m
-00000320: 6f69 7374 7572 650a 213e 2020 2020 2020  oisture.!>      
-00000330: 2028 3133 2920 534f 3a20 534d 3a20 2020   (13) SO: SM:   
-00000340: 2020 2020 312e 3020 2d20 6176 6572 6167      1.0 - averag
-00000350: 6520 7465 6d70 6f72 616c 2063 6f72 7265  e temporal corre
-00000360: 6c61 7469 6f6e 206f 6620 7370 6174 6961  lation of spatia
-00000370: 6c6c 7920 6469 7374 7269 6275 7465 6420  lly distributed 
-00000380: 736f 696c 206d 6f69 7374 7572 650a 213e  soil moisture.!>
-00000390: 2020 2020 2020 2028 3135 2920 534f 3a20         (15) SO: 
-000003a0: 5120 2b20 5457 533a 2020 5b31 2e30 2d4b  Q + TWS:  [1.0-K
-000003b0: 4745 2851 295d 2a52 4d53 4528 646f 6d61  GE(Q)]*RMSE(doma
-000003c0: 696e 5f61 7667 5f54 5753 2920 2d20 6f62  in_avg_TWS) - ob
-000003d0: 6a65 6374 6976 6520 6675 6e63 7469 6f6e  jective function
-000003e0: 2075 7369 6e67 2051 2061 6e64 2064 6f6d   using Q and dom
-000003f0: 6169 6e20 6176 6572 6167 6520 2154 6f44  ain average !ToD
-00000400: 6f3a 2063 6861 6e67 6520 636f 6d6d 656e  o: change commen
-00000410: 740a 213e 2020 2020 2020 2028 7374 616e  t.!>       (stan
-00000420: 6461 7264 2073 636f 7265 2920 5457 530a  dard score) TWS.
-00000430: 213e 2020 2020 2020 2028 3137 2920 534f  !>       (17) SO
-00000440: 3a20 4e3a 2020 2020 2020 2020 312e 3020  : N:        1.0 
-00000450: 2d20 4b47 4520 6f66 2073 7061 7469 6f2d  - KGE of spatio-
-00000460: 7465 6d70 6f72 616c 206e 6575 7472 6f6e  temporal neutron
-00000470: 2064 6174 612c 2063 6174 6368 6d65 6e74   data, catchment
-00000480: 2d61 7665 7261 6765 0a21 3e20 2020 2020  -average.!>     
-00000490: 2020 2832 3729 2053 4f3a 2045 543a 2020    (27) SO: ET:  
-000004a0: 2020 2020 2031 2e30 202d 204b 4745 206f       1.0 - KGE o
-000004b0: 6620 6361 7463 686d 656e 7420 6176 6572  f catchment aver
-000004c0: 6167 6520 6576 6170 6f74 7261 6e73 7069  age evapotranspi
-000004d0: 7261 7469 6f6e 0a0a 213e 2020 2020 2020  ration..!>      
-000004e0: 205c 6175 7468 6f72 7320 4a75 6c69 616e   \authors Julian
-000004f0: 6520 4d61 690a 0a21 3e20 2020 2020 2020  e Mai..!>       
-00000500: 5c64 6174 6520 4465 6320 3230 3132 0a0a  \date Dec 2012..
-00000510: 2120 4d6f 6469 6669 6361 7469 6f6e 733a  ! Modifications:
-00000520: 0a21 204f 6c64 7269 6368 2052 616b 6f76  .! Oldrich Rakov
-00000530: 6563 204f 6374 2032 3031 3520 2d20 6164  ec Oct 2015 - ad
-00000540: 6465 6420 6f62 6a2e 2066 756e 632e 2031  ded obj. func. 1
-00000550: 3520 286f 626a 6563 7469 7665 5f6b 6765  5 (objective_kge
-00000560: 5f71 5f72 6d73 655f 7477 7329 2061 6e64  _q_rmse_tws) and
-00000570: 2065 7874 7261 6374 5f64 6f6d 6169 6e5f   extract_domain_
-00000580: 6176 675f 7477 7320 726f 7574 696e 652c  avg_tws routine,
-00000590: 2066 6f72 6d65 7220 6261 7369 6e5f 6176   former basin_av
-000005a0: 670a 2120 526f 6265 7274 2053 6368 7765  g.! Robert Schwe
-000005b0: 7070 6520 4a75 6e20 3230 3138 202d 2072  ppe Jun 2018 - r
-000005c0: 6566 6163 746f 7269 6e67 2061 6e64 2072  efactoring and r
-000005d0: 6566 6f72 6d61 7474 696e 670a 0a4d 4f44  eformatting..MOD
-000005e0: 554c 4520 6d6f 5f6f 626a 6563 7469 7665  ULE mo_objective
-000005f0: 5f66 756e 6374 696f 6e0a 0a20 2021 2054  _function..  ! T
-00000600: 6869 7320 6d6f 6475 6c65 2070 726f 7669  his module provi
-00000610: 6465 7320 6f62 6a65 6374 6976 6520 6675  des objective fu
-00000620: 6e63 7469 6f6e 7320 666f 7220 6f70 7469  nctions for opti
-00000630: 6d69 7a61 7469 6f6e 206f 6620 7468 6520  mization of the 
-00000640: 5546 5a20 4348 5320 6d65 736f 7363 616c  UFZ CHS mesoscal
-00000650: 6520 6879 6472 6f6c 6f67 6963 206d 6f64  e hydrologic mod
-00000660: 656c 206d 484d 2e0a 0a20 2021 2057 7269  el mHM...  ! Wri
-00000670: 7474 656e 2020 4a75 6c69 616e 6520 4d61  tten  Juliane Ma
-00000680: 692c 2044 6563 2032 3031 320a 2020 2120  i, Dec 2012.  ! 
-00000690: 4d6f 6469 6669 6564 2053 7465 7068 616e  Modified Stephan
-000006a0: 2054 686f 6265 722c 204f 6374 2032 3031   Thober, Oct 201
-000006b0: 3520 6d6f 7665 6420 616c 6c20 7275 6e6f  5 moved all runo
-000006c0: 6666 206f 6e6c 7920 7265 6c61 7465 6420  ff only related 
-000006d0: 6f62 6a65 6374 6976 6573 2074 6f20 6d52  objectives to mR
-000006e0: 4d0a 0a20 2055 5345 206d 6f5f 6b69 6e64  M..  USE mo_kind
-000006f0: 2c20 4f4e 4c59 203a 2069 342c 2064 700a  , ONLY : i4, dp.
-00000700: 2020 7573 6520 6d6f 5f6f 7074 696d 697a    use mo_optimiz
-00000710: 6174 696f 6e5f 7574 696c 732c 206f 6e6c  ation_utils, onl
-00000720: 7920 3a20 6576 616c 5f69 6e74 6572 6661  y : eval_interfa
-00000730: 6365 0a0a 2020 494d 504c 4943 4954 204e  ce..  IMPLICIT N
-00000740: 4f4e 450a 0a20 2050 5249 5641 5445 0a0a  ONE..  PRIVATE..
-00000750: 2020 5055 424c 4943 203a 3a20 6f62 6a65    PUBLIC :: obje
-00000760: 6374 6976 650a 2369 6664 6566 204d 5049  ctive.#ifdef MPI
-00000770: 0a20 2050 5542 4c49 4320 3a3a 206f 626a  .  PUBLIC :: obj
-00000780: 6563 7469 7665 5f6d 6173 7465 722c 206f  ective_master, o
-00000790: 626a 6563 7469 7665 5f73 7562 7072 6f63  bjective_subproc
-000007a0: 6573 7320 2120 6f62 6a65 6374 6976 6520  ess ! objective 
-000007b0: 6675 6e63 7469 6f6e 2077 7261 7070 6572  function wrapper
-000007c0: 2066 6f72 2073 6f69 6c20 6d6f 6973 7475   for soil moistu
-000007d0: 7265 206f 6e6c 790a 2365 6e64 6966 0a0a  re only.#endif..
-000007e0: 2020 2120 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d    ! ------------
-000007f0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00000800: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00000810: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00000820: 2d2d 2d2d 2d2d 0a0a 434f 4e54 4149 4e53  ------..CONTAINS
-00000830: 0a0a 2020 2120 2d2d 2d2d 2d2d 2d2d 2d2d  ..  ! ----------
-00000840: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00000850: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00000860: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00000870: 2d2d 2d2d 2d2d 2d2d 0a0a 2020 2120 2020  --------..  !   
-00000880: 204e 414d 450a 2020 2120 2020 2020 2020   NAME.  !       
-00000890: 206f 626a 6563 7469 7665 0a0a 2020 2120   objective..  ! 
-000008a0: 2020 2050 5552 504f 5345 0a20 2021 3e20     PURPOSE.  !> 
-000008b0: 2020 2020 2020 5c62 7269 6566 2057 7261        \brief Wra
-000008c0: 7070 6572 2066 6f72 206f 626a 6563 7469  pper for objecti
-000008d0: 7665 2066 756e 6374 696f 6e73 2e0a 0a20  ve functions... 
-000008e0: 2021 3e20 2020 2020 2020 5c64 6574 6169   !>       \detai
-000008f0: 6c73 2054 6865 2066 756e 6374 696f 6e73  ls The functions
-00000900: 2073 656c 6563 7473 2074 6865 206f 626a   selects the obj
-00000910: 6563 7469 7665 2066 756e 6374 696f 6e20  ective function 
-00000920: 6361 7365 2064 6566 696e 6564 2069 6e20  case defined in 
-00000930: 6120 6e61 6d65 6c69 7374 2c0a 2020 213e  a namelist,.  !>
-00000940: 2020 2020 2020 2069 2e65 2e20 7468 6520         i.e. the 
-00000950: 676c 6f62 616c 2076 6172 6961 626c 6520  global variable 
-00000960: 5c65 206f 7074 695c 5f66 756e 6374 696f  \e opti\_functio
-00000970: 6e2e 0a20 2021 3e20 2020 2020 2020 4974  n..  !>       It
-00000980: 2072 6574 7572 6e20 7468 6520 6f62 6a65   return the obje
-00000990: 6374 6976 6520 6675 6e63 7469 6f6e 2076  ctive function v
-000009a0: 616c 7565 2066 6f72 2061 2073 7065 6369  alue for a speci
-000009b0: 6669 6320 7061 7261 6d65 7465 7220 7365  fic parameter se
-000009c0: 742e 0a0a 2020 2120 2020 2049 4e54 454e  t...  !    INTEN
-000009d0: 5428 494e 290a 2020 213e 2020 2020 2020  T(IN).  !>      
-000009e0: 205c 7061 7261 6d5b 696e 5d20 2252 4541   \param[in] "REA
-000009f0: 4c28 6470 292c 2044 494d 454e 5349 4f4e  L(dp), DIMENSION
-00000a00: 283a 2920 3a3a 2070 6172 616d 6574 6572  (:) :: parameter
-00000a10: 7365 7422 0a20 2021 3e20 2020 2020 2020  set".  !>       
-00000a20: 5c70 6172 616d 5b69 6e5d 2022 7072 6f63  \param[in] "proc
-00000a30: 6564 7572 6528 6576 616c 5f69 6e74 6572  edure(eval_inter
-00000a40: 6661 6365 2920 3a3a 2065 7661 6c22 0a0a  face) :: eval"..
-00000a50: 2020 2120 2020 2049 4e54 454e 5428 494e    !    INTENT(IN
-00000a60: 292c 204f 5054 494f 4e41 4c0a 2020 213e  ), OPTIONAL.  !>
-00000a70: 2020 2020 2020 205c 7061 7261 6d5b 696e         \param[in
-00000a80: 5d20 2272 6561 6c28 6470 292c 206f 7074  ] "real(dp), opt
-00000a90: 696f 6e61 6c20 3a3a 2061 7267 3122 0a0a  ional :: arg1"..
-00000aa0: 2020 2120 2020 2049 4e54 454e 5428 4f55    !    INTENT(OU
-00000ab0: 5429 2c20 4f50 5449 4f4e 414c 0a20 2021  T), OPTIONAL.  !
-00000ac0: 3e20 2020 2020 2020 5c70 6172 616d 5b6f  >       \param[o
-00000ad0: 7574 5d20 2272 6561 6c28 6470 292c 206f  ut] "real(dp), o
-00000ae0: 7074 696f 6e61 6c20 3a3a 2061 7267 3222  ptional :: arg2"
-00000af0: 0a20 2021 3e20 2020 2020 2020 5c70 6172  .  !>       \par
-00000b00: 616d 5b6f 7574 5d20 2272 6561 6c28 6470  am[out] "real(dp
-00000b10: 292c 206f 7074 696f 6e61 6c20 3a3a 2061  ), optional :: a
-00000b20: 7267 3322 0a0a 2020 2120 2020 2052 4554  rg3"..  !    RET
-00000b30: 5552 4e0a 2020 213e 2020 2020 2020 205c  URN.  !>       \
-00000b40: 7265 7475 726e 2072 6561 6c28 6470 2920  return real(dp) 
-00000b50: 3a3a 206f 626a 6563 7469 7665 2026 6d64  :: objective &md
-00000b60: 6173 683b 206f 626a 6563 7469 7665 2066  ash; objective f
-00000b70: 756e 6374 696f 6e20 7661 6c75 650a 2020  unction value.  
-00000b80: 213e 2020 2020 2020 2028 7768 6963 6820  !>       (which 
-00000b90: 7769 6c6c 2062 6520 652e 672e 206d 696e  will be e.g. min
-00000ba0: 696d 697a 6564 2062 7920 616e 206f 7074  imized by an opt
-00000bb0: 696d 697a 6174 696f 6e20 726f 7574 696e  imization routin
-00000bc0: 6520 6c69 6b65 2044 4453 290a 0a20 2021  e like DDS)..  !
-00000bd0: 2020 2020 4849 5354 4f52 590a 2020 213e      HISTORY.  !>
-00000be0: 2020 2020 2020 205c 6175 7468 6f72 7320         \authors 
-00000bf0: 4a75 6c69 616e 6520 4d61 690a 0a20 2021  Juliane Mai..  !
-00000c00: 3e20 2020 2020 2020 5c64 6174 6520 4465  >       \date De
-00000c10: 6320 3230 3132 0a0a 2020 2120 4d6f 6469  c 2012..  ! Modi
-00000c20: 6669 6361 7469 6f6e 733a 0a20 2021 2053  fications:.  ! S
-00000c30: 7465 7068 616e 2054 686f 6265 7220 4f63  tephan Thober Oc
-00000c40: 7420 3230 3135 202d 206d 6f76 6564 2061  t 2015 - moved a
-00000c50: 6c6c 2072 756e 6f66 6620 7265 6c61 7465  ll runoff relate
-00000c60: 6420 6f62 6a65 6374 6976 6520 6675 6e63  d objective func
-00000c70: 7469 6f6e 7320 746f 206d 524d 0a20 2021  tions to mRM.  !
-00000c80: 2052 6f62 6572 7420 5363 6877 6570 7065   Robert Schweppe
-00000c90: 204a 756e 2032 3031 3820 2d20 7265 6661   Jun 2018 - refa
-00000ca0: 6374 6f72 696e 6720 616e 6420 7265 666f  ctoring and refo
-00000cb0: 726d 6174 7469 6e67 0a0a 2020 4655 4e43  rmatting..  FUNC
-00000cc0: 5449 4f4e 206f 626a 6563 7469 7665 2870  TION objective(p
-00000cd0: 6172 616d 6574 6572 7365 742c 2065 7661  arameterset, eva
-00000ce0: 6c2c 2061 7267 312c 2061 7267 322c 2061  l, arg1, arg2, a
-00000cf0: 7267 3329 0a0a 2020 2020 7573 6520 6d6f  rg3)..    use mo
-00000d00: 5f63 6f6d 6d6f 6e5f 636f 6e73 7461 6e74  _common_constant
-00000d10: 732c 206f 6e6c 7920 3a20 6e6f 6461 7461  s, only : nodata
-00000d20: 5f64 700a 2020 2020 7573 6520 6d6f 5f63  _dp.    use mo_c
-00000d30: 6f6d 6d6f 6e5f 6d48 4d5f 6d52 4d5f 7661  ommon_mHM_mRM_va
-00000d40: 7269 6162 6c65 732c 206f 6e6c 7920 3a20  riables, only : 
-00000d50: 6f70 7469 5f66 756e 6374 696f 6e0a 2020  opti_function.  
-00000d60: 2020 7573 6520 6d6f 5f6d 6573 7361 6765    use mo_message
-00000d70: 2c20 6f6e 6c79 203a 206d 6573 7361 6765  , only : message
-00000d80: 0a0a 2020 2020 696d 706c 6963 6974 206e  ..    implicit n
-00000d90: 6f6e 650a 0a20 2020 2052 4541 4c28 6470  one..    REAL(dp
-00000da0: 292c 2044 494d 454e 5349 4f4e 283a 292c  ), DIMENSION(:),
-00000db0: 2049 4e54 454e 5428 494e 2920 3a3a 2070   INTENT(IN) :: p
-00000dc0: 6172 616d 6574 6572 7365 740a 0a20 2020  arameterset..   
-00000dd0: 2070 726f 6365 6475 7265 2865 7661 6c5f   procedure(eval_
-00000de0: 696e 7465 7266 6163 6529 2c20 494e 5445  interface), INTE
-00000df0: 4e54 2849 4e29 2c20 504f 494e 5445 5220  NT(IN), POINTER 
-00000e00: 3a3a 2065 7661 6c0a 0a20 2020 2072 6561  :: eval..    rea
-00000e10: 6c28 6470 292c 206f 7074 696f 6e61 6c2c  l(dp), optional,
-00000e20: 2069 6e74 656e 7428 696e 2920 3a3a 2061   intent(in) :: a
-00000e30: 7267 310a 0a20 2020 2072 6561 6c28 6470  rg1..    real(dp
-00000e40: 292c 206f 7074 696f 6e61 6c2c 2069 6e74  ), optional, int
-00000e50: 656e 7428 6f75 7429 203a 3a20 6172 6732  ent(out) :: arg2
-00000e60: 0a0a 2020 2020 7265 616c 2864 7029 2c20  ..    real(dp), 
-00000e70: 6f70 7469 6f6e 616c 2c20 696e 7465 6e74  optional, intent
-00000e80: 286f 7574 2920 3a3a 2061 7267 330a 0a20  (out) :: arg3.. 
-00000e90: 2020 2052 4541 4c28 6470 2920 3a3a 206f     REAL(dp) :: o
-00000ea0: 626a 6563 7469 7665 0a0a 2020 2020 7265  bjective..    re
-00000eb0: 616c 2864 7029 2c20 6469 6d65 6e73 696f  al(dp), dimensio
-00000ec0: 6e28 3629 203a 3a20 6d75 6c74 6970 6c65  n(6) :: multiple
-00000ed0: 5f6f 626a 6563 7469 7665 0a0a 0a20 2020  _objective...   
-00000ee0: 2069 6620 2870 7265 7365 6e74 2861 7267   if (present(arg
-00000ef0: 3129 202e 6f72 2e20 7072 6573 656e 7428  1) .or. present(
-00000f00: 6172 6732 2920 2e6f 722e 2070 7265 7365  arg2) .or. prese
-00000f10: 6e74 2861 7267 3329 2920 7468 656e 0a20  nt(arg3)) then. 
-00000f20: 2020 2020 2063 616c 6c20 6d65 7373 6167       call messag
-00000f30: 6528 2245 7272 6f72 206d 6f5f 6f62 6a65  e("Error mo_obje
-00000f40: 6374 6976 655f 6675 6e63 7469 6f6e 3a20  ctive_function: 
-00000f50: 5265 6365 6976 6564 2075 6e65 7870 6563  Received unexpec
-00000f60: 7465 6420 6172 6775 6d65 6e74 2c20 6368  ted argument, ch
-00000f70: 6563 6b20 6f70 7469 6d69 7a61 7469 6f6e  eck optimization
-00000f80: 2073 6574 7469 6e67 7322 290a 2020 2020   settings").    
-00000f90: 2020 7374 6f70 2031 0a20 2020 2065 6e64    stop 1.    end
-00000fa0: 2069 660a 0a20 2020 2021 2073 6574 2074   if..    ! set t
-00000fb0: 6865 7365 2074 6f20 6e61 6e20 736f 2063  hese to nan so c
-00000fc0: 6f6d 7069 6c65 7220 646f 6573 206e 6f74  ompiler does not
-00000fd0: 2063 6f6d 706c 6169 6e0a 2020 2020 6966   complain.    if
-00000fe0: 2028 7072 6573 656e 7428 6172 6732 2929   (present(arg2))
-00000ff0: 2074 6865 6e0a 2020 2020 2020 6172 6732   then.      arg2
-00001000: 203d 206e 6f64 6174 615f 6470 0a20 2020   = nodata_dp.   
-00001010: 2065 6e64 2069 660a 2020 2020 6966 2028   end if.    if (
-00001020: 7072 6573 656e 7428 6172 6733 2929 2074  present(arg3)) t
-00001030: 6865 6e0a 2020 2020 2020 6172 6733 203d  hen.      arg3 =
-00001040: 206e 6f64 6174 615f 6470 0a20 2020 2065   nodata_dp.    e
-00001050: 6e64 2069 660a 0a20 2020 2073 656c 6563  nd if..    selec
-00001060: 7420 6361 7365 2028 6f70 7469 5f66 756e  t case (opti_fun
-00001070: 6374 696f 6e29 0a20 2020 2063 6173 6520  ction).    case 
-00001080: 2831 3029 0a20 2020 2020 2021 204b 4745  (10).      ! KGE
-00001090: 206f 6620 6361 7463 686d 656e 7420 6176   of catchment av
-000010a0: 6572 6167 6520 534d 0a20 2020 2020 206f  erage SM.      o
-000010b0: 626a 6563 7469 7665 203d 206f 626a 6563  bjective = objec
-000010c0: 7469 7665 5f73 6d5f 6b67 655f 6361 7463  tive_sm_kge_catc
-000010d0: 686d 656e 745f 6176 6728 7061 7261 6d65  hment_avg(parame
-000010e0: 7465 7273 6574 2c20 6576 616c 290a 2020  terset, eval).  
-000010f0: 2020 6361 7365 2028 3131 290a 2020 2020    case (11).    
-00001100: 2020 2120 7061 7474 6572 6e20 6469 7373    ! pattern diss
-00001110: 696d 696c 6172 6974 7920 2850 4429 206f  imilarity (PD) o
-00001120: 6620 534d 2066 6965 6c64 730a 2020 2020  f SM fields.    
-00001130: 2020 6f62 6a65 6374 6976 6520 3d20 6f62    objective = ob
-00001140: 6a65 6374 6976 655f 736d 5f70 6428 7061  jective_sm_pd(pa
-00001150: 7261 6d65 7465 7273 6574 2c20 6576 616c  rameterset, eval
-00001160: 290a 2020 2020 6361 7365 2028 3132 290a  ).    case (12).
-00001170: 2020 2020 2020 2120 7375 6d20 6f66 2073        ! sum of s
-00001180: 7175 6172 6564 2065 7272 6f72 7320 6f66  quared errors of
-00001190: 2073 7461 6e64 6172 645f 7363 6f72 6520   standard_score 
-000011a0: 534d 0a20 2020 2020 206f 626a 6563 7469  SM.      objecti
-000011b0: 7665 203d 206f 626a 6563 7469 7665 5f73  ve = objective_s
-000011c0: 6d5f 7373 655f 7374 616e 6461 7264 5f73  m_sse_standard_s
-000011d0: 636f 7265 2870 6172 616d 6574 6572 7365  core(parameterse
-000011e0: 742c 2065 7661 6c29 0a20 2020 2063 6173  t, eval).    cas
-000011f0: 6520 2831 3329 0a20 2020 2020 2021 2073  e (13).      ! s
-00001200: 6f69 6c20 6d6f 6973 7475 7265 2063 6f72  oil moisture cor
-00001210: 7265 6c61 7469 6f6e 202d 2074 656d 706f  relation - tempo
-00001220: 7261 6c0a 2020 2020 2020 6f62 6a65 6374  ral.      object
-00001230: 6976 6520 3d20 6f62 6a65 6374 6976 655f  ive = objective_
-00001240: 736d 5f63 6f72 7228 7061 7261 6d65 7465  sm_corr(paramete
-00001250: 7273 6574 2c20 6576 616c 290a 2020 2020  rset, eval).    
-00001260: 6361 7365 2028 3135 290a 2020 2020 2020  case (15).      
-00001270: 2120 4b47 4520 666f 7220 5120 2a20 524d  ! KGE for Q * RM
-00001280: 5345 2066 6f72 2064 6f6d 6169 6e5f 6176  SE for domain_av
-00001290: 6720 5457 5320 2873 7461 6e64 6172 697a  g TWS (standariz
-000012a0: 6564 2073 636f 7265 6429 0a20 2020 2020  ed scored).     
-000012b0: 206f 626a 6563 7469 7665 203d 206f 626a   objective = obj
-000012c0: 6563 7469 7665 5f6b 6765 5f71 5f72 6d73  ective_kge_q_rms
-000012d0: 655f 7477 7328 7061 7261 6d65 7465 7273  e_tws(parameters
-000012e0: 6574 2c20 6576 616c 290a 2020 2020 6361  et, eval).    ca
-000012f0: 7365 2028 3137 290a 2020 2020 2020 2120  se (17).      ! 
-00001300: 4b47 4520 6f66 2063 6174 6368 6d65 6e74  KGE of catchment
-00001310: 2061 7665 7261 6765 2053 4d0a 2020 2020   average SM.    
-00001320: 2020 6f62 6a65 6374 6976 6520 3d20 6f62    objective = ob
-00001330: 6a65 6374 6976 655f 6e65 7574 726f 6e73  jective_neutrons
-00001340: 5f6b 6765 5f63 6174 6368 6d65 6e74 5f61  _kge_catchment_a
-00001350: 7667 2870 6172 616d 6574 6572 7365 742c  vg(parameterset,
-00001360: 2065 7661 6c29 0a20 2020 2063 6173 6520   eval).    case 
-00001370: 2832 3729 0a20 2020 2020 2021 204b 4745  (27).      ! KGE
-00001380: 206f 6620 6361 7463 686d 656e 7420 6176   of catchment av
-00001390: 6572 6167 6520 4554 0a20 2020 2020 206f  erage ET.      o
-000013a0: 626a 6563 7469 7665 203d 206f 626a 6563  bjective = objec
-000013b0: 7469 7665 5f65 745f 6b67 655f 6361 7463  tive_et_kge_catc
-000013c0: 686d 656e 745f 6176 6728 7061 7261 6d65  hment_avg(parame
-000013d0: 7465 7273 6574 2c20 6576 616c 290a 2020  terset, eval).  
-000013e0: 2020 6361 7365 2028 3238 290a 2020 2020    case (28).    
-000013f0: 2020 2120 204b 4745 2066 6f72 2051 202b    !  KGE for Q +
-00001400: 2053 5345 2066 6f72 2053 4d20 2873 7461   SSE for SM (sta
-00001410: 6e64 6172 697a 6564 2073 636f 7265 6429  ndarized scored)
-00001420: 0a20 2020 2020 206f 626a 6563 7469 7665  .      objective
-00001430: 203d 206f 626a 6563 7469 7665 5f6b 6765   = objective_kge
-00001440: 5f71 5f73 6d5f 636f 7272 2870 6172 616d  _q_sm_corr(param
-00001450: 6574 6572 7365 742c 2065 7661 6c29 0a20  eterset, eval). 
-00001460: 2020 2063 6173 6520 2832 3929 0a20 2020     case (29).   
-00001470: 2020 2021 2020 4b47 4520 666f 7220 5120     !  KGE for Q 
-00001480: 2b20 4b47 4520 6f66 2063 6174 6368 6d65  + KGE of catchme
-00001490: 6e74 2061 7665 7261 6765 2045 540a 2020  nt average ET.  
-000014a0: 2020 2020 6f62 6a65 6374 6976 6520 3d20      objective = 
-000014b0: 6f62 6a65 6374 6976 655f 6b67 655f 715f  objective_kge_q_
-000014c0: 6574 2870 6172 616d 6574 6572 7365 742c  et(parameterset,
-000014d0: 2065 7661 6c29 0a20 2020 2063 6173 6520   eval).    case 
-000014e0: 2833 3029 0a20 2020 2020 2021 204b 4745  (30).      ! KGE
-000014f0: 2066 6f72 2051 202a 2052 4d53 4520 666f   for Q * RMSE fo
-00001500: 7220 646f 6d61 696e 5f61 7667 2045 5420  r domain_avg ET 
-00001510: 2873 7461 6e64 6172 697a 6564 2073 636f  (standarized sco
-00001520: 7265 6429 0a20 2020 2020 206f 626a 6563  red).      objec
-00001530: 7469 7665 203d 206f 626a 6563 7469 7665  tive = objective
-00001540: 5f6b 6765 5f71 5f72 6d73 655f 6574 2870  _kge_q_rmse_et(p
-00001550: 6172 616d 6574 6572 7365 742c 2065 7661  arameterset, eva
-00001560: 6c29 0a20 2020 2063 6173 6520 2833 3329  l).    case (33)
-00001570: 0a20 2020 2020 206d 756c 7469 706c 655f  .      multiple_
-00001580: 6f62 6a65 6374 6976 6520 3d20 6f62 6a65  objective = obje
-00001590: 6374 6976 655f 715f 6574 5f74 7773 5f6b  ctive_q_et_tws_k
-000015a0: 6765 5f63 6174 6368 6d65 6e74 5f61 7667  ge_catchment_avg
-000015b0: 2870 6172 616d 6574 6572 7365 742c 2065  (parameterset, e
-000015c0: 7661 6c29 0a20 2020 2020 206f 626a 6563  val).      objec
-000015d0: 7469 7665 203d 206d 756c 7469 706c 655f  tive = multiple_
-000015e0: 6f62 6a65 6374 6976 6528 3129 0a20 2020  objective(1).   
-000015f0: 2063 6173 6520 2833 3429 0a20 2020 2020   case (34).     
-00001600: 2021 204b 4745 2066 6f72 2051 202a 2041   ! KGE for Q * A
-00001610: 6273 6f6c 7574 652d 4572 726f 7220 666f  bsolute-Error fo
-00001620: 7220 4246 490a 2020 2020 2020 6f62 6a65  r BFI.      obje
-00001630: 6374 6976 6520 3d20 6f62 6a65 6374 6976  ctive = objectiv
-00001640: 655f 6b67 655f 715f 4246 4928 7061 7261  e_kge_q_BFI(para
-00001650: 6d65 7465 7273 6574 2c20 6576 616c 290a  meterset, eval).
-00001660: 0a20 2020 2063 6173 6520 6465 6661 756c  .    case defaul
-00001670: 740a 2020 2020 2020 6361 6c6c 206d 6573  t.      call mes
-00001680: 7361 6765 2822 4572 726f 7220 6f62 6a65  sage("Error obje
-00001690: 6374 6976 653a 206f 7074 695f 6675 6e63  ctive: opti_func
-000016a0: 7469 6f6e 206e 6f74 2069 6d70 6c65 6d65  tion not impleme
-000016b0: 6e74 6564 2079 6574 2e22 290a 2020 2020  nted yet.").    
-000016c0: 2020 7374 6f70 2031 0a20 2020 2065 6e64    stop 1.    end
-000016d0: 2073 656c 6563 740a 0a20 2045 4e44 2046   select..  END F
-000016e0: 554e 4354 494f 4e20 6f62 6a65 6374 6976  UNCTION objectiv
-000016f0: 650a 0a20 2021 202d 2d2d 2d2d 2d2d 2d2d  e..  ! ---------
-00001700: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00001710: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00001720: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00001730: 2d2d 2d2d 2d2d 2d2d 2d0a 0a20 2021 2020  ---------..  !  
-00001740: 2020 4e41 4d45 0a20 2021 2020 2020 2020    NAME.  !      
-00001750: 2020 6f62 6a65 6374 6976 655f 6d61 7374    objective_mast
-00001760: 6572 0a0a 2020 2120 2020 2050 5552 504f  er..  !    PURPO
-00001770: 5345 0a20 2021 3e20 2020 2020 2020 5c62  SE.  !>       \b
-00001780: 7269 6566 2057 7261 7070 6572 2066 6f72  rief Wrapper for
-00001790: 206f 626a 6563 7469 7665 2066 756e 6374   objective funct
-000017a0: 696f 6e73 2e0a 0a20 2021 3e20 2020 2020  ions...  !>     
-000017b0: 2020 5c64 6574 6169 6c73 2054 6865 2066    \details The f
-000017c0: 756e 6374 696f 6e73 2073 656e 6473 2074  unctions sends t
-000017d0: 6865 2070 6172 616d 6574 6572 7365 7420  he parameterset 
-000017e0: 746f 2074 6865 2073 7562 7072 6f63 6573  to the subproces
-000017f0: 732c 2072 6563 6569 7665 730a 2020 213e  s, receives.  !>
-00001800: 2020 2020 2020 2074 6865 2070 6172 7469         the parti
-00001810: 616c 206f 626a 6563 7469 7665 2061 6e64  al objective and
-00001820: 2063 616c 6375 6c61 7465 7320 7468 6520   calculates the 
-00001830: 6669 6e61 6c20 6f62 6a65 6374 6976 650a  final objective.
-00001840: 2020 2120 2020 2049 4e54 454e 5428 494e    !    INTENT(IN
-00001850: 290a 2020 213e 2020 2020 2020 205c 7061  ).  !>       \pa
-00001860: 7261 6d5b 696e 5d20 2252 4541 4c28 6470  ram[in] "REAL(dp
-00001870: 292c 2044 494d 454e 5349 4f4e 283a 2920  ), DIMENSION(:) 
-00001880: 3a3a 2070 6172 616d 6574 6572 7365 7422  :: parameterset"
-00001890: 0a20 2021 3e20 2020 2020 2020 5c70 6172  .  !>       \par
-000018a0: 616d 5b69 6e5d 2022 7072 6f63 6564 7572  am[in] "procedur
-000018b0: 6528 6576 616c 5f69 6e74 6572 6661 6365  e(eval_interface
-000018c0: 2920 3a3a 2065 7661 6c22 0a0a 2020 2120  ) :: eval"..  ! 
-000018d0: 2020 2049 4e54 454e 5428 494e 292c 204f     INTENT(IN), O
-000018e0: 5054 494f 4e41 4c0a 2020 213e 2020 2020  PTIONAL.  !>    
-000018f0: 2020 205c 7061 7261 6d5b 696e 5d20 2272     \param[in] "r
-00001900: 6561 6c28 6470 292c 206f 7074 696f 6e61  eal(dp), optiona
-00001910: 6c20 3a3a 2061 7267 3122 0a0a 2020 2120  l :: arg1"..  ! 
-00001920: 2020 2049 4e54 454e 5428 4f55 5429 2c20     INTENT(OUT), 
-00001930: 4f50 5449 4f4e 414c 0a20 2021 3e20 2020  OPTIONAL.  !>   
-00001940: 2020 2020 5c70 6172 616d 5b6f 7574 5d20      \param[out] 
-00001950: 2272 6561 6c28 6470 292c 206f 7074 696f  "real(dp), optio
-00001960: 6e61 6c20 3a3a 2061 7267 3222 0a20 2021  nal :: arg2".  !
-00001970: 3e20 2020 2020 2020 5c70 6172 616d 5b6f  >       \param[o
-00001980: 7574 5d20 2272 6561 6c28 6470 292c 206f  ut] "real(dp), o
-00001990: 7074 696f 6e61 6c20 3a3a 2061 7267 3322  ptional :: arg3"
-000019a0: 0a0a 2020 2120 2020 2052 4554 5552 4e0a  ..  !    RETURN.
-000019b0: 2020 213e 2020 2020 2020 205c 7265 7475    !>       \retu
-000019c0: 726e 2072 6561 6c28 6470 2920 3a3a 206f  rn real(dp) :: o
-000019d0: 626a 6563 7469 7665 2026 6d64 6173 683b  bjective &mdash;
-000019e0: 206f 626a 6563 7469 7665 2066 756e 6374   objective funct
-000019f0: 696f 6e20 7661 6c75 650a 2020 213e 2020  ion value.  !>  
-00001a00: 2020 2020 2028 7768 6963 6820 7769 6c6c       (which will
-00001a10: 2062 6520 652e 672e 206d 696e 696d 697a   be e.g. minimiz
-00001a20: 6564 2062 7920 616e 206f 7074 696d 697a  ed by an optimiz
-00001a30: 6174 696f 6e20 726f 7574 696e 6520 6c69  ation routine li
-00001a40: 6b65 2044 4453 290a 0a20 2021 2020 2020  ke DDS)..  !    
-00001a50: 4849 5354 4f52 590a 2020 213e 2020 2020  HISTORY.  !>    
-00001a60: 2020 205c 6175 7468 6f72 7320 4a75 6c69     \authors Juli
-00001a70: 616e 6520 4d61 690a 0a20 2021 3e20 2020  ane Mai..  !>   
-00001a80: 2020 2020 5c64 6174 6520 4465 6320 3230      \date Dec 20
-00001a90: 3132 0a0a 2020 2120 4d6f 6469 6669 6361  12..  ! Modifica
-00001aa0: 7469 6f6e 733a 0a20 2021 2053 7465 7068  tions:.  ! Steph
-00001ab0: 616e 2054 686f 6265 7220 4f63 7420 3230  an Thober Oct 20
-00001ac0: 3135 202d 206d 6f76 6564 2061 6c6c 2072  15 - moved all r
-00001ad0: 756e 6f66 6620 7265 6c61 7465 6420 6f62  unoff related ob
-00001ae0: 6a65 6374 6976 6520 6675 6e63 7469 6f6e  jective function
-00001af0: 7320 746f 206d 524d 0a20 2021 2052 6f62  s to mRM.  ! Rob
-00001b00: 6572 7420 5363 6877 6570 7065 204a 756e  ert Schweppe Jun
-00001b10: 2032 3031 3820 2d20 7265 6661 6374 6f72   2018 - refactor
-00001b20: 696e 6720 616e 6420 7265 666f 726d 6174  ing and reformat
-00001b30: 7469 6e67 0a20 2021 204d 6172 656e 204b  ting.  ! Maren K
-00001b40: 616c 757a 6120 4a75 6e20 3230 3139 202d  aluza Jun 2019 -
-00001b50: 2070 6172 616c 6c65 6c20 7665 7273 696f   parallel versio
-00001b60: 6e0a 0a23 6966 6465 6620 4d50 490a 2020  n..#ifdef MPI.  
-00001b70: 4655 4e43 5449 4f4e 206f 626a 6563 7469  FUNCTION objecti
-00001b80: 7665 5f6d 6173 7465 7228 7061 7261 6d65  ve_master(parame
-00001b90: 7465 7273 6574 2c20 6576 616c 2c20 6172  terset, eval, ar
-00001ba0: 6731 2c20 6172 6732 2c20 6172 6733 290a  g1, arg2, arg3).
-00001bb0: 0a20 2020 2075 7365 206d 6f5f 636f 6d6d  .    use mo_comm
-00001bc0: 6f6e 5f63 6f6e 7374 616e 7473 2c20 6f6e  on_constants, on
-00001bd0: 6c79 203a 206e 6f64 6174 615f 6470 0a20  ly : nodata_dp. 
-00001be0: 2020 2075 7365 206d 6f5f 636f 6d6d 6f6e     use mo_common
-00001bf0: 5f6d 484d 5f6d 524d 5f76 6172 6961 626c  _mHM_mRM_variabl
-00001c00: 6573 2c20 6f6e 6c79 203a 206f 7074 695f  es, only : opti_
-00001c10: 6675 6e63 7469 6f6e 0a20 2020 2075 7365  function.    use
-00001c20: 206d 6f5f 636f 6d6d 6f6e 5f6d 7069 5f74   mo_common_mpi_t
-00001c30: 6f6f 6c73 2c20 6f6e 6c79 203a 2064 6973  ools, only : dis
-00001c40: 7472 6962 7574 655f 7061 7261 6d65 7465  tribute_paramete
-00001c50: 7273 6574 0a20 2020 2075 7365 206d 6f5f  rset.    use mo_
-00001c60: 636f 6d6d 6f6e 5f76 6172 6961 626c 6573  common_variables
-00001c70: 2c20 6f6e 6c79 203a 2064 6f6d 6169 6e4d  , only : domainM
-00001c80: 6574 610a 2020 2020 7573 6520 6d6f 5f6d  eta.    use mo_m
-00001c90: 6573 7361 6765 2c20 6f6e 6c79 203a 206d  essage, only : m
-00001ca0: 6573 7361 6765 0a20 2020 2075 7365 206d  essage.    use m
-00001cb0: 6f5f 7374 7269 6e67 5f75 7469 6c73 2c20  o_string_utils, 
-00001cc0: 6f6e 6c79 203a 206e 756d 3273 7472 0a20  only : num2str. 
-00001cd0: 2020 2075 7365 206d 7069 5f66 3038 0a0a     use mpi_f08..
-00001ce0: 2020 2020 696d 706c 6963 6974 206e 6f6e      implicit non
-00001cf0: 650a 0a20 2020 2052 4541 4c28 6470 292c  e..    REAL(dp),
-00001d00: 2044 494d 454e 5349 4f4e 283a 292c 2049   DIMENSION(:), I
-00001d10: 4e54 454e 5428 494e 2920 3a3a 2070 6172  NTENT(IN) :: par
-00001d20: 616d 6574 6572 7365 740a 0a20 2020 2070  ameterset..    p
-00001d30: 726f 6365 6475 7265 2865 7661 6c5f 696e  rocedure(eval_in
-00001d40: 7465 7266 6163 6529 2c20 494e 5445 4e54  terface), INTENT
-00001d50: 2849 4e29 2c20 504f 494e 5445 5220 3a3a  (IN), POINTER ::
-00001d60: 2065 7661 6c0a 0a20 2020 2072 6561 6c28   eval..    real(
-00001d70: 6470 292c 206f 7074 696f 6e61 6c2c 2069  dp), optional, i
-00001d80: 6e74 656e 7428 696e 2920 3a3a 2061 7267  ntent(in) :: arg
-00001d90: 310a 0a20 2020 2072 6561 6c28 6470 292c  1..    real(dp),
-00001da0: 206f 7074 696f 6e61 6c2c 2069 6e74 656e   optional, inten
-00001db0: 7428 6f75 7429 203a 3a20 6172 6732 0a0a  t(out) :: arg2..
-00001dc0: 2020 2020 7265 616c 2864 7029 2c20 6f70      real(dp), op
-00001dd0: 7469 6f6e 616c 2c20 696e 7465 6e74 286f  tional, intent(o
-00001de0: 7574 2920 3a3a 2061 7267 330a 0a20 2020  ut) :: arg3..   
-00001df0: 2052 4541 4c28 6470 2920 3a3a 206f 626a   REAL(dp) :: obj
-00001e00: 6563 7469 7665 5f6d 6173 7465 720a 0a20  ective_master.. 
-00001e10: 2020 2052 4541 4c28 6470 2920 3a3a 2070     REAL(dp) :: p
-00001e20: 6172 7469 616c 5f6f 626a 6563 7469 7665  artial_objective
-00001e30: 0a0a 2020 2020 7265 616c 2864 7029 2c20  ..    real(dp), 
-00001e40: 6469 6d65 6e73 696f 6e28 3629 203a 3a20  dimension(6) :: 
-00001e50: 6d75 6c74 6970 6c65 5f70 6172 7469 616c  multiple_partial
-00001e60: 5f6f 626a 6563 7469 7665 0a0a 2020 2020  _objective..    
-00001e70: 7265 616c 2864 7029 2c20 6469 6d65 6e73  real(dp), dimens
-00001e80: 696f 6e28 3629 203a 3a20 6d75 6c74 6970  ion(6) :: multip
-00001e90: 6c65 5f6d 6173 7465 725f 6f62 6a65 6374  le_master_object
-00001ea0: 6976 650a 0a20 2020 2021 2066 6f72 2073  ive..    ! for s
-00001eb0: 6978 7468 2072 6f6f 740a 2020 2020 7265  ixth root.    re
-00001ec0: 616c 2864 7029 2c20 7061 7261 6d65 7465  al(dp), paramete
-00001ed0: 7220 3a3a 206f 6e65 7369 7874 6820 3d20  r :: onesixth = 
-00001ee0: 312e 305f 6470 202f 2036 2e30 5f64 700a  1.0_dp / 6.0_dp.
-00001ef0: 0a20 2020 2069 6e74 6567 6572 2869 3429  .    integer(i4)
-00001f00: 203a 3a20 6970 726f 632c 206e 7072 6f63   :: iproc, nproc
-00001f10: 0a0a 2020 2020 696e 7465 6765 7228 6934  ..    integer(i4
-00001f20: 2920 3a3a 2069 6572 726f 720a 0a20 2020  ) :: ierror..   
-00001f30: 2074 7970 6528 4d50 495f 5374 6174 7573   type(MPI_Status
-00001f40: 2920 3a3a 2073 7461 7475 730a 0a0a 2020  ) :: status...  
-00001f50: 2020 6966 2028 7072 6573 656e 7428 6172    if (present(ar
-00001f60: 6731 2920 2e6f 722e 2070 7265 7365 6e74  g1) .or. present
-00001f70: 2861 7267 3229 202e 6f72 2e20 7072 6573  (arg2) .or. pres
-00001f80: 656e 7428 6172 6733 2929 2074 6865 6e0a  ent(arg3)) then.
-00001f90: 2020 2020 2020 6361 6c6c 206d 6573 7361        call messa
-00001fa0: 6765 2822 4572 726f 7220 6d6f 5f6f 626a  ge("Error mo_obj
-00001fb0: 6563 7469 7665 5f66 756e 6374 696f 6e3a  ective_function:
-00001fc0: 2052 6563 6569 7665 6420 756e 6578 7065   Received unexpe
-00001fd0: 6374 6564 2061 7267 756d 656e 742c 2063  cted argument, c
-00001fe0: 6865 636b 206f 7074 696d 697a 6174 696f  heck optimizatio
-00001ff0: 6e20 7365 7474 696e 6773 2229 0a20 2020  n settings").   
-00002000: 2020 2073 746f 7020 310a 2020 2020 656e     stop 1.    en
-00002010: 6420 6966 0a0a 2020 2020 2120 7365 7420  d if..    ! set 
-00002020: 7468 6573 6520 746f 206e 616e 2073 6f20  these to nan so 
-00002030: 636f 6d70 696c 6572 2064 6f65 7320 6e6f  compiler does no
-00002040: 7420 636f 6d70 6c61 696e 0a20 2020 2069  t complain.    i
-00002050: 6620 2870 7265 7365 6e74 2861 7267 3229  f (present(arg2)
-00002060: 2920 7468 656e 0a20 2020 2020 2061 7267  ) then.      arg
-00002070: 3220 3d20 6e6f 6461 7461 5f64 700a 2020  2 = nodata_dp.  
-00002080: 2020 656e 6420 6966 0a20 2020 2069 6620    end if.    if 
-00002090: 2870 7265 7365 6e74 2861 7267 3329 2920  (present(arg3)) 
-000020a0: 7468 656e 0a20 2020 2020 2061 7267 3320  then.      arg3 
-000020b0: 3d20 6e6f 6461 7461 5f64 700a 2020 2020  = nodata_dp.    
-000020c0: 656e 6420 6966 0a0a 2020 2020 6361 6c6c  end if..    call
-000020d0: 2064 6973 7472 6962 7574 655f 7061 7261   distribute_para
-000020e0: 6d65 7465 7273 6574 2870 6172 616d 6574  meterset(paramet
-000020f0: 6572 7365 7429 0a20 2020 2073 656c 6563  erset).    selec
-00002100: 7420 6361 7365 2028 6f70 7469 5f66 756e  t case (opti_fun
-00002110: 6374 696f 6e29 0a20 2020 2063 6173 6520  ction).    case 
-00002120: 2831 3020 3a20 3133 2c20 3137 2c20 3237  (10 : 13, 17, 27
-00002130: 203a 2032 3929 0a20 2020 2020 2063 616c   : 29).      cal
-00002140: 6c20 4d50 495f 436f 6d6d 5f73 697a 6528  l MPI_Comm_size(
-00002150: 646f 6d61 696e 4d65 7461 2563 6f6d 4d61  domainMeta%comMa
-00002160: 7374 6572 2c20 6e70 726f 632c 2069 6572  ster, nproc, ier
-00002170: 726f 7229 0a20 2020 2020 206f 626a 6563  ror).      objec
-00002180: 7469 7665 5f6d 6173 7465 7220 3d20 302e  tive_master = 0.
-00002190: 305f 6470 0a20 2020 2020 2064 6f20 6970  0_dp.      do ip
-000021a0: 726f 6320 3d20 312c 206e 7072 6f63 202d  roc = 1, nproc -
-000021b0: 2031 0a20 2020 2020 2020 2063 616c 6c20   1.        call 
-000021c0: 4d50 495f 5265 6376 2870 6172 7469 616c  MPI_Recv(partial
-000021d0: 5f6f 626a 6563 7469 7665 2c20 312c 204d  _objective, 1, M
-000021e0: 5049 5f44 4f55 424c 455f 5052 4543 4953  PI_DOUBLE_PRECIS
-000021f0: 494f 4e2c 2069 7072 6f63 2c20 302c 2064  ION, iproc, 0, d
-00002200: 6f6d 6169 6e4d 6574 6125 636f 6d4d 6173  omainMeta%comMas
-00002210: 7465 722c 2073 7461 7475 732c 2069 6572  ter, status, ier
-00002220: 726f 7229 0a20 2020 2020 2020 206f 626a  ror).        obj
-00002230: 6563 7469 7665 5f6d 6173 7465 7220 3d20  ective_master = 
-00002240: 6f62 6a65 6374 6976 655f 6d61 7374 6572  objective_master
-00002250: 202b 2070 6172 7469 616c 5f6f 626a 6563   + partial_objec
-00002260: 7469 7665 0a20 2020 2020 2065 6e64 2064  tive.      end d
-00002270: 6f0a 2020 2020 2020 6f62 6a65 6374 6976  o.      objectiv
-00002280: 655f 6d61 7374 6572 203d 206f 626a 6563  e_master = objec
-00002290: 7469 7665 5f6d 6173 7465 722a 2a6f 6e65  tive_master**one
-000022a0: 7369 7874 680a 2020 2020 6361 7365 2028  sixth.    case (
-000022b0: 3135 290a 2020 2020 2020 2120 4b47 4520  15).      ! KGE 
-000022c0: 666f 7220 5120 2a20 524d 5345 2066 6f72  for Q * RMSE for
-000022d0: 2064 6f6d 6169 6e5f 6176 6720 5457 5320   domain_avg TWS 
-000022e0: 2873 7461 6e64 6172 697a 6564 2073 636f  (standarized sco
-000022f0: 7265 6429 0a20 2020 2020 2063 616c 6c20  red).      call 
-00002300: 6d65 7373 6167 6528 2263 6173 6520 3135  message("case 15
-00002310: 2c20 6f62 6a65 6374 6976 655f 6b67 655f  , objective_kge_
-00002320: 715f 726d 7365 5f74 7773 206e 6f74 2069  q_rmse_tws not i
-00002330: 6d70 6c65 6d65 6e74 6564 2069 6e20 7061  mplemented in pa
-00002340: 7261 6c6c 656c 2079 6574 2229 0a20 2020  rallel yet").   
-00002350: 2020 2073 746f 700a 2020 2020 6361 7365     stop.    case
-00002360: 2028 3330 290a 2020 2020 2020 2120 4b47   (30).      ! KG
-00002370: 4520 666f 7220 5120 2a20 524d 5345 2066  E for Q * RMSE f
-00002380: 6f72 2064 6f6d 6169 6e5f 6176 6720 4554  or domain_avg ET
-00002390: 2028 7374 616e 6461 7269 7a65 6420 7363   (standarized sc
-000023a0: 6f72 6564 290a 2020 2020 2020 2120 6f62  ored).      ! ob
-000023b0: 6a65 6374 6976 655f 6d61 7374 6572 203d  jective_master =
-000023c0: 206f 626a 6563 7469 7665 5f6b 6765 5f71   objective_kge_q
-000023d0: 5f72 6d73 655f 6574 2870 6172 616d 6574  _rmse_et(paramet
-000023e0: 6572 7365 742c 2065 7661 6c29 0a20 2020  erset, eval).   
-000023f0: 2020 2063 616c 6c20 6d65 7373 6167 6528     call message(
-00002400: 2263 6173 6520 3330 2c20 6f62 6a65 6374  "case 30, object
-00002410: 6976 655f 6b67 655f 715f 726d 7365 5f65  ive_kge_q_rmse_e
-00002420: 7420 6e6f 7420 696d 706c 656d 656e 7465  t not implemente
-00002430: 6420 696e 2070 6172 616c 6c65 6c20 7965  d in parallel ye
-00002440: 7422 290a 2020 2020 6361 7365 2833 3329  t").    case(33)
-00002450: 0a20 2020 2020 2063 616c 6c20 4d50 495f  .      call MPI_
-00002460: 436f 6d6d 5f73 697a 6528 646f 6d61 696e  Comm_size(domain
-00002470: 4d65 7461 2563 6f6d 4d61 7374 6572 2c20  Meta%comMaster, 
-00002480: 6e70 726f 632c 2069 6572 726f 7229 0a20  nproc, ierror). 
-00002490: 2020 2020 206f 626a 6563 7469 7665 5f6d       objective_m
-000024a0: 6173 7465 7220 3d20 302e 305f 6470 0a20  aster = 0.0_dp. 
-000024b0: 2020 2020 206d 756c 7469 706c 655f 6d61       multiple_ma
-000024c0: 7374 6572 5f6f 626a 6563 7469 7665 283a  ster_objective(:
-000024d0: 2920 3d20 302e 305f 6470 0a20 2020 2020  ) = 0.0_dp.     
-000024e0: 2064 6f20 6970 726f 6320 3d20 312c 206e   do iproc = 1, n
-000024f0: 7072 6f63 202d 2031 0a20 2020 2020 2020  proc - 1.       
-00002500: 2063 616c 6c20 4d50 495f 5265 6376 286d   call MPI_Recv(m
-00002510: 756c 7469 706c 655f 7061 7274 6961 6c5f  ultiple_partial_
-00002520: 6f62 6a65 6374 6976 652c 2036 2c20 4d50  objective, 6, MP
-00002530: 495f 444f 5542 4c45 5f50 5245 4349 5349  I_DOUBLE_PRECISI
-00002540: 4f4e 2c20 6970 726f 632c 2030 2c20 646f  ON, iproc, 0, do
-00002550: 6d61 696e 4d65 7461 2563 6f6d 4d61 7374  mainMeta%comMast
-00002560: 6572 2c20 7374 6174 7573 2c20 6965 7272  er, status, ierr
-00002570: 6f72 290a 2020 2020 2020 2020 6d75 6c74  or).        mult
-00002580: 6970 6c65 5f6d 6173 7465 725f 6f62 6a65  iple_master_obje
-00002590: 6374 6976 6520 3d20 6d75 6c74 6970 6c65  ctive = multiple
-000025a0: 5f6d 6173 7465 725f 6f62 6a65 6374 6976  _master_objectiv
-000025b0: 6520 2b20 6d75 6c74 6970 6c65 5f70 6172  e + multiple_par
-000025c0: 7469 616c 5f6f 626a 6563 7469 7665 0a20  tial_objective. 
-000025d0: 2020 2020 2065 6e64 2064 6f0a 2020 2020       end do.    
-000025e0: 2020 6f62 6a65 6374 6976 655f 6d61 7374    objective_mast
-000025f0: 6572 203d 206f 626a 6563 7469 7665 5f6d  er = objective_m
-00002600: 6173 7465 7220 2b20 260a 2020 2020 2020  aster + &.      
-00002610: 2020 286d 756c 7469 706c 655f 6d61 7374    (multiple_mast
-00002620: 6572 5f6f 626a 6563 7469 7665 2831 292b  er_objective(1)+
-00002630: 6d75 6c74 6970 6c65 5f6d 6173 7465 725f  multiple_master_
-00002640: 6f62 6a65 6374 6976 6528 3229 2b6d 756c  objective(2)+mul
-00002650: 7469 706c 655f 6d61 7374 6572 5f6f 626a  tiple_master_obj
-00002660: 6563 7469 7665 2833 2929 0a20 2020 2020  ective(3)).     
-00002670: 206f 626a 6563 7469 7665 5f6d 6173 7465   objective_maste
-00002680: 7220 3d20 286f 626a 6563 7469 7665 5f6d  r = (objective_m
-00002690: 6173 7465 722f 6d75 6c74 6970 6c65 5f6d  aster/multiple_m
-000026a0: 6173 7465 725f 6f62 6a65 6374 6976 6528  aster_objective(
-000026b0: 3429 292a 2a6f 6e65 7369 7874 680a 0a20  4))**onesixth.. 
-000026c0: 2020 2063 6173 6520 6465 6661 756c 740a     case default.
-000026d0: 2020 2020 2020 6361 6c6c 206d 6573 7361        call messa
-000026e0: 6765 2822 4572 726f 7220 6f62 6a65 6374  ge("Error object
-000026f0: 6976 655f 6d61 7374 6572 3a20 6f70 7469  ive_master: opti
-00002700: 5f66 756e 6374 696f 6e20 6e6f 7420 696d  _function not im
-00002710: 706c 656d 656e 7465 6420 7965 742e 2229  plemented yet.")
-00002720: 0a20 2020 2020 2073 746f 7020 310a 2020  .      stop 1.  
-00002730: 2020 656e 6420 7365 6c65 6374 0a0a 2020    end select..  
-00002740: 2020 7365 6c65 6374 2063 6173 6520 286f    select case (o
-00002750: 7074 695f 6675 6e63 7469 6f6e 290a 2020  pti_function).  
-00002760: 2020 6361 7365 2831 3029 0a20 2020 2020    case(10).     
-00002770: 2063 616c 6c20 6d65 7373 6167 6528 2720   call message(' 
-00002780: 2020 206f 626a 6563 7469 7665 5f73 6d5f     objective_sm_
-00002790: 6b67 655f 6361 7463 686d 656e 745f 6176  kge_catchment_av
-000027a0: 6720 3d20 272c 206e 756d 3273 7472 286f  g = ', num2str(o
-000027b0: 626a 6563 7469 7665 5f6d 6173 7465 722c  bjective_master,
-000027c0: 2027 2846 392e 3529 2729 290a 2020 2020   '(F9.5)')).    
-000027d0: 6361 7365 2831 3129 0a20 2020 2020 2063  case(11).      c
-000027e0: 616c 6c20 6d65 7373 6167 6528 2720 2020  all message('   
-000027f0: 206f 626a 6563 7469 7665 5f73 6d5f 7064   objective_sm_pd
-00002800: 203d 2027 2c20 6e75 6d32 7374 7228 6f62   = ', num2str(ob
-00002810: 6a65 6374 6976 655f 6d61 7374 6572 2c20  jective_master, 
-00002820: 2728 4639 2e35 2927 2929 0a20 2020 2063  '(F9.5)')).    c
-00002830: 6173 6528 3132 290a 2020 2020 2020 6361  ase(12).      ca
-00002840: 6c6c 206d 6573 7361 6765 2827 2020 2020  ll message('    
-00002850: 6f62 6a65 6374 6976 655f 736d 5f73 7365  objective_sm_sse
-00002860: 5f73 7461 6e64 6172 645f 7363 6f72 6520  _standard_score 
-00002870: 3d20 272c 206e 756d 3273 7472 286f 626a  = ', num2str(obj
-00002880: 6563 7469 7665 5f6d 6173 7465 722c 2027  ective_master, '
-00002890: 2845 3132 2e35 2927 2929 0a20 2020 2063  (E12.5)')).    c
-000028a0: 6173 6528 3133 290a 2020 2020 2020 6361  ase(13).      ca
-000028b0: 6c6c 206d 6573 7361 6765 2827 2020 2020  ll message('    
-000028c0: 6f62 6a65 6374 6976 655f 736d 5f63 6f72  objective_sm_cor
-000028d0: 7220 3d20 272c 206e 756d 3273 7472 286f  r = ', num2str(o
-000028e0: 626a 6563 7469 7665 5f6d 6173 7465 722c  bjective_master,
-000028f0: 2027 2846 392e 3529 2729 290a 2020 2020   '(F9.5)')).    
-00002900: 6361 7365 2831 3729 0a20 2020 2020 2063  case(17).      c
-00002910: 616c 6c20 6d65 7373 6167 6528 2720 2020  all message('   
-00002920: 206f 626a 6563 7469 7665 5f6e 6575 7472   objective_neutr
-00002930: 6f6e 735f 6b67 655f 6361 7463 686d 656e  ons_kge_catchmen
-00002940: 745f 6176 6720 3d20 272c 206e 756d 3273  t_avg = ', num2s
-00002950: 7472 286f 626a 6563 7469 7665 5f6d 6173  tr(objective_mas
-00002960: 7465 722c 2027 2846 392e 3529 2729 290a  ter, '(F9.5)')).
-00002970: 2020 2020 6361 7365 2832 3729 0a20 2020      case(27).   
+00000000: 213e 205c 6669 6c65 206d 6f5f 6f62 6a65  !> \file mo_obje
+00000010: 6374 6976 655f 6675 6e63 7469 6f6e 2e66  ctive_function.f
+00000020: 3930 0a21 3e20 5c62 7269 6566 2020 205c  90.!> \brief   \
+00000030: 636f 7079 6272 6965 6620 6d6f 5f6f 626a  copybrief mo_obj
+00000040: 6563 7469 7665 5f66 756e 6374 696f 6e0a  ective_function.
+00000050: 213e 205c 6465 7461 696c 7320 5c63 6f70  !> \details \cop
+00000060: 7964 6574 6169 6c73 206d 6f5f 6f62 6a65  ydetails mo_obje
+00000070: 6374 6976 655f 6675 6e63 7469 6f6e 0a0a  ctive_function..
+00000080: 2120 546f 446f 3a20 6368 616e 6765 2063  ! ToDo: change c
+00000090: 6f6d 6d65 6e74 2066 6f72 204f 4620 3135  omment for OF 15
+000000a0: 0a0a 213e 205c 6272 6965 6620 4f62 6a65  ..!> \brief Obje
+000000b0: 6374 6976 6520 4675 6e63 7469 6f6e 7320  ctive Functions 
+000000c0: 666f 7220 4f70 7469 6d69 7a61 7469 6f6e  for Optimization
+000000d0: 206f 6620 6d48 4d2e 0a21 3e20 5c64 6574   of mHM..!> \det
+000000e0: 6169 6c73 2054 6869 7320 6d6f 6475 6c65  ails This module
+000000f0: 2070 726f 7669 6465 7320 6120 7772 6170   provides a wrap
+00000100: 7065 7220 666f 7220 7365 7665 7261 6c20  per for several 
+00000110: 6f62 6a65 6374 6976 6520 6675 6e63 7469  objective functi
+00000120: 6f6e 7320 7573 6564 2074 6f20 6f70 7469  ons used to opti
+00000130: 6d69 7a65 206d 484d 2061 6761 696e 7374  mize mHM against
+00000140: 2076 6172 696f 7573 0a21 2120 2020 2020   various.!!     
+00000150: 2020 7661 7269 6162 6c65 732e 0a21 2120    variables..!! 
+00000160: 2020 2020 2020 4966 2074 6865 206f 626a        If the obj
+00000170: 6563 7469 7665 2069 7320 6f6e 6c79 2072  ective is only r
+00000180: 6567 6172 6469 6e67 2072 756e 6f66 6620  egarding runoff 
+00000190: 6d6f 7665 2069 7420 746f 206d 524d 2f6d  move it to mRM/m
+000001a0: 6f5f 6d72 6d5f 6f62 6a65 6374 6976 655f  o_mrm_objective_
+000001b0: 6675 6e63 7469 6f6e 5f72 756e 6f66 662e  function_runoff.
+000001c0: 6639 302e 0a21 2120 2020 2020 2020 4966  f90..!!       If
+000001d0: 2069 7420 636f 6e74 6169 6e73 2062 6573   it contains bes
+000001e0: 6964 6573 2072 756e 6f66 6620 616e 6f74  ides runoff anot
+000001f0: 6865 7220 7661 7269 6162 6c65 206c 696b  her variable lik
+00000200: 6520 5457 5320 696d 706c 656d 656e 7420  e TWS implement 
+00000210: 6974 2068 6572 652e 0a21 210a 2121 2020  it here..!!.!!  
+00000220: 2020 2020 2041 6c6c 2074 6865 206f 626a       All the obj
+00000230: 6563 7469 7665 2066 756e 6374 696f 6e73  ective functions
+00000240: 2061 7265 2073 7570 706f 7365 6420 746f   are supposed to
+00000250: 2062 6520 6d69 6e69 6d69 7a65 6421 0a21   be minimized!.!
+00000260: 2120 2020 2020 2020 2d20 2831 3029 2053  !       - (10) S
+00000270: 4f3a 2053 4d3a 2020 2020 2020 2031 2e30  O: SM:       1.0
+00000280: 202d 204b 4745 206f 6620 6361 7463 686d   - KGE of catchm
+00000290: 656e 7420 6176 6572 6167 6520 736f 696c  ent average soil
+000002a0: 6d6f 6973 7475 7265 0a21 2120 2020 2020  moisture.!!     
+000002b0: 2020 2d20 2831 3129 2053 4f3a 2053 4d3a    - (11) SO: SM:
+000002c0: 2020 2020 2020 2031 2e30 202d 2050 6174         1.0 - Pat
+000002d0: 7465 726e 2064 6973 7369 6d69 6c61 7269  tern dissimilari
+000002e0: 7479 2028 5044 2920 6f66 2073 7061 7469  ty (PD) of spati
+000002f0: 616c 6c79 2064 6973 7472 6962 7574 6564  ally distributed
+00000300: 2073 6f69 6c20 6d6f 6973 7475 7265 0a21   soil moisture.!
+00000310: 2120 2020 2020 2020 2d20 2831 3229 2053  !       - (12) S
+00000320: 4f3a 2053 4d3a 2020 2020 2020 2053 756d  O: SM:       Sum
+00000330: 206f 6620 7371 7561 7265 6420 6572 726f   of squared erro
+00000340: 7273 2028 5353 4529 206f 6620 7370 6174  rs (SSE) of spat
+00000350: 6961 6c6c 7920 6469 7374 7269 6275 7465  ially distribute
+00000360: 6420 7374 616e 6461 7264 2073 636f 7265  d standard score
+00000370: 2028 6e6f 726d 616c 697a 6174 696f 6e29   (normalization)
+00000380: 206f 6620 736f 696c 206d 6f69 7374 7572   of soil moistur
+00000390: 650a 2121 2020 2020 2020 202d 2028 3133  e.!!       - (13
+000003a0: 2920 534f 3a20 534d 3a20 2020 2020 2020  ) SO: SM:       
+000003b0: 312e 3020 2d20 6176 6572 6167 6520 7465  1.0 - average te
+000003c0: 6d70 6f72 616c 2063 6f72 7265 6c61 7469  mporal correlati
+000003d0: 6f6e 206f 6620 7370 6174 6961 6c6c 7920  on of spatially 
+000003e0: 6469 7374 7269 6275 7465 6420 736f 696c  distributed soil
+000003f0: 206d 6f69 7374 7572 650a 2121 2020 2020   moisture.!!    
+00000400: 2020 202d 2028 3135 2920 534f 3a20 5120     - (15) SO: Q 
+00000410: 2b20 5457 533a 2020 5b31 2e30 2d4b 4745  + TWS:  [1.0-KGE
+00000420: 2851 295d 2a52 4d53 4528 646f 6d61 696e  (Q)]*RMSE(domain
+00000430: 5f61 7667 5f54 5753 2920 2d20 6f62 6a65  _avg_TWS) - obje
+00000440: 6374 6976 6520 6675 6e63 7469 6f6e 2075  ctive function u
+00000450: 7369 6e67 2051 2061 6e64 2064 6f6d 6169  sing Q and domai
+00000460: 6e20 6176 6572 6167 6520 2873 7461 6e64  n average (stand
+00000470: 6172 6420 7363 6f72 6529 2054 5753 0a21  ard score) TWS.!
+00000480: 2120 2020 2020 2020 2d20 2831 3729 2053  !       - (17) S
+00000490: 4f3a 204e 3a20 2020 2020 2020 2031 2e30  O: N:        1.0
+000004a0: 202d 204b 4745 206f 6620 7370 6174 696f   - KGE of spatio
+000004b0: 2d74 656d 706f 7261 6c20 6e65 7574 726f  -temporal neutro
+000004c0: 6e20 6461 7461 2c20 6361 7463 686d 656e  n data, catchmen
+000004d0: 742d 6176 6572 6167 650a 2121 2020 2020  t-average.!!    
+000004e0: 2020 202d 2028 3237 2920 534f 3a20 4554     - (27) SO: ET
+000004f0: 3a20 2020 2020 2020 312e 3020 2d20 4b47  :       1.0 - KG
+00000500: 4520 6f66 2063 6174 6368 6d65 6e74 2061  E of catchment a
+00000510: 7665 7261 6765 2065 7661 706f 7472 616e  verage evapotran
+00000520: 7370 6972 6174 696f 6e0a 213e 205c 6368  spiration.!> \ch
+00000530: 616e 6765 6c6f 670a 2121 202d 204f 6c64  angelog.!! - Old
+00000540: 7269 6368 2052 616b 6f76 6563 204f 6374  rich Rakovec Oct
+00000550: 2032 3031 350a 2121 2020 202d 2061 6464   2015.!!   - add
+00000560: 6564 206f 626a 2e20 6675 6e63 2e20 3135  ed obj. func. 15
+00000570: 2028 6f62 6a65 6374 6976 655f 6b67 655f   (objective_kge_
+00000580: 715f 726d 7365 5f74 7773 2920 616e 6420  q_rmse_tws) and 
+00000590: 6578 7472 6163 745f 646f 6d61 696e 5f61  extract_domain_a
+000005a0: 7667 5f74 7773 2072 6f75 7469 6e65 2c20  vg_tws routine, 
+000005b0: 666f 726d 6572 2062 6173 696e 5f61 7667  former basin_avg
+000005c0: 0a21 2120 2d20 526f 6265 7274 2053 6368  .!! - Robert Sch
+000005d0: 7765 7070 6520 4a75 6e20 3230 3138 0a21  weppe Jun 2018.!
+000005e0: 2120 2020 2d20 7265 6661 6374 6f72 696e  !   - refactorin
+000005f0: 6720 616e 6420 7265 666f 726d 6174 7469  g and reformatti
+00000600: 6e67 0a21 3e20 5c61 7574 686f 7273 204a  ng.!> \authors J
+00000610: 756c 6961 6e65 204d 6169 0a21 3e20 5c64  uliane Mai.!> \d
+00000620: 6174 6520 4465 6320 3230 3132 0a21 3e20  ate Dec 2012.!> 
+00000630: 5c63 6f70 7972 6967 6874 2043 6f70 7972  \copyright Copyr
+00000640: 6967 6874 2032 3030 352d 5c74 6f64 6179  ight 2005-\today
+00000650: 2c20 7468 6520 6d48 4d20 4465 7665 6c6f  , the mHM Develo
+00000660: 7065 7273 2c20 4c75 6973 2053 616d 616e  pers, Luis Saman
+00000670: 6965 676f 2c20 5361 6269 6e65 2041 7474  iego, Sabine Att
+00000680: 696e 6765 723a 2041 6c6c 2072 6967 6874  inger: All right
+00000690: 7320 7265 7365 7276 6564 2e0a 2121 206d  s reserved..!! m
+000006a0: 484d 2069 7320 7265 6c65 6173 6564 2075  HM is released u
+000006b0: 6e64 6572 2074 6865 204c 4750 4c76 332b  nder the LGPLv3+
+000006c0: 206c 6963 656e 7365 205c 6c69 6365 6e73   license \licens
+000006d0: 655f 6e6f 7465 0a21 3e20 5c69 6e67 726f  e_note.!> \ingro
+000006e0: 7570 2066 5f6d 686d 0a4d 4f44 554c 4520  up f_mhm.MODULE 
+000006f0: 6d6f 5f6f 626a 6563 7469 7665 5f66 756e  mo_objective_fun
+00000700: 6374 696f 6e0a 0a20 2021 2054 6869 7320  ction..  ! This 
+00000710: 6d6f 6475 6c65 2070 726f 7669 6465 7320  module provides 
+00000720: 6f62 6a65 6374 6976 6520 6675 6e63 7469  objective functi
+00000730: 6f6e 7320 666f 7220 6f70 7469 6d69 7a61  ons for optimiza
+00000740: 7469 6f6e 206f 6620 7468 6520 5546 5a20  tion of the UFZ 
+00000750: 4348 5320 6d65 736f 7363 616c 6520 6879  CHS mesoscale hy
+00000760: 6472 6f6c 6f67 6963 206d 6f64 656c 206d  drologic model m
+00000770: 484d 2e0a 0a20 2021 2057 7269 7474 656e  HM...  ! Written
+00000780: 2020 4a75 6c69 616e 6520 4d61 692c 2044    Juliane Mai, D
+00000790: 6563 2032 3031 320a 2020 2120 4d6f 6469  ec 2012.  ! Modi
+000007a0: 6669 6564 2053 7465 7068 616e 2054 686f  fied Stephan Tho
+000007b0: 6265 722c 204f 6374 2032 3031 3520 6d6f  ber, Oct 2015 mo
+000007c0: 7665 6420 616c 6c20 7275 6e6f 6666 206f  ved all runoff o
+000007d0: 6e6c 7920 7265 6c61 7465 6420 6f62 6a65  nly related obje
+000007e0: 6374 6976 6573 2074 6f20 6d52 4d0a 0a20  ctives to mRM.. 
+000007f0: 2055 5345 206d 6f5f 6b69 6e64 2c20 4f4e   USE mo_kind, ON
+00000800: 4c59 203a 2069 342c 2064 700a 2020 7573  LY : i4, dp.  us
+00000810: 6520 6d6f 5f6f 7074 696d 697a 6174 696f  e mo_optimizatio
+00000820: 6e5f 7574 696c 732c 206f 6e6c 7920 3a20  n_utils, only : 
+00000830: 6576 616c 5f69 6e74 6572 6661 6365 0a20  eval_interface. 
+00000840: 2075 7365 206d 6f5f 6d65 7373 6167 652c   use mo_message,
+00000850: 206f 6e6c 7920 3a20 6d65 7373 6167 652c   only : message,
+00000860: 2065 7272 6f72 5f6d 6573 7361 6765 0a0a   error_message..
+00000870: 2020 494d 504c 4943 4954 204e 4f4e 450a    IMPLICIT NONE.
+00000880: 0a20 2050 5249 5641 5445 0a0a 2020 5055  .  PRIVATE..  PU
+00000890: 424c 4943 203a 3a20 6f62 6a65 6374 6976  BLIC :: objectiv
+000008a0: 650a 2369 6664 6566 204d 5049 0a20 2050  e.#ifdef MPI.  P
+000008b0: 5542 4c49 4320 3a3a 206f 626a 6563 7469  UBLIC :: objecti
+000008c0: 7665 5f6d 6173 7465 722c 206f 626a 6563  ve_master, objec
+000008d0: 7469 7665 5f73 7562 7072 6f63 6573 7320  tive_subprocess 
+000008e0: 2120 6f62 6a65 6374 6976 6520 6675 6e63  ! objective func
+000008f0: 7469 6f6e 2077 7261 7070 6572 2066 6f72  tion wrapper for
+00000900: 2073 6f69 6c20 6d6f 6973 7475 7265 206f   soil moisture o
+00000910: 6e6c 790a 2365 6e64 6966 0a0a 2020 2120  nly.#endif..  ! 
+00000920: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00000930: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00000940: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00000950: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00000960: 2d2d 0a0a 434f 4e54 4149 4e53 0a0a 2020  --..CONTAINS..  
+00000970: 2120 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ! --------------
+00000980: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00000990: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000009a0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000009b0: 2d2d 2d2d 0a0a 2020 2120 2020 204e 414d  ----..  !    NAM
+000009c0: 450a 2020 2120 2020 2020 2020 206f 626a  E.  !        obj
+000009d0: 6563 7469 7665 0a0a 2020 2120 2020 2050  ective..  !    P
+000009e0: 5552 504f 5345 0a20 2021 3e20 2020 2020  URPOSE.  !>     
+000009f0: 2020 5c62 7269 6566 2057 7261 7070 6572    \brief Wrapper
+00000a00: 2066 6f72 206f 626a 6563 7469 7665 2066   for objective f
+00000a10: 756e 6374 696f 6e73 2e0a 0a20 2021 3e20  unctions...  !> 
+00000a20: 2020 2020 2020 5c64 6574 6169 6c73 2054        \details T
+00000a30: 6865 2066 756e 6374 696f 6e73 2073 656c  he functions sel
+00000a40: 6563 7473 2074 6865 206f 626a 6563 7469  ects the objecti
+00000a50: 7665 2066 756e 6374 696f 6e20 6361 7365  ve function case
+00000a60: 2064 6566 696e 6564 2069 6e20 6120 6e61   defined in a na
+00000a70: 6d65 6c69 7374 2c0a 2020 213e 2020 2020  melist,.  !>    
+00000a80: 2020 2069 2e65 2e20 7468 6520 676c 6f62     i.e. the glob
+00000a90: 616c 2076 6172 6961 626c 6520 5c65 206f  al variable \e o
+00000aa0: 7074 695c 5f66 756e 6374 696f 6e2e 0a20  pti\_function.. 
+00000ab0: 2021 3e20 2020 2020 2020 4974 2072 6574   !>       It ret
+00000ac0: 7572 6e20 7468 6520 6f62 6a65 6374 6976  urn the objectiv
+00000ad0: 6520 6675 6e63 7469 6f6e 2076 616c 7565  e function value
+00000ae0: 2066 6f72 2061 2073 7065 6369 6669 6320   for a specific 
+00000af0: 7061 7261 6d65 7465 7220 7365 742e 0a0a  parameter set...
+00000b00: 2020 2120 2020 2049 4e54 454e 5428 494e    !    INTENT(IN
+00000b10: 290a 2020 213e 2020 2020 2020 205c 7061  ).  !>       \pa
+00000b20: 7261 6d5b 696e 5d20 2252 4541 4c28 6470  ram[in] "REAL(dp
+00000b30: 292c 2044 494d 454e 5349 4f4e 283a 2920  ), DIMENSION(:) 
+00000b40: 3a3a 2070 6172 616d 6574 6572 7365 7422  :: parameterset"
+00000b50: 0a20 2021 3e20 2020 2020 2020 5c70 6172  .  !>       \par
+00000b60: 616d 5b69 6e5d 2022 7072 6f63 6564 7572  am[in] "procedur
+00000b70: 6528 6576 616c 5f69 6e74 6572 6661 6365  e(eval_interface
+00000b80: 2920 3a3a 2065 7661 6c22 0a0a 2020 2120  ) :: eval"..  ! 
+00000b90: 2020 2049 4e54 454e 5428 494e 292c 204f     INTENT(IN), O
+00000ba0: 5054 494f 4e41 4c0a 2020 213e 2020 2020  PTIONAL.  !>    
+00000bb0: 2020 205c 7061 7261 6d5b 696e 5d20 2272     \param[in] "r
+00000bc0: 6561 6c28 6470 292c 206f 7074 696f 6e61  eal(dp), optiona
+00000bd0: 6c20 3a3a 2061 7267 3122 0a0a 2020 2120  l :: arg1"..  ! 
+00000be0: 2020 2049 4e54 454e 5428 4f55 5429 2c20     INTENT(OUT), 
+00000bf0: 4f50 5449 4f4e 414c 0a20 2021 3e20 2020  OPTIONAL.  !>   
+00000c00: 2020 2020 5c70 6172 616d 5b6f 7574 5d20      \param[out] 
+00000c10: 2272 6561 6c28 6470 292c 206f 7074 696f  "real(dp), optio
+00000c20: 6e61 6c20 3a3a 2061 7267 3222 0a20 2021  nal :: arg2".  !
+00000c30: 3e20 2020 2020 2020 5c70 6172 616d 5b6f  >       \param[o
+00000c40: 7574 5d20 2272 6561 6c28 6470 292c 206f  ut] "real(dp), o
+00000c50: 7074 696f 6e61 6c20 3a3a 2061 7267 3322  ptional :: arg3"
+00000c60: 0a0a 2020 2120 2020 2052 4554 5552 4e0a  ..  !    RETURN.
+00000c70: 2020 213e 2020 2020 2020 205c 7265 7475    !>       \retu
+00000c80: 726e 2072 6561 6c28 6470 2920 3a3a 206f  rn real(dp) :: o
+00000c90: 626a 6563 7469 7665 2026 6d64 6173 683b  bjective &mdash;
+00000ca0: 206f 626a 6563 7469 7665 2066 756e 6374   objective funct
+00000cb0: 696f 6e20 7661 6c75 650a 2020 213e 2020  ion value.  !>  
+00000cc0: 2020 2020 2028 7768 6963 6820 7769 6c6c       (which will
+00000cd0: 2062 6520 652e 672e 206d 696e 696d 697a   be e.g. minimiz
+00000ce0: 6564 2062 7920 616e 206f 7074 696d 697a  ed by an optimiz
+00000cf0: 6174 696f 6e20 726f 7574 696e 6520 6c69  ation routine li
+00000d00: 6b65 2044 4453 290a 0a20 2021 2020 2020  ke DDS)..  !    
+00000d10: 4849 5354 4f52 590a 2020 213e 2020 2020  HISTORY.  !>    
+00000d20: 2020 205c 6175 7468 6f72 7320 4a75 6c69     \authors Juli
+00000d30: 616e 6520 4d61 690a 0a20 2021 3e20 2020  ane Mai..  !>   
+00000d40: 2020 2020 5c64 6174 6520 4465 6320 3230      \date Dec 20
+00000d50: 3132 0a0a 2020 2120 4d6f 6469 6669 6361  12..  ! Modifica
+00000d60: 7469 6f6e 733a 0a20 2021 2053 7465 7068  tions:.  ! Steph
+00000d70: 616e 2054 686f 6265 7220 4f63 7420 3230  an Thober Oct 20
+00000d80: 3135 202d 206d 6f76 6564 2061 6c6c 2072  15 - moved all r
+00000d90: 756e 6f66 6620 7265 6c61 7465 6420 6f62  unoff related ob
+00000da0: 6a65 6374 6976 6520 6675 6e63 7469 6f6e  jective function
+00000db0: 7320 746f 206d 524d 0a20 2021 2052 6f62  s to mRM.  ! Rob
+00000dc0: 6572 7420 5363 6877 6570 7065 204a 756e  ert Schweppe Jun
+00000dd0: 2032 3031 3820 2d20 7265 6661 6374 6f72   2018 - refactor
+00000de0: 696e 6720 616e 6420 7265 666f 726d 6174  ing and reformat
+00000df0: 7469 6e67 0a0a 2020 4655 4e43 5449 4f4e  ting..  FUNCTION
+00000e00: 206f 626a 6563 7469 7665 2870 6172 616d   objective(param
+00000e10: 6574 6572 7365 742c 2065 7661 6c2c 2061  eterset, eval, a
+00000e20: 7267 312c 2061 7267 322c 2061 7267 3329  rg1, arg2, arg3)
+00000e30: 0a0a 2020 2020 7573 6520 6d6f 5f63 6f6d  ..    use mo_com
+00000e40: 6d6f 6e5f 636f 6e73 7461 6e74 732c 206f  mon_constants, o
+00000e50: 6e6c 7920 3a20 6e6f 6461 7461 5f64 700a  nly : nodata_dp.
+00000e60: 2020 2020 7573 6520 6d6f 5f63 6f6d 6d6f      use mo_commo
+00000e70: 6e5f 6d48 4d5f 6d52 4d5f 7661 7269 6162  n_mHM_mRM_variab
+00000e80: 6c65 732c 206f 6e6c 7920 3a20 6f70 7469  les, only : opti
+00000e90: 5f66 756e 6374 696f 6e0a 0a20 2020 2069  _function..    i
+00000ea0: 6d70 6c69 6369 7420 6e6f 6e65 0a0a 2020  mplicit none..  
+00000eb0: 2020 5245 414c 2864 7029 2c20 4449 4d45    REAL(dp), DIME
+00000ec0: 4e53 494f 4e28 3a29 2c20 494e 5445 4e54  NSION(:), INTENT
+00000ed0: 2849 4e29 203a 3a20 7061 7261 6d65 7465  (IN) :: paramete
+00000ee0: 7273 6574 0a0a 2020 2020 7072 6f63 6564  rset..    proced
+00000ef0: 7572 6528 6576 616c 5f69 6e74 6572 6661  ure(eval_interfa
+00000f00: 6365 292c 2049 4e54 454e 5428 494e 292c  ce), INTENT(IN),
+00000f10: 2050 4f49 4e54 4552 203a 3a20 6576 616c   POINTER :: eval
+00000f20: 0a0a 2020 2020 7265 616c 2864 7029 2c20  ..    real(dp), 
+00000f30: 6f70 7469 6f6e 616c 2c20 696e 7465 6e74  optional, intent
+00000f40: 2869 6e29 203a 3a20 6172 6731 0a0a 2020  (in) :: arg1..  
+00000f50: 2020 7265 616c 2864 7029 2c20 6f70 7469    real(dp), opti
+00000f60: 6f6e 616c 2c20 696e 7465 6e74 286f 7574  onal, intent(out
+00000f70: 2920 3a3a 2061 7267 320a 0a20 2020 2072  ) :: arg2..    r
+00000f80: 6561 6c28 6470 292c 206f 7074 696f 6e61  eal(dp), optiona
+00000f90: 6c2c 2069 6e74 656e 7428 6f75 7429 203a  l, intent(out) :
+00000fa0: 3a20 6172 6733 0a0a 2020 2020 5245 414c  : arg3..    REAL
+00000fb0: 2864 7029 203a 3a20 6f62 6a65 6374 6976  (dp) :: objectiv
+00000fc0: 650a 0a20 2020 2072 6561 6c28 6470 292c  e..    real(dp),
+00000fd0: 2064 696d 656e 7369 6f6e 2836 2920 3a3a   dimension(6) ::
+00000fe0: 206d 756c 7469 706c 655f 6f62 6a65 6374   multiple_object
+00000ff0: 6976 650a 0a0a 2020 2020 6966 2028 7072  ive...    if (pr
+00001000: 6573 656e 7428 6172 6731 2920 2e6f 722e  esent(arg1) .or.
+00001010: 2070 7265 7365 6e74 2861 7267 3229 202e   present(arg2) .
+00001020: 6f72 2e20 7072 6573 656e 7428 6172 6733  or. present(arg3
+00001030: 2929 2074 6865 6e0a 2020 2020 2020 6361  )) then.      ca
+00001040: 6c6c 2065 7272 6f72 5f6d 6573 7361 6765  ll error_message
+00001050: 2822 4572 726f 7220 6d6f 5f6f 626a 6563  ("Error mo_objec
+00001060: 7469 7665 5f66 756e 6374 696f 6e3a 2052  tive_function: R
+00001070: 6563 6569 7665 6420 756e 6578 7065 6374  eceived unexpect
+00001080: 6564 2061 7267 756d 656e 742c 2063 6865  ed argument, che
+00001090: 636b 206f 7074 696d 697a 6174 696f 6e20  ck optimization 
+000010a0: 7365 7474 696e 6773 2229 0a20 2020 2065  settings").    e
+000010b0: 6e64 2069 660a 0a20 2020 2021 2073 6574  nd if..    ! set
+000010c0: 2074 6865 7365 2074 6f20 6e61 6e20 736f   these to nan so
+000010d0: 2063 6f6d 7069 6c65 7220 646f 6573 206e   compiler does n
+000010e0: 6f74 2063 6f6d 706c 6169 6e0a 2020 2020  ot complain.    
+000010f0: 6966 2028 7072 6573 656e 7428 6172 6732  if (present(arg2
+00001100: 2929 2074 6865 6e0a 2020 2020 2020 6172  )) then.      ar
+00001110: 6732 203d 206e 6f64 6174 615f 6470 0a20  g2 = nodata_dp. 
+00001120: 2020 2065 6e64 2069 660a 2020 2020 6966     end if.    if
+00001130: 2028 7072 6573 656e 7428 6172 6733 2929   (present(arg3))
+00001140: 2074 6865 6e0a 2020 2020 2020 6172 6733   then.      arg3
+00001150: 203d 206e 6f64 6174 615f 6470 0a20 2020   = nodata_dp.   
+00001160: 2065 6e64 2069 660a 0a20 2020 2073 656c   end if..    sel
+00001170: 6563 7420 6361 7365 2028 6f70 7469 5f66  ect case (opti_f
+00001180: 756e 6374 696f 6e29 0a20 2020 2063 6173  unction).    cas
+00001190: 6520 2831 3029 0a20 2020 2020 2021 204b  e (10).      ! K
+000011a0: 4745 206f 6620 6361 7463 686d 656e 7420  GE of catchment 
+000011b0: 6176 6572 6167 6520 534d 0a20 2020 2020  average SM.     
+000011c0: 206f 626a 6563 7469 7665 203d 206f 626a   objective = obj
+000011d0: 6563 7469 7665 5f73 6d5f 6b67 655f 6361  ective_sm_kge_ca
+000011e0: 7463 686d 656e 745f 6176 6728 7061 7261  tchment_avg(para
+000011f0: 6d65 7465 7273 6574 2c20 6576 616c 290a  meterset, eval).
+00001200: 2020 2020 6361 7365 2028 3131 290a 2020      case (11).  
+00001210: 2020 2020 2120 7061 7474 6572 6e20 6469      ! pattern di
+00001220: 7373 696d 696c 6172 6974 7920 2850 4429  ssimilarity (PD)
+00001230: 206f 6620 534d 2066 6965 6c64 730a 2020   of SM fields.  
+00001240: 2020 2020 6f62 6a65 6374 6976 6520 3d20      objective = 
+00001250: 6f62 6a65 6374 6976 655f 736d 5f70 6428  objective_sm_pd(
+00001260: 7061 7261 6d65 7465 7273 6574 2c20 6576  parameterset, ev
+00001270: 616c 290a 2020 2020 6361 7365 2028 3132  al).    case (12
+00001280: 290a 2020 2020 2020 2120 7375 6d20 6f66  ).      ! sum of
+00001290: 2073 7175 6172 6564 2065 7272 6f72 7320   squared errors 
+000012a0: 6f66 2073 7461 6e64 6172 645f 7363 6f72  of standard_scor
+000012b0: 6520 534d 0a20 2020 2020 206f 626a 6563  e SM.      objec
+000012c0: 7469 7665 203d 206f 626a 6563 7469 7665  tive = objective
+000012d0: 5f73 6d5f 7373 655f 7374 616e 6461 7264  _sm_sse_standard
+000012e0: 5f73 636f 7265 2870 6172 616d 6574 6572  _score(parameter
+000012f0: 7365 742c 2065 7661 6c29 0a20 2020 2063  set, eval).    c
+00001300: 6173 6520 2831 3329 0a20 2020 2020 2021  ase (13).      !
+00001310: 2073 6f69 6c20 6d6f 6973 7475 7265 2063   soil moisture c
+00001320: 6f72 7265 6c61 7469 6f6e 202d 2074 656d  orrelation - tem
+00001330: 706f 7261 6c0a 2020 2020 2020 6f62 6a65  poral.      obje
+00001340: 6374 6976 6520 3d20 6f62 6a65 6374 6976  ctive = objectiv
+00001350: 655f 736d 5f63 6f72 7228 7061 7261 6d65  e_sm_corr(parame
+00001360: 7465 7273 6574 2c20 6576 616c 290a 2020  terset, eval).  
+00001370: 2020 6361 7365 2028 3135 290a 2020 2020    case (15).    
+00001380: 2020 2120 4b47 4520 666f 7220 5120 2a20    ! KGE for Q * 
+00001390: 524d 5345 2066 6f72 2064 6f6d 6169 6e5f  RMSE for domain_
+000013a0: 6176 6720 5457 5320 2873 7461 6e64 6172  avg TWS (standar
+000013b0: 697a 6564 2073 636f 7265 6429 0a20 2020  ized scored).   
+000013c0: 2020 206f 626a 6563 7469 7665 203d 206f     objective = o
+000013d0: 626a 6563 7469 7665 5f6b 6765 5f71 5f72  bjective_kge_q_r
+000013e0: 6d73 655f 7477 7328 7061 7261 6d65 7465  mse_tws(paramete
+000013f0: 7273 6574 2c20 6576 616c 290a 2020 2020  rset, eval).    
+00001400: 6361 7365 2028 3137 290a 2020 2020 2020  case (17).      
+00001410: 2120 4b47 4520 6f66 2063 6174 6368 6d65  ! KGE of catchme
+00001420: 6e74 2061 7665 7261 6765 2053 4d0a 2020  nt average SM.  
+00001430: 2020 2020 6f62 6a65 6374 6976 6520 3d20      objective = 
+00001440: 6f62 6a65 6374 6976 655f 6e65 7574 726f  objective_neutro
+00001450: 6e73 5f6b 6765 5f63 6174 6368 6d65 6e74  ns_kge_catchment
+00001460: 5f61 7667 2870 6172 616d 6574 6572 7365  _avg(parameterse
+00001470: 742c 2065 7661 6c29 0a20 2020 2063 6173  t, eval).    cas
+00001480: 6520 2832 3729 0a20 2020 2020 2021 204b  e (27).      ! K
+00001490: 4745 206f 6620 6361 7463 686d 656e 7420  GE of catchment 
+000014a0: 6176 6572 6167 6520 4554 0a20 2020 2020  average ET.     
+000014b0: 206f 626a 6563 7469 7665 203d 206f 626a   objective = obj
+000014c0: 6563 7469 7665 5f65 745f 6b67 655f 6361  ective_et_kge_ca
+000014d0: 7463 686d 656e 745f 6176 6728 7061 7261  tchment_avg(para
+000014e0: 6d65 7465 7273 6574 2c20 6576 616c 290a  meterset, eval).
+000014f0: 2020 2020 6361 7365 2028 3238 290a 2020      case (28).  
+00001500: 2020 2020 2120 204b 4745 2066 6f72 2051      !  KGE for Q
+00001510: 202b 2053 5345 2066 6f72 2053 4d20 2873   + SSE for SM (s
+00001520: 7461 6e64 6172 697a 6564 2073 636f 7265  tandarized score
+00001530: 6429 0a20 2020 2020 206f 626a 6563 7469  d).      objecti
+00001540: 7665 203d 206f 626a 6563 7469 7665 5f6b  ve = objective_k
+00001550: 6765 5f71 5f73 6d5f 636f 7272 2870 6172  ge_q_sm_corr(par
+00001560: 616d 6574 6572 7365 742c 2065 7661 6c29  ameterset, eval)
+00001570: 0a20 2020 2063 6173 6520 2832 3929 0a20  .    case (29). 
+00001580: 2020 2020 2021 2020 4b47 4520 666f 7220       !  KGE for 
+00001590: 5120 2b20 4b47 4520 6f66 2063 6174 6368  Q + KGE of catch
+000015a0: 6d65 6e74 2061 7665 7261 6765 2045 540a  ment average ET.
+000015b0: 2020 2020 2020 6f62 6a65 6374 6976 6520        objective 
+000015c0: 3d20 6f62 6a65 6374 6976 655f 6b67 655f  = objective_kge_
+000015d0: 715f 6574 2870 6172 616d 6574 6572 7365  q_et(parameterse
+000015e0: 742c 2065 7661 6c29 0a20 2020 2063 6173  t, eval).    cas
+000015f0: 6520 2833 3029 0a20 2020 2020 2021 204b  e (30).      ! K
+00001600: 4745 2066 6f72 2051 202a 2052 4d53 4520  GE for Q * RMSE 
+00001610: 666f 7220 646f 6d61 696e 5f61 7667 2045  for domain_avg E
+00001620: 5420 2873 7461 6e64 6172 697a 6564 2073  T (standarized s
+00001630: 636f 7265 6429 0a20 2020 2020 206f 626a  cored).      obj
+00001640: 6563 7469 7665 203d 206f 626a 6563 7469  ective = objecti
+00001650: 7665 5f6b 6765 5f71 5f72 6d73 655f 6574  ve_kge_q_rmse_et
+00001660: 2870 6172 616d 6574 6572 7365 742c 2065  (parameterset, e
+00001670: 7661 6c29 0a20 2020 2063 6173 6520 2833  val).    case (3
+00001680: 3329 0a20 2020 2020 206d 756c 7469 706c  3).      multipl
+00001690: 655f 6f62 6a65 6374 6976 6520 3d20 6f62  e_objective = ob
+000016a0: 6a65 6374 6976 655f 715f 6574 5f74 7773  jective_q_et_tws
+000016b0: 5f6b 6765 5f63 6174 6368 6d65 6e74 5f61  _kge_catchment_a
+000016c0: 7667 2870 6172 616d 6574 6572 7365 742c  vg(parameterset,
+000016d0: 2065 7661 6c29 0a20 2020 2020 206f 626a   eval).      obj
+000016e0: 6563 7469 7665 203d 206d 756c 7469 706c  ective = multipl
+000016f0: 655f 6f62 6a65 6374 6976 6528 3129 0a20  e_objective(1). 
+00001700: 2020 2063 6173 6520 2833 3429 0a20 2020     case (34).   
+00001710: 2020 2021 204b 4745 2066 6f72 2051 202a     ! KGE for Q *
+00001720: 2041 6273 6f6c 7574 652d 4572 726f 7220   Absolute-Error 
+00001730: 666f 7220 4246 490a 2020 2020 2020 6f62  for BFI.      ob
+00001740: 6a65 6374 6976 6520 3d20 6f62 6a65 6374  jective = object
+00001750: 6976 655f 6b67 655f 715f 4246 4928 7061  ive_kge_q_BFI(pa
+00001760: 7261 6d65 7465 7273 6574 2c20 6576 616c  rameterset, eval
+00001770: 290a 0a20 2020 2063 6173 6520 6465 6661  )..    case defa
+00001780: 756c 740a 2020 2020 2020 6361 6c6c 2065  ult.      call e
+00001790: 7272 6f72 5f6d 6573 7361 6765 2822 4572  rror_message("Er
+000017a0: 726f 7220 6f62 6a65 6374 6976 653a 206f  ror objective: o
+000017b0: 7074 695f 6675 6e63 7469 6f6e 206e 6f74  pti_function not
+000017c0: 2069 6d70 6c65 6d65 6e74 6564 2079 6574   implemented yet
+000017d0: 2e22 290a 2020 2020 656e 6420 7365 6c65  .").    end sele
+000017e0: 6374 0a0a 2020 454e 4420 4655 4e43 5449  ct..  END FUNCTI
+000017f0: 4f4e 206f 626a 6563 7469 7665 0a0a 2020  ON objective..  
+00001800: 2120 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ! --------------
+00001810: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00001820: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00001830: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00001840: 2d2d 2d2d 0a0a 2020 2120 2020 204e 414d  ----..  !    NAM
+00001850: 450a 2020 2120 2020 2020 2020 206f 626a  E.  !        obj
+00001860: 6563 7469 7665 5f6d 6173 7465 720a 0a20  ective_master.. 
+00001870: 2021 2020 2020 5055 5250 4f53 450a 2020   !    PURPOSE.  
+00001880: 213e 2020 2020 2020 205c 6272 6965 6620  !>       \brief 
+00001890: 5772 6170 7065 7220 666f 7220 6f62 6a65  Wrapper for obje
+000018a0: 6374 6976 6520 6675 6e63 7469 6f6e 732e  ctive functions.
+000018b0: 0a0a 2020 213e 2020 2020 2020 205c 6465  ..  !>       \de
+000018c0: 7461 696c 7320 5468 6520 6675 6e63 7469  tails The functi
+000018d0: 6f6e 7320 7365 6e64 7320 7468 6520 7061  ons sends the pa
+000018e0: 7261 6d65 7465 7273 6574 2074 6f20 7468  rameterset to th
+000018f0: 6520 7375 6270 726f 6365 7373 2c20 7265  e subprocess, re
+00001900: 6365 6976 6573 0a20 2021 3e20 2020 2020  ceives.  !>     
+00001910: 2020 7468 6520 7061 7274 6961 6c20 6f62    the partial ob
+00001920: 6a65 6374 6976 6520 616e 6420 6361 6c63  jective and calc
+00001930: 756c 6174 6573 2074 6865 2066 696e 616c  ulates the final
+00001940: 206f 626a 6563 7469 7665 0a20 2021 2020   objective.  !  
+00001950: 2020 494e 5445 4e54 2849 4e29 0a20 2021    INTENT(IN).  !
+00001960: 3e20 2020 2020 2020 5c70 6172 616d 5b69  >       \param[i
+00001970: 6e5d 2022 5245 414c 2864 7029 2c20 4449  n] "REAL(dp), DI
+00001980: 4d45 4e53 494f 4e28 3a29 203a 3a20 7061  MENSION(:) :: pa
+00001990: 7261 6d65 7465 7273 6574 220a 2020 213e  rameterset".  !>
+000019a0: 2020 2020 2020 205c 7061 7261 6d5b 696e         \param[in
+000019b0: 5d20 2270 726f 6365 6475 7265 2865 7661  ] "procedure(eva
+000019c0: 6c5f 696e 7465 7266 6163 6529 203a 3a20  l_interface) :: 
+000019d0: 6576 616c 220a 0a20 2021 2020 2020 494e  eval"..  !    IN
+000019e0: 5445 4e54 2849 4e29 2c20 4f50 5449 4f4e  TENT(IN), OPTION
+000019f0: 414c 0a20 2021 3e20 2020 2020 2020 5c70  AL.  !>       \p
+00001a00: 6172 616d 5b69 6e5d 2022 7265 616c 2864  aram[in] "real(d
+00001a10: 7029 2c20 6f70 7469 6f6e 616c 203a 3a20  p), optional :: 
+00001a20: 6172 6731 220a 0a20 2021 2020 2020 494e  arg1"..  !    IN
+00001a30: 5445 4e54 284f 5554 292c 204f 5054 494f  TENT(OUT), OPTIO
+00001a40: 4e41 4c0a 2020 213e 2020 2020 2020 205c  NAL.  !>       \
+00001a50: 7061 7261 6d5b 6f75 745d 2022 7265 616c  param[out] "real
+00001a60: 2864 7029 2c20 6f70 7469 6f6e 616c 203a  (dp), optional :
+00001a70: 3a20 6172 6732 220a 2020 213e 2020 2020  : arg2".  !>    
+00001a80: 2020 205c 7061 7261 6d5b 6f75 745d 2022     \param[out] "
+00001a90: 7265 616c 2864 7029 2c20 6f70 7469 6f6e  real(dp), option
+00001aa0: 616c 203a 3a20 6172 6733 220a 0a20 2021  al :: arg3"..  !
+00001ab0: 2020 2020 5245 5455 524e 0a20 2021 3e20      RETURN.  !> 
+00001ac0: 2020 2020 2020 5c72 6574 7572 6e20 7265        \return re
+00001ad0: 616c 2864 7029 203a 3a20 6f62 6a65 6374  al(dp) :: object
+00001ae0: 6976 6520 266d 6461 7368 3b20 6f62 6a65  ive &mdash; obje
+00001af0: 6374 6976 6520 6675 6e63 7469 6f6e 2076  ctive function v
+00001b00: 616c 7565 0a20 2021 3e20 2020 2020 2020  alue.  !>       
+00001b10: 2877 6869 6368 2077 696c 6c20 6265 2065  (which will be e
+00001b20: 2e67 2e20 6d69 6e69 6d69 7a65 6420 6279  .g. minimized by
+00001b30: 2061 6e20 6f70 7469 6d69 7a61 7469 6f6e   an optimization
+00001b40: 2072 6f75 7469 6e65 206c 696b 6520 4444   routine like DD
+00001b50: 5329 0a0a 2020 2120 2020 2048 4953 544f  S)..  !    HISTO
+00001b60: 5259 0a20 2021 3e20 2020 2020 2020 5c61  RY.  !>       \a
+00001b70: 7574 686f 7273 204a 756c 6961 6e65 204d  uthors Juliane M
+00001b80: 6169 0a0a 2020 213e 2020 2020 2020 205c  ai..  !>       \
+00001b90: 6461 7465 2044 6563 2032 3031 320a 0a20  date Dec 2012.. 
+00001ba0: 2021 204d 6f64 6966 6963 6174 696f 6e73   ! Modifications
+00001bb0: 3a0a 2020 2120 5374 6570 6861 6e20 5468  :.  ! Stephan Th
+00001bc0: 6f62 6572 204f 6374 2032 3031 3520 2d20  ober Oct 2015 - 
+00001bd0: 6d6f 7665 6420 616c 6c20 7275 6e6f 6666  moved all runoff
+00001be0: 2072 656c 6174 6564 206f 626a 6563 7469   related objecti
+00001bf0: 7665 2066 756e 6374 696f 6e73 2074 6f20  ve functions to 
+00001c00: 6d52 4d0a 2020 2120 526f 6265 7274 2053  mRM.  ! Robert S
+00001c10: 6368 7765 7070 6520 4a75 6e20 3230 3138  chweppe Jun 2018
+00001c20: 202d 2072 6566 6163 746f 7269 6e67 2061   - refactoring a
+00001c30: 6e64 2072 6566 6f72 6d61 7474 696e 670a  nd reformatting.
+00001c40: 2020 2120 4d61 7265 6e20 4b61 6c75 7a61    ! Maren Kaluza
+00001c50: 204a 756e 2032 3031 3920 2d20 7061 7261   Jun 2019 - para
+00001c60: 6c6c 656c 2076 6572 7369 6f6e 0a0a 2369  llel version..#i
+00001c70: 6664 6566 204d 5049 0a20 2046 554e 4354  fdef MPI.  FUNCT
+00001c80: 494f 4e20 6f62 6a65 6374 6976 655f 6d61  ION objective_ma
+00001c90: 7374 6572 2870 6172 616d 6574 6572 7365  ster(parameterse
+00001ca0: 742c 2065 7661 6c2c 2061 7267 312c 2061  t, eval, arg1, a
+00001cb0: 7267 322c 2061 7267 3329 0a0a 2020 2020  rg2, arg3)..    
+00001cc0: 7573 6520 6d6f 5f63 6f6d 6d6f 6e5f 636f  use mo_common_co
+00001cd0: 6e73 7461 6e74 732c 206f 6e6c 7920 3a20  nstants, only : 
+00001ce0: 6e6f 6461 7461 5f64 700a 2020 2020 7573  nodata_dp.    us
+00001cf0: 6520 6d6f 5f63 6f6d 6d6f 6e5f 6d48 4d5f  e mo_common_mHM_
+00001d00: 6d52 4d5f 7661 7269 6162 6c65 732c 206f  mRM_variables, o
+00001d10: 6e6c 7920 3a20 6f70 7469 5f66 756e 6374  nly : opti_funct
+00001d20: 696f 6e0a 2020 2020 7573 6520 6d6f 5f63  ion.    use mo_c
+00001d30: 6f6d 6d6f 6e5f 6d70 695f 746f 6f6c 732c  ommon_mpi_tools,
+00001d40: 206f 6e6c 7920 3a20 6469 7374 7269 6275   only : distribu
+00001d50: 7465 5f70 6172 616d 6574 6572 7365 740a  te_parameterset.
+00001d60: 2020 2020 7573 6520 6d6f 5f63 6f6d 6d6f      use mo_commo
+00001d70: 6e5f 7661 7269 6162 6c65 732c 206f 6e6c  n_variables, onl
+00001d80: 7920 3a20 646f 6d61 696e 4d65 7461 0a20  y : domainMeta. 
+00001d90: 2020 2075 7365 206d 6f5f 7374 7269 6e67     use mo_string
+00001da0: 5f75 7469 6c73 2c20 6f6e 6c79 203a 206e  _utils, only : n
+00001db0: 756d 3273 7472 0a20 2020 2075 7365 206d  um2str.    use m
+00001dc0: 7069 5f66 3038 0a0a 2020 2020 696d 706c  pi_f08..    impl
+00001dd0: 6963 6974 206e 6f6e 650a 0a20 2020 2052  icit none..    R
+00001de0: 4541 4c28 6470 292c 2044 494d 454e 5349  EAL(dp), DIMENSI
+00001df0: 4f4e 283a 292c 2049 4e54 454e 5428 494e  ON(:), INTENT(IN
+00001e00: 2920 3a3a 2070 6172 616d 6574 6572 7365  ) :: parameterse
+00001e10: 740a 0a20 2020 2070 726f 6365 6475 7265  t..    procedure
+00001e20: 2865 7661 6c5f 696e 7465 7266 6163 6529  (eval_interface)
+00001e30: 2c20 494e 5445 4e54 2849 4e29 2c20 504f  , INTENT(IN), PO
+00001e40: 494e 5445 5220 3a3a 2065 7661 6c0a 0a20  INTER :: eval.. 
+00001e50: 2020 2072 6561 6c28 6470 292c 206f 7074     real(dp), opt
+00001e60: 696f 6e61 6c2c 2069 6e74 656e 7428 696e  ional, intent(in
+00001e70: 2920 3a3a 2061 7267 310a 0a20 2020 2072  ) :: arg1..    r
+00001e80: 6561 6c28 6470 292c 206f 7074 696f 6e61  eal(dp), optiona
+00001e90: 6c2c 2069 6e74 656e 7428 6f75 7429 203a  l, intent(out) :
+00001ea0: 3a20 6172 6732 0a0a 2020 2020 7265 616c  : arg2..    real
+00001eb0: 2864 7029 2c20 6f70 7469 6f6e 616c 2c20  (dp), optional, 
+00001ec0: 696e 7465 6e74 286f 7574 2920 3a3a 2061  intent(out) :: a
+00001ed0: 7267 330a 0a20 2020 2052 4541 4c28 6470  rg3..    REAL(dp
+00001ee0: 2920 3a3a 206f 626a 6563 7469 7665 5f6d  ) :: objective_m
+00001ef0: 6173 7465 720a 0a20 2020 2052 4541 4c28  aster..    REAL(
+00001f00: 6470 2920 3a3a 2070 6172 7469 616c 5f6f  dp) :: partial_o
+00001f10: 626a 6563 7469 7665 0a0a 2020 2020 7265  bjective..    re
+00001f20: 616c 2864 7029 2c20 6469 6d65 6e73 696f  al(dp), dimensio
+00001f30: 6e28 3629 203a 3a20 6d75 6c74 6970 6c65  n(6) :: multiple
+00001f40: 5f70 6172 7469 616c 5f6f 626a 6563 7469  _partial_objecti
+00001f50: 7665 0a0a 2020 2020 7265 616c 2864 7029  ve..    real(dp)
+00001f60: 2c20 6469 6d65 6e73 696f 6e28 3629 203a  , dimension(6) :
+00001f70: 3a20 6d75 6c74 6970 6c65 5f6d 6173 7465  : multiple_maste
+00001f80: 725f 6f62 6a65 6374 6976 650a 0a20 2020  r_objective..   
+00001f90: 2021 2066 6f72 2073 6978 7468 2072 6f6f   ! for sixth roo
+00001fa0: 740a 2020 2020 7265 616c 2864 7029 2c20  t.    real(dp), 
+00001fb0: 7061 7261 6d65 7465 7220 3a3a 206f 6e65  parameter :: one
+00001fc0: 7369 7874 6820 3d20 312e 305f 6470 202f  sixth = 1.0_dp /
+00001fd0: 2036 2e30 5f64 700a 0a20 2020 2069 6e74   6.0_dp..    int
+00001fe0: 6567 6572 2869 3429 203a 3a20 6970 726f  eger(i4) :: ipro
+00001ff0: 632c 206e 7072 6f63 0a0a 2020 2020 696e  c, nproc..    in
+00002000: 7465 6765 7228 6934 2920 3a3a 2069 6572  teger(i4) :: ier
+00002010: 726f 720a 0a20 2020 2074 7970 6528 4d50  ror..    type(MP
+00002020: 495f 5374 6174 7573 2920 3a3a 2073 7461  I_Status) :: sta
+00002030: 7475 730a 0a0a 2020 2020 6966 2028 7072  tus...    if (pr
+00002040: 6573 656e 7428 6172 6731 2920 2e6f 722e  esent(arg1) .or.
+00002050: 2070 7265 7365 6e74 2861 7267 3229 202e   present(arg2) .
+00002060: 6f72 2e20 7072 6573 656e 7428 6172 6733  or. present(arg3
+00002070: 2929 2074 6865 6e0a 2020 2020 2020 6361  )) then.      ca
+00002080: 6c6c 2065 7272 6f72 5f6d 6573 7361 6765  ll error_message
+00002090: 2822 4572 726f 7220 6d6f 5f6f 626a 6563  ("Error mo_objec
+000020a0: 7469 7665 5f66 756e 6374 696f 6e3a 2052  tive_function: R
+000020b0: 6563 6569 7665 6420 756e 6578 7065 6374  eceived unexpect
+000020c0: 6564 2061 7267 756d 656e 742c 2063 6865  ed argument, che
+000020d0: 636b 206f 7074 696d 697a 6174 696f 6e20  ck optimization 
+000020e0: 7365 7474 696e 6773 2229 0a20 2020 2065  settings").    e
+000020f0: 6e64 2069 660a 0a20 2020 2021 2073 6574  nd if..    ! set
+00002100: 2074 6865 7365 2074 6f20 6e61 6e20 736f   these to nan so
+00002110: 2063 6f6d 7069 6c65 7220 646f 6573 206e   compiler does n
+00002120: 6f74 2063 6f6d 706c 6169 6e0a 2020 2020  ot complain.    
+00002130: 6966 2028 7072 6573 656e 7428 6172 6732  if (present(arg2
+00002140: 2929 2074 6865 6e0a 2020 2020 2020 6172  )) then.      ar
+00002150: 6732 203d 206e 6f64 6174 615f 6470 0a20  g2 = nodata_dp. 
+00002160: 2020 2065 6e64 2069 660a 2020 2020 6966     end if.    if
+00002170: 2028 7072 6573 656e 7428 6172 6733 2929   (present(arg3))
+00002180: 2074 6865 6e0a 2020 2020 2020 6172 6733   then.      arg3
+00002190: 203d 206e 6f64 6174 615f 6470 0a20 2020   = nodata_dp.   
+000021a0: 2065 6e64 2069 660a 0a20 2020 2063 616c   end if..    cal
+000021b0: 6c20 6469 7374 7269 6275 7465 5f70 6172  l distribute_par
+000021c0: 616d 6574 6572 7365 7428 7061 7261 6d65  ameterset(parame
+000021d0: 7465 7273 6574 290a 2020 2020 7365 6c65  terset).    sele
+000021e0: 6374 2063 6173 6520 286f 7074 695f 6675  ct case (opti_fu
+000021f0: 6e63 7469 6f6e 290a 2020 2020 6361 7365  nction).    case
+00002200: 2028 3130 203a 2031 332c 2031 372c 2032   (10 : 13, 17, 2
+00002210: 3720 3a20 3239 290a 2020 2020 2020 6361  7 : 29).      ca
+00002220: 6c6c 204d 5049 5f43 6f6d 6d5f 7369 7a65  ll MPI_Comm_size
+00002230: 2864 6f6d 6169 6e4d 6574 6125 636f 6d4d  (domainMeta%comM
+00002240: 6173 7465 722c 206e 7072 6f63 2c20 6965  aster, nproc, ie
+00002250: 7272 6f72 290a 2020 2020 2020 6f62 6a65  rror).      obje
+00002260: 6374 6976 655f 6d61 7374 6572 203d 2030  ctive_master = 0
+00002270: 2e30 5f64 700a 2020 2020 2020 646f 2069  .0_dp.      do i
+00002280: 7072 6f63 203d 2031 2c20 6e70 726f 6320  proc = 1, nproc 
+00002290: 2d20 310a 2020 2020 2020 2020 6361 6c6c  - 1.        call
+000022a0: 204d 5049 5f52 6563 7628 7061 7274 6961   MPI_Recv(partia
+000022b0: 6c5f 6f62 6a65 6374 6976 652c 2031 2c20  l_objective, 1, 
+000022c0: 4d50 495f 444f 5542 4c45 5f50 5245 4349  MPI_DOUBLE_PRECI
+000022d0: 5349 4f4e 2c20 6970 726f 632c 2030 2c20  SION, iproc, 0, 
+000022e0: 646f 6d61 696e 4d65 7461 2563 6f6d 4d61  domainMeta%comMa
+000022f0: 7374 6572 2c20 7374 6174 7573 2c20 6965  ster, status, ie
+00002300: 7272 6f72 290a 2020 2020 2020 2020 6f62  rror).        ob
+00002310: 6a65 6374 6976 655f 6d61 7374 6572 203d  jective_master =
+00002320: 206f 626a 6563 7469 7665 5f6d 6173 7465   objective_maste
+00002330: 7220 2b20 7061 7274 6961 6c5f 6f62 6a65  r + partial_obje
+00002340: 6374 6976 650a 2020 2020 2020 656e 6420  ctive.      end 
+00002350: 646f 0a20 2020 2020 206f 626a 6563 7469  do.      objecti
+00002360: 7665 5f6d 6173 7465 7220 3d20 6f62 6a65  ve_master = obje
+00002370: 6374 6976 655f 6d61 7374 6572 2a2a 6f6e  ctive_master**on
+00002380: 6573 6978 7468 0a20 2020 2063 6173 6520  esixth.    case 
+00002390: 2831 3529 0a20 2020 2020 2021 204b 4745  (15).      ! KGE
+000023a0: 2066 6f72 2051 202a 2052 4d53 4520 666f   for Q * RMSE fo
+000023b0: 7220 646f 6d61 696e 5f61 7667 2054 5753  r domain_avg TWS
+000023c0: 2028 7374 616e 6461 7269 7a65 6420 7363   (standarized sc
+000023d0: 6f72 6564 290a 2020 2020 2020 6361 6c6c  ored).      call
+000023e0: 2065 7272 6f72 5f6d 6573 7361 6765 2822   error_message("
+000023f0: 6361 7365 2031 352c 206f 626a 6563 7469  case 15, objecti
+00002400: 7665 5f6b 6765 5f71 5f72 6d73 655f 7477  ve_kge_q_rmse_tw
+00002410: 7320 6e6f 7420 696d 706c 656d 656e 7465  s not implemente
+00002420: 6420 696e 2070 6172 616c 6c65 6c20 7965  d in parallel ye
+00002430: 7422 290a 2020 2020 6361 7365 2028 3330  t").    case (30
+00002440: 290a 2020 2020 2020 2120 4b47 4520 666f  ).      ! KGE fo
+00002450: 7220 5120 2a20 524d 5345 2066 6f72 2064  r Q * RMSE for d
+00002460: 6f6d 6169 6e5f 6176 6720 4554 2028 7374  omain_avg ET (st
+00002470: 616e 6461 7269 7a65 6420 7363 6f72 6564  andarized scored
+00002480: 290a 2020 2020 2020 2120 6f62 6a65 6374  ).      ! object
+00002490: 6976 655f 6d61 7374 6572 203d 206f 626a  ive_master = obj
+000024a0: 6563 7469 7665 5f6b 6765 5f71 5f72 6d73  ective_kge_q_rms
+000024b0: 655f 6574 2870 6172 616d 6574 6572 7365  e_et(parameterse
+000024c0: 742c 2065 7661 6c29 0a20 2020 2020 2063  t, eval).      c
+000024d0: 616c 6c20 6d65 7373 6167 6528 2263 6173  all message("cas
+000024e0: 6520 3330 2c20 6f62 6a65 6374 6976 655f  e 30, objective_
+000024f0: 6b67 655f 715f 726d 7365 5f65 7420 6e6f  kge_q_rmse_et no
+00002500: 7420 696d 706c 656d 656e 7465 6420 696e  t implemented in
+00002510: 2070 6172 616c 6c65 6c20 7965 7422 290a   parallel yet").
+00002520: 2020 2020 6361 7365 2833 3329 0a20 2020      case(33).   
+00002530: 2020 2063 616c 6c20 4d50 495f 436f 6d6d     call MPI_Comm
+00002540: 5f73 697a 6528 646f 6d61 696e 4d65 7461  _size(domainMeta
+00002550: 2563 6f6d 4d61 7374 6572 2c20 6e70 726f  %comMaster, npro
+00002560: 632c 2069 6572 726f 7229 0a20 2020 2020  c, ierror).     
+00002570: 206f 626a 6563 7469 7665 5f6d 6173 7465   objective_maste
+00002580: 7220 3d20 302e 305f 6470 0a20 2020 2020  r = 0.0_dp.     
+00002590: 206d 756c 7469 706c 655f 6d61 7374 6572   multiple_master
+000025a0: 5f6f 626a 6563 7469 7665 283a 2920 3d20  _objective(:) = 
+000025b0: 302e 305f 6470 0a20 2020 2020 2064 6f20  0.0_dp.      do 
+000025c0: 6970 726f 6320 3d20 312c 206e 7072 6f63  iproc = 1, nproc
+000025d0: 202d 2031 0a20 2020 2020 2020 2063 616c   - 1.        cal
+000025e0: 6c20 4d50 495f 5265 6376 286d 756c 7469  l MPI_Recv(multi
+000025f0: 706c 655f 7061 7274 6961 6c5f 6f62 6a65  ple_partial_obje
+00002600: 6374 6976 652c 2036 2c20 4d50 495f 444f  ctive, 6, MPI_DO
+00002610: 5542 4c45 5f50 5245 4349 5349 4f4e 2c20  UBLE_PRECISION, 
+00002620: 6970 726f 632c 2030 2c20 646f 6d61 696e  iproc, 0, domain
+00002630: 4d65 7461 2563 6f6d 4d61 7374 6572 2c20  Meta%comMaster, 
+00002640: 7374 6174 7573 2c20 6965 7272 6f72 290a  status, ierror).
+00002650: 2020 2020 2020 2020 6d75 6c74 6970 6c65          multiple
+00002660: 5f6d 6173 7465 725f 6f62 6a65 6374 6976  _master_objectiv
+00002670: 6520 3d20 6d75 6c74 6970 6c65 5f6d 6173  e = multiple_mas
+00002680: 7465 725f 6f62 6a65 6374 6976 6520 2b20  ter_objective + 
+00002690: 6d75 6c74 6970 6c65 5f70 6172 7469 616c  multiple_partial
+000026a0: 5f6f 626a 6563 7469 7665 0a20 2020 2020  _objective.     
+000026b0: 2065 6e64 2064 6f0a 2020 2020 2020 6f62   end do.      ob
+000026c0: 6a65 6374 6976 655f 6d61 7374 6572 203d  jective_master =
+000026d0: 206f 626a 6563 7469 7665 5f6d 6173 7465   objective_maste
+000026e0: 7220 2b20 260a 2020 2020 2020 2020 286d  r + &.        (m
+000026f0: 756c 7469 706c 655f 6d61 7374 6572 5f6f  ultiple_master_o
+00002700: 626a 6563 7469 7665 2831 292b 6d75 6c74  bjective(1)+mult
+00002710: 6970 6c65 5f6d 6173 7465 725f 6f62 6a65  iple_master_obje
+00002720: 6374 6976 6528 3229 2b6d 756c 7469 706c  ctive(2)+multipl
+00002730: 655f 6d61 7374 6572 5f6f 626a 6563 7469  e_master_objecti
+00002740: 7665 2833 2929 0a20 2020 2020 206f 626a  ve(3)).      obj
+00002750: 6563 7469 7665 5f6d 6173 7465 7220 3d20  ective_master = 
+00002760: 286f 626a 6563 7469 7665 5f6d 6173 7465  (objective_maste
+00002770: 722f 6d75 6c74 6970 6c65 5f6d 6173 7465  r/multiple_maste
+00002780: 725f 6f62 6a65 6374 6976 6528 3429 292a  r_objective(4))*
+00002790: 2a6f 6e65 7369 7874 680a 0a20 2020 2063  *onesixth..    c
+000027a0: 6173 6520 6465 6661 756c 740a 2020 2020  ase default.    
+000027b0: 2020 6361 6c6c 2065 7272 6f72 5f6d 6573    call error_mes
+000027c0: 7361 6765 2822 4572 726f 7220 6f62 6a65  sage("Error obje
+000027d0: 6374 6976 655f 6d61 7374 6572 3a20 6f70  ctive_master: op
+000027e0: 7469 5f66 756e 6374 696f 6e20 6e6f 7420  ti_function not 
+000027f0: 696d 706c 656d 656e 7465 6420 7965 742e  implemented yet.
+00002800: 2229 0a20 2020 2065 6e64 2073 656c 6563  ").    end selec
+00002810: 740a 0a20 2020 2073 656c 6563 7420 6361  t..    select ca
+00002820: 7365 2028 6f70 7469 5f66 756e 6374 696f  se (opti_functio
+00002830: 6e29 0a20 2020 2063 6173 6528 3130 290a  n).    case(10).
+00002840: 2020 2020 2020 6361 6c6c 206d 6573 7361        call messa
+00002850: 6765 2827 2020 2020 6f62 6a65 6374 6976  ge('    objectiv
+00002860: 655f 736d 5f6b 6765 5f63 6174 6368 6d65  e_sm_kge_catchme
+00002870: 6e74 5f61 7667 203d 2027 2c20 6e75 6d32  nt_avg = ', num2
+00002880: 7374 7228 6f62 6a65 6374 6976 655f 6d61  str(objective_ma
+00002890: 7374 6572 2c20 2728 4639 2e35 2927 2929  ster, '(F9.5)'))
+000028a0: 0a20 2020 2063 6173 6528 3131 290a 2020  .    case(11).  
+000028b0: 2020 2020 6361 6c6c 206d 6573 7361 6765      call message
+000028c0: 2827 2020 2020 6f62 6a65 6374 6976 655f  ('    objective_
+000028d0: 736d 5f70 6420 3d20 272c 206e 756d 3273  sm_pd = ', num2s
+000028e0: 7472 286f 626a 6563 7469 7665 5f6d 6173  tr(objective_mas
+000028f0: 7465 722c 2027 2846 392e 3529 2729 290a  ter, '(F9.5)')).
+00002900: 2020 2020 6361 7365 2831 3229 0a20 2020      case(12).   
+00002910: 2020 2063 616c 6c20 6d65 7373 6167 6528     call message(
+00002920: 2720 2020 206f 626a 6563 7469 7665 5f73  '    objective_s
+00002930: 6d5f 7373 655f 7374 616e 6461 7264 5f73  m_sse_standard_s
+00002940: 636f 7265 203d 2027 2c20 6e75 6d32 7374  core = ', num2st
+00002950: 7228 6f62 6a65 6374 6976 655f 6d61 7374  r(objective_mast
+00002960: 6572 2c20 2728 4531 322e 3529 2729 290a  er, '(E12.5)')).
+00002970: 2020 2020 6361 7365 2831 3329 0a20 2020      case(13).   
 00002980: 2020 2063 616c 6c20 6d65 7373 6167 6528     call message(
-00002990: 2720 2020 206f 626a 6563 7469 7665 5f65  '    objective_e
-000029a0: 745f 6b67 655f 6361 7463 686d 656e 745f  t_kge_catchment_
-000029b0: 6176 6720 3d20 272c 206e 756d 3273 7472  avg = ', num2str
-000029c0: 286f 626a 6563 7469 7665 5f6d 6173 7465  (objective_maste
-000029d0: 722c 2027 2846 392e 3529 2729 290a 2020  r, '(F9.5)')).  
-000029e0: 2020 6361 7365 2832 3829 0a20 2020 2020    case(28).     
-000029f0: 2063 616c 6c20 6d65 7373 6167 6528 2720   call message(' 
-00002a00: 2020 206f 626a 6563 7469 7665 5f6b 6765     objective_kge
-00002a10: 5f71 5f73 6d5f 636f 7272 203d 2027 2c20  _q_sm_corr = ', 
+00002990: 2720 2020 206f 626a 6563 7469 7665 5f73  '    objective_s
+000029a0: 6d5f 636f 7272 203d 2027 2c20 6e75 6d32  m_corr = ', num2
+000029b0: 7374 7228 6f62 6a65 6374 6976 655f 6d61  str(objective_ma
+000029c0: 7374 6572 2c20 2728 4639 2e35 2927 2929  ster, '(F9.5)'))
+000029d0: 0a20 2020 2063 6173 6528 3137 290a 2020  .    case(17).  
+000029e0: 2020 2020 6361 6c6c 206d 6573 7361 6765      call message
+000029f0: 2827 2020 2020 6f62 6a65 6374 6976 655f  ('    objective_
+00002a00: 6e65 7574 726f 6e73 5f6b 6765 5f63 6174  neutrons_kge_cat
+00002a10: 6368 6d65 6e74 5f61 7667 203d 2027 2c20  chment_avg = ', 
 00002a20: 6e75 6d32 7374 7228 6f62 6a65 6374 6976  num2str(objectiv
 00002a30: 655f 6d61 7374 6572 2c20 2728 4639 2e35  e_master, '(F9.5
-00002a40: 2927 2929 0a20 2020 2063 6173 6528 3239  )')).    case(29
+00002a40: 2927 2929 0a20 2020 2063 6173 6528 3237  )')).    case(27
 00002a50: 290a 2020 2020 2020 6361 6c6c 206d 6573  ).      call mes
 00002a60: 7361 6765 2827 2020 2020 6f62 6a65 6374  sage('    object
-00002a70: 6976 655f 6b67 655f 715f 6574 203d 2027  ive_kge_q_et = '
-00002a80: 2c20 6e75 6d32 7374 7228 6f62 6a65 6374  , num2str(object
-00002a90: 6976 655f 6d61 7374 6572 2c20 2728 4639  ive_master, '(F9
-00002aa0: 2e35 2927 2929 0a20 2020 2063 6173 6528  .5)')).    case(
-00002ab0: 3333 290a 2020 2020 2020 6361 6c6c 206d  33).      call m
-00002ac0: 6573 7361 6765 2827 2020 2020 6f62 6a65  essage('    obje
-00002ad0: 6374 6976 655f 715f 6574 5f74 7773 5f6b  ctive_q_et_tws_k
-00002ae0: 6765 5f63 6174 6368 6d65 6e74 5f61 7667  ge_catchment_avg
-00002af0: 203d 2027 2c20 6e75 6d32 7374 7228 6f62   = ', num2str(ob
-00002b00: 6a65 6374 6976 655f 6d61 7374 6572 2c20  jective_master, 
-00002b10: 2728 4639 2e35 2927 2929 0a20 2020 2063  '(F9.5)')).    c
-00002b20: 6173 6520 6465 6661 756c 740a 2020 2020  ase default.    
-00002b30: 2020 6361 6c6c 206d 6573 7361 6765 2822    call message("
-00002b40: 4572 726f 7220 6f62 6a65 6374 6976 655f  Error objective_
-00002b50: 6d61 7374 6572 3a20 6f70 7469 5f66 756e  master: opti_fun
-00002b60: 6374 696f 6e20 6e6f 7420 696d 706c 656d  ction not implem
-00002b70: 656e 7465 6420 7965 742c 2074 6869 7320  ented yet, this 
-00002b80: 7061 7274 206f 6620 7468 6520 636f 6465  part of the code
-00002b90: 2073 686f 756c 6420 6e65 7665 7220 6578   should never ex
-00002ba0: 6563 7574 652e 2229 0a20 2020 2020 2073  ecute.").      s
-00002bb0: 746f 7020 310a 2020 2020 656e 6420 7365  top 1.    end se
-00002bc0: 6c65 6374 0a0a 2020 454e 4420 4655 4e43  lect..  END FUNC
-00002bd0: 5449 4f4e 206f 626a 6563 7469 7665 5f6d  TION objective_m
-00002be0: 6173 7465 720a 0a20 2021 202d 2d2d 2d2d  aster..  ! -----
-00002bf0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00002c00: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00002c10: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00002c20: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 0a20  -------------.. 
-00002c30: 2021 2020 2020 4e41 4d45 0a20 2021 2020   !    NAME.  !  
-00002c40: 2020 2020 2020 6f62 6a65 6374 6976 655f        objective_
-00002c50: 7375 6270 726f 6365 7373 0a0a 2020 2120  subprocess..  ! 
-00002c60: 2020 2050 5552 504f 5345 0a20 2021 3e20     PURPOSE.  !> 
-00002c70: 2020 2020 2020 5c62 7269 6566 2057 7261        \brief Wra
-00002c80: 7070 6572 2066 6f72 206f 626a 6563 7469  pper for objecti
-00002c90: 7665 2066 756e 6374 696f 6e73 2e0a 0a20  ve functions... 
-00002ca0: 2021 3e20 2020 2020 2020 5c64 6574 6169   !>       \detai
-00002cb0: 6c73 2054 6865 2066 756e 6374 696f 6e20  ls The function 
-00002cc0: 7265 6365 6976 6573 2074 6865 2070 6172  receives the par
-00002cd0: 616d 6574 6572 7365 7420 6672 6f6d 2074  ameterset from t
-00002ce0: 6865 206d 6173 7465 720a 2020 213e 2020  he master.  !>  
-00002cf0: 2020 2020 2070 726f 6365 7373 2c20 7365       process, se
-00002d00: 6c65 6374 7320 7468 6520 6f62 6a65 6374  lects the object
-00002d10: 6976 6520 6675 6e63 7469 6f6e 2063 6173  ive function cas
-00002d20: 6520 6465 6669 6e65 6420 696e 2061 206e  e defined in a n
-00002d30: 616d 656c 6973 742c 0a20 2021 3e20 2020  amelist,.  !>   
-00002d40: 2020 2020 692e 652e 2074 6865 2067 6c6f      i.e. the glo
-00002d50: 6261 6c20 7661 7269 6162 6c65 205c 6520  bal variable \e 
-00002d60: 6f70 7469 5c5f 6675 6e63 7469 6f6e 2e0a  opti\_function..
-00002d70: 2020 213e 2020 2020 2020 2049 7420 7265    !>       It re
-00002d80: 7475 726e 7320 7468 6520 7061 7274 6961  turns the partia
-00002d90: 6c20 6f62 6a65 6374 6976 6520 6675 6e63  l objective func
-00002da0: 7469 6f6e 2076 616c 7565 2066 6f72 2061  tion value for a
-00002db0: 2073 7065 6369 6669 6320 7061 7261 6d65   specific parame
-00002dc0: 7465 7220 7365 742e 0a0a 2020 2120 2020  ter set...  !   
-00002dd0: 2049 4e54 454e 5428 494e 290a 2020 213e   INTENT(IN).  !>
-00002de0: 2020 2020 2020 205c 7061 7261 6d5b 696e         \param[in
-00002df0: 5d20 2252 4541 4c28 6470 292c 2044 494d  ] "REAL(dp), DIM
-00002e00: 454e 5349 4f4e 283a 2920 3a3a 2070 6172  ENSION(:) :: par
-00002e10: 616d 6574 6572 7365 7422 0a20 2021 3e20  ameterset".  !> 
-00002e20: 2020 2020 2020 5c70 6172 616d 5b69 6e5d        \param[in]
-00002e30: 2022 7072 6f63 6564 7572 6528 6576 616c   "procedure(eval
-00002e40: 5f69 6e74 6572 6661 6365 2920 3a3a 2065  _interface) :: e
-00002e50: 7661 6c22 0a0a 2020 2120 2020 2049 4e54  val"..  !    INT
-00002e60: 454e 5428 494e 292c 204f 5054 494f 4e41  ENT(IN), OPTIONA
-00002e70: 4c0a 2020 213e 2020 2020 2020 205c 7061  L.  !>       \pa
-00002e80: 7261 6d5b 696e 5d20 2272 6561 6c28 6470  ram[in] "real(dp
-00002e90: 292c 206f 7074 696f 6e61 6c20 3a3a 2061  ), optional :: a
-00002ea0: 7267 3122 0a0a 2020 2120 2020 2049 4e54  rg1"..  !    INT
-00002eb0: 454e 5428 4f55 5429 2c20 4f50 5449 4f4e  ENT(OUT), OPTION
-00002ec0: 414c 0a20 2021 3e20 2020 2020 2020 5c70  AL.  !>       \p
-00002ed0: 6172 616d 5b6f 7574 5d20 2272 6561 6c28  aram[out] "real(
-00002ee0: 6470 292c 206f 7074 696f 6e61 6c20 3a3a  dp), optional ::
-00002ef0: 2061 7267 3222 0a20 2021 3e20 2020 2020   arg2".  !>     
-00002f00: 2020 5c70 6172 616d 5b6f 7574 5d20 2272    \param[out] "r
-00002f10: 6561 6c28 6470 292c 206f 7074 696f 6e61  eal(dp), optiona
-00002f20: 6c20 3a3a 2061 7267 3322 0a0a 2020 2120  l :: arg3"..  ! 
-00002f30: 2020 2052 4554 5552 4e0a 2020 213e 2020     RETURN.  !>  
-00002f40: 2020 2020 205c 7265 7475 726e 2072 6561       \return rea
-00002f50: 6c28 6470 2920 3a3a 206f 626a 6563 7469  l(dp) :: objecti
-00002f60: 7665 2026 6d64 6173 683b 206f 626a 6563  ve &mdash; objec
-00002f70: 7469 7665 2066 756e 6374 696f 6e20 7661  tive function va
-00002f80: 6c75 650a 2020 213e 2020 2020 2020 2028  lue.  !>       (
-00002f90: 7768 6963 6820 7769 6c6c 2062 6520 652e  which will be e.
-00002fa0: 672e 206d 696e 696d 697a 6564 2062 7920  g. minimized by 
-00002fb0: 616e 206f 7074 696d 697a 6174 696f 6e20  an optimization 
-00002fc0: 726f 7574 696e 6520 6c69 6b65 2044 4453  routine like DDS
-00002fd0: 290a 0a20 2021 2020 2020 4849 5354 4f52  )..  !    HISTOR
-00002fe0: 590a 2020 213e 2020 2020 2020 205c 6175  Y.  !>       \au
-00002ff0: 7468 6f72 7320 4a75 6c69 616e 6520 4d61  thors Juliane Ma
-00003000: 690a 0a20 2021 3e20 2020 2020 2020 5c64  i..  !>       \d
-00003010: 6174 6520 4465 6320 3230 3132 0a0a 2020  ate Dec 2012..  
-00003020: 2120 4d6f 6469 6669 6361 7469 6f6e 733a  ! Modifications:
-00003030: 0a20 2021 2053 7465 7068 616e 2054 686f  .  ! Stephan Tho
-00003040: 6265 7220 4f63 7420 3230 3135 202d 206d  ber Oct 2015 - m
-00003050: 6f76 6564 2061 6c6c 2072 756e 6f66 6620  oved all runoff 
-00003060: 7265 6c61 7465 6420 6f62 6a65 6374 6976  related objectiv
-00003070: 6520 6675 6e63 7469 6f6e 7320 746f 206d  e functions to m
-00003080: 524d 0a20 2021 2052 6f62 6572 7420 5363  RM.  ! Robert Sc
-00003090: 6877 6570 7065 204a 756e 2032 3031 3820  hweppe Jun 2018 
-000030a0: 2d20 7265 6661 6374 6f72 696e 6720 616e  - refactoring an
-000030b0: 6420 7265 666f 726d 6174 7469 6e67 0a20  d reformatting. 
-000030c0: 2021 204d 6172 656e 204b 616c 757a 6120   ! Maren Kaluza 
-000030d0: 4a75 6e20 3230 3139 202d 2070 6172 616c  Jun 2019 - paral
-000030e0: 6c65 6c20 7665 7273 696f 6e0a 0a20 2073  lel version..  s
-000030f0: 7562 726f 7574 696e 6520 6f62 6a65 6374  ubroutine object
-00003100: 6976 655f 7375 6270 726f 6365 7373 2865  ive_subprocess(e
-00003110: 7661 6c2c 2061 7267 312c 2061 7267 322c  val, arg1, arg2,
-00003120: 2061 7267 3329 0a0a 2020 2020 7573 6520   arg3)..    use 
-00003130: 6d6f 5f63 6f6d 6d6f 6e5f 636f 6e73 7461  mo_common_consta
-00003140: 6e74 732c 206f 6e6c 7920 3a20 6e6f 6461  nts, only : noda
-00003150: 7461 5f64 700a 2020 2020 7573 6520 6d6f  ta_dp.    use mo
-00003160: 5f63 6f6d 6d6f 6e5f 6d48 4d5f 6d52 4d5f  _common_mHM_mRM_
-00003170: 7661 7269 6162 6c65 732c 206f 6e6c 7920  variables, only 
-00003180: 3a20 6f70 7469 5f66 756e 6374 696f 6e0a  : opti_function.
-00003190: 2020 2020 7573 6520 6d6f 5f63 6f6d 6d6f      use mo_commo
-000031a0: 6e5f 6d70 695f 746f 6f6c 732c 206f 6e6c  n_mpi_tools, onl
-000031b0: 7920 3a20 6765 745f 7061 7261 6d65 7465  y : get_paramete
-000031c0: 7273 6574 0a20 2020 2075 7365 206d 6f5f  rset.    use mo_
-000031d0: 636f 6d6d 6f6e 5f76 6172 6961 626c 6573  common_variables
-000031e0: 2c20 6f6e 6c79 203a 2064 6f6d 6169 6e4d  , only : domainM
-000031f0: 6574 610a 2020 2020 7573 6520 6d6f 5f6d  eta.    use mo_m
-00003200: 6573 7361 6765 2c20 6f6e 6c79 203a 206d  essage, only : m
-00003210: 6573 7361 6765 0a20 2020 2075 7365 206d  essage.    use m
-00003220: 7069 5f66 3038 0a0a 2020 2020 696d 706c  pi_f08..    impl
-00003230: 6963 6974 206e 6f6e 650a 0a20 2020 2070  icit none..    p
-00003240: 726f 6365 6475 7265 2865 7661 6c5f 696e  rocedure(eval_in
-00003250: 7465 7266 6163 6529 2c20 494e 5445 4e54  terface), INTENT
-00003260: 2849 4e29 2c20 504f 494e 5445 5220 3a3a  (IN), POINTER ::
-00003270: 2065 7661 6c0a 0a20 2020 2072 6561 6c28   eval..    real(
-00003280: 6470 292c 206f 7074 696f 6e61 6c2c 2069  dp), optional, i
-00003290: 6e74 656e 7428 696e 2920 3a3a 2061 7267  ntent(in) :: arg
-000032a0: 310a 0a20 2020 2072 6561 6c28 6470 292c  1..    real(dp),
-000032b0: 206f 7074 696f 6e61 6c2c 2069 6e74 656e   optional, inten
-000032c0: 7428 6f75 7429 203a 3a20 6172 6732 0a0a  t(out) :: arg2..
-000032d0: 2020 2020 7265 616c 2864 7029 2c20 6f70      real(dp), op
-000032e0: 7469 6f6e 616c 2c20 696e 7465 6e74 286f  tional, intent(o
-000032f0: 7574 2920 3a3a 2061 7267 330a 0a20 2020  ut) :: arg3..   
-00003300: 2052 4541 4c28 6470 2920 3a3a 2070 6172   REAL(dp) :: par
-00003310: 7469 616c 5f6f 626a 6563 7469 7665 0a0a  tial_objective..
-00003320: 2020 2020 7265 616c 2864 7029 2c20 6469      real(dp), di
-00003330: 6d65 6e73 696f 6e28 3629 203a 3a20 6d75  mension(6) :: mu
-00003340: 6c74 6970 6c65 5f70 6172 7469 616c 5f6f  ltiple_partial_o
-00003350: 626a 6563 7469 7665 0a0a 2020 2020 5245  bjective..    RE
-00003360: 414c 2864 7029 2c20 4449 4d45 4e53 494f  AL(dp), DIMENSIO
-00003370: 4e28 3a29 2c20 616c 6c6f 6361 7461 626c  N(:), allocatabl
-00003380: 6520 3a3a 2070 6172 616d 6574 6572 7365  e :: parameterse
-00003390: 740a 0a20 2020 2069 6e74 6567 6572 2869  t..    integer(i
-000033a0: 3429 203a 3a20 6965 7272 6f72 0a0a 2020  4) :: ierror..  
-000033b0: 2020 7479 7065 284d 5049 5f53 7461 7475    type(MPI_Statu
-000033c0: 7329 203a 3a20 7374 6174 7573 0a0a 2020  s) :: status..  
-000033d0: 2020 6c6f 6769 6361 6c20 3a3a 2064 6f5f    logical :: do_
-000033e0: 6f62 6a5f 6c6f 6f70 0a0a 2020 2020 646f  obj_loop..    do
-000033f0: 2021 2061 2064 6f20 6c6f 6f70 2077 6974   ! a do loop wit
-00003400: 686f 7574 2063 6f6e 6469 7469 6f6e 2072  hout condition r
-00003410: 756e 7320 756e 7469 6c20 6578 6974 0a20  uns until exit. 
-00003420: 2020 2020 2063 616c 6c20 4d50 495f 5265       call MPI_Re
-00003430: 6376 2864 6f5f 6f62 6a5f 6c6f 6f70 2c20  cv(do_obj_loop, 
-00003440: 312c 204d 5049 5f4c 4f47 4943 414c 2c20  1, MPI_LOGICAL, 
-00003450: 302c 2030 2c20 646f 6d61 696e 4d65 7461  0, 0, domainMeta
-00003460: 2563 6f6d 4d61 7374 6572 2c20 7374 6174  %comMaster, stat
-00003470: 7573 2c20 6965 7272 6f72 290a 0a20 2020  us, ierror)..   
-00003480: 2020 2069 6620 282e 6e6f 742e 2064 6f5f     if (.not. do_
-00003490: 6f62 6a5f 6c6f 6f70 2920 6578 6974 0a0a  obj_loop) exit..
-000034a0: 2020 2020 2020 6966 2028 7072 6573 656e        if (presen
-000034b0: 7428 6172 6731 2920 2e6f 722e 2070 7265  t(arg1) .or. pre
-000034c0: 7365 6e74 2861 7267 3229 202e 6f72 2e20  sent(arg2) .or. 
-000034d0: 7072 6573 656e 7428 6172 6733 2929 2074  present(arg3)) t
-000034e0: 6865 6e0a 2020 2020 2020 2020 6361 6c6c  hen.        call
-000034f0: 206d 6573 7361 6765 2822 4572 726f 7220   message("Error 
-00003500: 6d6f 5f6f 626a 6563 7469 7665 5f66 756e  mo_objective_fun
-00003510: 6374 696f 6e3a 2052 6563 6569 7665 6420  ction: Received 
-00003520: 756e 6578 7065 6374 6564 2061 7267 756d  unexpected argum
-00003530: 656e 742c 2063 6865 636b 206f 7074 696d  ent, check optim
-00003540: 697a 6174 696f 6e20 7365 7474 696e 6773  ization settings
-00003550: 2229 0a20 2020 2020 2020 2073 746f 7020  ").        stop 
-00003560: 310a 2020 2020 2020 656e 6420 6966 0a0a  1.      end if..
-00003570: 2020 2020 2020 2120 7365 7420 7468 6573        ! set thes
-00003580: 6520 746f 206e 616e 2073 6f20 636f 6d70  e to nan so comp
-00003590: 696c 6572 2064 6f65 7320 6e6f 7420 636f  iler does not co
-000035a0: 6d70 6c61 696e 0a20 2020 2020 2069 6620  mplain.      if 
-000035b0: 2870 7265 7365 6e74 2861 7267 3229 2920  (present(arg2)) 
-000035c0: 7468 656e 0a20 2020 2020 2020 2061 7267  then.        arg
-000035d0: 3220 3d20 6e6f 6461 7461 5f64 700a 2020  2 = nodata_dp.  
-000035e0: 2020 2020 656e 6420 6966 0a20 2020 2020      end if.     
-000035f0: 2069 6620 2870 7265 7365 6e74 2861 7267   if (present(arg
-00003600: 3329 2920 7468 656e 0a20 2020 2020 2020  3)) then.       
-00003610: 2061 7267 3320 3d20 6e6f 6461 7461 5f64   arg3 = nodata_d
-00003620: 700a 2020 2020 2020 656e 6420 6966 0a20  p.      end if. 
-00003630: 2020 2020 2063 616c 6c20 6765 745f 7061       call get_pa
-00003640: 7261 6d65 7465 7273 6574 2870 6172 616d  rameterset(param
-00003650: 6574 6572 7365 7429 0a20 2020 2020 2073  eterset).      s
-00003660: 656c 6563 7420 6361 7365 2028 6f70 7469  elect case (opti
-00003670: 5f66 756e 6374 696f 6e29 0a20 2020 2020  _function).     
-00003680: 2063 6173 6520 2831 3029 0a20 2020 2020   case (10).     
-00003690: 2020 2021 204b 4745 206f 6620 6361 7463     ! KGE of catc
-000036a0: 686d 656e 7420 6176 6572 6167 6520 534d  hment average SM
-000036b0: 0a20 2020 2020 2020 2070 6172 7469 616c  .        partial
-000036c0: 5f6f 626a 6563 7469 7665 203d 206f 626a  _objective = obj
-000036d0: 6563 7469 7665 5f73 6d5f 6b67 655f 6361  ective_sm_kge_ca
-000036e0: 7463 686d 656e 745f 6176 6728 7061 7261  tchment_avg(para
-000036f0: 6d65 7465 7273 6574 2c20 6576 616c 290a  meterset, eval).
-00003700: 2020 2020 2020 6361 7365 2028 3131 290a        case (11).
-00003710: 2020 2020 2020 2020 2120 7061 7474 6572          ! patter
-00003720: 6e20 6469 7373 696d 696c 6172 6974 7920  n dissimilarity 
-00003730: 2850 4429 206f 6620 534d 2066 6965 6c64  (PD) of SM field
-00003740: 730a 2020 2020 2020 2020 7061 7274 6961  s.        partia
-00003750: 6c5f 6f62 6a65 6374 6976 6520 3d20 6f62  l_objective = ob
-00003760: 6a65 6374 6976 655f 736d 5f70 6428 7061  jective_sm_pd(pa
-00003770: 7261 6d65 7465 7273 6574 2c20 6576 616c  rameterset, eval
-00003780: 290a 2020 2020 2020 6361 7365 2028 3132  ).      case (12
-00003790: 290a 2020 2020 2020 2020 2120 7375 6d20  ).        ! sum 
-000037a0: 6f66 2073 7175 6172 6564 2065 7272 6f72  of squared error
-000037b0: 7320 6f66 2073 7461 6e64 6172 645f 7363  s of standard_sc
-000037c0: 6f72 6520 534d 0a20 2020 2020 2020 2070  ore SM.        p
-000037d0: 6172 7469 616c 5f6f 626a 6563 7469 7665  artial_objective
-000037e0: 203d 206f 626a 6563 7469 7665 5f73 6d5f   = objective_sm_
-000037f0: 7373 655f 7374 616e 6461 7264 5f73 636f  sse_standard_sco
-00003800: 7265 2870 6172 616d 6574 6572 7365 742c  re(parameterset,
-00003810: 2065 7661 6c29 0a20 2020 2020 2063 6173   eval).      cas
-00003820: 6520 2831 3329 0a20 2020 2020 2020 2021  e (13).        !
-00003830: 2073 6f69 6c20 6d6f 6973 7475 7265 2063   soil moisture c
-00003840: 6f72 7265 6c61 7469 6f6e 202d 2074 656d  orrelation - tem
-00003850: 706f 7261 6c0a 2020 2020 2020 2020 7061  poral.        pa
-00003860: 7274 6961 6c5f 6f62 6a65 6374 6976 6520  rtial_objective 
-00003870: 3d20 6f62 6a65 6374 6976 655f 736d 5f63  = objective_sm_c
-00003880: 6f72 7228 7061 7261 6d65 7465 7273 6574  orr(parameterset
-00003890: 2c20 6576 616c 290a 2020 2020 2020 6361  , eval).      ca
-000038a0: 7365 2028 3135 290a 2020 2020 2020 2020  se (15).        
-000038b0: 2120 4b47 4520 666f 7220 5120 2a20 524d  ! KGE for Q * RM
-000038c0: 5345 2066 6f72 2064 6f6d 6169 6e5f 6176  SE for domain_av
-000038d0: 6720 5457 5320 2873 7461 6e64 6172 697a  g TWS (standariz
-000038e0: 6564 2073 636f 7265 6429 0a20 2020 2020  ed scored).     
-000038f0: 2020 2021 2070 6172 7469 616c 5f6f 626a     ! partial_obj
-00003900: 6563 7469 7665 203d 206f 626a 6563 7469  ective = objecti
-00003910: 7665 5f6b 6765 5f71 5f72 6d73 655f 7477  ve_kge_q_rmse_tw
-00003920: 7328 7061 7261 6d65 7465 7273 6574 2c20  s(parameterset, 
-00003930: 6576 616c 290a 2020 2020 2020 2020 7374  eval).        st
-00003940: 6f70 0a20 2020 2020 2063 6173 6520 2831  op.      case (1
-00003950: 3729 0a20 2020 2020 2020 2021 204b 4745  7).        ! KGE
-00003960: 206f 6620 6361 7463 686d 656e 7420 6176   of catchment av
-00003970: 6572 6167 6520 534d 0a20 2020 2020 2020  erage SM.       
-00003980: 2070 6172 7469 616c 5f6f 626a 6563 7469   partial_objecti
-00003990: 7665 203d 206f 626a 6563 7469 7665 5f6e  ve = objective_n
-000039a0: 6575 7472 6f6e 735f 6b67 655f 6361 7463  eutrons_kge_catc
-000039b0: 686d 656e 745f 6176 6728 7061 7261 6d65  hment_avg(parame
-000039c0: 7465 7273 6574 2c20 6576 616c 290a 2020  terset, eval).  
-000039d0: 2020 2020 6361 7365 2028 3237 290a 2020      case (27).  
-000039e0: 2020 2020 2020 2120 4b47 4520 6f66 2063        ! KGE of c
-000039f0: 6174 6368 6d65 6e74 2061 7665 7261 6765  atchment average
-00003a00: 2045 540a 2020 2020 2020 2020 7061 7274   ET.        part
-00003a10: 6961 6c5f 6f62 6a65 6374 6976 6520 3d20  ial_objective = 
-00003a20: 6f62 6a65 6374 6976 655f 6574 5f6b 6765  objective_et_kge
-00003a30: 5f63 6174 6368 6d65 6e74 5f61 7667 2870  _catchment_avg(p
-00003a40: 6172 616d 6574 6572 7365 742c 2065 7661  arameterset, eva
-00003a50: 6c29 0a20 2020 2020 2063 6173 6520 2832  l).      case (2
-00003a60: 3829 0a20 2020 2020 2020 2021 2020 4b47  8).        !  KG
-00003a70: 4520 666f 7220 5120 2b20 5353 4520 666f  E for Q + SSE fo
-00003a80: 7220 534d 2028 7374 616e 6461 7269 7a65  r SM (standarize
-00003a90: 6420 7363 6f72 6564 290a 2020 2020 2020  d scored).      
-00003aa0: 2020 7061 7274 6961 6c5f 6f62 6a65 6374    partial_object
-00003ab0: 6976 6520 3d20 6f62 6a65 6374 6976 655f  ive = objective_
-00003ac0: 6b67 655f 715f 736d 5f63 6f72 7228 7061  kge_q_sm_corr(pa
-00003ad0: 7261 6d65 7465 7273 6574 2c20 6576 616c  rameterset, eval
-00003ae0: 290a 2020 2020 2020 6361 7365 2028 3239  ).      case (29
-00003af0: 290a 2020 2020 2020 2020 2120 204b 4745  ).        !  KGE
-00003b00: 2066 6f72 2051 202b 204b 4745 206f 6620   for Q + KGE of 
-00003b10: 6361 7463 686d 656e 7420 6176 6572 6167  catchment averag
-00003b20: 6520 4554 0a20 2020 2020 2020 2070 6172  e ET.        par
-00003b30: 7469 616c 5f6f 626a 6563 7469 7665 203d  tial_objective =
-00003b40: 206f 626a 6563 7469 7665 5f6b 6765 5f71   objective_kge_q
-00003b50: 5f65 7428 7061 7261 6d65 7465 7273 6574  _et(parameterset
-00003b60: 2c20 6576 616c 290a 2020 2020 2020 6361  , eval).      ca
-00003b70: 7365 2028 3330 290a 2020 2020 2020 2020  se (30).        
-00003b80: 2120 4b47 4520 666f 7220 5120 2a20 524d  ! KGE for Q * RM
-00003b90: 5345 2066 6f72 2064 6f6d 6169 6e5f 6176  SE for domain_av
-00003ba0: 6720 4554 2028 7374 616e 6461 7269 7a65  g ET (standarize
-00003bb0: 6420 7363 6f72 6564 290a 2020 2020 2020  d scored).      
-00003bc0: 2020 7061 7274 6961 6c5f 6f62 6a65 6374    partial_object
-00003bd0: 6976 6520 3d20 6f62 6a65 6374 6976 655f  ive = objective_
-00003be0: 6b67 655f 715f 726d 7365 5f65 7428 7061  kge_q_rmse_et(pa
-00003bf0: 7261 6d65 7465 7273 6574 2c20 6576 616c  rameterset, eval
-00003c00: 290a 2020 2020 2020 2020 7374 6f70 0a20  ).        stop. 
-00003c10: 2020 2020 2063 6173 6528 3333 290a 2020       case(33).  
-00003c20: 2020 2020 2020 6d75 6c74 6970 6c65 5f70        multiple_p
-00003c30: 6172 7469 616c 5f6f 626a 6563 7469 7665  artial_objective
-00003c40: 203d 206f 626a 6563 7469 7665 5f71 5f65   = objective_q_e
-00003c50: 745f 7477 735f 6b67 655f 6361 7463 686d  t_tws_kge_catchm
-00003c60: 656e 745f 6176 6728 7061 7261 6d65 7465  ent_avg(paramete
-00003c70: 7273 6574 2c20 6576 616c 290a 2020 2020  rset, eval).    
-00003c80: 2020 6361 7365 2064 6566 6175 6c74 0a20    case default. 
-00003c90: 2020 2020 2020 2063 616c 6c20 6d65 7373         call mess
-00003ca0: 6167 6528 2245 7272 6f72 206f 626a 6563  age("Error objec
-00003cb0: 7469 7665 5f73 7562 7072 6f63 6573 733a  tive_subprocess:
-00003cc0: 206f 7074 695f 6675 6e63 7469 6f6e 206e   opti_function n
-00003cd0: 6f74 2069 6d70 6c65 6d65 6e74 6564 2079  ot implemented y
-00003ce0: 6574 2e22 290a 2020 2020 2020 2020 7374  et.").        st
-00003cf0: 6f70 2031 0a20 2020 2020 2065 6e64 2073  op 1.      end s
-00003d00: 656c 6563 740a 0a20 2020 2020 2073 656c  elect..      sel
-00003d10: 6563 7420 6361 7365 2028 6f70 7469 5f66  ect case (opti_f
-00003d20: 756e 6374 696f 6e29 0a20 2020 2020 2063  unction).      c
-00003d30: 6173 6520 2831 3020 3a20 3133 2c20 3137  ase (10 : 13, 17
-00003d40: 2c20 3237 203a 2032 3929 0a20 2020 2020  , 27 : 29).     
-00003d50: 2020 2063 616c 6c20 4d50 495f 5365 6e64     call MPI_Send
-00003d60: 2870 6172 7469 616c 5f6f 626a 6563 7469  (partial_objecti
-00003d70: 7665 2c31 2c20 4d50 495f 444f 5542 4c45  ve,1, MPI_DOUBLE
-00003d80: 5f50 5245 4349 5349 4f4e 2c30 2c30 2c64  _PRECISION,0,0,d
-00003d90: 6f6d 6169 6e4d 6574 6125 636f 6d4d 6173  omainMeta%comMas
-00003da0: 7465 722c 6965 7272 6f72 290a 2020 2020  ter,ierror).    
-00003db0: 2020 6361 7365 2833 3329 0a20 2020 2020    case(33).     
-00003dc0: 2020 2063 616c 6c20 4d50 495f 5365 6e64     call MPI_Send
-00003dd0: 286d 756c 7469 706c 655f 7061 7274 6961  (multiple_partia
-00003de0: 6c5f 6f62 6a65 6374 6976 652c 2036 2c20  l_objective, 6, 
-00003df0: 4d50 495f 444f 5542 4c45 5f50 5245 4349  MPI_DOUBLE_PRECI
-00003e00: 5349 4f4e 2c30 2c30 2c64 6f6d 6169 6e4d  SION,0,0,domainM
-00003e10: 6574 6125 636f 6d4d 6173 7465 722c 6965  eta%comMaster,ie
-00003e20: 7272 6f72 290a 2020 2020 2020 6361 7365  rror).      case
-00003e30: 2064 6566 6175 6c74 0a20 2020 2020 2020   default.       
-00003e40: 2063 616c 6c20 6d65 7373 6167 6528 2245   call message("E
-00003e50: 7272 6f72 206f 626a 6563 7469 7665 5f73  rror objective_s
-00003e60: 7562 7072 6f63 6573 733a 2074 6869 7320  ubprocess: this 
-00003e70: 7061 7274 2073 686f 756c 6420 6e6f 7420  part should not 
-00003e80: 6265 2065 7865 6375 7465 6420 2d3e 2065  be executed -> e
-00003e90: 7272 6f72 2069 6e20 7468 6520 636f 6465  rror in the code
-00003ea0: 2e22 290a 2020 2020 2020 2020 7374 6f70  .").        stop
-00003eb0: 2031 0a20 2020 2020 2065 6e64 2073 656c   1.      end sel
-00003ec0: 6563 740a 0a20 2020 2020 2064 6561 6c6c  ect..      deall
-00003ed0: 6f63 6174 6528 7061 7261 6d65 7465 7273  ocate(parameters
-00003ee0: 6574 290a 2020 2020 656e 6420 646f 0a0a  et).    end do..
-00003ef0: 2020 454e 4420 7375 6272 6f75 7469 6e65    END subroutine
-00003f00: 206f 626a 6563 7469 7665 5f73 7562 7072   objective_subpr
-00003f10: 6f63 6573 730a 0a23 656e 6469 660a 2020  ocess..#endif.  
-00003f20: 2120 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ! --------------
-00003f30: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00003f40: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00003f50: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00003f60: 2d2d 2d2d 0a0a 2020 2120 2020 204e 414d  ----..  !    NAM
-00003f70: 450a 2020 2120 2020 2020 2020 206f 626a  E.  !        obj
-00003f80: 6563 7469 7665 5f73 6d5f 6b67 655f 6361  ective_sm_kge_ca
-00003f90: 7463 686d 656e 745f 6176 670a 0a20 2021  tchment_avg..  !
-00003fa0: 2020 2020 5055 5250 4f53 450a 2020 213e      PURPOSE.  !>
-00003fb0: 2020 2020 2020 205c 6272 6965 6620 4f62         \brief Ob
-00003fc0: 6a65 6374 6976 6520 6675 6e63 7469 6f6e  jective function
-00003fd0: 2066 6f72 2073 6f69 6c20 6d6f 6973 7475   for soil moistu
-00003fe0: 7265 2e0a 0a20 2021 3e20 2020 2020 2020  re...  !>       
-00003ff0: 5c64 6574 6169 6c73 2054 6865 206f 626a  \details The obj
-00004000: 6563 7469 7665 2066 756e 6374 696f 6e20  ective function 
-00004010: 6f6e 6c79 2064 6570 656e 6473 206f 6e20  only depends on 
-00004020: 6120 7061 7261 6d65 7465 7220 7665 6374  a parameter vect
-00004030: 6f72 2e0a 2020 213e 2020 2020 2020 2054  or..  !>       T
-00004040: 6865 206d 6f64 656c 2077 696c 6c20 6265  he model will be
-00004050: 2063 616c 6c65 6420 7769 7468 2074 6861   called with tha
-00004060: 7420 7061 7261 6d65 7465 7220 7665 6374  t parameter vect
-00004070: 6f72 2061 6e64 0a20 2021 3e20 2020 2020  or and.  !>     
-00004080: 2020 7468 6520 6d6f 6465 6c20 6f75 7470    the model outp
-00004090: 7574 2069 7320 7375 6273 6571 7565 6e74  ut is subsequent
-000040a0: 6c79 2063 6f6d 7061 7265 6420 746f 206f  ly compared to o
-000040b0: 6273 6572 7665 6420 6461 7461 2e0a 0a20  bserved data... 
-000040c0: 2021 3e20 2020 2020 2020 5468 6572 6566   !>       Theref
-000040d0: 6f72 652c 2074 6865 204b 6c69 6e67 2d47  ore, the Kling-G
-000040e0: 7570 7461 206d 6f64 656c 2065 6666 6963  upta model effic
-000040f0: 6965 6e63 7920 5c66 2420 4b47 4520 5c66  iency \f$ KGE \f
-00004100: 2420 6f66 2074 6865 2063 6174 6368 6d65  $ of the catchme
-00004110: 6e74 2061 7665 7261 6765 0a20 2021 3e20  nt average.  !> 
-00004120: 2020 2020 2020 736f 696c 206d 6c6f 6973        soil mlois
-00004130: 7475 7265 2028 534d 2920 6973 2063 616c  ture (SM) is cal
-00004140: 6375 6c61 7465 640a 2020 213e 2020 2020  culated.  !>    
-00004150: 2020 205c 665b 204b 4745 203d 2031 2e30     \f[ KGE = 1.0
-00004160: 202d 205c 7371 7274 7b28 2028 312d 7229   - \sqrt{( (1-r)
-00004170: 5e32 202b 2028 312d 5c61 6c70 6861 295e  ^2 + (1-\alpha)^
-00004180: 3220 2b20 2831 2d5c 6265 7461 295e 3220  2 + (1-\beta)^2 
-00004190: 297d 205c 665d 0a20 2021 3e20 2020 2020  )} \f].  !>     
-000041a0: 2020 7768 6572 650a 2020 213e 2020 2020    where.  !>    
-000041b0: 2020 205c 6624 2072 205c 6624 203d 2050     \f$ r \f$ = P
-000041c0: 6561 7273 6f6e 2070 726f 6475 6374 2d6d  earson product-m
-000041d0: 6f6d 656e 7420 636f 7272 656c 6174 696f  oment correlatio
-000041e0: 6e20 636f 6566 6669 6369 656e 740a 2020  n coefficient.  
-000041f0: 213e 2020 2020 2020 205c 6624 205c 616c  !>       \f$ \al
-00004200: 7068 6120 5c66 2420 3d20 7261 7469 6f20  pha \f$ = ratio 
-00004210: 6f66 2073 696d 756c 6174 6564 206d 6561  of simulated mea
-00004220: 6e20 746f 206f 6273 6572 7665 6420 6d65  n to observed me
-00004230: 616e 2053 4d0a 2020 213e 2020 2020 2020  an SM.  !>      
-00004240: 205c 6624 205c 6265 7461 2020 5c66 2420   \f$ \beta  \f$ 
-00004250: 3d20 7261 7469 6f20 6f66 2073 696d 696c  = ratio of simil
-00004260: 6174 6564 2073 7461 6e64 6172 6420 6465  ated standard de
-00004270: 7669 6174 696f 6e20 746f 206f 6273 6572  viation to obser
-00004280: 7665 6420 7374 616e 6461 7264 2064 6576  ved standard dev
-00004290: 6961 7469 6f6e 0a20 2021 3e20 2020 2020  iation.  !>     
-000042a0: 2020 6973 2063 616c 6375 6c61 7465 6420    is calculated 
-000042b0: 616e 6420 7468 6520 6f62 6a65 6374 6976  and the objectiv
-000042c0: 6520 6675 6e63 7469 6f6e 2066 6f72 2061  e function for a
-000042d0: 2067 6976 656e 2064 6f6d 6169 6e20 5c66   given domain \f
-000042e0: 2420 6920 5c66 2420 6973 0a20 2021 3e20  $ i \f$ is.  !> 
-000042f0: 2020 2020 2020 5c66 5b20 5c70 6869 5f7b        \f[ \phi_{
-00004300: 697d 203d 2031 2e30 202d 204b 4745 5f7b  i} = 1.0 - KGE_{
-00004310: 697d 205c 665d 0a20 2021 3e20 2020 2020  i} \f].  !>     
-00004320: 2020 5c66 2420 5c70 6869 5f7b 697d 205c    \f$ \phi_{i} \
-00004330: 6624 2069 7320 7468 6520 6f62 6a65 6374  f$ is the object
-00004340: 6976 6520 7369 6e63 6520 7765 2061 6c77  ive since we alw
-00004350: 6179 7320 6170 706c 7920 6d69 6e69 6d69  ays apply minimi
-00004360: 7a61 7469 6f6e 206d 6574 686f 6473 2e0a  zation methods..
-00004370: 2020 213e 2020 2020 2020 2054 6865 206d    !>       The m
-00004380: 696e 696d 616c 2076 616c 7565 206f 6620  inimal value of 
-00004390: 5c66 2420 5c70 6869 5f7b 697d 205c 6624  \f$ \phi_{i} \f$
-000043a0: 2069 7320 3020 666f 7220 7468 6520 6f70   is 0 for the op
-000043b0: 7469 6d61 6c20 4b47 4520 6f66 2031 2e30  timal KGE of 1.0
-000043c0: 2e0a 0a20 2021 3e20 2020 2020 2020 4669  ...  !>       Fi
-000043d0: 6e61 6c6c 792c 2074 6865 206f 7665 7261  nally, the overa
-000043e0: 6c6c 206f 626a 6563 7469 7665 2066 756e  ll objective fun
-000043f0: 6374 696f 6e20 7661 6c75 6520 5c66 2420  ction value \f$ 
-00004400: 4f46 205c 6624 2069 7320 6573 7469 6d61  OF \f$ is estima
-00004410: 7465 6420 6261 7365 6420 6f6e 2074 6865  ted based on the
-00004420: 2070 6f77 6572 2d36 0a20 2021 3e20 2020   power-6.  !>   
-00004430: 2020 2020 6e6f 726d 2074 6f20 636f 6d62      norm to comb
-00004440: 696e 6520 7468 6520 5c66 2420 5c70 6869  ine the \f$ \phi
-00004450: 5f7b 697d 205c 6624 2066 726f 6d20 616c  _{i} \f$ from al
-00004460: 6c20 646f 6d61 696e 7320 5c66 2420 4e20  l domains \f$ N 
-00004470: 5c66 242e 0a20 2021 3e20 2020 2020 2020  \f$..  !>       
-00004480: 5c66 5b20 4f46 203d 205c 7371 7274 5b36  \f[ OF = \sqrt[6
-00004490: 5d7b 5c73 756d 2828 312e 3020 2d20 4b47  ]{\sum((1.0 - KG
-000044a0: 455f 7b69 7d29 2f4e 295e 3620 7d2e 2020  E_{i})/N)^6 }.  
-000044b0: 5c66 5d0a 2020 213e 2020 2020 2020 2054  \f].  !>       T
-000044c0: 6865 206f 6273 6572 7665 6420 6461 7461  he observed data
-000044d0: 204c 315f 736d 2c20 4c31 5f73 6d5f 6d61   L1_sm, L1_sm_ma
-000044e0: 736b 2061 7265 2067 6c6f 6261 6c20 696e  sk are global in
-000044f0: 2074 6869 7320 6d6f 6475 6c65 2e0a 0a20   this module... 
-00004500: 2021 2020 2020 494e 5445 4e54 2849 4e29   !    INTENT(IN)
-00004510: 0a20 2021 3e20 2020 2020 2020 5c70 6172  .  !>       \par
-00004520: 616d 5b69 6e5d 2022 7265 616c 2864 7029  am[in] "real(dp)
-00004530: 2c20 6469 6d65 6e73 696f 6e28 3a29 203a  , dimension(:) :
-00004540: 3a20 7061 7261 6d65 7465 7273 6574 220a  : parameterset".
-00004550: 2020 213e 2020 2020 2020 205c 7061 7261    !>       \para
-00004560: 6d5b 696e 5d20 2270 726f 6365 6475 7265  m[in] "procedure
-00004570: 2865 7661 6c5f 696e 7465 7266 6163 6529  (eval_interface)
-00004580: 203a 3a20 6576 616c 220a 0a20 2021 2020   :: eval"..  !  
-00004590: 2020 5245 5455 524e 0a20 2021 3e20 2020    RETURN.  !>   
-000045a0: 2020 2020 5c72 6574 7572 6e20 7265 616c      \return real
-000045b0: 2864 7029 203a 3a20 6f62 6a65 6374 6976  (dp) :: objectiv
-000045c0: 655f 736d 5f6b 6765 5f63 6174 6368 6d65  e_sm_kge_catchme
-000045d0: 6e74 5f61 7667 2026 6d64 6173 683b 206f  nt_avg &mdash; o
-000045e0: 626a 6563 7469 7665 2066 756e 6374 696f  bjective functio
-000045f0: 6e20 7661 6c75 650a 2020 213e 2020 2020  n value.  !>    
-00004600: 2020 2028 7768 6963 6820 7769 6c6c 2062     (which will b
-00004610: 6520 652e 672e 206d 696e 696d 697a 6564  e e.g. minimized
-00004620: 2062 7920 616e 206f 7074 696d 697a 6174   by an optimizat
-00004630: 696f 6e20 726f 7574 696e 6520 6c69 6b65  ion routine like
-00004640: 2044 4453 290a 0a20 2021 2020 2020 4849   DDS)..  !    HI
-00004650: 5354 4f52 590a 2020 213e 2020 2020 2020  STORY.  !>      
-00004660: 205c 6175 7468 6f72 7320 4d61 7474 6869   \authors Matthi
-00004670: 6173 205a 696e 6b0a 0a20 2021 3e20 2020  as Zink..  !>   
-00004680: 2020 2020 5c64 6174 6520 4d61 7920 3230      \date May 20
-00004690: 3135 0a0a 2020 2120 4d6f 6469 6669 6361  15..  ! Modifica
-000046a0: 7469 6f6e 733a 0a20 2021 2052 6f62 6572  tions:.  ! Rober
-000046b0: 7420 5363 6877 6570 7065 204a 756e 2032  t Schweppe Jun 2
-000046c0: 3031 3820 2d20 7265 6661 6374 6f72 696e  018 - refactorin
-000046d0: 6720 616e 6420 7265 666f 726d 6174 7469  g and reformatti
-000046e0: 6e67 0a0a 2020 4655 4e43 5449 4f4e 206f  ng..  FUNCTION o
-000046f0: 626a 6563 7469 7665 5f73 6d5f 6b67 655f  bjective_sm_kge_
-00004700: 6361 7463 686d 656e 745f 6176 6728 7061  catchment_avg(pa
-00004710: 7261 6d65 7465 7273 6574 2c20 6576 616c  rameterset, eval
-00004720: 290a 0a20 2020 2075 7365 206d 6f5f 6f70  )..    use mo_op
-00004730: 7469 6d69 7a61 7469 6f6e 5f74 7970 6573  timization_types
-00004740: 2c20 6f6e 6c79 203a 206f 7074 6964 6174  , only : optidat
-00004750: 615f 7369 6d0a 2020 2020 7573 6520 6d6f  a_sim.    use mo
-00004760: 5f63 6f6d 6d6f 6e5f 636f 6e73 7461 6e74  _common_constant
-00004770: 732c 206f 6e6c 7920 3a20 6e6f 6461 7461  s, only : nodata
-00004780: 5f64 700a 2020 2020 7573 6520 6d6f 5f63  _dp.    use mo_c
-00004790: 6f6d 6d6f 6e5f 7661 7269 6162 6c65 732c  ommon_variables,
-000047a0: 206f 6e6c 7920 3a20 6c65 7665 6c31 2c20   only : level1, 
-000047b0: 646f 6d61 696e 4d65 7461 0a20 2020 2075  domainMeta.    u
-000047c0: 7365 206d 6f5f 6572 726f 726d 6561 7375  se mo_errormeasu
-000047d0: 7265 732c 206f 6e6c 7920 3a20 4b47 450a  res, only : KGE.
-000047e0: 2020 2020 7573 6520 6d6f 5f67 6c6f 6261      use mo_globa
-000047f0: 6c5f 7661 7269 6162 6c65 732c 206f 6e6c  l_variables, onl
-00004800: 7920 3a20 4c31 5f73 6d4f 6273 0a20 2020  y : L1_smObs.   
-00004810: 2075 7365 206d 6f5f 6d65 7373 6167 652c   use mo_message,
-00004820: 206f 6e6c 7920 3a20 6d65 7373 6167 650a   only : message.
-00004830: 2020 2020 7573 6520 6d6f 5f6d 6f6d 656e      use mo_momen
-00004840: 742c 206f 6e6c 7920 3a20 6176 6572 6167  t, only : averag
-00004850: 650a 2020 2020 7573 6520 6d6f 5f73 7472  e.    use mo_str
-00004860: 696e 675f 7574 696c 732c 206f 6e6c 7920  ing_utils, only 
-00004870: 3a20 6e75 6d32 7374 720a 0a20 2020 2069  : num2str..    i
-00004880: 6d70 6c69 6369 7420 6e6f 6e65 0a0a 2020  mplicit none..  
-00004890: 2020 7265 616c 2864 7029 2c20 6469 6d65    real(dp), dime
-000048a0: 6e73 696f 6e28 3a29 2c20 696e 7465 6e74  nsion(:), intent
-000048b0: 2869 6e29 203a 3a20 7061 7261 6d65 7465  (in) :: paramete
-000048c0: 7273 6574 0a0a 2020 2020 7072 6f63 6564  rset..    proced
-000048d0: 7572 6528 6576 616c 5f69 6e74 6572 6661  ure(eval_interfa
-000048e0: 6365 292c 2049 4e54 454e 5428 494e 292c  ce), INTENT(IN),
-000048f0: 2050 4f49 4e54 4552 203a 3a20 6576 616c   POINTER :: eval
-00004900: 0a0a 2020 2020 7265 616c 2864 7029 203a  ..    real(dp) :
-00004910: 3a20 6f62 6a65 6374 6976 655f 736d 5f6b  : objective_sm_k
-00004920: 6765 5f63 6174 6368 6d65 6e74 5f61 7667  ge_catchment_avg
-00004930: 0a0a 2020 2020 2120 646f 6d61 696e 206c  ..    ! domain l
-00004940: 6f6f 7020 636f 756e 7465 720a 2020 2020  oop counter.    
-00004950: 696e 7465 6765 7228 6934 2920 3a3a 2069  integer(i4) :: i
-00004960: 446f 6d61 696e 0a0a 2020 2020 2120 7469  Domain..    ! ti
-00004970: 6d65 206c 6f6f 7020 636f 756e 7465 720a  me loop counter.
-00004980: 2020 2020 696e 7465 6765 7228 6934 2920      integer(i4) 
-00004990: 3a3a 2069 5469 6d65 0a0a 2020 2020 2120  :: iTime..    ! 
-000049a0: 6e75 6d62 6572 206f 6620 7469 6d65 2073  number of time s
-000049b0: 7465 7073 2069 6e20 7369 6d75 6c61 7465  teps in simulate
-000049c0: 6420 534d 0a20 2020 2069 6e74 6567 6572  d SM.    integer
-000049d0: 2869 3429 203a 3a20 6e5f 7469 6d65 5f73  (i4) :: n_time_s
-000049e0: 7465 7073 0a0a 2020 2020 2120 6e63 656c  teps..    ! ncel
-000049f0: 6c73 3120 6f66 206c 6576 656c 2031 0a20  ls1 of level 1. 
-00004a00: 2020 2069 6e74 6567 6572 2869 3429 203a     integer(i4) :
-00004a10: 3a20 6e63 656c 6c73 310a 0a20 2020 2021  : ncells1..    !
-00004a20: 206e 756d 6265 7220 6f66 2069 6e76 616c   number of inval
-00004a30: 6964 2074 696d 6573 7465 7073 0a20 2020  id timesteps.   
-00004a40: 2072 6561 6c28 6470 2920 3a3a 2069 6e76   real(dp) :: inv
-00004a50: 616c 6964 5f74 696d 6573 0a23 6966 6e64  alid_times.#ifnd
-00004a60: 6566 204d 5049 0a20 2020 2021 2066 6f72  ef MPI.    ! for
-00004a70: 2073 6978 7468 2072 6f6f 740a 2020 2020   sixth root.    
-00004a80: 7265 616c 2864 7029 2c20 7061 7261 6d65  real(dp), parame
-00004a90: 7465 7220 3a3a 206f 6e65 7369 7874 6820  ter :: onesixth 
-00004aa0: 3d20 312e 305f 6470 202f 2036 2e30 5f64  = 1.0_dp / 6.0_d
-00004ab0: 700a 2365 6e64 6966 0a0a 2020 2020 2120  p.#endif..    ! 
-00004ac0: 7370 6174 6961 6c20 6176 6572 6167 6520  spatial average 
-00004ad0: 6f66 206f 6273 6572 7665 6420 736f 696c  of observed soil
-00004ae0: 206d 6f69 7374 7572 650a 2020 2020 7265   moisture.    re
-00004af0: 616c 2864 7029 2c20 6469 6d65 6e73 696f  al(dp), dimensio
-00004b00: 6e28 3a29 2c20 616c 6c6f 6361 7461 626c  n(:), allocatabl
-00004b10: 6520 3a3a 2073 6d5f 6361 7463 685f 6176  e :: sm_catch_av
-00004b20: 675f 646f 6d61 696e 0a0a 2020 2020 2120  g_domain..    ! 
-00004b30: 7370 6174 6961 6c20 6176 6572 6761 6520  spatial avergae 
-00004b40: 6f66 206d 6f64 656c 6564 2020 736f 696c  of modeled  soil
-00004b50: 206d 6f69 7374 7572 650a 2020 2020 7265   moisture.    re
-00004b60: 616c 2864 7029 2c20 6469 6d65 6e73 696f  al(dp), dimensio
-00004b70: 6e28 3a29 2c20 616c 6c6f 6361 7461 626c  n(:), allocatabl
-00004b80: 6520 3a3a 2073 6d5f 6f70 7469 5f63 6174  e :: sm_opti_cat
-00004b90: 6368 5f61 7667 5f64 6f6d 6169 6e0a 0a20  ch_avg_domain.. 
-00004ba0: 2020 2074 7970 6528 6f70 7469 6461 7461     type(optidata
-00004bb0: 5f73 696d 292c 2064 696d 656e 7369 6f6e  _sim), dimension
-00004bc0: 283a 292c 2061 6c6c 6f63 6174 6162 6c65  (:), allocatable
-00004bd0: 203a 3a20 736d 4f70 7469 5369 6d0a 0a20   :: smOptiSim.. 
-00004be0: 2020 2021 206d 6173 6b20 666f 7220 7661     ! mask for va
-00004bf0: 6c69 6420 736d 2063 6174 6368 6d65 6e74  lid sm catchment
-00004c00: 2061 7667 2074 696d 6520 7374 6570 730a   avg time steps.
-00004c10: 2020 2020 6c6f 6769 6361 6c2c 2064 696d      logical, dim
-00004c20: 656e 7369 6f6e 283a 292c 2061 6c6c 6f63  ension(:), alloc
-00004c30: 6174 6162 6c65 203a 3a20 6d61 736b 5f74  atable :: mask_t
-00004c40: 696d 6573 0a0a 0a20 2020 2061 6c6c 6f63  imes...    alloc
-00004c50: 6174 6528 736d 4f70 7469 5369 6d28 646f  ate(smOptiSim(do
-00004c60: 6d61 696e 4d65 7461 256e 446f 6d61 696e  mainMeta%nDomain
-00004c70: 7329 290a 2020 2020 6361 6c6c 2065 7661  s)).    call eva
-00004c80: 6c28 7061 7261 6d65 7465 7273 6574 2c20  l(parameterset, 
-00004c90: 736d 4f70 7469 5369 6d20 3d20 736d 4f70  smOptiSim = smOp
-00004ca0: 7469 5369 6d29 0a0a 2020 2020 2120 696e  tiSim)..    ! in
-00004cb0: 6974 6961 6c69 7a65 2073 6f6d 6520 7661  itialize some va
-00004cc0: 7269 6162 6c65 730a 2020 2020 6f62 6a65  riables.    obje
-00004cd0: 6374 6976 655f 736d 5f6b 6765 5f63 6174  ctive_sm_kge_cat
-00004ce0: 6368 6d65 6e74 5f61 7667 203d 2030 2e30  chment_avg = 0.0
-00004cf0: 5f64 700a 0a20 2020 2021 206c 6f6f 7020  _dp..    ! loop 
-00004d00: 6f76 6572 2064 6f6d 6169 6e20 2d20 666f  over domain - fo
-00004d10: 7220 6170 706c 7969 6e67 2070 6f77 6572  r applying power
-00004d20: 206c 6177 206c 6174 6572 206f 6e0a 2020   law later on.  
-00004d30: 2020 646f 2069 446f 6d61 696e 203d 2031    do iDomain = 1
-00004d40: 2c20 646f 6d61 696e 4d65 7461 256e 446f  , domainMeta%nDo
-00004d50: 6d61 696e 730a 0a20 2020 2020 2021 2067  mains..      ! g
-00004d60: 6574 2064 6f6d 6169 6e20 696e 666f 726d  et domain inform
-00004d70: 6174 696f 6e0a 2020 2020 2020 6e63 656c  ation.      ncel
-00004d80: 6c73 3120 3d20 6c65 7665 6c31 2869 446f  ls1 = level1(iDo
-00004d90: 6d61 696e 2925 6e63 656c 6c73 0a0a 2020  main)%ncells..  
-00004da0: 2020 2020 2120 616c 6c6f 6361 7465 0a20      ! allocate. 
-00004db0: 2020 2020 2061 6c6c 6f63 6174 6528 6d61       allocate(ma
-00004dc0: 736b 5f74 696d 6573 2020 2020 2020 2020  sk_times        
-00004dd0: 2020 2020 2020 2873 697a 6528 736d 4f70        (size(smOp
-00004de0: 7469 5369 6d28 6944 6f6d 6169 6e29 2564  tiSim(iDomain)%d
-00004df0: 6174 6153 696d 2c20 6469 6d20 3d20 3229  ataSim, dim = 2)
-00004e00: 2929 0a20 2020 2020 2061 6c6c 6f63 6174  )).      allocat
-00004e10: 6528 736d 5f63 6174 6368 5f61 7667 5f64  e(sm_catch_avg_d
-00004e20: 6f6d 6169 6e20 2020 2020 2873 697a 6528  omain     (size(
-00004e30: 736d 4f70 7469 5369 6d28 6944 6f6d 6169  smOptiSim(iDomai
-00004e40: 6e29 2564 6174 6153 696d 2c20 6469 6d20  n)%dataSim, dim 
-00004e50: 3d20 3229 2929 0a20 2020 2020 2061 6c6c  = 2))).      all
-00004e60: 6f63 6174 6528 736d 5f6f 7074 695f 6361  ocate(sm_opti_ca
-00004e70: 7463 685f 6176 675f 646f 6d61 696e 2873  tch_avg_domain(s
-00004e80: 697a 6528 736d 4f70 7469 5369 6d28 6944  ize(smOptiSim(iD
-00004e90: 6f6d 6169 6e29 2564 6174 6153 696d 2c20  omain)%dataSim, 
-00004ea0: 6469 6d20 3d20 3229 2929 0a0a 2020 2020  dim = 2)))..    
-00004eb0: 2020 2120 696e 6974 616c 697a 650a 2020    ! initalize.  
-00004ec0: 2020 2020 6d61 736b 5f74 696d 6573 203d      mask_times =
-00004ed0: 202e 5452 5545 2e0a 2020 2020 2020 736d   .TRUE..      sm
-00004ee0: 5f63 6174 6368 5f61 7667 5f64 6f6d 6169  _catch_avg_domai
-00004ef0: 6e20 3d20 6e6f 6461 7461 5f64 700a 2020  n = nodata_dp.  
-00004f00: 2020 2020 736d 5f6f 7074 695f 6361 7463      sm_opti_catc
-00004f10: 685f 6176 675f 646f 6d61 696e 203d 206e  h_avg_domain = n
-00004f20: 6f64 6174 615f 6470 0a0a 2020 2020 2020  odata_dp..      
-00004f30: 696e 7661 6c69 645f 7469 6d65 7320 3d20  invalid_times = 
-00004f40: 302e 305f 6470 0a20 2020 2020 2021 2063  0.0_dp.      ! c
-00004f50: 616c 6375 6c61 7465 2063 6174 6368 6d65  alculate catchme
-00004f60: 6e74 2061 7665 7261 6765 2073 6f69 6c20  nt average soil 
-00004f70: 6d6f 6973 7475 7265 0a20 2020 2020 206e  moisture.      n
-00004f80: 5f74 696d 655f 7374 6570 7320 3d20 7369  _time_steps = si
-00004f90: 7a65 2873 6d4f 7074 6953 696d 2869 446f  ze(smOptiSim(iDo
-00004fa0: 6d61 696e 2925 6461 7461 5369 6d2c 2064  main)%dataSim, d
-00004fb0: 696d 203d 2032 290a 2020 2020 2020 646f  im = 2).      do
-00004fc0: 2069 5469 6d65 203d 2031 2c20 6e5f 7469   iTime = 1, n_ti
-00004fd0: 6d65 5f73 7465 7073 0a0a 2020 2020 2020  me_steps..      
-00004fe0: 2020 2120 6368 6563 6b20 666f 7220 656e    ! check for en
-00004ff0: 6f75 6768 2064 6174 6120 706f 696e 7473  ough data points
-00005000: 2069 6e20 7469 6d65 7374 6570 7320 666f   in timesteps fo
-00005010: 7220 4b47 4520 6361 6c63 756c 6174 696f  r KGE calculatio
-00005020: 6e0a 2020 2020 2020 2020 2120 6d6f 7265  n.        ! more
-00005030: 2074 6865 6e20 3130 2070 6572 6365 6e74   then 10 percent
-00005040: 2061 7661 6961 626c 6520 696e 2063 7572   avaiable in cur
-00005050: 7265 6e74 2066 6965 6c64 0a20 2020 2020  rent field.     
-00005060: 2020 2069 6620 2863 6f75 6e74 284c 315f     if (count(L1_
-00005070: 736d 4f62 7328 6944 6f6d 6169 6e29 256d  smObs(iDomain)%m
-00005080: 6173 6b4f 6273 283a 2c20 6954 696d 6529  askObs(:, iTime)
-00005090: 2920 2e4c 452e 2028 302e 3130 5f64 7020  ) .LE. (0.10_dp 
-000050a0: 2a20 7265 616c 286e 4365 6c6c 7331 2c20  * real(nCells1, 
-000050b0: 6470 2929 2920 7468 656e 0a20 2020 2020  dp))) then.     
-000050c0: 2020 2020 2069 6e76 616c 6964 5f74 696d       invalid_tim
-000050d0: 6573 203d 2069 6e76 616c 6964 5f74 696d  es = invalid_tim
-000050e0: 6573 202b 2031 2e30 5f64 700a 2020 2020  es + 1.0_dp.    
-000050f0: 2020 2020 2020 6d61 736b 5f74 696d 6573        mask_times
-00005100: 2869 5469 6d65 2920 3d20 2e46 414c 5345  (iTime) = .FALSE
-00005110: 2e0a 2020 2020 2020 2020 2020 6379 636c  ..          cycl
-00005120: 650a 2020 2020 2020 2020 656e 6420 6966  e.        end if
-00005130: 0a20 2020 2020 2020 2073 6d5f 6361 7463  .        sm_catc
-00005140: 685f 6176 675f 646f 6d61 696e 2869 5469  h_avg_domain(iTi
-00005150: 6d65 2920 3d20 6176 6572 6167 6528 4c31  me) = average(L1
-00005160: 5f73 6d4f 6273 2869 446f 6d61 696e 2925  _smObs(iDomain)%
-00005170: 6461 7461 4f62 7328 3a2c 2069 5469 6d65  dataObs(:, iTime
-00005180: 292c 206d 6173 6b20 3d20 4c31 5f73 6d4f  ), mask = L1_smO
-00005190: 6273 2869 446f 6d61 696e 2925 6d61 736b  bs(iDomain)%mask
-000051a0: 4f62 7328 3a2c 2069 5469 6d65 2929 0a20  Obs(:, iTime)). 
-000051b0: 2020 2020 2020 2073 6d5f 6f70 7469 5f63         sm_opti_c
-000051c0: 6174 6368 5f61 7667 5f64 6f6d 6169 6e28  atch_avg_domain(
-000051d0: 6954 696d 6529 203d 2061 7665 7261 6765  iTime) = average
-000051e0: 2873 6d4f 7074 6953 696d 2869 446f 6d61  (smOptiSim(iDoma
-000051f0: 696e 2925 6461 7461 5369 6d28 3a2c 2069  in)%dataSim(:, i
-00005200: 5469 6d65 292c 206d 6173 6b20 3d20 4c31  Time), mask = L1
-00005210: 5f73 6d4f 6273 2869 446f 6d61 696e 2925  _smObs(iDomain)%
-00005220: 6d61 736b 4f62 7328 3a2c 2069 5469 6d65  maskObs(:, iTime
-00005230: 2929 0a20 2020 2020 2065 6e64 2064 6f0a  )).      end do.
-00005240: 0a20 2020 2020 2021 2075 7365 7220 696e  .      ! user in
-00005250: 666f 726d 6174 696f 6e20 6162 6f75 7420  formation about 
-00005260: 696e 7661 6c69 6420 7469 6d65 730a 2020  invalid times.  
-00005270: 2020 2020 6966 2028 696e 7661 6c69 645f      if (invalid_
-00005280: 7469 6d65 7320 2e47 542e 2030 2e35 5f64  times .GT. 0.5_d
-00005290: 7029 2074 6865 6e0a 2020 2020 2020 2020  p) then.        
-000052a0: 6361 6c6c 206d 6573 7361 6765 2827 2020  call message('  
-000052b0: 2057 4152 4e49 4e47 3a20 6f62 6a65 6374   WARNING: object
-000052c0: 6976 655f 736d 3a20 4465 7465 6374 6564  ive_sm: Detected
-000052d0: 2069 6e76 616c 6964 2074 696d 6573 7465   invalid timeste
-000052e0: 7073 2028 2e4c 542e 2031 3020 7661 6c69  ps (.LT. 10 vali
-000052f0: 6420 6461 7461 2070 6f69 6e74 7329 2e27  d data points).'
-00005300: 290a 2020 2020 2020 2020 6361 6c6c 206d  ).        call m
-00005310: 6573 7361 6765 2827 2020 2020 2020 2020  essage('        
-00005320: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005330: 2020 4672 6163 7469 6f6e 206f 6620 696e    Fraction of in
-00005340: 7661 6c69 6420 7469 6d65 7374 6570 733a  valid timesteps:
-00005350: 2027 2c20 260a 2020 2020 2020 2020 2020   ', &.          
-00005360: 2020 2020 2020 6e75 6d32 7374 7228 696e        num2str(in
-00005370: 7661 6c69 645f 7469 6d65 7320 2f20 7265  valid_times / re
-00005380: 616c 286e 5f74 696d 655f 7374 6570 732c  al(n_time_steps,
-00005390: 2064 7029 2c20 2728 4634 2e32 2927 2929   dp), '(F4.2)'))
-000053a0: 0a20 2020 2020 2065 6e64 2069 660a 0a0a  .      end if...
-000053b0: 2020 2020 2020 2120 6361 6c63 756c 6174        ! calculat
-000053c0: 6520 6176 6572 6167 6520 736f 696c 206d  e average soil m
-000053d0: 6f69 7374 7572 6520 4b47 4520 6f76 6572  oisture KGE over
-000053e0: 2061 6c6c 2064 6f6d 6169 6e73 2077 6974   all domains wit
-000053f0: 6820 706f 7765 7220 6c61 770a 2020 2020  h power law.    
-00005400: 2020 2120 646f 6d61 696e 7320 6172 6520    ! domains are 
-00005410: 7765 6967 6874 6564 2065 7175 616c 6c79  weighted equally
-00005420: 2028 2031 202f 2072 6561 6c28 646f 6d61   ( 1 / real(doma
-00005430: 696e 4d65 7461 256f 7665 7261 6c6c 4e75  inMeta%overallNu
-00005440: 6d62 6572 4f66 446f 6d61 696e 732c 6470  mberOfDomains,dp
-00005450: 2929 2a2a 360a 2020 2020 2020 6f62 6a65  ))**6.      obje
-00005460: 6374 6976 655f 736d 5f6b 6765 5f63 6174  ctive_sm_kge_cat
-00005470: 6368 6d65 6e74 5f61 7667 203d 206f 626a  chment_avg = obj
-00005480: 6563 7469 7665 5f73 6d5f 6b67 655f 6361  ective_sm_kge_ca
-00005490: 7463 686d 656e 745f 6176 6720 2b20 260a  tchment_avg + &.
-000054a0: 2020 2020 2020 2020 2020 2020 2020 2828                ((
-000054b0: 312e 305f 6470 202d 204b 4745 2873 6d5f  1.0_dp - KGE(sm_
-000054c0: 6361 7463 685f 6176 675f 646f 6d61 696e  catch_avg_domain
-000054d0: 2c20 736d 5f6f 7074 695f 6361 7463 685f  , sm_opti_catch_
-000054e0: 6176 675f 646f 6d61 696e 2c20 6d61 736b  avg_domain, mask
-000054f0: 203d 206d 6173 6b5f 7469 6d65 7329 2920   = mask_times)) 
-00005500: 2f20 260a 2020 2020 2020 2020 2020 2020  / &.            
-00005510: 2020 2020 2020 2020 2020 2020 7265 616c              real
-00005520: 2864 6f6d 6169 6e4d 6574 6125 6f76 6572  (domainMeta%over
-00005530: 616c 6c4e 756d 6265 724f 6644 6f6d 6169  allNumberOfDomai
-00005540: 6e73 2c20 6470 2929 2a2a 360a 0a20 2020  ns, dp))**6..   
-00005550: 2020 2021 2064 6561 6c6c 6f63 6174 650a     ! deallocate.
-00005560: 2020 2020 2020 6465 616c 6c6f 6361 7465        deallocate
-00005570: 286d 6173 6b5f 7469 6d65 7329 0a20 2020  (mask_times).   
-00005580: 2020 2064 6561 6c6c 6f63 6174 6528 736d     deallocate(sm
-00005590: 5f63 6174 6368 5f61 7667 5f64 6f6d 6169  _catch_avg_domai
-000055a0: 6e29 0a20 2020 2020 2064 6561 6c6c 6f63  n).      dealloc
-000055b0: 6174 6528 736d 5f6f 7074 695f 6361 7463  ate(sm_opti_catc
-000055c0: 685f 6176 675f 646f 6d61 696e 290a 2020  h_avg_domain).  
-000055d0: 2020 2020 6361 6c6c 2073 6d4f 7074 6953      call smOptiS
-000055e0: 696d 2869 446f 6d61 696e 2925 6465 7374  im(iDomain)%dest
-000055f0: 726f 7928 290a 2020 2020 656e 6420 646f  roy().    end do
-00005600: 0a20 2020 2064 6561 6c6c 6f63 6174 6528  .    deallocate(
-00005610: 736d 4f70 7469 5369 6d29 0a0a 2369 666e  smOptiSim)..#ifn
-00005620: 6465 6620 4d50 490a 2020 2020 6f62 6a65  def MPI.    obje
-00005630: 6374 6976 655f 736d 5f6b 6765 5f63 6174  ctive_sm_kge_cat
-00005640: 6368 6d65 6e74 5f61 7667 203d 206f 626a  chment_avg = obj
-00005650: 6563 7469 7665 5f73 6d5f 6b67 655f 6361  ective_sm_kge_ca
-00005660: 7463 686d 656e 745f 6176 672a 2a6f 6e65  tchment_avg**one
-00005670: 7369 7874 680a 0a20 2020 2063 616c 6c20  sixth..    call 
-00005680: 6d65 7373 6167 6528 2720 2020 206f 626a  message('    obj
-00005690: 6563 7469 7665 5f73 6d5f 6b67 655f 6361  ective_sm_kge_ca
-000056a0: 7463 686d 656e 745f 6176 6720 3d20 272c  tchment_avg = ',
-000056b0: 206e 756d 3273 7472 286f 626a 6563 7469   num2str(objecti
-000056c0: 7665 5f73 6d5f 6b67 655f 6361 7463 686d  ve_sm_kge_catchm
-000056d0: 656e 745f 6176 672c 2027 2846 392e 3529  ent_avg, '(F9.5)
-000056e0: 2729 290a 2365 6e64 6966 0a0a 0a20 2045  ')).#endif...  E
-000056f0: 4e44 2046 554e 4354 494f 4e20 6f62 6a65  ND FUNCTION obje
-00005700: 6374 6976 655f 736d 5f6b 6765 5f63 6174  ctive_sm_kge_cat
-00005710: 6368 6d65 6e74 5f61 7667 0a0a 2020 2120  chment_avg..  ! 
-00005720: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00005730: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00005740: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00005750: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00005760: 2d2d 0a0a 2020 2120 2020 204e 414d 450a  --..  !    NAME.
-00005770: 2020 2120 2020 2020 2020 206f 626a 6563    !        objec
-00005780: 7469 7665 5f71 5f65 745f 7477 735f 6b67  tive_q_et_tws_kg
-00005790: 655f 6361 7463 686d 656e 745f 6176 670a  e_catchment_avg.
-000057a0: 0a20 2021 2020 2020 5055 5250 4f53 450a  .  !    PURPOSE.
-000057b0: 2020 213e 2020 2020 2020 205c 6272 6965    !>       \brie
-000057c0: 6620 4f62 6a65 6374 6976 6520 6675 6e63  f Objective func
-000057d0: 7469 6f6e 2066 6f72 2065 742c 2074 7773  tion for et, tws
-000057e0: 2061 6e64 2071 2e0a 0a20 2021 3e20 2020   and q...  !>   
-000057f0: 2020 2020 5c64 6574 6169 6c73 2054 6865      \details The
-00005800: 2066 6561 7475 7265 206f 6620 7468 6973   feature of this
-00005810: 206f 626a 6563 7469 7665 2066 756e 6374   objective funct
-00005820: 696f 6e20 6973 2074 6865 0a20 2021 3e20  ion is the.  !> 
-00005830: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-00005840: 6570 6172 6174 696f 6e20 6f66 2074 6865  eparation of the
-00005850: 2065 7661 6c20 6361 6c6c 2069 6e74 6f20   eval call into 
-00005860: 666f 7572 0a20 2021 3e20 2020 2020 2020  four.  !>       
-00005870: 2020 2020 2020 2020 2063 616c 6c73 2c20           calls, 
-00005880: 6561 6368 2077 6974 6820 616e 6f74 6865  each with anothe
-00005890: 7220 696e 6465 7820 6c69 7374 2e20 5468  r index list. Th
-000058a0: 6520 7375 6272 6f75 7469 6e65 2065 7661  e subroutine eva
-000058b0: 6c20 7468 656e 206f 6e6c 790a 2020 213e  l then only.  !>
-000058c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000058d0: 7573 6573 2074 6865 2069 6e64 6963 6573  uses the indices
-000058e0: 2066 726f 6d20 7468 6174 2069 6e64 6578   from that index
-000058f0: 206c 6973 7420 696e 7465 726e 616c 6c79   list internally
-00005900: 2069 6e73 7465 6164 206f 6620 6861 7669   instead of havi
-00005910: 6e67 206c 6f6f 7073 0a20 2021 3e20 2020  ng loops.  !>   
-00005920: 2020 2020 2020 2020 2020 2020 206f 7665               ove
-00005930: 7220 616c 6c20 646f 6d61 696e 732e 2054  r all domains. T
-00005940: 6865 2069 6e74 6567 6572 2061 7272 6179  he integer array
-00005950: 2064 6f6d 6169 6e4d 6574 6125 6f70 7469   domainMeta%opti
-00005960: 6461 7461 2064 6563 6964 6573 2077 6869  data decides whi
-00005970: 6368 0a20 2021 3e20 2020 2020 2020 2020  ch.  !>         
-00005980: 2020 2020 2020 2069 6e64 6963 6573 2074         indices t
-00005990: 6f20 7573 652e 2054 6865 7265 666f 7265  o use. Therefore
-000059a0: 2074 6865 2061 7272 6179 2069 7320 7370   the array is sp
-000059b0: 6c69 7420 696e 746f 2064 6973 6a75 6e63  lit into disjunc
-000059c0: 7420 7375 6273 6574 732c 2061 6e64 2c0a  t subsets, and,.
-000059d0: 2020 213e 2020 2020 2020 2020 2020 2020    !>            
-000059e0: 2020 2020 6966 2063 686f 7365 6e20 7769      if chosen wi
-000059f0: 7365 6c79 2069 6e20 7468 6520 6e61 6d65  sely in the name
-00005a00: 6c69 7374 2c20 616c 736f 2063 6f76 6572  list, also cover
-00005a10: 7320 616c 6c20 646f 6d61 696e 732e 0a20  s all domains.. 
-00005a20: 2021 3e0a 2020 213e 2020 2020 2020 2020   !>.  !>        
-00005a30: 2020 2020 2020 2020 5769 7468 2074 6869          With thi
-00005a40: 7320 7468 6520 6576 616c 2063 616c 6c73  s the eval calls
-00005a50: 2073 756d 2075 7020 696e 2061 2077 6179   sum up in a way
-00005a60: 2074 6861 7420 666f 7220 6561 6368 2064   that for each d
-00005a70: 6f6d 6169 6e20 6576 616c 2077 6173 0a20  omain eval was. 
-00005a80: 2021 3e20 2020 2020 2020 2020 2020 2020   !>             
-00005a90: 2020 2063 616c 6c65 6420 6174 206d 6f73     called at mos
-00005aa0: 7420 6f6e 6365 2c20 6275 7420 666f 7220  t once, but for 
-00005ab0: 6469 6666 6572 656e 7420 6f70 7469 5f64  different opti_d
-00005ac0: 6174 612e 0a0a 2020 2120 2020 2048 4953  ata...  !    HIS
-00005ad0: 544f 5259 0a20 2021 3e20 2020 2020 2020  TORY.  !>       
-00005ae0: 5c61 7574 686f 7273 204d 6172 656e 204b  \authors Maren K
-00005af0: 616c 757a 610a 0a20 2021 3e20 2020 2020  aluza..  !>     
-00005b00: 2020 5c64 6174 6520 4a75 6c79 2032 3031    \date July 201
-00005b10: 390a 0a20 2021 204d 6f64 6966 6963 6174  9..  ! Modificat
-00005b20: 696f 6e73 3a0a 0a20 2046 554e 4354 494f  ions:..  FUNCTIO
-00005b30: 4e20 6f62 6a65 6374 6976 655f 715f 6574  N objective_q_et
-00005b40: 5f74 7773 5f6b 6765 5f63 6174 6368 6d65  _tws_kge_catchme
-00005b50: 6e74 5f61 7667 2870 6172 616d 6574 6572  nt_avg(parameter
-00005b60: 7365 742c 2065 7661 6c29 0a0a 2020 2020  set, eval)..    
-00005b70: 7573 6520 6d6f 5f6f 7074 696d 697a 6174  use mo_optimizat
-00005b80: 696f 6e5f 7479 7065 732c 206f 6e6c 7920  ion_types, only 
-00005b90: 3a20 6f70 7469 6461 7461 5f73 696d 0a20  : optidata_sim. 
-00005ba0: 2020 2075 7365 206d 6f5f 636f 6d6d 6f6e     use mo_common
-00005bb0: 5f63 6f6e 7374 616e 7473 2c20 6f6e 6c79  _constants, only
-00005bc0: 203a 206e 6f64 6174 615f 6470 0a20 2020   : nodata_dp.   
-00005bd0: 2075 7365 206d 6f5f 636f 6d6d 6f6e 5f76   use mo_common_v
-00005be0: 6172 6961 626c 6573 2c20 6f6e 6c79 203a  ariables, only :
-00005bf0: 2064 6f6d 6169 6e4d 6574 610a 2020 2020   domainMeta.    
-00005c00: 7573 6520 6d6f 5f67 6c6f 6261 6c5f 7661  use mo_global_va
-00005c10: 7269 6162 6c65 732c 206f 6e6c 7920 3a20  riables, only : 
-00005c20: 4c31 5f65 744f 6273 2c20 4c31 5f74 7773  L1_etObs, L1_tws
-00005c30: 614f 6273 0a20 2020 2075 7365 206d 6f5f  aObs.    use mo_
-00005c40: 6572 726f 726d 6561 7375 7265 732c 206f  errormeasures, o
-00005c50: 6e6c 7920 3a20 6b67 650a 2020 2020 7573  nly : kge.    us
-00005c60: 6520 6d6f 5f6d 6573 7361 6765 2c20 6f6e  e mo_message, on
-00005c70: 6c79 203a 206d 6573 7361 6765 0a20 2020  ly : message.   
-00005c80: 2075 7365 206d 6f5f 6d6f 6d65 6e74 2c20   use mo_moment, 
-00005c90: 6f6e 6c79 203a 2061 7665 7261 6765 0a20  only : average. 
-00005ca0: 2020 2075 7365 206d 6f5f 7374 7269 6e67     use mo_string
-00005cb0: 5f75 7469 6c73 2c20 6f6e 6c79 203a 206e  _utils, only : n
-00005cc0: 756d 3273 7472 0a20 2020 2075 7365 206d  um2str.    use m
-00005cd0: 6f5f 6d72 6d5f 6f62 6a65 6374 6976 655f  o_mrm_objective_
-00005ce0: 6675 6e63 7469 6f6e 5f72 756e 6f66 662c  function_runoff,
-00005cf0: 206f 6e6c 7920 3a20 6578 7472 6163 745f   only : extract_
-00005d00: 7275 6e6f 6666 0a0a 2020 2020 696d 706c  runoff..    impl
-00005d10: 6963 6974 206e 6f6e 650a 0a20 2020 2021  icit none..    !
-00005d20: 3e20 7468 6520 7061 7261 6d65 7465 7273  > the parameters
-00005d30: 6574 2070 6173 7365 6420 746f 2074 6865  et passed to the
-00005d40: 2065 7661 6c20 7375 6272 6f75 7469 6e65   eval subroutine
-00005d50: 0a20 2020 2072 6561 6c28 6470 292c 2064  .    real(dp), d
-00005d60: 696d 656e 7369 6f6e 283a 292c 2069 6e74  imension(:), int
-00005d70: 656e 7428 696e 2920 3a3a 2070 6172 616d  ent(in) :: param
-00005d80: 6574 6572 7365 740a 2020 2020 213e 2074  eterset.    !> t
-00005d90: 6865 2065 7661 6c20 7375 6272 6f75 7469  he eval subrouti
-00005da0: 6e65 2063 616c 6c65 6420 6279 2074 6869  ne called by thi
-00005db0: 7320 6f62 6a65 6374 6976 6520 6675 6e63  s objective func
-00005dc0: 7469 6f6e 0a20 2020 2070 726f 6365 6475  tion.    procedu
-00005dd0: 7265 2865 7661 6c5f 696e 7465 7266 6163  re(eval_interfac
-00005de0: 6529 2c20 494e 5445 4e54 2849 4e29 2c20  e), INTENT(IN), 
-00005df0: 504f 494e 5445 5220 3a3a 2065 7661 6c0a  POINTER :: eval.
-00005e00: 2020 2020 213e 2074 6865 2072 6574 7572      !> the retur
-00005e10: 6e20 7661 6c75 6520 6f66 2074 6865 206f  n value of the o
-00005e20: 626a 6563 7469 7665 2066 756e 6374 696f  bjective functio
-00005e30: 6e2e 2049 6e20 7468 6973 2063 6173 6520  n. In this case 
-00005e40: 6974 2069 730a 2020 2020 213e 2061 6e20  it is.    !> an 
-00005e50: 6172 7261 7920 746f 2070 726f 7669 6465  array to provide
-00005e60: 2074 6865 2070 6f73 7369 6269 6c69 7479   the possibility
-00005e70: 2074 6f20 7765 6967 6874 2074 6865 206f   to weight the o
-00005e80: 7574 636f 6d65 2061 6363 6f72 6469 6e67  utcome according
-00005e90: 6c79 0a20 2020 2072 6561 6c28 6470 292c  ly.    real(dp),
-00005ea0: 2064 696d 656e 7369 6f6e 2836 2920 3a3a   dimension(6) ::
-00005eb0: 206f 626a 6563 7469 7665 5f71 5f65 745f   objective_q_et_
-00005ec0: 7477 735f 6b67 655f 6361 7463 686d 656e  tws_kge_catchmen
-00005ed0: 745f 6176 670a 0a20 2020 2021 3e20 646f  t_avg..    !> do
-00005ee0: 6d61 696e 206c 6f6f 7020 636f 756e 7465  main loop counte
-00005ef0: 720a 2020 2020 696e 7465 6765 7228 6934  r.    integer(i4
-00005f00: 2920 3a3a 2069 446f 6d61 696e 0a0a 2020  ) :: iDomain..  
-00005f10: 2020 213e 2063 6f75 6e74 6572 2066 6f72    !> counter for
-00005f20: 2073 686f 7274 206c 6f6f 7073 0a20 2020   short loops.   
-00005f30: 2069 6e74 6567 6572 2869 3429 203a 3a20   integer(i4) :: 
-00005f40: 690a 2369 666e 6465 6620 4d50 490a 2020  i.#ifndef MPI.  
-00005f50: 2020 213e 2066 6f72 2073 6978 7468 2072    !> for sixth r
-00005f60: 6f6f 740a 2020 2020 7265 616c 2864 7029  oot.    real(dp)
-00005f70: 2c20 7061 7261 6d65 7465 7220 3a3a 206f  , parameter :: o
-00005f80: 6e65 7369 7874 6820 3d20 312e 305f 6470  nesixth = 1.0_dp
-00005f90: 202f 2036 2e30 5f64 700a 2365 6e64 6966   / 6.0_dp.#endif
-00005fa0: 0a0a 2020 2020 213e 206d 6f64 656c 6c65  ..    !> modelle
-00005fb0: 6420 7275 6e6f 6666 2066 6f72 2061 2067  d runoff for a g
-00005fc0: 6976 656e 2070 6172 616d 6574 6572 2073  iven parameter s
-00005fd0: 6574 0a20 2020 2021 2064 696d 313d 6e54  et.    ! dim1=nT
-00005fe0: 696d 6553 7465 7073 2c20 6469 6d32 3d6e  imeSteps, dim2=n
-00005ff0: 4761 7567 6573 0a20 2020 2072 6561 6c28  Gauges.    real(
-00006000: 6470 292c 2061 6c6c 6f63 6174 6162 6c65  dp), allocatable
-00006010: 2c20 6469 6d65 6e73 696f 6e28 3a2c 203a  , dimension(:, :
-00006020: 2920 3a3a 2072 756e 6f66 660a 2020 2020  ) :: runoff.    
-00006030: 213e 206e 756d 6265 7220 6f66 2061 6c6c  !> number of all
-00006040: 2067 6175 6765 732c 2061 7175 6972 6564   gauges, aquired
-00006050: 2076 6961 2072 756e 6f66 660a 2020 2020   via runoff.    
-00006060: 696e 7465 6765 7228 6934 2920 3a3a 206e  integer(i4) :: n
-00006070: 4761 7567 6573 546f 7461 6c0a 0a20 2020  GaugesTotal..   
-00006080: 2021 3e20 6167 6772 6567 6174 6564 2073   !> aggregated s
-00006090: 696d 756c 6174 6564 2072 756e 6f66 660a  imulated runoff.
-000060a0: 2020 2020 7265 616c 2864 7029 2c20 6469      real(dp), di
-000060b0: 6d65 6e73 696f 6e28 3a29 2c20 616c 6c6f  mension(:), allo
-000060c0: 6361 7461 626c 6520 3a3a 2072 756e 6f66  catable :: runof
-000060d0: 665f 6167 670a 0a20 2020 2021 3e20 6d65  f_agg..    !> me
-000060e0: 6173 7572 6564 2072 756e 6f66 660a 2020  asured runoff.  
-000060f0: 2020 7265 616c 2864 7029 2c20 6469 6d65    real(dp), dime
-00006100: 6e73 696f 6e28 3a29 2c20 616c 6c6f 6361  nsion(:), alloca
-00006110: 7461 626c 6520 3a3a 2072 756e 6f66 665f  table :: runoff_
-00006120: 6f62 730a 0a20 2020 2021 3e20 6d61 736b  obs..    !> mask
-00006130: 2066 6f72 206d 6561 7375 7265 6420 7275   for measured ru
-00006140: 6e6f 6666 0a20 2020 206c 6f67 6963 616c  noff.    logical
-00006150: 2c20 6469 6d65 6e73 696f 6e28 3a29 2c20  , dimension(:), 
-00006160: 616c 6c6f 6361 7461 626c 6520 3a3a 2072  allocatable :: r
-00006170: 756e 6f66 665f 6f62 735f 6d61 736b 0a0a  unoff_obs_mask..
-00006180: 2020 2020 213e 206b 6765 5f71 286e 4761      !> kge_q(nGa
-00006190: 7567 6573 546f 7461 6c29 0a20 2020 2072  ugesTotal).    r
-000061a0: 6561 6c28 6470 2920 3a3a 206b 6765 5f71  eal(dp) :: kge_q
-000061b0: 0a0a 2020 2020 213e 2067 6175 6765 7320  ..    !> gauges 
-000061c0: 636f 756e 7465 720a 2020 2020 696e 7465  counter.    inte
-000061d0: 6765 7228 6934 2920 3a3a 2067 672c 2069  ger(i4) :: gg, i
-000061e0: 4365 6c6c 0a0a 2020 2020 213e 206e 756d  Cell..    !> num
-000061f0: 6265 7220 6f66 2071 2064 6f6d 6169 6e73  ber of q domains
-00006200: 0a20 2020 2069 6e74 6567 6572 2869 3429  .    integer(i4)
-00006210: 203a 3a20 6e51 446f 6d61 696e 730a 0a20   :: nQDomains.. 
-00006220: 2020 2021 3e20 6e75 6d62 6572 206f 6620     !> number of 
-00006230: 6574 2064 6f6d 6169 6e73 0a20 2020 2069  et domains.    i
-00006240: 6e74 6567 6572 2869 3429 203a 3a20 6e45  nteger(i4) :: nE
-00006250: 7444 6f6d 6169 6e73 0a0a 2020 2020 213e  tDomains..    !>
-00006260: 206e 756d 6265 7220 6f66 2074 7773 2064   number of tws d
-00006270: 6f6d 6169 6e73 0a20 2020 2069 6e74 6567  omains.    integ
-00006280: 6572 2869 3429 203a 3a20 6e54 7773 446f  er(i4) :: nTwsDo
-00006290: 6d61 696e 730a 0a20 2020 2021 3e20 6e75  mains..    !> nu
-000062a0: 6d62 6572 206f 6620 5457 5320 616e 6420  mber of TWS and 
-000062b0: 4554 2064 6f6d 6169 6e73 2028 7072 6f76  ET domains (prov
-000062c0: 6964 696e 6720 626f 7468 290a 2020 2020  iding both).    
-000062d0: 696e 7465 6765 7228 6934 2920 3a3a 206e  integer(i4) :: n
-000062e0: 4574 5477 7344 6f6d 6169 6e73 0a0a 2020  EtTwsDomains..  
-000062f0: 2020 213e 2069 6e64 6578 2061 7272 6179    !> index array
-00006300: 206f 6620 4554 2064 6f6d 6169 6e73 0a20   of ET domains. 
-00006310: 2020 2069 6e74 6567 6572 2869 3429 2c20     integer(i4), 
-00006320: 6469 6d65 6e73 696f 6e28 3a29 2c20 616c  dimension(:), al
-00006330: 6c6f 6361 7461 626c 6520 3a3a 206f 7074  locatable :: opt
-00006340: 695f 646f 6d61 696e 5f69 6e64 6963 6573  i_domain_indices
-00006350: 5f45 540a 0a20 2020 2021 3e20 696e 6465  _ET..    !> inde
-00006360: 7820 6172 7261 7920 6f66 2054 5753 2064  x array of TWS d
-00006370: 6f6d 6169 6e73 0a20 2020 2069 6e74 6567  omains.    integ
-00006380: 6572 2869 3429 2c20 6469 6d65 6e73 696f  er(i4), dimensio
-00006390: 6e28 3a29 2c20 616c 6c6f 6361 7461 626c  n(:), allocatabl
-000063a0: 6520 3a3a 206f 7074 695f 646f 6d61 696e  e :: opti_domain
-000063b0: 5f69 6e64 6963 6573 5f54 5753 0a0a 2020  _indices_TWS..  
-000063c0: 2020 213e 2069 6e64 6578 2061 7272 6179    !> index array
-000063d0: 206f 6620 5457 5320 616e 6420 4554 2064   of TWS and ET d
-000063e0: 6f6d 6169 6e73 2028 7072 6f76 6964 696e  omains (providin
-000063f0: 6720 626f 7468 290a 2020 2020 696e 7465  g both).    inte
-00006400: 6765 7228 6934 292c 2064 696d 656e 7369  ger(i4), dimensi
-00006410: 6f6e 283a 292c 2061 6c6c 6f63 6174 6162  on(:), allocatab
-00006420: 6c65 203a 3a20 6f70 7469 5f64 6f6d 6169  le :: opti_domai
-00006430: 6e5f 696e 6469 6365 735f 4554 5f54 5753  n_indices_ET_TWS
-00006440: 0a0a 2020 2020 213e 2069 6e64 6578 2061  ..    !> index a
-00006450: 7272 6179 206f 6620 4554 2064 6f6d 6169  rray of ET domai
-00006460: 6e73 0a20 2020 2069 6e74 6567 6572 2869  ns.    integer(i
-00006470: 3429 2c20 6469 6d65 6e73 696f 6e28 3a29  4), dimension(:)
-00006480: 2c20 616c 6c6f 6361 7461 626c 6520 3a3a  , allocatable ::
-00006490: 206f 7074 695f 646f 6d61 696e 5f69 6e64   opti_domain_ind
-000064a0: 6963 6573 5f51 0a0a 2020 2020 213e 2073  ices_Q..    !> s
-000064b0: 696d 756c 6174 6564 2065 740a 2020 2020  imulated et.    
-000064c0: 7479 7065 286f 7074 6964 6174 615f 7369  type(optidata_si
-000064d0: 6d29 2c20 6469 6d65 6e73 696f 6e28 3a29  m), dimension(:)
-000064e0: 2c20 616c 6c6f 6361 7461 626c 6520 3a3a  , allocatable ::
-000064f0: 2065 744f 7074 6953 696d 0a0a 2020 2020   etOptiSim..    
-00006500: 213e 2073 696d 756c 6174 6564 2074 7773  !> simulated tws
-00006510: 0a20 2020 2074 7970 6528 6f70 7469 6461  .    type(optida
-00006520: 7461 5f73 696d 292c 2064 696d 656e 7369  ta_sim), dimensi
-00006530: 6f6e 283a 292c 2061 6c6c 6f63 6174 6162  on(:), allocatab
-00006540: 6c65 203a 3a20 7477 734f 7074 6953 696d  le :: twsOptiSim
-00006550: 0a0a 2020 2020 213e 2073 696d 756c 6174  ..    !> simulat
-00006560: 6564 2074 7773 6120 2861 6e6f 6d61 6c79  ed twsa (anomaly
-00006570: 290a 2020 2020 7479 7065 286f 7074 6964  ).    type(optid
-00006580: 6174 615f 7369 6d29 2c20 6469 6d65 6e73  ata_sim), dimens
-00006590: 696f 6e28 3a29 2c20 616c 6c6f 6361 7461  ion(:), allocata
-000065a0: 626c 6520 3a3a 2074 7773 614f 7074 6953  ble :: twsaOptiS
-000065b0: 696d 0a0a 2020 2020 7265 616c 2864 7029  im..    real(dp)
-000065c0: 203a 3a20 6b67 655f 7477 730a 0a20 2020   :: kge_tws..   
-000065d0: 2072 6561 6c28 6470 2920 3a3a 206b 6765   real(dp) :: kge
-000065e0: 5f65 740a 0a20 2020 2069 6e74 6567 6572  _et..    integer
-000065f0: 2869 3429 203a 3a20 6e75 6d62 6572 4f66  (i4) :: numberOf
-00006600: 5375 6d6d 616e 6473 0a0a 0a20 2020 2021  Summands...    !
-00006610: 2069 6e69 7469 616c 697a 6520 736f 6d65   initialize some
-00006620: 2076 6172 6961 626c 6573 0a20 2020 206f   variables.    o
-00006630: 626a 6563 7469 7665 5f71 5f65 745f 7477  bjective_q_et_tw
-00006640: 735f 6b67 655f 6361 7463 686d 656e 745f  s_kge_catchment_
-00006650: 6176 6728 3a29 203d 2030 2e30 5f64 700a  avg(:) = 0.0_dp.
-00006660: 2020 2020 6b67 655f 7477 7320 3d20 302e      kge_tws = 0.
-00006670: 305f 6470 0a20 2020 206b 6765 5f65 7420  0_dp.    kge_et 
-00006680: 3d20 302e 305f 6470 0a20 2020 206b 6765  = 0.0_dp.    kge
-00006690: 5f71 203d 2030 2e30 5f64 700a 2020 2020  _q = 0.0_dp.    
-000066a0: 6e75 6d62 6572 4f66 5375 6d6d 616e 6473  numberOfSummands
-000066b0: 203d 2030 0a20 2020 2021 2d2d 2d2d 2d2d   = 0.    !------
-000066c0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000066d0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000066e0: 2d2d 2d2d 2d2d 0a20 2020 2021 2045 5420  ------.    ! ET 
-000066f0: 2620 5457 530a 2020 2020 212d 2d2d 2d2d  & TWS.    !-----
-00006700: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00006710: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00006720: 2d2d 2d2d 2d2d 2d0a 2020 2020 2120 6576  -------.    ! ev
-00006730: 616c 2072 756e 7320 746f 2067 6574 2073  al runs to get s
-00006740: 696d 756c 6174 6564 206f 7574 7075 7420  imulated output 
-00006750: 666f 7220 6574 2061 6e64 2074 7773 0a20  for et and tws. 
-00006760: 2020 2021 2062 6566 6f72 6520 6561 6368     ! before each
-00006770: 2065 7661 6c20 6361 6c6c 2077 6520 6765   eval call we ge
-00006780: 6e65 7261 7465 2061 6e20 696e 6465 7820  nerate an index 
-00006790: 6c69 7374 206f 6620 7468 6520 646f 6d61  list of the doma
-000067a0: 696e 7320 666f 7220 7768 6963 680a 2020  ins for which.  
-000067b0: 2020 2120 6576 616c 2073 686f 756c 6420    ! eval should 
-000067c0: 6265 2063 616c 6c65 642e 2052 6561 6420  be called. Read 
-000067d0: 6465 7461 696c 7320 666f 7220 6675 7274  details for furt
-000067e0: 6865 7220 696e 666f 726d 6174 696f 6e0a  her information.
-000067f0: 2020 2020 6361 6c6c 2069 6e69 745f 696e      call init_in
-00006800: 6465 7861 7272 6179 5f66 6f72 5f6f 7074  dexarray_for_opt
-00006810: 695f 6461 7461 2864 6f6d 6169 6e4d 6574  i_data(domainMet
-00006820: 612c 2036 2c20 6e45 7454 7773 446f 6d61  a, 6, nEtTwsDoma
-00006830: 696e 732c 206f 7074 695f 646f 6d61 696e  ins, opti_domain
-00006840: 5f69 6e64 6963 6573 5f45 545f 5457 5329  _indices_ET_TWS)
-00006850: 0a20 2020 2069 6620 286e 4574 5477 7344  .    if (nEtTwsD
-00006860: 6f6d 6169 6e73 203e 2030 2920 7468 656e  omains > 0) then
-00006870: 0a20 2020 2020 2061 6c6c 6f63 6174 6528  .      allocate(
-00006880: 2065 744f 7074 6953 696d 2864 6f6d 6169   etOptiSim(domai
-00006890: 6e4d 6574 6125 6e44 6f6d 6169 6e73 2929  nMeta%nDomains))
-000068a0: 0a20 2020 2020 2061 6c6c 6f63 6174 6528  .      allocate(
-000068b0: 7477 734f 7074 6953 696d 2864 6f6d 6169  twsOptiSim(domai
-000068c0: 6e4d 6574 6125 6e44 6f6d 6169 6e73 2929  nMeta%nDomains))
-000068d0: 0a20 2020 2020 2061 6c6c 6f63 6174 6528  .      allocate(
-000068e0: 7477 7361 4f70 7469 5369 6d28 646f 6d61  twsaOptiSim(doma
-000068f0: 696e 4d65 7461 256e 446f 6d61 696e 7329  inMeta%nDomains)
-00006900: 290a 2020 2020 2020 6361 6c6c 2065 7661  ).      call eva
-00006910: 6c28 7061 7261 6d65 7465 7273 6574 2c20  l(parameterset, 
-00006920: 6f70 7469 5f64 6f6d 6169 6e5f 696e 6469  opti_domain_indi
-00006930: 6365 7320 3d20 6f70 7469 5f64 6f6d 6169  ces = opti_domai
-00006940: 6e5f 696e 6469 6365 735f 4554 5f54 5753  n_indices_ET_TWS
-00006950: 2c20 260a 2020 2020 2020 2020 2020 2020  , &.            
-00006960: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006970: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006980: 2020 2020 2074 7773 4f70 7469 5369 6d20       twsOptiSim 
-00006990: 3d20 7477 734f 7074 6953 696d 2c20 6574  = twsOptiSim, et
-000069a0: 4f70 7469 5369 6d20 3d20 6574 4f70 7469  OptiSim = etOpti
-000069b0: 5369 6d29 0a20 2020 2020 2021 2066 6f72  Sim).      ! for
-000069c0: 2061 6c6c 2064 6f6d 6169 6e73 2074 6861   all domains tha
-000069d0: 7420 6861 7665 2045 5420 616e 6420 5457  t have ET and TW
-000069e0: 530a 2020 2020 2020 646f 2069 203d 2031  S.      do i = 1
-000069f0: 2c20 7369 7a65 286f 7074 695f 646f 6d61  , size(opti_doma
-00006a00: 696e 5f69 6e64 6963 6573 5f45 545f 5457  in_indices_ET_TW
-00006a10: 5329 0a20 2020 2020 2020 2069 446f 6d61  S).        iDoma
-00006a20: 696e 203d 206f 7074 695f 646f 6d61 696e  in = opti_domain
-00006a30: 5f69 6e64 6963 6573 5f45 545f 5457 5328  _indices_ET_TWS(
-00006a40: 6929 0a20 2020 2020 2020 2063 616c 6c20  i).        call 
-00006a50: 636f 6e76 6572 745f 7477 735f 746f 5f74  convert_tws_to_t
-00006a60: 7773 6128 7477 734f 7074 6953 696d 2869  wsa(twsOptiSim(i
-00006a70: 446f 6d61 696e 292c 204c 315f 7477 7361  Domain), L1_twsa
-00006a80: 4f62 7328 6944 6f6d 6169 6e29 2c20 7477  Obs(iDomain), tw
-00006a90: 7361 4f70 7469 5369 6d28 6944 6f6d 6169  saOptiSim(iDomai
-00006aa0: 6e29 290a 2020 2020 2020 2020 646f 2069  n)).        do i
-00006ab0: 4365 6c6c 203d 2031 2c20 7369 7a65 284c  Cell = 1, size(L
-00006ac0: 315f 6574 4f62 7328 6944 6f6d 6169 6e29  1_etObs(iDomain)
-00006ad0: 256d 6173 6b4f 6273 283a 2c20 3a29 2c20  %maskObs(:, :), 
-00006ae0: 6469 6d20 3d20 3129 0a20 2020 2020 2020  dim = 1).       
-00006af0: 2020 206b 6765 5f65 7420 3d20 6b67 655f     kge_et = kge_
-00006b00: 6574 202b 2026 0a20 2020 2020 2020 2020  et + &.         
-00006b10: 2020 2028 312e 305f 6470 202d 204b 4745     (1.0_dp - KGE
-00006b20: 284c 315f 6574 4f62 7328 6944 6f6d 6169  (L1_etObs(iDomai
-00006b30: 6e29 2564 6174 614f 6273 2869 4365 6c6c  n)%dataObs(iCell
-00006b40: 2c20 3a29 2c20 6574 4f70 7469 5369 6d28  , :), etOptiSim(
-00006b50: 6944 6f6d 6169 6e29 2564 6174 6153 696d  iDomain)%dataSim
-00006b60: 2869 4365 6c6c 2c20 3a29 2c26 0a20 2020  (iCell, :),&.   
-00006b70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006b80: 2020 2020 2020 2020 6d61 736b 203d 204c          mask = L
-00006b90: 315f 6574 4f62 7328 6944 6f6d 6169 6e29  1_etObs(iDomain)
-00006ba0: 256d 6173 6b4f 6273 2869 4365 6c6c 2c20  %maskObs(iCell, 
-00006bb0: 3a29 2929 2a2a 360a 2020 2020 2020 2020  :)))**6.        
-00006bc0: 2020 6e75 6d62 6572 4f66 5375 6d6d 616e    numberOfSumman
-00006bd0: 6473 203d 206e 756d 6265 724f 6653 756d  ds = numberOfSum
-00006be0: 6d61 6e64 7320 2b20 310a 2020 2020 2020  mands + 1.      
-00006bf0: 2020 656e 6420 646f 0a20 2020 2020 2020    end do.       
-00006c00: 2064 6f20 6943 656c 6c20 3d20 312c 2073   do iCell = 1, s
-00006c10: 697a 6528 4c31 5f74 7773 614f 6273 2869  ize(L1_twsaObs(i
-00006c20: 446f 6d61 696e 2925 6d61 736b 4f62 7328  Domain)%maskObs(
-00006c30: 3a2c 203a 292c 2064 696d 203d 2031 290a  :, :), dim = 1).
-00006c40: 2020 2020 2020 2020 2020 6b67 655f 7477            kge_tw
-00006c50: 7320 3d20 6b67 655f 7477 7320 2b20 260a  s = kge_tws + &.
-00006c60: 2020 2020 2020 2020 2020 2020 2831 2e30              (1.0
-00006c70: 5f64 7020 2d20 4b47 4528 4c31 5f74 7773  _dp - KGE(L1_tws
-00006c80: 614f 6273 2869 446f 6d61 696e 2925 6461  aObs(iDomain)%da
-00006c90: 7461 4f62 7328 6943 656c 6c2c 203a 292c  taObs(iCell, :),
-00006ca0: 2074 7773 614f 7074 6953 696d 2869 446f   twsaOptiSim(iDo
-00006cb0: 6d61 696e 2925 6461 7461 5369 6d28 6943  main)%dataSim(iC
-00006cc0: 656c 6c2c 203a 292c 260a 2020 2020 2020  ell, :),&.      
-00006cd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006ce0: 2020 2020 206d 6173 6b20 3d20 4c31 5f74       mask = L1_t
-00006cf0: 7773 614f 6273 2869 446f 6d61 696e 2925  wsaObs(iDomain)%
-00006d00: 6d61 736b 4f62 7328 6943 656c 6c2c 203a  maskObs(iCell, :
-00006d10: 2929 292a 2a36 0a20 2020 2020 2020 2020  )))**6.         
-00006d20: 206e 756d 6265 724f 6653 756d 6d61 6e64   numberOfSummand
-00006d30: 7320 3d20 6e75 6d62 6572 4f66 5375 6d6d  s = numberOfSumm
-00006d40: 616e 6473 202b 2031 0a20 2020 2020 2020  ands + 1.       
-00006d50: 2065 6e64 2064 6f0a 2020 2020 2020 2020   end do.        
-00006d60: 2120 6465 616c 6c6f 6361 7465 0a20 2020  ! deallocate.   
-00006d70: 2020 2020 2063 616c 6c20 6574 4f70 7469       call etOpti
-00006d80: 5369 6d28 6944 6f6d 6169 6e29 2564 6573  Sim(iDomain)%des
-00006d90: 7472 6f79 2829 0a20 2020 2020 2020 2063  troy().        c
-00006da0: 616c 6c20 7477 734f 7074 6953 696d 2869  all twsOptiSim(i
-00006db0: 446f 6d61 696e 2925 6465 7374 726f 7928  Domain)%destroy(
-00006dc0: 290a 2020 2020 2020 2020 6361 6c6c 2074  ).        call t
-00006dd0: 7773 614f 7074 6953 696d 2869 446f 6d61  wsaOptiSim(iDoma
-00006de0: 696e 2925 6465 7374 726f 7928 290a 2020  in)%destroy().  
-00006df0: 2020 2020 656e 6420 646f 0a20 2020 2020      end do.     
-00006e00: 2064 6561 6c6c 6f63 6174 6528 6574 4f70   deallocate(etOp
-00006e10: 7469 5369 6d29 0a20 2020 2020 2064 6561  tiSim).      dea
-00006e20: 6c6c 6f63 6174 6528 7477 734f 7074 6953  llocate(twsOptiS
-00006e30: 696d 290a 2020 2020 2020 6465 616c 6c6f  im).      deallo
-00006e40: 6361 7465 2874 7773 614f 7074 6953 696d  cate(twsaOptiSim
-00006e50: 290a 2020 2020 2021 2077 7269 7465 2830  ).     ! write(0
-00006e60: 2c2a 2920 276e 4574 5477 7344 6f6d 6169  ,*) 'nEtTwsDomai
-00006e70: 6e73 2c20 6b67 655f 7477 7327 2c20 6e45  ns, kge_tws', nE
-00006e80: 7454 7773 446f 6d61 696e 732c 206b 6765  tTwsDomains, kge
-00006e90: 5f74 7773 0a20 2020 2020 2120 7772 6974  _tws.     ! writ
-00006ea0: 6528 302c 2a29 2027 6e45 7454 7773 446f  e(0,*) 'nEtTwsDo
-00006eb0: 6d61 696e 732c 206b 6765 5f65 7427 2c20  mains, kge_et', 
-00006ec0: 6e45 7454 7773 446f 6d61 696e 732c 206b  nEtTwsDomains, k
-00006ed0: 6765 5f65 740a 2020 2020 656e 6420 6966  ge_et.    end if
-00006ee0: 0a20 2020 2021 2d2d 2d2d 2d2d 2d2d 2d2d  .    !----------
-00006ef0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00006f00: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00006f10: 2d2d 0a20 2020 2021 2054 5753 0a20 2020  --.    ! TWS.   
-00006f20: 2021 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d   !--------------
-00006f30: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00006f40: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a20  --------------. 
-00006f50: 2020 2021 2065 7661 6c20 7275 6e73 2074     ! eval runs t
-00006f60: 6f20 6765 7420 7369 6d75 6c61 7465 6420  o get simulated 
-00006f70: 6f75 7470 7574 2066 6f72 2074 7773 0a20  output for tws. 
-00006f80: 2020 2021 2062 6566 6f72 6520 6561 6368     ! before each
-00006f90: 2065 7661 6c20 6361 6c6c 2077 6520 6765   eval call we ge
-00006fa0: 6e65 7261 7465 2061 6e20 696e 6465 7820  nerate an index 
-00006fb0: 6c69 7374 206f 6620 7468 6520 646f 6d61  list of the doma
-00006fc0: 696e 7320 666f 7220 7768 6963 680a 2020  ins for which.  
-00006fd0: 2020 2120 6576 616c 2073 686f 756c 6420    ! eval should 
-00006fe0: 6265 2063 616c 6c65 642e 2052 6561 6420  be called. Read 
-00006ff0: 6465 7461 696c 7320 666f 7220 6675 7274  details for furt
-00007000: 6865 7220 696e 666f 726d 6174 696f 6e0a  her information.
-00007010: 2020 2020 6361 6c6c 2069 6e69 745f 696e      call init_in
-00007020: 6465 7861 7272 6179 5f66 6f72 5f6f 7074  dexarray_for_opt
-00007030: 695f 6461 7461 2864 6f6d 6169 6e4d 6574  i_data(domainMet
-00007040: 612c 2033 2c20 6e54 7773 446f 6d61 696e  a, 3, nTwsDomain
-00007050: 732c 206f 7074 695f 646f 6d61 696e 5f69  s, opti_domain_i
-00007060: 6e64 6963 6573 5f54 5753 290a 2020 2020  ndices_TWS).    
-00007070: 6966 2028 6e54 7773 446f 6d61 696e 7320  if (nTwsDomains 
-00007080: 3e20 3029 2074 6865 6e0a 2020 2020 2020  > 0) then.      
-00007090: 616c 6c6f 6361 7465 2874 7773 4f70 7469  allocate(twsOpti
-000070a0: 5369 6d28 646f 6d61 696e 4d65 7461 256e  Sim(domainMeta%n
-000070b0: 446f 6d61 696e 7329 290a 2020 2020 2020  Domains)).      
-000070c0: 616c 6c6f 6361 7465 2874 7773 614f 7074  allocate(twsaOpt
-000070d0: 6953 696d 2864 6f6d 6169 6e4d 6574 6125  iSim(domainMeta%
-000070e0: 6e44 6f6d 6169 6e73 2929 0a20 2020 2020  nDomains)).     
-000070f0: 2063 616c 6c20 6576 616c 2870 6172 616d   call eval(param
-00007100: 6574 6572 7365 742c 206f 7074 695f 646f  eterset, opti_do
-00007110: 6d61 696e 5f69 6e64 6963 6573 203d 206f  main_indices = o
-00007120: 7074 695f 646f 6d61 696e 5f69 6e64 6963  pti_domain_indic
-00007130: 6573 5f54 5753 2c20 7477 734f 7074 6953  es_TWS, twsOptiS
-00007140: 696d 203d 2074 7773 4f70 7469 5369 6d29  im = twsOptiSim)
-00007150: 0a20 2020 2020 2021 2066 6f72 2061 6c6c  .      ! for all
-00007160: 2064 6f6d 6169 6e73 2074 6861 7420 6861   domains that ha
-00007170: 7665 2045 5420 616e 6420 5457 530a 2020  ve ET and TWS.  
-00007180: 2020 2020 646f 2069 203d 2031 2c20 7369      do i = 1, si
-00007190: 7a65 286f 7074 695f 646f 6d61 696e 5f69  ze(opti_domain_i
-000071a0: 6e64 6963 6573 5f54 5753 290a 2020 2020  ndices_TWS).    
-000071b0: 2020 2020 6944 6f6d 6169 6e20 3d20 6f70      iDomain = op
-000071c0: 7469 5f64 6f6d 6169 6e5f 696e 6469 6365  ti_domain_indice
-000071d0: 735f 5457 5328 6929 0a20 2020 2020 2020  s_TWS(i).       
-000071e0: 2063 616c 6c20 636f 6e76 6572 745f 7477   call convert_tw
-000071f0: 735f 746f 5f74 7773 6128 7477 734f 7074  s_to_twsa(twsOpt
-00007200: 6953 696d 2869 446f 6d61 696e 292c 204c  iSim(iDomain), L
-00007210: 315f 7477 7361 4f62 7328 6944 6f6d 6169  1_twsaObs(iDomai
-00007220: 6e29 2c20 7477 7361 4f70 7469 5369 6d28  n), twsaOptiSim(
-00007230: 6944 6f6d 6169 6e29 290a 2020 2020 2020  iDomain)).      
-00007240: 2020 646f 2069 4365 6c6c 203d 2031 2c20    do iCell = 1, 
-00007250: 7369 7a65 284c 315f 7477 7361 4f62 7328  size(L1_twsaObs(
-00007260: 6944 6f6d 6169 6e29 256d 6173 6b4f 6273  iDomain)%maskObs
-00007270: 283a 2c20 3a29 2c20 6469 6d20 3d20 3129  (:, :), dim = 1)
-00007280: 0a20 2020 2020 2020 2020 206b 6765 5f74  .          kge_t
-00007290: 7773 203d 206b 6765 5f74 7773 202b 2026  ws = kge_tws + &
-000072a0: 0a20 2020 2020 2020 2020 2020 2028 312e  .            (1.
-000072b0: 305f 6470 202d 204b 4745 284c 315f 7477  0_dp - KGE(L1_tw
-000072c0: 7361 4f62 7328 6944 6f6d 6169 6e29 2564  saObs(iDomain)%d
-000072d0: 6174 614f 6273 2869 4365 6c6c 2c20 3a29  ataObs(iCell, :)
-000072e0: 2c20 7477 7361 4f70 7469 5369 6d28 6944  , twsaOptiSim(iD
-000072f0: 6f6d 6169 6e29 2564 6174 6153 696d 2869  omain)%dataSim(i
-00007300: 4365 6c6c 2c20 3a29 2c26 0a20 2020 2020  Cell, :),&.     
-00007310: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007320: 2020 2020 2020 6d61 736b 203d 204c 315f        mask = L1_
-00007330: 7477 7361 4f62 7328 6944 6f6d 6169 6e29  twsaObs(iDomain)
-00007340: 256d 6173 6b4f 6273 2869 4365 6c6c 2c20  %maskObs(iCell, 
-00007350: 3a29 2929 2a2a 360a 2020 2020 2020 2020  :)))**6.        
-00007360: 2020 6e75 6d62 6572 4f66 5375 6d6d 616e    numberOfSumman
-00007370: 6473 203d 206e 756d 6265 724f 6653 756d  ds = numberOfSum
-00007380: 6d61 6e64 7320 2b20 310a 2020 2020 2020  mands + 1.      
-00007390: 2020 656e 6420 646f 0a20 2020 2020 2020    end do.       
-000073a0: 2063 616c 6c20 7477 734f 7074 6953 696d   call twsOptiSim
-000073b0: 2869 446f 6d61 696e 2925 6465 7374 726f  (iDomain)%destro
-000073c0: 7928 290a 2020 2020 2020 656e 6420 646f  y().      end do
-000073d0: 0a20 2020 2020 2064 6561 6c6c 6f63 6174  .      deallocat
-000073e0: 6528 7477 734f 7074 6953 696d 290a 2020  e(twsOptiSim).  
-000073f0: 2020 2120 2077 7269 7465 2830 2c2a 2920    !  write(0,*) 
-00007400: 276e 5477 7344 6f6d 6169 6e73 2c20 6b67  'nTwsDomains, kg
-00007410: 655f 7477 7327 2c20 6e54 7773 446f 6d61  e_tws', nTwsDoma
-00007420: 696e 732c 206b 6765 5f74 7773 0a20 2020  ins, kge_tws.   
-00007430: 2065 6e64 2069 660a 2020 2020 6f62 6a65   end if.    obje
-00007440: 6374 6976 655f 715f 6574 5f74 7773 5f6b  ctive_q_et_tws_k
-00007450: 6765 5f63 6174 6368 6d65 6e74 5f61 7667  ge_catchment_avg
-00007460: 2832 2920 3d20 6b67 655f 7477 730a 0a20  (2) = kge_tws.. 
-00007470: 2020 2021 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d     !------------
-00007480: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00007490: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000074a0: 0a20 2020 2021 2045 540a 2020 2020 212d  .    ! ET.    !-
-000074b0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000074c0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000074d0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020  -----------.    
-000074e0: 2120 6576 616c 2072 756e 7320 746f 2067  ! eval runs to g
-000074f0: 6574 2073 696d 756c 6174 6564 206f 7574  et simulated out
-00007500: 7075 7420 666f 7220 6574 0a20 2020 2021  put for et.    !
-00007510: 2062 6566 6f72 6520 6561 6368 2065 7661   before each eva
-00007520: 6c20 6361 6c6c 2077 6520 6765 6e65 7261  l call we genera
-00007530: 7465 2061 6e20 696e 6465 7820 6c69 7374  te an index list
-00007540: 206f 6620 7468 6520 646f 6d61 696e 7320   of the domains 
-00007550: 666f 7220 7768 6963 680a 2020 2020 2120  for which.    ! 
-00007560: 6576 616c 2073 686f 756c 6420 6265 2063  eval should be c
-00007570: 616c 6c65 642e 2052 6561 6420 6465 7461  alled. Read deta
-00007580: 696c 7320 666f 7220 6675 7274 6865 7220  ils for further 
-00007590: 696e 666f 726d 6174 696f 6e0a 2020 2020  information.    
-000075a0: 6361 6c6c 2069 6e69 745f 696e 6465 7861  call init_indexa
-000075b0: 7272 6179 5f66 6f72 5f6f 7074 695f 6461  rray_for_opti_da
-000075c0: 7461 2864 6f6d 6169 6e4d 6574 612c 2035  ta(domainMeta, 5
-000075d0: 2c20 6e45 7444 6f6d 6169 6e73 2c20 6f70  , nEtDomains, op
-000075e0: 7469 5f64 6f6d 6169 6e5f 696e 6469 6365  ti_domain_indice
-000075f0: 735f 4554 290a 2020 2020 6966 2028 6e45  s_ET).    if (nE
-00007600: 7444 6f6d 6169 6e73 203e 2030 2920 7468  tDomains > 0) th
-00007610: 656e 0a20 2020 2020 2061 6c6c 6f63 6174  en.      allocat
-00007620: 6528 6574 4f70 7469 5369 6d28 646f 6d61  e(etOptiSim(doma
-00007630: 696e 4d65 7461 256e 446f 6d61 696e 7329  inMeta%nDomains)
-00007640: 290a 2020 2020 2020 6361 6c6c 2065 7661  ).      call eva
-00007650: 6c28 7061 7261 6d65 7465 7273 6574 2c20  l(parameterset, 
-00007660: 6f70 7469 5f64 6f6d 6169 6e5f 696e 6469  opti_domain_indi
-00007670: 6365 7320 3d20 6f70 7469 5f64 6f6d 6169  ces = opti_domai
-00007680: 6e5f 696e 6469 6365 735f 4554 2c20 6574  n_indices_ET, et
-00007690: 4f70 7469 5369 6d20 3d20 6574 4f70 7469  OptiSim = etOpti
-000076a0: 5369 6d29 0a20 2020 2020 2021 2066 6f72  Sim).      ! for
-000076b0: 2061 6c6c 2064 6f6d 6169 6e73 2074 6861   all domains tha
-000076c0: 7420 6861 7665 2045 5420 616e 6420 5457  t have ET and TW
-000076d0: 530a 2020 2020 2020 646f 2069 203d 2031  S.      do i = 1
-000076e0: 2c20 7369 7a65 286f 7074 695f 646f 6d61  , size(opti_doma
-000076f0: 696e 5f69 6e64 6963 6573 5f45 5429 0a20  in_indices_ET). 
-00007700: 2020 2020 2020 2069 446f 6d61 696e 203d         iDomain =
-00007710: 206f 7074 695f 646f 6d61 696e 5f69 6e64   opti_domain_ind
-00007720: 6963 6573 5f45 5428 6929 0a20 2020 2020  ices_ET(i).     
-00007730: 2020 2064 6f20 6943 656c 6c20 3d20 312c     do iCell = 1,
-00007740: 2073 697a 6528 4c31 5f65 744f 6273 2869   size(L1_etObs(i
-00007750: 446f 6d61 696e 2925 6d61 736b 4f62 7328  Domain)%maskObs(
-00007760: 3a2c 203a 292c 2064 696d 203d 2031 290a  :, :), dim = 1).
-00007770: 2020 2020 2020 2020 2020 6b67 655f 6574            kge_et
-00007780: 203d 206b 6765 5f65 7420 2b20 260a 2020   = kge_et + &.  
-00007790: 2020 2020 2020 2020 2020 2831 2e30 5f64            (1.0_d
-000077a0: 7020 2d20 4b47 4528 4c31 5f65 744f 6273  p - KGE(L1_etObs
-000077b0: 2869 446f 6d61 696e 2925 6461 7461 4f62  (iDomain)%dataOb
-000077c0: 7328 6943 656c 6c2c 203a 292c 2065 744f  s(iCell, :), etO
-000077d0: 7074 6953 696d 2869 446f 6d61 696e 2925  ptiSim(iDomain)%
-000077e0: 6461 7461 5369 6d28 6943 656c 6c2c 203a  dataSim(iCell, :
-000077f0: 292c 260a 2020 2020 2020 2020 2020 2020  ),&.            
-00007800: 2020 2020 2020 2020 2020 2020 2020 206d                 m
-00007810: 6173 6b20 3d20 4c31 5f65 744f 6273 2869  ask = L1_etObs(i
-00007820: 446f 6d61 696e 2925 6d61 736b 4f62 7328  Domain)%maskObs(
-00007830: 6943 656c 6c2c 203a 2929 292a 2a36 0a20  iCell, :)))**6. 
-00007840: 2020 2020 2020 2020 206e 756d 6265 724f           numberO
-00007850: 6653 756d 6d61 6e64 7320 3d20 6e75 6d62  fSummands = numb
-00007860: 6572 4f66 5375 6d6d 616e 6473 202b 2031  erOfSummands + 1
-00007870: 0a20 2020 2020 2020 2065 6e64 2064 6f0a  .        end do.
-00007880: 2020 2020 2020 2020 6361 6c6c 2065 744f          call etO
-00007890: 7074 6953 696d 2869 446f 6d61 696e 2925  ptiSim(iDomain)%
-000078a0: 6465 7374 726f 7928 290a 2020 2020 2020  destroy().      
-000078b0: 656e 6420 646f 0a20 2020 2020 2064 6561  end do.      dea
-000078c0: 6c6c 6f63 6174 6528 6574 4f70 7469 5369  llocate(etOptiSi
-000078d0: 6d29 0a20 2020 2020 2120 7772 6974 6528  m).     ! write(
-000078e0: 302c 2a29 2027 6e45 7444 6f6d 6169 6e73  0,*) 'nEtDomains
-000078f0: 2c20 6b67 655f 6574 272c 206e 4574 446f  , kge_et', nEtDo
-00007900: 6d61 696e 732c 206b 6765 5f65 740a 2020  mains, kge_et.  
-00007910: 2020 656e 6420 6966 0a20 2020 206f 626a    end if.    obj
-00007920: 6563 7469 7665 5f71 5f65 745f 7477 735f  ective_q_et_tws_
-00007930: 6b67 655f 6361 7463 686d 656e 745f 6176  kge_catchment_av
-00007940: 6728 3329 203d 206b 6765 5f65 740a 0a20  g(3) = kge_et.. 
-00007950: 2020 2021 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d     !------------
-00007960: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00007970: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00007980: 0a20 2020 2021 2052 554e 4f46 460a 2020  .    ! RUNOFF.  
-00007990: 2020 212d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d    !-------------
-000079a0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000079b0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a  ---------------.
-000079c0: 2020 2020 2120 6576 616c 2072 756e 7320      ! eval runs 
-000079d0: 746f 2067 6574 2073 696d 756c 6174 6564  to get simulated
-000079e0: 206f 7574 7075 7420 666f 7220 7275 6e6f   output for runo
-000079f0: 6666 0a20 2020 2021 2062 6566 6f72 6520  ff.    ! before 
-00007a00: 7468 6520 6576 616c 2063 616c 6c20 7765  the eval call we
-00007a10: 2067 656e 6572 6174 6520 616e 2069 6e64   generate an ind
-00007a20: 6578 206c 6973 7420 6f66 2074 6865 2064  ex list of the d
-00007a30: 6f6d 6169 6e73 2066 6f72 2077 6869 6368  omains for which
-00007a40: 0a20 2020 2021 2065 7661 6c20 7368 6f75  .    ! eval shou
-00007a50: 6c64 2062 6520 6361 6c6c 6564 2e20 5265  ld be called. Re
-00007a60: 6164 2064 6574 6169 6c73 2066 6f72 2066  ad details for f
-00007a70: 7572 7468 6572 2069 6e66 6f72 6d61 7469  urther informati
-00007a80: 6f6e 0a20 2020 2021 2054 6f44 6f3a 2020  on.    ! ToDo:  
-00007a90: 5468 6520 6172 7261 7973 2066 6f72 2071  The arrays for q
-00007aa0: 5469 6e2c 2071 546f 7574 2c20 7769 6c6c  Tin, qTout, will
-00007ab0: 2062 6520 7265 7772 6974 7465 6e20 696e   be rewritten in
-00007ac0: 2074 6865 206f 7468 6572 2063 616c 6c73   the other calls
-00007ad0: 2077 6865 6e0a 2020 2020 2120 5120 6973   when.    ! Q is
-00007ae0: 206e 6f74 2063 616c 6c65 6420 6c61 7374   not called last
-00007af0: 2e20 4368 616e 6765 2074 6861 7420 666f  . Change that fo
-00007b00: 7220 6d6f 7265 2066 6c65 7869 6269 6c69  r more flexibili
-00007b10: 7479 0a20 2020 2063 616c 6c20 696e 6974  ty.    call init
-00007b20: 5f69 6e64 6578 6172 7261 795f 666f 725f  _indexarray_for_
-00007b30: 6f70 7469 5f64 6174 6128 646f 6d61 696e  opti_data(domain
-00007b40: 4d65 7461 2c20 312c 206e 5144 6f6d 6169  Meta, 1, nQDomai
-00007b50: 6e73 2c20 6f70 7469 5f64 6f6d 6169 6e5f  ns, opti_domain_
-00007b60: 696e 6469 6365 735f 5129 0a0a 2020 2020  indices_Q)..    
-00007b70: 6966 2028 6e51 446f 6d61 696e 7320 3e20  if (nQDomains > 
-00007b80: 3029 2074 6865 6e0a 2020 2020 2020 6361  0) then.      ca
-00007b90: 6c6c 2065 7661 6c28 7061 7261 6d65 7465  ll eval(paramete
-00007ba0: 7273 6574 2c20 6f70 7469 5f64 6f6d 6169  rset, opti_domai
-00007bb0: 6e5f 696e 6469 6365 7320 3d20 6f70 7469  n_indices = opti
-00007bc0: 5f64 6f6d 6169 6e5f 696e 6469 6365 735f  _domain_indices_
-00007bd0: 512c 2072 756e 6f66 6620 3d20 7275 6e6f  Q, runoff = runo
-00007be0: 6666 290a 2020 2020 2020 6e47 6175 6765  ff).      nGauge
-00007bf0: 7354 6f74 616c 203d 2073 697a 6528 7275  sTotal = size(ru
-00007c00: 6e6f 6666 2c20 6469 6d20 3d20 3229 0a20  noff, dim = 2). 
-00007c10: 2020 2020 2064 6f20 6767 203d 2031 2c20       do gg = 1, 
-00007c20: 6e47 6175 6765 7354 6f74 616c 0a0a 2020  nGaugesTotal..  
-00007c30: 2020 2020 2020 2120 6578 7472 6163 7420        ! extract 
-00007c40: 7275 6e6f 6666 0a20 2020 2020 2020 2063  runoff.        c
-00007c50: 616c 6c20 6578 7472 6163 745f 7275 6e6f  all extract_runo
-00007c60: 6666 2867 672c 2072 756e 6f66 662c 2072  ff(gg, runoff, r
-00007c70: 756e 6f66 665f 6167 672c 2072 756e 6f66  unoff_agg, runof
-00007c80: 665f 6f62 732c 2072 756e 6f66 665f 6f62  f_obs, runoff_ob
-00007c90: 735f 6d61 736b 290a 0a20 2020 2020 2020  s_mask)..       
-00007ca0: 206b 6765 5f71 203d 206b 6765 5f71 202b   kge_q = kge_q +
-00007cb0: 2026 0a20 2020 2020 2020 2020 2020 2020   &.             
-00007cc0: 2028 312e 305f 6470 202d 206b 6765 2872   (1.0_dp - kge(r
-00007cd0: 756e 6f66 665f 6f62 732c 2072 756e 6f66  unoff_obs, runof
-00007ce0: 665f 6167 672c 206d 6173 6b20 3d20 7275  f_agg, mask = ru
-00007cf0: 6e6f 6666 5f6f 6273 5f6d 6173 6b29 292a  noff_obs_mask))*
-00007d00: 2a36 0a20 2020 2020 2020 206e 756d 6265  *6.        numbe
-00007d10: 724f 6653 756d 6d61 6e64 7320 3d20 6e75  rOfSummands = nu
-00007d20: 6d62 6572 4f66 5375 6d6d 616e 6473 202b  mberOfSummands +
-00007d30: 2031 0a20 2020 2020 2020 2064 6561 6c6c   1.        deall
-00007d40: 6f63 6174 6520 2872 756e 6f66 665f 6167  ocate (runoff_ag
-00007d50: 672c 2072 756e 6f66 665f 6f62 732c 2072  g, runoff_obs, r
-00007d60: 756e 6f66 665f 6f62 735f 6d61 736b 290a  unoff_obs_mask).
-00007d70: 2020 2020 2020 656e 6420 646f 0a20 2020        end do.   
-00007d80: 2020 2120 7772 6974 6528 302c 2a29 2027    ! write(0,*) '
-00007d90: 6e51 446f 6d61 696e 732c 206b 6765 5f71  nQDomains, kge_q
-00007da0: 272c 206e 5144 6f6d 6169 6e73 2c20 6b67  ', nQDomains, kg
-00007db0: 655f 710a 2020 2020 656e 6420 6966 0a20  e_q.    end if. 
-00007dc0: 2020 206f 626a 6563 7469 7665 5f71 5f65     objective_q_e
-00007dd0: 745f 7477 735f 6b67 655f 6361 7463 686d  t_tws_kge_catchm
-00007de0: 656e 745f 6176 6728 3129 203d 206b 6765  ent_avg(1) = kge
-00007df0: 5f71 0a0a 2020 2020 6f62 6a65 6374 6976  _q..    objectiv
-00007e00: 655f 715f 6574 5f74 7773 5f6b 6765 5f63  e_q_et_tws_kge_c
-00007e10: 6174 6368 6d65 6e74 5f61 7667 2834 2920  atchment_avg(4) 
-00007e20: 3d20 7265 616c 286e 756d 6265 724f 6653  = real(numberOfS
-00007e30: 756d 6d61 6e64 732c 2064 7029 0a0a 0a23  ummands, dp)...#
-00007e40: 6966 6e64 6566 204d 5049 0a20 2020 206f  ifndef MPI.    o
-00007e50: 626a 6563 7469 7665 5f71 5f65 745f 7477  bjective_q_et_tw
-00007e60: 735f 6b67 655f 6361 7463 686d 656e 745f  s_kge_catchment_
-00007e70: 6176 6728 3129 203d 2028 286b 6765 5f71  avg(1) = ((kge_q
-00007e80: 2b6b 6765 5f65 742b 6b67 655f 7477 7329  +kge_et+kge_tws)
-00007e90: 2f72 6561 6c28 6e75 6d62 6572 4f66 5375  /real(numberOfSu
-00007ea0: 6d6d 616e 6473 2c20 6470 2929 2a2a 6f6e  mmands, dp))**on
-00007eb0: 6573 6978 7468 0a0a 2020 2020 6361 6c6c  esixth..    call
-00007ec0: 206d 6573 7361 6765 2827 2020 2020 6f62   message('    ob
-00007ed0: 6a65 6374 6976 655f 715f 6574 5f74 7773  jective_q_et_tws
-00007ee0: 5f6b 6765 5f63 6174 6368 6d65 6e74 5f61  _kge_catchment_a
-00007ef0: 7667 203d 2027 2c20 260a 2020 2020 2020  vg = ', &.      
-00007f00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007f10: 6e75 6d32 7374 7228 6f62 6a65 6374 6976  num2str(objectiv
-00007f20: 655f 715f 6574 5f74 7773 5f6b 6765 5f63  e_q_et_tws_kge_c
-00007f30: 6174 6368 6d65 6e74 5f61 7667 2831 292c  atchment_avg(1),
-00007f40: 2027 2846 392e 3529 2729 290a 2365 6e64   '(F9.5)')).#end
-00007f50: 6966 0a0a 2020 454e 4420 4655 4e43 5449  if..  END FUNCTI
-00007f60: 4f4e 206f 626a 6563 7469 7665 5f71 5f65  ON objective_q_e
-00007f70: 745f 7477 735f 6b67 655f 6361 7463 686d  t_tws_kge_catchm
-00007f80: 656e 745f 6176 670a 0a20 2021 202d 2d2d  ent_avg..  ! ---
-00007f90: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00007fa0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00007fb0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00007fc0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a  ---------------.
-00007fd0: 0a20 2021 2020 2020 4e41 4d45 0a20 2021  .  !    NAME.  !
-00007fe0: 2020 2020 2020 2020 696e 6974 5f69 6e64          init_ind
-00007ff0: 6578 6172 7261 795f 666f 725f 6f70 7469  exarray_for_opti
-00008000: 5f64 6174 610a 0a20 2021 2020 2020 5055  _data..  !    PU
-00008010: 5250 4f53 450a 2020 213e 2020 2020 2020  RPOSE.  !>      
-00008020: 205c 6272 6965 6620 6372 6561 7465 7320   \brief creates 
-00008030: 616e 2069 6e64 6578 2061 7272 6179 206f  an index array o
-00008040: 6620 7468 6520 696e 6964 6963 6573 206f  f the inidices o
-00008050: 6620 7468 6520 646f 6d61 696e 7320 6576  f the domains ev
-00008060: 616c 0a20 2021 3e20 2020 2020 2020 2020  al.  !>         
-00008070: 2020 2020 2073 686f 756c 6420 4d50 4920       should MPI 
-00008080: 7072 6f63 6573 732e 0a20 2021 0a20 2021  process..  !.  !
-00008090: 3e20 2020 2020 2020 5c64 6574 6169 6c73  >       \details
-000080a0: 2054 6865 2064 6174 6120 7479 7065 2064   The data type d
-000080b0: 6f6d 6169 6e4d 6574 6120 636f 6e74 6169  omainMeta contai
-000080c0: 6e73 2061 6e20 6172 7261 7920 6f70 7469  ns an array opti
-000080d0: 6461 7461 206f 6620 7369 7a65 0a20 2021  data of size.  !
-000080e0: 3e20 2020 2020 2020 2020 2020 2020 2020  >               
-000080f0: 2064 6f6d 6169 6e4d 6574 6125 6e44 6f6d   domainMeta%nDom
-00008100: 6169 6e73 2c20 7465 6c6c 696e 6720 7573  ains, telling us
-00008110: 2c20 7768 6963 6820 646f 6d61 696e 7320  , which domains 
-00008120: 7368 6f75 6c64 2062 650a 2020 213e 2020  should be.  !>  
-00008130: 2020 2020 2020 2020 2020 2020 2020 6f70                op
-00008140: 7469 6d69 7a65 6420 7769 7468 2077 6869  timized with whi
-00008150: 6368 206f 7074 695f 6461 7461 2e20 5468  ch opti_data. Th
-00008160: 6973 2073 7562 726f 7574 696e 6520 7370  is subroutine sp
-00008170: 6c69 7473 2061 6c6c 0a20 2021 3e20 2020  lits all.  !>   
-00008180: 2020 2020 2020 2020 2020 2020 2064 6f6d               dom
-00008190: 6169 6e73 2061 7373 6967 6e65 6420 746f  ains assigned to
-000081a0: 2061 2070 726f 6365 7373 2061 6e64 2072   a process and r
-000081b0: 6574 7572 6e73 2061 6e20 696e 6465 7820  eturns an index 
-000081c0: 6c69 7374 0a20 2021 3e20 2020 2020 2020  list.  !>       
-000081d0: 2020 2020 2020 2020 2063 6f72 7265 7370           corresp
-000081e0: 6f6e 6469 6e67 2074 6f20 7468 6520 7661  onding to the va
-000081f0: 6c75 6520 6f66 2064 6f6d 6169 6e4d 6574  lue of domainMet
-00008200: 6125 6f70 7469 6461 7461 2e0a 2020 213e  a%optidata..  !>
-00008210: 0a20 2021 3e20 2020 2020 2020 2020 2020  .  !>           
-00008220: 2020 2020 2054 6865 2069 6e64 6578 2061       The index a
-00008230: 7272 6179 206f 7074 695f 646f 6d61 696e  rray opti_domain
-00008240: 5f69 6e64 6963 6573 2063 616e 2074 6865  _indices can the
-00008250: 6e20 6265 2070 6173 7365 640a 2020 213e  n be passed.  !>
-00008260: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008270: 6173 2061 6e20 6f70 7469 6f6e 616c 2061  as an optional a
-00008280: 7267 756d 656e 7420 746f 2074 6865 2065  rgument to the e
-00008290: 7661 6c20 7375 6272 6f75 7469 6e65 2e20  val subroutine. 
-000082a0: 5468 650a 2020 213e 2020 2020 2020 2020  The.  !>        
-000082b0: 2020 2020 2020 2020 6576 616c 2074 6865          eval the
-000082c0: 6e20 696e 7374 6561 6420 6f66 2075 7369  n instead of usi
-000082d0: 6e67 206c 6f6f 7073 206f 7665 7220 616c  ng loops over al
-000082e0: 6c20 646f 6d61 696e 7320 6f6e 6c79 0a20  l domains only. 
-000082f0: 2021 3e20 2020 2020 2020 2020 2020 2020   !>             
-00008300: 2020 2075 7365 7320 7468 6520 7061 7373     uses the pass
-00008310: 6564 2069 6e64 6963 6573 2e0a 2020 213e  ed indices..  !>
-00008320: 0a20 2021 3e20 2020 2020 2020 2020 2020  .  !>           
-00008330: 2020 2020 2054 6869 7320 7375 6272 6f75       This subrou
-00008340: 7469 6e65 2061 6c73 6f20 7265 7475 726e  tine also return
-00008350: 7320 7468 6520 7369 7a65 206f 6620 7468  s the size of th
-00008360: 6174 2061 7272 6179 2073 696e 6365 2069  at array since i
-00008370: 740a 2020 213e 2020 2020 2020 2020 2020  t.  !>          
-00008380: 2020 2020 2020 6865 6c70 7320 7769 7468        helps with
-00008390: 2074 6865 2063 616c 6375 6c61 7469 6f6e   the calculation
-000083a0: 7320 6f66 2074 6865 206f 7074 696d 697a  s of the optimiz
-000083b0: 6174 696f 6e20 696e 2074 6865 2065 6e64  ation in the end
-000083c0: 2e0a 0a20 2021 2020 2020 4849 5354 4f52  ...  !    HISTOR
-000083d0: 590a 2020 213e 2020 2020 2020 205c 6175  Y.  !>       \au
-000083e0: 7468 6f72 7320 4d61 7265 6e20 4b61 6c75  thors Maren Kalu
-000083f0: 7a61 0a0a 2020 213e 2020 2020 2020 205c  za..  !>       \
-00008400: 6461 7465 204a 756c 7920 3230 3139 0a20  date July 2019. 
-00008410: 2073 7562 726f 7574 696e 6520 696e 6974   subroutine init
-00008420: 5f69 6e64 6578 6172 7261 795f 666f 725f  _indexarray_for_
-00008430: 6f70 7469 5f64 6174 6128 646f 6d61 696e  opti_data(domain
-00008440: 4d65 7461 2c20 6f70 7469 6461 7461 4f70  Meta, optidataOp
-00008450: 7469 6f6e 2c20 6e4f 7074 6944 6f6d 6169  tion, nOptiDomai
-00008460: 6e73 2c20 6f70 7469 5f64 6f6d 6169 6e5f  ns, opti_domain_
-00008470: 696e 6469 6365 7329 0a20 2020 2075 7365  indices).    use
-00008480: 206d 6f5f 6d65 7373 6167 652c 206f 6e6c   mo_message, onl
-00008490: 7920 3a20 6d65 7373 6167 650a 2020 2020  y : message.    
-000084a0: 7573 6520 6d6f 5f63 6f6d 6d6f 6e5f 7661  use mo_common_va
-000084b0: 7269 6162 6c65 732c 206f 6e6c 7920 3a20  riables, only : 
-000084c0: 646f 6d61 696e 5f6d 6574 610a 2020 2020  domain_meta.    
-000084d0: 213e 206d 6574 6120 6461 7461 2066 6f72  !> meta data for
-000084e0: 2061 6c6c 2064 6f6d 6169 6e73 2061 7373   all domains ass
-000084f0: 6967 6e65 6420 746f 2074 6861 7420 7072  igned to that pr
-00008500: 6f63 6573 730a 2020 2020 7479 7065 2864  ocess.    type(d
-00008510: 6f6d 6169 6e5f 6d65 7461 292c 2020 2020  omain_meta),    
-00008520: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008530: 2020 2020 2020 2020 2020 2020 696e 7465              inte
-00008540: 6e74 2869 6e29 2020 2020 3a3a 2064 6f6d  nt(in)    :: dom
-00008550: 6169 6e4d 6574 610a 2020 2020 213e 2077  ainMeta.    !> w
-00008560: 6869 6368 206f 7074 6920 6461 7461 2073  hich opti data s
-00008570: 686f 756c 6420 6265 2075 7365 6420 696e  hould be used in
-00008580: 2074 6865 2065 7661 6c20 6361 6c6c 6564   the eval called
-00008590: 2061 6674 6572 2063 616c 6c69 6e67 2074   after calling t
-000085a0: 6869 7320 7375 6272 6f75 7469 6e65 0a20  his subroutine. 
-000085b0: 2020 2069 6e74 6567 6572 2869 3429 2c20     integer(i4), 
-000085c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000085d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000085e0: 2020 2020 2069 6e74 656e 7428 696e 2920       intent(in) 
-000085f0: 2020 203a 3a20 6f70 7469 6461 7461 4f70     :: optidataOp
-00008600: 7469 6f6e 0a20 2020 2021 3e20 6e75 6d62  tion.    !> numb
-00008610: 6572 206f 6620 646f 6d61 696e 7320 7468  er of domains th
-00008620: 6174 2077 696c 6c20 6265 206f 7074 696d  at will be optim
-00008630: 697a 6564 2069 6e20 7468 6520 666f 6c6c  ized in the foll
-00008640: 6f77 696e 6720 6576 616c 2063 616c 6c0a  owing eval call.
-00008650: 2020 2020 696e 7465 6765 7228 6934 292c      integer(i4),
-00008660: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008670: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008680: 2020 2020 2020 696e 7465 6e74 286f 7574        intent(out
-00008690: 2920 2020 3a3a 206e 4f70 7469 446f 6d61  )   :: nOptiDoma
-000086a0: 696e 730a 2020 2020 213e 2074 6865 2069  ins.    !> the i
-000086b0: 6e64 6963 6573 206f 6620 7468 6520 646f  ndices of the do
-000086c0: 6d61 696e 7320 7468 6174 2061 7265 2074  mains that are t
-000086d0: 6f20 6265 2070 726f 6365 7373 6564 2069  o be processed i
-000086e0: 6e20 7468 6520 666f 6c6c 6f77 696e 6720  n the following 
-000086f0: 6576 616c 2063 616c 6c0a 2020 2020 696e  eval call.    in
-00008700: 7465 6765 7228 6934 292c 2064 696d 656e  teger(i4), dimen
-00008710: 7369 6f6e 283a 292c 2061 6c6c 6f63 6174  sion(:), allocat
-00008720: 6162 6c65 2c20 2020 2020 2020 2020 2020  able,           
-00008730: 696e 7465 6e74 286f 7574 2920 2020 3a3a  intent(out)   ::
-00008740: 206f 7074 695f 646f 6d61 696e 5f69 6e64   opti_domain_ind
-00008750: 6963 6573 0a0a 2020 2020 213e 2064 6f6d  ices..    !> dom
-00008760: 6169 6e20 6c6f 6f70 2063 6f75 6e74 6572  ain loop counter
-00008770: 0a20 2020 2069 6e74 6567 6572 2869 3429  .    integer(i4)
-00008780: 203a 3a20 6944 6f6d 6169 6e2c 2069 0a0a   :: iDomain, i..
-00008790: 2020 2020 6966 2028 616c 6c6f 6361 7465      if (allocate
-000087a0: 6428 6f70 7469 5f64 6f6d 6169 6e5f 696e  d(opti_domain_in
-000087b0: 6469 6365 7329 2920 6465 616c 6c6f 6361  dices)) dealloca
-000087c0: 7465 286f 7074 695f 646f 6d61 696e 5f69  te(opti_domain_i
-000087d0: 6e64 6963 6573 290a 2020 2020 2120 636f  ndices).    ! co
-000087e0: 756e 7420 646f 6d61 696e 7320 6f6e 204d  unt domains on M
-000087f0: 5049 2070 726f 6365 7373 2074 6861 7420  PI process that 
-00008800: 7573 6520 6f70 7469 6461 7461 0a20 2020  use optidata.   
-00008810: 206e 4f70 7469 446f 6d61 696e 7320 3d20   nOptiDomains = 
-00008820: 300a 2020 2020 646f 2069 446f 6d61 696e  0.    do iDomain
-00008830: 203d 2031 2c20 646f 6d61 696e 4d65 7461   = 1, domainMeta
-00008840: 256e 446f 6d61 696e 730a 2020 2020 2020  %nDomains.      
-00008850: 6966 2028 646f 6d61 696e 4d65 7461 256f  if (domainMeta%o
-00008860: 7074 6964 6174 6128 6944 6f6d 6169 6e29  ptidata(iDomain)
-00008870: 203d 3d20 6f70 7469 6461 7461 4f70 7469   == optidataOpti
-00008880: 6f6e 2920 6e4f 7074 6944 6f6d 6169 6e73  on) nOptiDomains
-00008890: 203d 206e 4f70 7469 446f 6d61 696e 7320   = nOptiDomains 
-000088a0: 2b20 310a 2020 2020 656e 6420 646f 0a20  + 1.    end do. 
-000088b0: 2020 2021 2077 7269 7465 2069 6e64 6963     ! write indic
-000088c0: 6573 206f 6620 7468 6573 6520 646f 6d61  es of these doma
-000088d0: 696e 7320 696e 746f 2061 6e20 6172 7261  ins into an arra
-000088e0: 790a 2020 2020 6966 2028 6e4f 7074 6944  y.    if (nOptiD
-000088f0: 6f6d 6169 6e73 203e 2030 2920 7468 656e  omains > 0) then
-00008900: 0a20 2020 2020 2061 6c6c 6f63 6174 6528  .      allocate(
-00008910: 6f70 7469 5f64 6f6d 6169 6e5f 696e 6469  opti_domain_indi
-00008920: 6365 7328 6e4f 7074 6944 6f6d 6169 6e73  ces(nOptiDomains
-00008930: 2929 0a20 2020 2020 2069 203d 2030 0a20  )).      i = 0. 
-00008940: 2020 2020 2064 6f20 6944 6f6d 6169 6e20       do iDomain 
-00008950: 3d20 312c 2064 6f6d 6169 6e4d 6574 6125  = 1, domainMeta%
-00008960: 6e44 6f6d 6169 6e73 0a20 2020 2020 2020  nDomains.       
-00008970: 2069 6620 2864 6f6d 6169 6e4d 6574 6125   if (domainMeta%
-00008980: 6f70 7469 6461 7461 2869 446f 6d61 696e  optidata(iDomain
-00008990: 2920 3d3d 206f 7074 6964 6174 614f 7074  ) == optidataOpt
-000089a0: 696f 6e29 2074 6865 6e0a 2020 2020 2020  ion) then.      
-000089b0: 2020 2020 6920 3d20 6920 2b20 310a 2020      i = i + 1.  
-000089c0: 2020 2020 2020 2020 6f70 7469 5f64 6f6d          opti_dom
-000089d0: 6169 6e5f 696e 6469 6365 7328 6929 203d  ain_indices(i) =
-000089e0: 2069 446f 6d61 696e 0a20 2020 2020 2020   iDomain.       
-000089f0: 2065 6e64 2069 660a 2020 2020 2020 656e   end if.      en
-00008a00: 6420 646f 0a20 2020 2065 6e64 2069 660a  d do.    end if.
-00008a10: 2020 656e 6420 7375 6272 6f75 7469 6e65    end subroutine
-00008a20: 2069 6e69 745f 696e 6465 7861 7272 6179   init_indexarray
-00008a30: 5f66 6f72 5f6f 7074 695f 6461 7461 0a20  _for_opti_data. 
-00008a40: 2021 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d   ! -------------
-00008a50: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00008a60: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00008a70: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00008a80: 2d2d 2d2d 2d0a 0a20 2021 2020 2020 4e41  -----..  !    NA
-00008a90: 4d45 0a20 2021 2020 2020 2020 2020 6f62  ME.  !        ob
-00008aa0: 6a65 6374 6976 655f 736d 5f63 6f72 720a  jective_sm_corr.
-00008ab0: 0a20 2021 2020 2020 5055 5250 4f53 450a  .  !    PURPOSE.
-00008ac0: 2020 213e 2020 2020 2020 205c 6272 6965    !>       \brie
-00008ad0: 6620 4f62 6a65 6374 6976 6520 6675 6e63  f Objective func
-00008ae0: 7469 6f6e 2066 6f72 2073 6f69 6c20 6d6f  tion for soil mo
-00008af0: 6973 7475 7265 2e0a 0a20 2021 3e20 2020  isture...  !>   
-00008b00: 2020 2020 5c64 6574 6169 6c73 2054 6865      \details The
-00008b10: 206f 626a 6563 7469 7665 2066 756e 6374   objective funct
-00008b20: 696f 6e20 6f6e 6c79 2064 6570 656e 6473  ion only depends
-00008b30: 206f 6e20 6120 7061 7261 6d65 7465 7220   on a parameter 
-00008b40: 7665 6374 6f72 2e0a 2020 213e 2020 2020  vector..  !>    
-00008b50: 2020 2054 6865 206d 6f64 656c 2077 696c     The model wil
-00008b60: 6c20 6265 2063 616c 6c65 6420 7769 7468  l be called with
-00008b70: 2074 6861 7420 7061 7261 6d65 7465 7220   that parameter 
-00008b80: 7665 6374 6f72 2061 6e64 0a20 2021 3e20  vector and.  !> 
-00008b90: 2020 2020 2020 7468 6520 6d6f 6465 6c20        the model 
-00008ba0: 6f75 7470 7574 2069 7320 7375 6273 6571  output is subseq
-00008bb0: 7565 6e74 6c79 2063 6f6d 7061 7265 6420  uently compared 
-00008bc0: 746f 206f 6273 6572 7665 6420 6461 7461  to observed data
-00008bd0: 2e0a 0a20 2021 3e20 2020 2020 2020 5468  ...  !>       Th
-00008be0: 6572 6566 6f72 6520 7468 6520 5065 6172  erefore the Pear
-00008bf0: 736f 6e20 636f 7272 656c 6174 696f 6e20  son correlation 
-00008c00: 6265 7477 6565 6e20 6f62 7365 7276 6564  between observed
-00008c10: 2061 6e64 206d 6f64 656c 6564 2073 6f69   and modeled soi
-00008c20: 6c0a 2020 213e 2020 2020 2020 206d 6f69  l.  !>       moi
-00008c30: 7374 7572 6520 6f6e 2065 6163 6820 6772  sture on each gr
-00008c40: 6964 2063 656c 6c20 5c66 2420 6a20 5c66  id cell \f$ j \f
-00008c50: 2420 6973 2063 6f6d 7061 7265 640a 2020  $ is compared.  
-00008c60: 213e 2020 2020 2020 205c 665b 2072 5f6a  !>       \f[ r_j
-00008c70: 203d 2072 5e32 2853 4d5f 7b6f 6273 7d5e   = r^2(SM_{obs}^
-00008c80: 6a2c 2053 4d5f 7b73 696d 7d5e 6a29 205c  j, SM_{sim}^j) \
-00008c90: 665d 0a20 2021 3e20 2020 2020 2020 7768  f].  !>       wh
-00008ca0: 6572 650a 2020 213e 2020 2020 2020 205c  ere.  !>       \
-00008cb0: 6624 2072 5e32 5c66 2420 2020 2020 2020  f$ r^2\f$       
-00008cc0: 203d 2050 6561 7273 6f6e 2063 6f72 7265   = Pearson corre
-00008cd0: 6c61 7469 6f6e 2063 6f65 6666 6963 6965  lation coefficie
-00008ce0: 6e74 2c0a 2020 213e 2020 2020 2020 205c  nt,.  !>       \
-00008cf0: 6624 2053 4d5f 7b6f 6273 7d20 5c66 2420  f$ SM_{obs} \f$ 
-00008d00: 203d 206f 6273 6572 7665 6420 736f 696c   = observed soil
-00008d10: 206d 6f69 7374 7572 652c 0a20 2021 3e20   moisture,.  !> 
-00008d20: 2020 2020 2020 5c66 2420 534d 5f7b 7369        \f$ SM_{si
-00008d30: 6d7d 2020 5c66 2420 3d20 7369 6d75 6c61  m}  \f$ = simula
-00008d40: 7465 6420 736f 696c 206d 6f69 7374 7572  ted soil moistur
-00008d50: 652e 0a20 2021 3e20 2020 2020 2020 5468  e..  !>       Th
-00008d60: 6520 6f62 7365 7276 6564 2064 6174 6120  e observed data 
-00008d70: 5c66 2420 534d 5f7b 6f62 737d 205c 6624  \f$ SM_{obs} \f$
-00008d80: 2061 7265 2067 6c6f 6261 6c20 696e 2074   are global in t
-00008d90: 6869 7320 6d6f 6475 6c65 2e0a 0a20 2021  his module...  !
-00008da0: 3e20 2020 2020 2020 5468 6520 7468 6520  >       The the 
-00008db0: 636f 7272 656c 6174 696f 6e20 6973 2073  correlation is s
-00008dc0: 7061 7469 616c 6c79 2061 7665 7261 6765  patially average
-00008dd0: 6420 6173 0a20 2021 3e20 2020 2020 2020  d as.  !>       
-00008de0: 5c66 5b20 5c70 6869 5f7b 697d 203d 205c  \f[ \phi_{i} = \
-00008df0: 6672 6163 7b31 7d7b 4b7d 205c 6364 6f74  frac{1}{K} \cdot
-00008e00: 205c 7375 6d5f 7b6a 3d31 7d5e 4b20 725f   \sum_{j=1}^K r_
-00008e10: 6a20 5c66 5d0a 2020 213e 2020 2020 2020  j \f].  !>      
-00008e20: 2077 6865 7265 205c 6624 204b 205c 6624   where \f$ K \f$
-00008e30: 2064 656e 6f74 6573 2074 6865 206e 756d   denotes the num
-00008e40: 6265 7220 6f66 2076 616c 6964 2063 656c  ber of valid cel
-00008e50: 6c73 2069 6e20 7468 6520 7374 7564 7920  ls in the study 
-00008e60: 646f 6d61 696e 2e0a 2020 213e 2020 2020  domain..  !>    
-00008e70: 2020 2046 696e 616c 6c79 2c20 7468 6520     Finally, the 
-00008e80: 6f76 6572 616c 6c20 6f62 6a65 6374 6976  overall objectiv
-00008e90: 6520 6675 6e63 7469 6f6e 2076 616c 7565  e function value
-00008ea0: 205c 6624 204f 4620 5c66 2420 6973 2065   \f$ OF \f$ is e
-00008eb0: 7374 696d 6174 6564 2062 6173 6564 206f  stimated based o
-00008ec0: 6e20 7468 6520 706f 7765 722d 360a 2020  n the power-6.  
-00008ed0: 213e 2020 2020 2020 206e 6f72 6d20 746f  !>       norm to
-00008ee0: 2063 6f6d 6269 6e65 2074 6865 205c 6624   combine the \f$
-00008ef0: 205c 7068 695f 7b69 7d20 5c66 2420 6672   \phi_{i} \f$ fr
-00008f00: 6f6d 2061 6c6c 2064 6f6d 6169 6e73 205c  om all domains \
-00008f10: 6624 204e 205c 6624 2e0a 2020 213e 2020  f$ N \f$..  !>  
-00008f20: 2020 2020 205c 665b 204f 4620 3d20 5c73       \f[ OF = \s
-00008f30: 7172 745b 365d 7b5c 7375 6d28 2831 2e30  qrt[6]{\sum((1.0
-00008f40: 202d 205c 7068 695f 7b69 7d29 2f4e 295e   - \phi_{i})/N)^
-00008f50: 3620 7d2e 205c 665d 0a20 2021 3e20 2020  6 }. \f].  !>   
-00008f60: 2020 2020 5468 6520 6f62 7365 7276 6564      The observed
-00008f70: 2064 6174 6120 4c31 5f73 6d2c 204c 315f   data L1_sm, L1_
-00008f80: 736d 5f6d 6173 6b20 6172 6520 676c 6f62  sm_mask are glob
-00008f90: 616c 2069 6e20 7468 6973 206d 6f64 756c  al in this modul
-00008fa0: 652e 0a0a 2020 2120 2020 2049 4e54 454e  e...  !    INTEN
-00008fb0: 5428 494e 290a 2020 213e 2020 2020 2020  T(IN).  !>      
-00008fc0: 205c 7061 7261 6d5b 696e 5d20 2272 6561   \param[in] "rea
-00008fd0: 6c28 6470 292c 2064 696d 656e 7369 6f6e  l(dp), dimension
-00008fe0: 283a 2920 3a3a 2070 6172 616d 6574 6572  (:) :: parameter
-00008ff0: 7365 7422 0a20 2021 3e20 2020 2020 2020  set".  !>       
-00009000: 5c70 6172 616d 5b69 6e5d 2022 7072 6f63  \param[in] "proc
-00009010: 6564 7572 6528 6576 616c 5f69 6e74 6572  edure(eval_inter
-00009020: 6661 6365 2920 3a3a 2065 7661 6c22 0a0a  face) :: eval"..
-00009030: 2020 2120 2020 2052 4554 5552 4e0a 2020    !    RETURN.  
-00009040: 213e 2020 2020 2020 205c 7265 7475 726e  !>       \return
-00009050: 2072 6561 6c28 6470 2920 3a3a 206f 626a   real(dp) :: obj
-00009060: 6563 7469 7665 5f73 6d5f 636f 7272 2026  ective_sm_corr &
-00009070: 6d64 6173 683b 206f 626a 6563 7469 7665  mdash; objective
-00009080: 2066 756e 6374 696f 6e20 7661 6c75 650a   function value.
-00009090: 2020 213e 2020 2020 2020 2028 7768 6963    !>       (whic
-000090a0: 6820 7769 6c6c 2062 6520 652e 672e 206d  h will be e.g. m
-000090b0: 696e 696d 697a 6564 2062 7920 616e 206f  inimized by an o
-000090c0: 7074 696d 697a 6174 696f 6e20 726f 7574  ptimization rout
-000090d0: 696e 6520 6c69 6b65 2044 4453 290a 0a20  ine like DDS).. 
-000090e0: 2021 2020 2020 4849 5354 4f52 590a 2020   !    HISTORY.  
-000090f0: 213e 2020 2020 2020 205c 6175 7468 6f72  !>       \author
-00009100: 7320 4d61 7474 6869 6173 205a 696e 6b0a  s Matthias Zink.
-00009110: 0a20 2021 3e20 2020 2020 2020 5c64 6174  .  !>       \dat
-00009120: 6520 4d61 7263 6820 3230 3135 0a0a 2020  e March 2015..  
-00009130: 2120 4d6f 6469 6669 6361 7469 6f6e 733a  ! Modifications:
-00009140: 0a20 2021 2052 6f62 6572 7420 5363 6877  .  ! Robert Schw
-00009150: 6570 7065 204a 756e 2032 3031 3820 2d20  eppe Jun 2018 - 
-00009160: 7265 6661 6374 6f72 696e 6720 616e 6420  refactoring and 
-00009170: 7265 666f 726d 6174 7469 6e67 0a0a 2020  reformatting..  
-00009180: 4655 4e43 5449 4f4e 206f 626a 6563 7469  FUNCTION objecti
-00009190: 7665 5f73 6d5f 636f 7272 2870 6172 616d  ve_sm_corr(param
-000091a0: 6574 6572 7365 742c 2065 7661 6c29 0a0a  eterset, eval)..
-000091b0: 2020 2020 7573 6520 6d6f 5f6f 7074 696d      use mo_optim
-000091c0: 697a 6174 696f 6e5f 7479 7065 732c 206f  ization_types, o
-000091d0: 6e6c 7920 3a20 6f70 7469 6461 7461 5f73  nly : optidata_s
-000091e0: 696d 0a20 2020 2075 7365 206d 6f5f 636f  im.    use mo_co
-000091f0: 6d6d 6f6e 5f76 6172 6961 626c 6573 2c20  mmon_variables, 
-00009200: 6f6e 6c79 203a 206c 6576 656c 312c 2064  only : level1, d
-00009210: 6f6d 6169 6e4d 6574 610a 2020 2020 7573  omainMeta.    us
-00009220: 6520 6d6f 5f67 6c6f 6261 6c5f 7661 7269  e mo_global_vari
-00009230: 6162 6c65 732c 206f 6e6c 7920 3a20 4c31  ables, only : L1
-00009240: 5f73 6d4f 6273 0a20 2020 2075 7365 206d  _smObs.    use m
-00009250: 6f5f 6d65 7373 6167 652c 206f 6e6c 7920  o_message, only 
-00009260: 3a20 6d65 7373 6167 650a 2020 2020 7573  : message.    us
-00009270: 6520 6d6f 5f6d 6f6d 656e 742c 206f 6e6c  e mo_moment, onl
-00009280: 7920 3a20 636f 7272 656c 6174 696f 6e0a  y : correlation.
-00009290: 2020 2020 7573 6520 6d6f 5f73 7472 696e      use mo_strin
-000092a0: 675f 7574 696c 732c 206f 6e6c 7920 3a20  g_utils, only : 
-000092b0: 6e75 6d32 7374 720a 0a20 2020 2069 6d70  num2str..    imp
-000092c0: 6c69 6369 7420 6e6f 6e65 0a0a 2020 2020  licit none..    
-000092d0: 7265 616c 2864 7029 2c20 6469 6d65 6e73  real(dp), dimens
-000092e0: 696f 6e28 3a29 2c20 696e 7465 6e74 2869  ion(:), intent(i
-000092f0: 6e29 203a 3a20 7061 7261 6d65 7465 7273  n) :: parameters
-00009300: 6574 0a0a 2020 2020 7072 6f63 6564 7572  et..    procedur
-00009310: 6528 6576 616c 5f69 6e74 6572 6661 6365  e(eval_interface
-00009320: 292c 2049 4e54 454e 5428 494e 292c 2050  ), INTENT(IN), P
-00009330: 4f49 4e54 4552 203a 3a20 6576 616c 0a0a  OINTER :: eval..
-00009340: 2020 2020 7265 616c 2864 7029 203a 3a20      real(dp) :: 
-00009350: 6f62 6a65 6374 6976 655f 736d 5f63 6f72  objective_sm_cor
-00009360: 720a 0a20 2020 2021 2064 6f6d 6169 6e20  r..    ! domain 
-00009370: 6c6f 6f70 2063 6f75 6e74 6572 0a20 2020  loop counter.   
-00009380: 2069 6e74 6567 6572 2869 3429 203a 3a20   integer(i4) :: 
-00009390: 6944 6f6d 6169 6e0a 0a20 2020 2021 2063  iDomain..    ! c
-000093a0: 656c 6c20 6c6f 6f70 2063 6f75 6e74 6572  ell loop counter
-000093b0: 0a20 2020 2069 6e74 6567 6572 2869 3429  .    integer(i4)
-000093c0: 203a 3a20 6943 656c 6c0a 0a20 2020 2021   :: iCell..    !
-000093d0: 206e 6365 6c6c 7331 206f 6620 6c65 7665   ncells1 of leve
-000093e0: 6c20 310a 2020 2020 696e 7465 6765 7228  l 1.    integer(
-000093f0: 6934 2920 3a3a 206e 6365 6c6c 7331 0a0a  i4) :: ncells1..
-00009400: 2020 2020 2120 6e75 6d62 6572 206f 6620      ! number of 
-00009410: 696e 7661 6c69 6420 6365 6c6c 7320 696e  invalid cells in
-00009420: 2063 6174 6368 6d65 6e74 0a20 2020 2072   catchment.    r
-00009430: 6561 6c28 6470 2920 3a3a 2069 6e76 616c  eal(dp) :: inval
-00009440: 6964 5f63 656c 6c73 0a0a 2020 2020 2120  id_cells..    ! 
-00009450: 646f 6d61 696e 7320 7769 7365 206f 626a  domains wise obj
-00009460: 6563 7469 7665 730a 2020 2020 7265 616c  ectives.    real
-00009470: 2864 7029 203a 3a20 6f62 6a65 6374 6976  (dp) :: objectiv
-00009480: 655f 736d 5f63 6f72 725f 646f 6d61 696e  e_sm_corr_domain
-00009490: 0a0a 2369 666e 6465 6620 4d50 490a 2020  ..#ifndef MPI.  
-000094a0: 2020 7265 616c 2864 7029 2c20 7061 7261    real(dp), para
-000094b0: 6d65 7465 7220 3a3a 206f 6e65 7369 7874  meter :: onesixt
-000094c0: 6820 3d20 312e 305f 6470 202f 2036 2e30  h = 1.0_dp / 6.0
-000094d0: 5f64 700a 2365 6e64 6966 0a0a 2020 2020  _dp.#endif..    
-000094e0: 7479 7065 286f 7074 6964 6174 615f 7369  type(optidata_si
-000094f0: 6d29 2c20 6469 6d65 6e73 696f 6e28 3a29  m), dimension(:)
-00009500: 2c20 616c 6c6f 6361 7461 626c 6520 3a3a  , allocatable ::
-00009510: 2073 6d4f 7074 6953 696d 0a0a 0a20 2020   smOptiSim...   
-00009520: 2061 6c6c 6f63 6174 6528 736d 4f70 7469   allocate(smOpti
-00009530: 5369 6d28 646f 6d61 696e 4d65 7461 256e  Sim(domainMeta%n
-00009540: 446f 6d61 696e 7329 290a 2020 2020 6361  Domains)).    ca
-00009550: 6c6c 2065 7661 6c28 7061 7261 6d65 7465  ll eval(paramete
-00009560: 7273 6574 2c20 736d 4f70 7469 5369 6d20  rset, smOptiSim 
-00009570: 3d20 736d 4f70 7469 5369 6d29 0a0a 2020  = smOptiSim)..  
-00009580: 2020 2120 696e 6974 6961 6c69 7a65 2073    ! initialize s
-00009590: 6f6d 6520 7661 7269 6162 6c65 730a 2020  ome variables.  
-000095a0: 2020 6f62 6a65 6374 6976 655f 736d 5f63    objective_sm_c
-000095b0: 6f72 7220 3d20 302e 305f 6470 0a0a 2020  orr = 0.0_dp..  
-000095c0: 2020 2120 6c6f 6f70 206f 7665 7220 646f    ! loop over do
-000095d0: 6d61 696e 202d 2066 6f72 2061 7070 6c79  main - for apply
-000095e0: 696e 6720 706f 7765 7220 6c61 7720 6c61  ing power law la
-000095f0: 7465 7220 6f6e 0a20 2020 2064 6f20 6944  ter on.    do iD
-00009600: 6f6d 6169 6e20 3d20 312c 2064 6f6d 6169  omain = 1, domai
-00009610: 6e4d 6574 6125 6e44 6f6d 6169 6e73 0a0a  nMeta%nDomains..
-00009620: 2020 2020 2020 2120 696e 6974 0a20 2020        ! init.   
-00009630: 2020 206f 626a 6563 7469 7665 5f73 6d5f     objective_sm_
-00009640: 636f 7272 5f64 6f6d 6169 6e20 3d20 302e  corr_domain = 0.
-00009650: 305f 6470 0a20 2020 2020 2021 2067 6574  0_dp.      ! get
-00009660: 2064 6f6d 6169 6e20 696e 666f 726d 6174   domain informat
-00009670: 696f 6e0a 2020 2020 2020 6e63 656c 6c73  ion.      ncells
-00009680: 3120 3d20 6c65 7665 6c31 2869 446f 6d61  1 = level1(iDoma
-00009690: 696e 2925 6e63 656c 6c73 0a0a 2020 2020  in)%ncells..    
-000096a0: 2020 696e 7661 6c69 645f 6365 6c6c 7320    invalid_cells 
-000096b0: 3d20 302e 305f 6470 0a20 2020 2020 2021  = 0.0_dp.      !
-000096c0: 2074 656d 706f 7261 6c20 636f 7272 656c   temporal correl
-000096d0: 6174 696f 6e20 6973 2063 616c 6375 6c61  ation is calcula
-000096e0: 7465 6420 6f6e 2069 6e64 6976 6964 7561  ted on individua
-000096f0: 6c20 6772 6964 6420 6365 6c6c 730a 0a20  l gridd cells.. 
-00009700: 2020 2020 2064 6f20 6943 656c 6c20 3d20       do iCell = 
-00009710: 312c 2073 697a 6528 4c31 5f73 6d4f 6273  1, size(L1_smObs
-00009720: 2869 446f 6d61 696e 2925 6d61 736b 4f62  (iDomain)%maskOb
-00009730: 7328 3a2c 203a 292c 2064 696d 203d 2031  s(:, :), dim = 1
-00009740: 290a 0a20 2020 2020 2020 2021 2063 6865  )..        ! che
-00009750: 636b 2066 6f72 2065 6e6f 7567 6820 6461  ck for enough da
-00009760: 7461 2070 6f69 6e74 7320 696e 2074 696d  ta points in tim
-00009770: 6520 666f 7220 636f 7272 656c 6174 696f  e for correlatio
-00009780: 6e0a 2020 2020 2020 2020 6966 2028 636f  n.        if (co
-00009790: 756e 7428 4c31 5f73 6d4f 6273 2869 446f  unt(L1_smObs(iDo
-000097a0: 6d61 696e 2925 6d61 736b 4f62 7328 6943  main)%maskObs(iC
-000097b0: 656c 6c2c 203a 2929 202e 4c45 2e20 302e  ell, :)) .LE. 0.
-000097c0: 3130 5f64 7020 2a20 7265 616c 2873 697a  10_dp * real(siz
-000097d0: 6528 4c31 5f73 6d4f 6273 2869 446f 6d61  e(L1_smObs(iDoma
-000097e0: 696e 2925 6461 7461 4f62 7328 3a2c 203a  in)%dataObs(:, :
-000097f0: 292c 2064 696d 203d 2032 292c 2064 7029  ), dim = 2), dp)
-00009800: 2920 7468 656e 0a20 2020 2020 2020 2020  ) then.         
-00009810: 2069 6e76 616c 6964 5f63 656c 6c73 203d   invalid_cells =
-00009820: 2069 6e76 616c 6964 5f63 656c 6c73 202b   invalid_cells +
-00009830: 2031 2e30 5f64 700a 2020 2020 2020 2020   1.0_dp.        
-00009840: 2020 6379 636c 650a 2020 2020 2020 2020    cycle.        
-00009850: 656e 6420 6966 0a20 2020 2020 2020 206f  end if.        o
-00009860: 626a 6563 7469 7665 5f73 6d5f 636f 7272  bjective_sm_corr
-00009870: 5f64 6f6d 6169 6e20 3d20 6f62 6a65 6374  _domain = object
-00009880: 6976 655f 736d 5f63 6f72 725f 646f 6d61  ive_sm_corr_doma
-00009890: 696e 202b 2026 0a20 2020 2020 2020 2020  in + &.         
-000098a0: 2020 2020 2020 2063 6f72 7265 6c61 7469         correlati
-000098b0: 6f6e 284c 315f 736d 4f62 7328 6944 6f6d  on(L1_smObs(iDom
-000098c0: 6169 6e29 2564 6174 614f 6273 2869 4365  ain)%dataObs(iCe
-000098d0: 6c6c 2c20 3a29 2c20 736d 4f70 7469 5369  ll, :), smOptiSi
-000098e0: 6d28 6944 6f6d 6169 6e29 2564 6174 6153  m(iDomain)%dataS
-000098f0: 696d 2869 4365 6c6c 2c20 3a29 2c20 260a  im(iCell, :), &.
-00009900: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009910: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009920: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009930: 2020 2020 2020 2020 2020 206d 6173 6b20             mask 
-00009940: 3d20 4c31 5f73 6d4f 6273 2869 446f 6d61  = L1_smObs(iDoma
-00009950: 696e 2925 6d61 736b 4f62 7328 6943 656c  in)%maskObs(iCel
-00009960: 6c2c 203a 2929 0a20 2020 2020 2065 6e64  l, :)).      end
-00009970: 2064 6f0a 0a20 2020 2020 2021 2075 7365   do..      ! use
-00009980: 7220 696e 666f 726d 6174 696f 6e20 6162  r information ab
-00009990: 6f75 7420 696e 7661 6c69 6420 6365 6c6c  out invalid cell
-000099a0: 730a 2020 2020 2020 6966 2028 696e 7661  s.      if (inva
-000099b0: 6c69 645f 6365 6c6c 7320 2e47 542e 2030  lid_cells .GT. 0
-000099c0: 2e35 5f64 7029 2074 6865 6e0a 2020 2020  .5_dp) then.    
-000099d0: 2020 2020 6361 6c6c 206d 6573 7361 6765      call message
-000099e0: 2827 2020 2057 4152 4e49 4e47 3a20 6f62  ('   WARNING: ob
-000099f0: 6a65 6374 6976 655f 736d 3a20 4465 7465  jective_sm: Dete
-00009a00: 6374 6564 2069 6e76 616c 6964 2063 656c  cted invalid cel
-00009a10: 6c73 2069 6e20 7374 7564 7920 6172 6561  ls in study area
-00009a20: 2028 2e4c 542e 2031 3020 7661 6c69 6420   (.LT. 10 valid 
-00009a30: 6461 7461 2070 6f69 6e74 7329 2e27 290a  data points).').
-00009a40: 2020 2020 2020 2020 6361 6c6c 206d 6573          call mes
-00009a50: 7361 6765 2827 2020 2020 2020 2020 2020  sage('          
-00009a60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009a70: 4672 6163 7469 6f6e 206f 6620 696e 7661  Fraction of inva
-00009a80: 6c69 6420 6365 6c6c 733a 2027 2c20 260a  lid cells: ', &.
-00009a90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009aa0: 6e75 6d32 7374 7228 696e 7661 6c69 645f  num2str(invalid_
-00009ab0: 6365 6c6c 7320 2f20 7265 616c 286e 4365  cells / real(nCe
-00009ac0: 6c6c 7331 2c20 6470 292c 2027 2846 342e  lls1, dp), '(F4.
-00009ad0: 3229 2729 290a 2020 2020 2020 656e 6420  2)')).      end 
-00009ae0: 6966 0a0a 0a20 2020 2020 2021 2063 616c  if...      ! cal
-00009af0: 6375 6c61 7465 2061 7665 7261 6765 2073  culate average s
-00009b00: 6f69 6c20 6d6f 6973 7475 7265 2063 6f72  oil moisture cor
-00009b10: 7265 6c61 7469 6f6e 206f 7665 7220 616c  relation over al
-00009b20: 6c20 646f 6d61 696e 7320 7769 7468 2070  l domains with p
-00009b30: 6f77 6572 206c 6177 0a20 2020 2020 2021  ower law.      !
-00009b40: 2064 6f6d 6169 6e73 2061 7265 2077 6569   domains are wei
-00009b50: 6768 7465 6420 6571 7561 6c6c 7920 2820  ghted equally ( 
-00009b60: 3120 2f20 7265 616c 2864 6f6d 6169 6e4d  1 / real(domainM
-00009b70: 6574 6125 6f76 6572 616c 6c4e 756d 6265  eta%overallNumbe
-00009b80: 724f 6644 6f6d 6169 6e73 2c64 7029 292a  rOfDomains,dp))*
-00009b90: 2a36 0a20 2020 2020 206f 626a 6563 7469  *6.      objecti
-00009ba0: 7665 5f73 6d5f 636f 7272 203d 206f 626a  ve_sm_corr = obj
-00009bb0: 6563 7469 7665 5f73 6d5f 636f 7272 202b  ective_sm_corr +
-00009bc0: 2026 0a20 2020 2020 2020 2020 2020 2020   &.             
-00009bd0: 2028 2831 2e30 5f64 7020 2d20 6f62 6a65   ((1.0_dp - obje
-00009be0: 6374 6976 655f 736d 5f63 6f72 725f 646f  ctive_sm_corr_do
-00009bf0: 6d61 696e 202f 2072 6561 6c28 6e43 656c  main / real(nCel
-00009c00: 6c73 312c 2064 7029 2920 2f20 7265 616c  ls1, dp)) / real
-00009c10: 2864 6f6d 6169 6e4d 6574 6125 6f76 6572  (domainMeta%over
-00009c20: 616c 6c4e 756d 6265 724f 6644 6f6d 6169  allNumberOfDomai
-00009c30: 6e73 2c20 6470 2929 2a2a 360a 2020 2020  ns, dp))**6.    
-00009c40: 656e 6420 646f 0a23 6966 6e64 6566 204d  end do.#ifndef M
-00009c50: 5049 0a20 2020 206f 626a 6563 7469 7665  PI.    objective
-00009c60: 5f73 6d5f 636f 7272 203d 206f 626a 6563  _sm_corr = objec
-00009c70: 7469 7665 5f73 6d5f 636f 7272 2a2a 6f6e  tive_sm_corr**on
-00009c80: 6573 6978 7468 0a0a 2020 2020 6361 6c6c  esixth..    call
-00009c90: 206d 6573 7361 6765 2827 2020 2020 6f62   message('    ob
-00009ca0: 6a65 6374 6976 655f 736d 5f63 6f72 7220  jective_sm_corr 
-00009cb0: 3d20 272c 206e 756d 3273 7472 286f 626a  = ', num2str(obj
-00009cc0: 6563 7469 7665 5f73 6d5f 636f 7272 2c20  ective_sm_corr, 
-00009cd0: 2728 4639 2e35 2927 2929 0a23 656e 6469  '(F9.5)')).#endi
-00009ce0: 660a 0a20 2045 4e44 2046 554e 4354 494f  f..  END FUNCTIO
-00009cf0: 4e20 6f62 6a65 6374 6976 655f 736d 5f63  N objective_sm_c
-00009d00: 6f72 720a 0a20 2021 202d 2d2d 2d2d 2d2d  orr..  ! -------
-00009d10: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00009d20: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00009d30: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00009d40: 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 0a20 2021  -----------..  !
-00009d50: 2020 2020 4e41 4d45 0a20 2021 2020 2020      NAME.  !    
-00009d60: 2020 2020 6f62 6a65 6374 6976 655f 736d      objective_sm
-00009d70: 5f70 640a 0a20 2021 2020 2020 5055 5250  _pd..  !    PURP
-00009d80: 4f53 450a 2020 213e 2020 2020 2020 205c  OSE.  !>       \
-00009d90: 6272 6965 6620 4f62 6a65 6374 6976 6520  brief Objective 
-00009da0: 6675 6e63 7469 6f6e 2066 6f72 2073 6f69  function for soi
-00009db0: 6c20 6d6f 6973 7475 7265 2e0a 0a20 2021  l moisture...  !
-00009dc0: 3e20 2020 2020 2020 5c64 6574 6169 6c73  >       \details
-00009dd0: 2054 6865 206f 626a 6563 7469 7665 2066   The objective f
-00009de0: 756e 6374 696f 6e20 6f6e 6c79 2064 6570  unction only dep
-00009df0: 656e 6473 206f 6e20 6120 7061 7261 6d65  ends on a parame
-00009e00: 7465 7220 7665 6374 6f72 2e0a 2020 213e  ter vector..  !>
-00009e10: 2020 2020 2020 2054 6865 206d 6f64 656c         The model
-00009e20: 2077 696c 6c20 6265 2063 616c 6c65 6420   will be called 
-00009e30: 7769 7468 2074 6861 7420 7061 7261 6d65  with that parame
-00009e40: 7465 7220 7665 6374 6f72 2061 6e64 0a20  ter vector and. 
-00009e50: 2021 3e20 2020 2020 2020 7468 6520 6d6f   !>       the mo
-00009e60: 6465 6c20 6f75 7470 7574 2069 7320 7375  del output is su
-00009e70: 6273 6571 7565 6e74 6c79 2063 6f6d 7061  bsequently compa
-00009e80: 7265 6420 746f 206f 6273 6572 7665 6420  red to observed 
-00009e90: 6461 7461 2e0a 0a20 2021 3e20 2020 2020  data...  !>     
-00009ea0: 2020 5468 6572 6566 6f72 6520 7468 6520    Therefore the 
-00009eb0: 5061 7474 6572 6e20 4469 7373 696d 696c  Pattern Dissimil
-00009ec0: 6172 6974 7920 2850 4429 206f 6620 6f62  arity (PD) of ob
-00009ed0: 7365 7276 6564 2061 6e64 206d 6f64 656c  served and model
-00009ee0: 6564 2073 6f69 6c0a 2020 213e 2020 2020  ed soil.  !>    
-00009ef0: 2020 206d 6f69 7374 7572 6520 6669 656c     moisture fiel
-00009f00: 6473 2069 7320 6361 6c63 756c 6174 6564  ds is calculated
-00009f10: 202d 2061 696d 3a20 6d61 7463 6869 6e67   - aim: matching
-00009f20: 2073 7061 7469 616c 2070 6174 7465 7273   spatial patters
-00009f30: 0a20 2021 3e20 2020 2020 2020 5c66 5b20  .  !>       \f[ 
-00009f40: 4528 7429 203d 2050 445c 6c65 6674 2820  E(t) = PD\left( 
-00009f50: 534d 5f7b 6f62 737d 2874 292c 2053 4d5f  SM_{obs}(t), SM_
-00009f60: 7b73 696d 7d28 7429 205c 7269 6768 7429  {sim}(t) \right)
-00009f70: 205c 665d 0a20 2021 3e20 2020 2020 2020   \f].  !>       
-00009f80: 7768 6572 650a 2020 213e 2020 2020 2020  where.  !>      
-00009f90: 205c 6624 2050 4420 5c66 2420 2020 2020   \f$ PD \f$     
-00009fa0: 2020 203d 2070 6174 7465 726e 2064 6973     = pattern dis
-00009fb0: 7369 6d69 6c61 7269 7479 2066 756e 6374  similarity funct
-00009fc0: 696f 6e2c 0a20 2021 3e20 2020 2020 2020  ion,.  !>       
-00009fd0: 5c66 2420 534d 5f7b 6f62 737d 205c 6624  \f$ SM_{obs} \f$
-00009fe0: 2020 3d20 6f62 7365 7276 6564 2073 6f69    = observed soi
-00009ff0: 6c20 6d6f 6973 7475 7265 2c0a 2020 213e  l moisture,.  !>
-0000a000: 2020 2020 2020 205c 6624 2053 4d5f 7b73         \f$ SM_{s
-0000a010: 696d 7d20 205c 6624 203d 2073 696d 756c  im}  \f$ = simul
-0000a020: 6174 6564 2073 6f69 6c20 6d6f 6973 7475  ated soil moistu
-0000a030: 7265 2e0a 2020 213e 2020 2020 2020 205c  re..  !>       \
-0000a040: 6624 2045 2874 2920 205c 6624 2020 2020  f$ E(t)  \f$    
-0000a050: 203d 2070 6174 7465 726e 2064 6973 7369   = pattern dissi
-0000a060: 6d69 6c61 7269 7479 2061 7420 7469 6d65  milarity at time
-0000a070: 7374 6570 205c 6624 2074 205c 6624 2e0a  step \f$ t \f$..
-0000a080: 2020 213e 2020 2020 2020 2054 6865 2074    !>       The t
-0000a090: 6865 2070 6174 7465 726e 2064 6973 7369  he pattern dissi
-0000a0a0: 6d69 6c61 6974 7920 2845 2920 6973 2073  milaity (E) is s
-0000a0b0: 7061 7469 616c 6c79 2061 7665 7261 6765  patially average
-0000a0c0: 6420 6173 0a20 2021 3e20 2020 2020 2020  d as.  !>       
-0000a0d0: 5c66 5b20 5c70 6869 5f7b 697d 203d 205c  \f[ \phi_{i} = \
-0000a0e0: 6672 6163 7b31 7d7b 547d 205c 6364 6f74  frac{1}{T} \cdot
-0000a0f0: 205c 7375 6d5f 7b74 3d31 7d5e 5420 455f   \sum_{t=1}^T E_
-0000a100: 7420 5c66 5d0a 2020 213e 2020 2020 2020  t \f].  !>      
-0000a110: 2077 6865 7265 205c 6624 2054 205c 6624   where \f$ T \f$
-0000a120: 2064 656e 6f74 6573 2074 6865 206e 756d   denotes the num
-0000a130: 6265 7220 6f66 2074 696d 6520 7374 6570  ber of time step
-0000a140: 732e 0a20 2021 3e20 2020 2020 2020 4669  s..  !>       Fi
-0000a150: 6e61 6c6c 792c 2074 6865 206f 7665 7261  nally, the overa
-0000a160: 6c6c 206f 626a 6563 7469 7665 2066 756e  ll objective fun
-0000a170: 6374 696f 6e20 7661 6c75 6520 5c66 2420  ction value \f$ 
-0000a180: 4f46 205c 6624 2069 7320 6573 7469 6d61  OF \f$ is estima
-0000a190: 7465 6420 6261 7365 6420 6f6e 2074 6865  ted based on the
-0000a1a0: 2070 6f77 6572 2d36 0a20 2021 3e20 2020   power-6.  !>   
-0000a1b0: 2020 2020 6e6f 726d 2074 6f20 636f 6d62      norm to comb
-0000a1c0: 696e 6520 7468 6520 5c66 2420 5c70 6869  ine the \f$ \phi
-0000a1d0: 5f7b 697d 205c 6624 2066 726f 6d20 616c  _{i} \f$ from al
-0000a1e0: 6c20 646f 6d61 696e 7320 5c66 2420 4e20  l domains \f$ N 
-0000a1f0: 5c66 242e 0a20 2021 3e20 2020 2020 2020  \f$..  !>       
-0000a200: 5c66 5b20 4f46 203d 205c 7371 7274 5b36  \f[ OF = \sqrt[6
-0000a210: 5d7b 5c73 756d 2828 312e 3020 2d20 5c70  ]{\sum((1.0 - \p
-0000a220: 6869 5f7b 697d 292f 4e29 5e36 207d 202e  hi_{i})/N)^6 } .
-0000a230: 205c 665d 0a20 2021 3e20 2020 2020 2020   \f].  !>       
-0000a240: 5468 6520 6f62 7365 7276 6564 2064 6174  The observed dat
-0000a250: 6120 4c31 5f73 6d2c 204c 315f 736d 5f6d  a L1_sm, L1_sm_m
-0000a260: 6173 6b20 6172 6520 676c 6f62 616c 2069  ask are global i
-0000a270: 6e20 7468 6973 206d 6f64 756c 652e 0a20  n this module.. 
-0000a280: 2021 3e20 2020 2020 2020 5468 6520 6f62   !>       The ob
-0000a290: 7365 7276 6564 2064 6174 6120 4c31 5f73  served data L1_s
-0000a2a0: 6d2c 204c 315f 736d 5f6d 6173 6b20 6172  m, L1_sm_mask ar
-0000a2b0: 6520 676c 6f62 616c 2069 6e20 7468 6973  e global in this
-0000a2c0: 206d 6f64 756c 652e 0a0a 2020 2120 2020   module...  !   
-0000a2d0: 2049 4e54 454e 5428 494e 290a 2020 213e   INTENT(IN).  !>
-0000a2e0: 2020 2020 2020 205c 7061 7261 6d5b 696e         \param[in
-0000a2f0: 5d20 2272 6561 6c28 6470 292c 2064 696d  ] "real(dp), dim
-0000a300: 656e 7369 6f6e 283a 2920 3a3a 2070 6172  ension(:) :: par
-0000a310: 616d 6574 6572 7365 7422 0a20 2021 3e20  ameterset".  !> 
-0000a320: 2020 2020 2020 5c70 6172 616d 5b69 6e5d        \param[in]
-0000a330: 2022 7072 6f63 6564 7572 6528 6576 616c   "procedure(eval
-0000a340: 5f69 6e74 6572 6661 6365 2920 3a3a 2065  _interface) :: e
-0000a350: 7661 6c22 0a0a 2020 2120 2020 2052 4554  val"..  !    RET
-0000a360: 5552 4e0a 2020 213e 2020 2020 2020 205c  URN.  !>       \
-0000a370: 7265 7475 726e 2072 6561 6c28 6470 2920  return real(dp) 
-0000a380: 3a3a 206f 626a 6563 6976 655f 736d 5f70  :: objecive_sm_p
-0000a390: 6420 266d 6461 7368 3b20 6f62 6a65 6374  d &mdash; object
-0000a3a0: 6976 6520 6675 6e63 7469 6f6e 2076 616c  ive function val
-0000a3b0: 7565 0a20 2021 3e20 2020 2020 2020 2877  ue.  !>       (w
-0000a3c0: 6869 6368 2077 696c 6c20 6265 2065 2e67  hich will be e.g
-0000a3d0: 2e20 6d69 6e69 6d69 7a65 6420 6279 2061  . minimized by a
-0000a3e0: 6e20 6f70 7469 6d69 7a61 7469 6f6e 2072  n optimization r
-0000a3f0: 6f75 7469 6e65 206c 696b 6520 4444 5329  outine like DDS)
-0000a400: 0a0a 2020 2120 2020 2048 4953 544f 5259  ..  !    HISTORY
-0000a410: 0a20 2021 3e20 2020 2020 2020 5c61 7574  .  !>       \aut
-0000a420: 686f 7273 204d 6174 7468 6961 7320 5a69  hors Matthias Zi
-0000a430: 6e6b 0a0a 2020 213e 2020 2020 2020 205c  nk..  !>       \
-0000a440: 6461 7465 204d 6179 2032 3031 350a 0a20  date May 2015.. 
-0000a450: 2021 204d 6f64 6966 6963 6174 696f 6e73   ! Modifications
-0000a460: 3a0a 2020 2120 526f 6265 7274 2053 6368  :.  ! Robert Sch
-0000a470: 7765 7070 6520 4a75 6e20 3230 3138 202d  weppe Jun 2018 -
-0000a480: 2072 6566 6163 746f 7269 6e67 2061 6e64   refactoring and
-0000a490: 2072 6566 6f72 6d61 7474 696e 670a 0a20   reformatting.. 
-0000a4a0: 2046 554e 4354 494f 4e20 6f62 6a65 6374   FUNCTION object
-0000a4b0: 6976 655f 736d 5f70 6428 7061 7261 6d65  ive_sm_pd(parame
-0000a4c0: 7465 7273 6574 2c20 6576 616c 290a 0a20  terset, eval).. 
-0000a4d0: 2020 2075 7365 206d 6f5f 6f70 7469 6d69     use mo_optimi
-0000a4e0: 7a61 7469 6f6e 5f74 7970 6573 2c20 6f6e  zation_types, on
-0000a4f0: 6c79 203a 206f 7074 6964 6174 615f 7369  ly : optidata_si
-0000a500: 6d0a 2020 2020 7573 6520 6d6f 5f63 6f6d  m.    use mo_com
-0000a510: 6d6f 6e5f 636f 6e73 7461 6e74 732c 206f  mon_constants, o
-0000a520: 6e6c 7920 3a20 6e6f 6461 7461 5f64 700a  nly : nodata_dp.
-0000a530: 2020 2020 7573 6520 6d6f 5f63 6f6d 6d6f      use mo_commo
-0000a540: 6e5f 7661 7269 6162 6c65 732c 206f 6e6c  n_variables, onl
-0000a550: 7920 3a20 6c65 7665 6c31 2c20 646f 6d61  y : level1, doma
-0000a560: 696e 4d65 7461 0a20 2020 2075 7365 206d  inMeta.    use m
-0000a570: 6f5f 676c 6f62 616c 5f76 6172 6961 626c  o_global_variabl
-0000a580: 6573 2c20 6f6e 6c79 203a 204c 315f 736d  es, only : L1_sm
-0000a590: 4f62 730a 2020 2020 7573 6520 6d6f 5f6d  Obs.    use mo_m
-0000a5a0: 6573 7361 6765 2c20 6f6e 6c79 203a 206d  essage, only : m
-0000a5b0: 6573 7361 6765 0a20 2020 2075 7365 206d  essage.    use m
-0000a5c0: 6f5f 7370 6174 6961 6c73 696d 696c 6172  o_spatialsimilar
-0000a5d0: 6974 792c 206f 6e6c 7920 3a20 5044 0a20  ity, only : PD. 
-0000a5e0: 2020 2075 7365 206d 6f5f 7374 7269 6e67     use mo_string
-0000a5f0: 5f75 7469 6c73 2c20 6f6e 6c79 203a 206e  _utils, only : n
-0000a600: 756d 3273 7472 0a0a 2020 2020 696d 706c  um2str..    impl
-0000a610: 6963 6974 206e 6f6e 650a 0a20 2020 2072  icit none..    r
-0000a620: 6561 6c28 6470 292c 2064 696d 656e 7369  eal(dp), dimensi
-0000a630: 6f6e 283a 292c 2069 6e74 656e 7428 696e  on(:), intent(in
-0000a640: 2920 3a3a 2070 6172 616d 6574 6572 7365  ) :: parameterse
-0000a650: 740a 0a20 2020 2070 726f 6365 6475 7265  t..    procedure
-0000a660: 2865 7661 6c5f 696e 7465 7266 6163 6529  (eval_interface)
-0000a670: 2c20 494e 5445 4e54 2849 4e29 2c20 504f  , INTENT(IN), PO
-0000a680: 494e 5445 5220 3a3a 2065 7661 6c0a 0a20  INTER :: eval.. 
-0000a690: 2020 2021 206f 626a 6563 7469 7665 2066     ! objective f
-0000a6a0: 756e 6374 696f 6e20 7661 6c75 650a 2020  unction value.  
-0000a6b0: 2020 7265 616c 2864 7029 203a 3a20 6f62    real(dp) :: ob
-0000a6c0: 6a65 6374 6976 655f 736d 5f70 640a 0a20  jective_sm_pd.. 
-0000a6d0: 2020 2021 2064 6f6d 6169 6e20 6c6f 6f70     ! domain loop
-0000a6e0: 2063 6f75 6e74 6572 0a20 2020 2069 6e74   counter.    int
-0000a6f0: 6567 6572 2869 3429 203a 3a20 6944 6f6d  eger(i4) :: iDom
-0000a700: 6169 6e0a 0a20 2020 2021 2074 696d 6520  ain..    ! time 
-0000a710: 6c6f 6f70 2063 6f75 6e74 6572 0a20 2020  loop counter.   
-0000a720: 2069 6e74 6567 6572 2869 3429 203a 3a20   integer(i4) :: 
-0000a730: 6954 696d 650a 0a20 2020 2021 206c 6576  iTime..    ! lev
-0000a740: 656c 2031 206e 756d 6265 7220 6f66 2063  el 1 number of c
-0000a750: 756c 6f6d 6e73 2061 6e64 2072 6f77 730a  ulomns and rows.
-0000a760: 2020 2020 696e 7465 6765 7228 6934 2920      integer(i4) 
-0000a770: 3a3a 206e 726f 7773 312c 206e 636f 6c73  :: nrows1, ncols
-0000a780: 310a 0a20 2020 2021 2066 6f72 2073 6978  1..    ! for six
-0000a790: 7468 2072 6f6f 740a 2369 666e 6465 6620  th root.#ifndef 
-0000a7a0: 4d50 490a 2020 2020 7265 616c 2864 7029  MPI.    real(dp)
-0000a7b0: 2c20 7061 7261 6d65 7465 7220 3a3a 206f  , parameter :: o
-0000a7c0: 6e65 7369 7874 6820 3d20 312e 305f 6470  nesixth = 1.0_dp
-0000a7d0: 202f 2036 2e30 5f64 700a 2365 6e64 6966   / 6.0_dp.#endif
-0000a7e0: 0a0a 2020 2020 2120 6d61 7472 6963 6573  ..    ! matrices
-0000a7f0: 206f 6620 534d 2066 726f 6d20 7665 6374   of SM from vect
-0000a800: 6f72 697a 6564 2061 7272 6179 730a 2020  orized arrays.  
-0000a810: 2020 7265 616c 2864 7029 2c20 6469 6d65    real(dp), dime
-0000a820: 6e73 696f 6e28 3a2c 203a 292c 2061 6c6c  nsion(:, :), all
-0000a830: 6f63 6174 6162 6c65 203a 3a20 6d61 7431  ocatable :: mat1
-0000a840: 2c20 6d61 7432 0a0a 2020 2020 2120 7061  , mat2..    ! pa
-0000a850: 7474 6572 6e20 6469 7373 696d 696c 6172  ttern dissimilar
-0000a860: 6974 7920 2870 6429 2061 7420 6576 6572  ity (pd) at ever
-0000a870: 7920 7469 6d65 2073 7465 700a 2020 2020  y time step.    
-0000a880: 7265 616c 2864 7029 2c20 6469 6d65 6e73  real(dp), dimens
-0000a890: 696f 6e28 3a29 2c20 616c 6c6f 6361 7461  ion(:), allocata
-0000a8a0: 626c 6520 3a3a 2070 645f 7469 6d65 5f73  ble :: pd_time_s
-0000a8b0: 6572 6965 730a 0a20 2020 2021 2073 696d  eries..    ! sim
-0000a8c0: 756c 6174 6564 2073 6f69 6c20 6d6f 6973  ulated soil mois
-0000a8d0: 7475 7265 0a20 2020 2074 7970 6528 6f70  ture.    type(op
-0000a8e0: 7469 6461 7461 5f73 696d 292c 2064 696d  tidata_sim), dim
-0000a8f0: 656e 7369 6f6e 283a 292c 2061 6c6c 6f63  ension(:), alloc
-0000a900: 6174 6162 6c65 203a 3a20 736d 4f70 7469  atable :: smOpti
-0000a910: 5369 6d0a 0a20 2020 2021 206d 6173 6b20  Sim..    ! mask 
-0000a920: 6f66 2076 616c 6964 2063 656c 6c73 2061  of valid cells a
-0000a930: 7420 6c65 7665 6c31 0a20 2020 206c 6f67  t level1.    log
-0000a940: 6963 616c 2c20 6469 6d65 6e73 696f 6e28  ical, dimension(
-0000a950: 3a2c 203a 292c 2061 6c6c 6f63 6174 6162  :, :), allocatab
-0000a960: 6c65 203a 3a20 6d61 736b 310a 0a20 2020  le :: mask1..   
-0000a970: 2021 206d 6173 6b20 6f66 2076 616c 6964   ! mask of valid
-0000a980: 2073 6d20 6365 6c6c 730a 2020 2020 6c6f   sm cells.    lo
-0000a990: 6769 6361 6c2c 2064 696d 656e 7369 6f6e  gical, dimension
-0000a9a0: 283a 2c20 3a29 2c20 616c 6c6f 6361 7461  (:, :), allocata
-0000a9b0: 626c 6520 3a3a 206d 6173 6b5f 736d 0a0a  ble :: mask_sm..
-0000a9c0: 2020 2020 2120 6d61 736b 2066 6f72 2076      ! mask for v
-0000a9d0: 616c 6964 2073 6d20 6361 7463 686d 656e  alid sm catchmen
-0000a9e0: 7420 6176 6720 7469 6d65 2073 7465 7073  t avg time steps
-0000a9f0: 0a20 2020 206c 6f67 6963 616c 2c20 6469  .    logical, di
-0000aa00: 6d65 6e73 696f 6e28 3a29 2c20 616c 6c6f  mension(:), allo
-0000aa10: 6361 7461 626c 6520 3a3a 206d 6173 6b5f  catable :: mask_
-0000aa20: 7469 6d65 730a 0a0a 2020 2020 616c 6c6f  times...    allo
-0000aa30: 6361 7465 2873 6d4f 7074 6953 696d 2864  cate(smOptiSim(d
-0000aa40: 6f6d 6169 6e4d 6574 6125 6e44 6f6d 6169  omainMeta%nDomai
-0000aa50: 6e73 2929 0a20 2020 2063 616c 6c20 6576  ns)).    call ev
-0000aa60: 616c 2870 6172 616d 6574 6572 7365 742c  al(parameterset,
-0000aa70: 2073 6d4f 7074 6953 696d 203d 2073 6d4f   smOptiSim = smO
-0000aa80: 7074 6953 696d 290a 0a20 2020 2021 2069  ptiSim)..    ! i
-0000aa90: 6e69 7469 616c 697a 6520 736f 6d65 2076  nitialize some v
-0000aaa0: 6172 6961 626c 6573 0a20 2020 206f 626a  ariables.    obj
-0000aab0: 6563 7469 7665 5f73 6d5f 7064 203d 2030  ective_sm_pd = 0
-0000aac0: 2e30 5f64 700a 0a20 2020 2021 206c 6f6f  .0_dp..    ! loo
-0000aad0: 7020 6f76 6572 2064 6f6d 6169 6e20 2d20  p over domain - 
-0000aae0: 666f 7220 6170 706c 7969 6e67 2070 6f77  for applying pow
-0000aaf0: 6572 206c 6177 206c 6174 6572 206f 6e0a  er law later on.
-0000ab00: 2020 2020 646f 2069 446f 6d61 696e 203d      do iDomain =
-0000ab10: 2031 2c20 646f 6d61 696e 4d65 7461 256e   1, domainMeta%n
-0000ab20: 446f 6d61 696e 730a 0a20 2020 2020 2021  Domains..      !
-0000ab30: 2067 6574 2064 6f6d 6169 6e20 696e 666f   get domain info
-0000ab40: 726d 6174 696f 6e0a 2020 2020 2020 6d61  rmation.      ma
-0000ab50: 736b 3120 3d20 6c65 7665 6c31 2869 446f  sk1 = level1(iDo
-0000ab60: 6d61 696e 2925 6d61 736b 0a20 2020 2020  main)%mask.     
-0000ab70: 206e 636f 6c73 3120 3d20 6c65 7665 6c31   ncols1 = level1
-0000ab80: 2869 446f 6d61 696e 2925 6e63 6f6c 730a  (iDomain)%ncols.
-0000ab90: 2020 2020 2020 6e72 6f77 7331 203d 206c        nrows1 = l
-0000aba0: 6576 656c 3128 6944 6f6d 6169 6e29 256e  evel1(iDomain)%n
-0000abb0: 726f 7773 0a0a 2020 2020 2020 2120 616c  rows..      ! al
-0000abc0: 6c6f 6361 7465 0a20 2020 2020 2061 6c6c  locate.      all
-0000abd0: 6f63 6174 6528 6d61 736b 5f74 696d 6573  ocate(mask_times
-0000abe0: 2020 2020 2873 697a 6528 736d 4f70 7469      (size(smOpti
-0000abf0: 5369 6d28 6944 6f6d 6169 6e29 2564 6174  Sim(iDomain)%dat
-0000ac00: 6153 696d 2c20 6469 6d20 3d20 3229 2929  aSim, dim = 2)))
-0000ac10: 0a20 2020 2020 2061 6c6c 6f63 6174 6528  .      allocate(
-0000ac20: 7064 5f74 696d 655f 7365 7269 6573 2873  pd_time_series(s
-0000ac30: 697a 6528 736d 4f70 7469 5369 6d28 6944  ize(smOptiSim(iD
-0000ac40: 6f6d 6169 6e29 2564 6174 6153 696d 2c20  omain)%dataSim, 
-0000ac50: 6469 6d20 3d20 3229 2929 0a20 2020 2020  dim = 2))).     
-0000ac60: 2061 6c6c 6f63 6174 6528 6d61 7431 2020   allocate(mat1  
-0000ac70: 2028 6e72 6f77 7331 2c20 6e63 6f6c 7331   (nrows1, ncols1
-0000ac80: 2929 0a20 2020 2020 2061 6c6c 6f63 6174  )).      allocat
-0000ac90: 6528 6d61 7432 2020 2028 6e72 6f77 7331  e(mat2   (nrows1
-0000aca0: 2c20 6e63 6f6c 7331 2929 0a20 2020 2020  , ncols1)).     
-0000acb0: 2061 6c6c 6f63 6174 6528 6d61 736b 5f73   allocate(mask_s
-0000acc0: 6d28 6e72 6f77 7331 2c20 6e63 6f6c 7331  m(nrows1, ncols1
-0000acd0: 2929 0a0a 2020 2020 2020 2120 696e 6974  ))..      ! init
-0000ace0: 616c 697a 650a 2020 2020 2020 6d61 736b  alize.      mask
-0000acf0: 5f74 696d 6573 203d 202e 4641 4c53 452e  _times = .FALSE.
-0000ad00: 0a20 2020 2020 2070 645f 7469 6d65 5f73  .      pd_time_s
-0000ad10: 6572 6965 7320 3d20 302e 305f 6470 0a0a  eries = 0.0_dp..
-0000ad20: 2020 2020 2020 2120 6361 6c63 756c 6174        ! calculat
-0000ad30: 6520 7061 7474 6572 6e20 7369 6d69 6c61  e pattern simila
-0000ad40: 7269 7479 2063 7269 7465 7269 6f6e 0a20  rity criterion. 
-0000ad50: 2020 2020 2064 6f20 6954 696d 6520 3d20       do iTime = 
-0000ad60: 312c 2073 697a 6528 736d 4f70 7469 5369  1, size(smOptiSi
-0000ad70: 6d28 6944 6f6d 6169 6e29 2564 6174 6153  m(iDomain)%dataS
-0000ad80: 696d 2c20 6469 6d20 3d20 3229 0a20 2020  im, dim = 2).   
-0000ad90: 2020 2020 206d 6174 3120 3d20 756e 7061       mat1 = unpa
-0000ada0: 636b 284c 315f 736d 4f62 7328 6944 6f6d  ck(L1_smObs(iDom
-0000adb0: 6169 6e29 2564 6174 614f 6273 283a 2c20  ain)%dataObs(:, 
-0000adc0: 6954 696d 6529 2c20 6d61 736b 312c 206e  iTime), mask1, n
-0000add0: 6f64 6174 615f 6470 290a 2020 2020 2020  odata_dp).      
-0000ade0: 2020 6d61 7432 203d 2075 6e70 6163 6b28    mat2 = unpack(
-0000adf0: 736d 4f70 7469 5369 6d28 6944 6f6d 6169  smOptiSim(iDomai
-0000ae00: 6e29 2564 6174 6153 696d 283a 2c20 6954  n)%dataSim(:, iT
-0000ae10: 696d 6529 2c20 6d61 736b 312c 206e 6f64  ime), mask1, nod
-0000ae20: 6174 615f 6470 290a 2020 2020 2020 2020  ata_dp).        
-0000ae30: 6d61 736b 5f73 6d20 3d20 756e 7061 636b  mask_sm = unpack
-0000ae40: 284c 315f 736d 4f62 7328 6944 6f6d 6169  (L1_smObs(iDomai
-0000ae50: 6e29 256d 6173 6b4f 6273 283a 2c20 6954  n)%maskObs(:, iT
-0000ae60: 696d 6529 2c20 6d61 736b 312c 202e 4641  ime), mask1, .FA
-0000ae70: 4c53 452e 290a 2020 2020 2020 2020 7064  LSE.).        pd
-0000ae80: 5f74 696d 655f 7365 7269 6573 203d 2050  _time_series = P
-0000ae90: 4428 6d61 7431 2c20 6d61 7432 2c20 6d61  D(mat1, mat2, ma
-0000aea0: 736b 203d 206d 6173 6b5f 736d 2c20 7661  sk = mask_sm, va
-0000aeb0: 6c69 6420 3d20 6d61 736b 5f74 696d 6573  lid = mask_times
-0000aec0: 2869 7469 6d65 2929 0a20 2020 2020 2065  (itime)).      e
-0000aed0: 6e64 2064 6f0a 0a20 2020 2020 2069 6620  nd do..      if 
-0000aee0: 2863 6f75 6e74 286d 6173 6b5f 7469 6d65  (count(mask_time
-0000aef0: 7329 203e 2030 5f69 3429 2074 6865 6e0a  s) > 0_i4) then.
-0000af00: 2020 2020 2020 2020 2120 6361 6c63 756c          ! calcul
-0000af10: 6174 6520 6176 6572 6761 6520 5044 206f  ate avergae PD o
-0000af20: 7665 7220 616c 6c20 646f 6d61 696e 7320  ver all domains 
-0000af30: 7769 7468 2070 6f77 6572 206c 6177 202d  with power law -
-0000af40: 646f 6d61 696e 7320 6172 6520 7765 6967  domains are weig
-0000af50: 6874 6564 2065 7175 616c 6c79 2028 2031  hted equally ( 1
-0000af60: 202f 2072 6561 6c28 646f 6d61 696e 4d65   / real(domainMe
-0000af70: 7461 256f 7665 7261 6c6c 4e75 6d62 6572  ta%overallNumber
-0000af80: 4f66 446f 6d61 696e 732c 6470 2929 2a2a  OfDomains,dp))**
-0000af90: 360a 2020 2020 2020 2020 6f62 6a65 6374  6.        object
-0000afa0: 6976 655f 736d 5f70 6420 3d20 6f62 6a65  ive_sm_pd = obje
-0000afb0: 6374 6976 655f 736d 5f70 6420 2b20 260a  ctive_sm_pd + &.
-0000afc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000afd0: 2828 312e 305f 6470 202d 2073 756d 2870  ((1.0_dp - sum(p
-0000afe0: 645f 7469 6d65 5f73 6572 6965 732c 206d  d_time_series, m
-0000aff0: 6173 6b20 3d20 6d61 736b 5f74 696d 6573  ask = mask_times
-0000b000: 2920 2f20 7265 616c 2863 6f75 6e74 286d  ) / real(count(m
-0000b010: 6173 6b5f 7469 6d65 7329 2c20 6470 2929  ask_times), dp))
-0000b020: 202f 2026 0a20 2020 2020 2020 2020 2020   / &.           
-0000b030: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b040: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b050: 2020 2020 2020 2020 2072 6561 6c28 646f           real(do
-0000b060: 6d61 696e 4d65 7461 256f 7665 7261 6c6c  mainMeta%overall
-0000b070: 4e75 6d62 6572 4f66 446f 6d61 696e 732c  NumberOfDomains,
-0000b080: 2064 7029 292a 2a36 0a20 2020 2020 2065   dp))**6.      e
-0000b090: 6c73 650a 2020 2020 2020 2020 6361 6c6c  lse.        call
-0000b0a0: 206d 6573 7361 6765 2827 2a2a 2a45 5252   message('***ERR
-0000b0b0: 4f52 3a20 6d6f 5f6f 626a 6563 7469 7665  OR: mo_objective
-0000b0c0: 5f66 756e 7469 6f6e 3a20 6f62 6a65 6374  _funtion: object
-0000b0d0: 6976 655f 736d 5f70 643a 204e 6f20 736f  ive_sm_pd: No so
-0000b0e0: 696c 206d 6f69 7374 7572 6520 6f62 7365  il moisture obse
-0000b0f0: 7276 6174 696f 6e73 2061 7661 696c 6162  rvations availab
-0000b100: 6c65 2127 290a 2020 2020 2020 2020 7374  le!').        st
-0000b110: 6f70 0a20 2020 2020 2065 6e64 2069 660a  op.      end if.
-0000b120: 0a20 2020 2020 2021 2064 6561 6c6c 6f63  .      ! dealloc
-0000b130: 6174 650a 2020 2020 2020 6465 616c 6c6f  ate.      deallo
-0000b140: 6361 7465 286d 6173 6b5f 7469 6d65 7329  cate(mask_times)
-0000b150: 0a20 2020 2020 2064 6561 6c6c 6f63 6174  .      deallocat
-0000b160: 6528 7064 5f74 696d 655f 7365 7269 6573  e(pd_time_series
-0000b170: 290a 2020 2020 2020 6465 616c 6c6f 6361  ).      dealloca
-0000b180: 7465 286d 6174 3129 0a20 2020 2020 2064  te(mat1).      d
-0000b190: 6561 6c6c 6f63 6174 6528 6d61 7432 290a  eallocate(mat2).
-0000b1a0: 2020 2020 2020 6465 616c 6c6f 6361 7465        deallocate
-0000b1b0: 286d 6173 6b5f 736d 290a 2020 2020 2020  (mask_sm).      
-0000b1c0: 6361 6c6c 2073 6d4f 7074 6953 696d 2869  call smOptiSim(i
-0000b1d0: 446f 6d61 696e 2925 6465 7374 726f 7928  Domain)%destroy(
-0000b1e0: 290a 2020 2020 656e 6420 646f 0a20 2020  ).    end do.   
-0000b1f0: 2064 6561 6c6c 6f63 6174 6528 736d 4f70   deallocate(smOp
-0000b200: 7469 5369 6d29 0a0a 2369 666e 6465 6620  tiSim)..#ifndef 
-0000b210: 4d50 490a 2020 2020 6f62 6a65 6374 6976  MPI.    objectiv
-0000b220: 655f 736d 5f70 6420 3d20 6f62 6a65 6374  e_sm_pd = object
-0000b230: 6976 655f 736d 5f70 642a 2a6f 6e65 7369  ive_sm_pd**onesi
-0000b240: 7874 680a 0a20 2020 2063 616c 6c20 6d65  xth..    call me
-0000b250: 7373 6167 6528 2720 2020 206f 626a 6563  ssage('    objec
-0000b260: 7469 7665 5f73 6d5f 7064 203d 2027 2c20  tive_sm_pd = ', 
-0000b270: 6e75 6d32 7374 7228 6f62 6a65 6374 6976  num2str(objectiv
-0000b280: 655f 736d 5f70 642c 2027 2846 392e 3529  e_sm_pd, '(F9.5)
-0000b290: 2729 290a 2365 6e64 6966 0a0a 2020 454e  ')).#endif..  EN
-0000b2a0: 4420 4655 4e43 5449 4f4e 206f 626a 6563  D FUNCTION objec
-0000b2b0: 7469 7665 5f73 6d5f 7064 0a0a 2020 2120  tive_sm_pd..  ! 
-0000b2c0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0000b2d0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0000b2e0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0000b2f0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0000b300: 2d2d 0a0a 2020 2120 2020 204e 414d 450a  --..  !    NAME.
-0000b310: 2020 2120 2020 2020 2020 206f 626a 6563    !        objec
-0000b320: 7469 7665 5f73 6d5f 7373 655f 7374 616e  tive_sm_sse_stan
-0000b330: 6461 7264 5f73 636f 7265 0a0a 2020 2120  dard_score..  ! 
-0000b340: 2020 2050 5552 504f 5345 0a20 2021 3e20     PURPOSE.  !> 
-0000b350: 2020 2020 2020 5c62 7269 6566 204f 626a        \brief Obj
-0000b360: 6563 7469 7665 2066 756e 6374 696f 6e20  ective function 
-0000b370: 666f 7220 736f 696c 206d 6f69 7374 7572  for soil moistur
-0000b380: 652e 0a0a 2020 213e 2020 2020 2020 205c  e...  !>       \
-0000b390: 6465 7461 696c 7320 5468 6520 6f62 6a65  details The obje
-0000b3a0: 6374 6976 6520 6675 6e63 7469 6f6e 206f  ctive function o
-0000b3b0: 6e6c 7920 6465 7065 6e64 7320 6f6e 2061  nly depends on a
-0000b3c0: 2070 6172 616d 6574 6572 2076 6563 746f   parameter vecto
-0000b3d0: 722e 0a20 2021 3e20 2020 2020 2020 5468  r..  !>       Th
-0000b3e0: 6520 6d6f 6465 6c20 7769 6c6c 2062 6520  e model will be 
-0000b3f0: 6361 6c6c 6564 2077 6974 6820 7468 6174  called with that
-0000b400: 2070 6172 616d 6574 6572 2076 6563 746f   parameter vecto
-0000b410: 7220 616e 640a 2020 213e 2020 2020 2020  r and.  !>      
-0000b420: 2074 6865 206d 6f64 656c 206f 7574 7075   the model outpu
-0000b430: 7420 6973 2073 7562 7365 7175 656e 746c  t is subsequentl
-0000b440: 7920 636f 6d70 6172 6564 2074 6f20 6f62  y compared to ob
-0000b450: 7365 7276 6564 2064 6174 612e 0a0a 2020  served data...  
-0000b460: 213e 2020 2020 2020 2054 6865 7265 666f  !>       Therefo
-0000b470: 7265 2074 6865 2073 756d 206f 6620 7371  re the sum of sq
-0000b480: 7561 7265 6420 6572 726f 7273 2028 5353  uared errors (SS
-0000b490: 4529 206f 6620 7468 6520 7374 616e 6461  E) of the standa
-0000b4a0: 7264 2073 636f 7265 206f 6620 6f62 7365  rd score of obse
-0000b4b0: 7276 6564 2061 6e64 0a20 2021 3e20 2020  rved and.  !>   
-0000b4c0: 2020 2020 6d6f 6465 6c65 6420 736f 696c      modeled soil
-0000b4d0: 206d 6f69 7374 7572 6520 6973 2063 616c   moisture is cal
-0000b4e0: 6375 6c61 7465 642e 2054 6865 2073 7461  culated. The sta
-0000b4f0: 6e64 6172 6420 7363 6f72 6520 6f72 206e  ndard score or n
-0000b500: 6f72 6d61 6c69 7a61 7469 6f6e 2028 616e  ormalization (an
-0000b510: 6f6d 616c 7929 0a20 2021 3e20 2020 2020  omaly).  !>     
-0000b520: 2020 6d61 6b65 2074 6865 206f 626a 6374    make the objct
-0000b530: 6976 6520 6675 6e63 7469 6f6e 2062 6961  ive function bia
-0000b540: 7320 696e 7365 6e73 6974 6976 6520 616e  s insensitive an
-0000b550: 6420 6261 7369 6361 6c6c 7920 7468 6520  d basically the 
-0000b560: 6479 6e61 6d69 6373 206f 6620 7468 6520  dynamics of the 
-0000b570: 736f 696c 206d 6f69 7374 7572 650a 2020  soil moisture.  
-0000b580: 213e 2020 2020 2020 2069 7320 7472 6965  !>       is trie
-0000b590: 6420 746f 2063 6170 7475 7265 2062 7920  d to capture by 
-0000b5a0: 7468 6973 206f 6265 6a65 6374 6976 6520  this obejective 
-0000b5b0: 6675 6e63 7469 6f6e 2e0a 2020 213e 2020  function..  !>  
-0000b5c0: 2020 2020 205c 665b 2070 6869 5f69 203d       \f[ phi_i =
-0000b5d0: 205c 7375 6d5f 7b6a 3d31 7d5e 4b20 5c7b   \sum_{j=1}^K \{
-0000b5e0: 2073 7461 6e64 6172 645c 5f73 636f 7265   standard\_score
-0000b5f0: 2820 534d 5f7b 6f62 737d 286a 2920 292d  ( SM_{obs}(j) )-
-0000b600: 2073 7461 6e64 6172 645c 5f73 636f 7265   standard\_score
-0000b610: 2853 4d5f 7b73 696d 7d28 6a29 2920 5c7d  (SM_{sim}(j)) \}
-0000b620: 5e32 205c 665d 0a20 2021 3e20 2020 2020  ^2 \f].  !>     
-0000b630: 2020 7768 6572 650a 2020 213e 2020 2020    where.  !>    
-0000b640: 2020 205c 6624 2020 7374 616e 6461 7264     \f$  standard
-0000b650: 5c5f 7363 6f72 6520 5c66 2420 3d20 7374  \_score \f$ = st
-0000b660: 616e 6461 7264 2073 636f 7265 2066 756e  andard score fun
-0000b670: 6374 696f 6e2c 0a20 2021 3e20 2020 2020  ction,.  !>     
-0000b680: 2020 5c66 2420 534d 5f7b 6f62 737d 205c    \f$ SM_{obs} \
-0000b690: 6624 2020 3d20 6f62 7365 7276 6564 2073  f$  = observed s
-0000b6a0: 6f69 6c20 6d6f 6973 7475 7265 2c0a 2020  oil moisture,.  
-0000b6b0: 213e 2020 2020 2020 205c 6624 2053 4d5f  !>       \f$ SM_
-0000b6c0: 7b73 696d 7d20 205c 6624 203d 2073 696d  {sim}  \f$ = sim
-0000b6d0: 756c 6174 6564 2073 6f69 6c20 6d6f 6973  ulated soil mois
-0000b6e0: 7475 7265 2e0a 2020 213e 2020 2020 2020  ture..  !>      
-0000b6f0: 205c 6624 204b 2020 5c66 2420 3d20 7661   \f$ K  \f$ = va
-0000b700: 6c69 6420 656c 656d 656e 7473 2069 6e20  lid elements in 
-0000b710: 7374 7564 7920 646f 6d61 696e 2e0a 2020  study domain..  
-0000b720: 213e 2020 2020 2020 2046 696e 616c 6c79  !>       Finally
-0000b730: 2c20 7468 6520 6f76 6572 616c 6c20 6f62  , the overall ob
-0000b740: 6a65 6374 6976 6520 6675 6e63 7469 6f6e  jective function
-0000b750: 2076 616c 7565 205c 6624 204f 4620 5c66   value \f$ OF \f
-0000b760: 2420 6973 2065 7374 696d 6174 6564 2062  $ is estimated b
-0000b770: 6173 6564 206f 6e20 7468 6520 706f 7765  ased on the powe
-0000b780: 722d 360a 2020 213e 2020 2020 2020 206e  r-6.  !>       n
-0000b790: 6f72 6d20 746f 2063 6f6d 6269 6e65 2074  orm to combine t
-0000b7a0: 6865 205c 6624 205c 7068 695f 7b69 7d20  he \f$ \phi_{i} 
-0000b7b0: 5c66 2420 6672 6f6d 2061 6c6c 2064 6f6d  \f$ from all dom
-0000b7c0: 6169 6e73 205c 6624 204e 205c 6624 2e0a  ains \f$ N \f$..
-0000b7d0: 2020 213e 2020 2020 2020 205c 665b 204f    !>       \f[ O
-0000b7e0: 4620 3d20 5c73 7172 745b 365d 7b5c 7375  F = \sqrt[6]{\su
-0000b7f0: 6d28 5c70 6869 5f7b 697d 2f4e 295e 3620  m(\phi_{i}/N)^6 
-0000b800: 7d2e 2020 5c66 5d0a 2020 213e 2020 2020  }.  \f].  !>    
-0000b810: 2020 2054 6865 206f 6273 6572 7665 6420     The observed 
-0000b820: 6461 7461 204c 315f 736d 2c20 4c31 5f73  data L1_sm, L1_s
-0000b830: 6d5f 6d61 736b 2061 7265 2067 6c6f 6261  m_mask are globa
-0000b840: 6c20 696e 2074 6869 7320 6d6f 6475 6c65  l in this module
-0000b850: 2e0a 0a20 2021 2020 2020 494e 5445 4e54  ...  !    INTENT
-0000b860: 2849 4e29 0a20 2021 3e20 2020 2020 2020  (IN).  !>       
-0000b870: 5c70 6172 616d 5b69 6e5d 2022 7265 616c  \param[in] "real
-0000b880: 2864 7029 2c20 6469 6d65 6e73 696f 6e28  (dp), dimension(
-0000b890: 3a29 203a 3a20 7061 7261 6d65 7465 7273  :) :: parameters
-0000b8a0: 6574 220a 2020 213e 2020 2020 2020 205c  et".  !>       \
-0000b8b0: 7061 7261 6d5b 696e 5d20 2270 726f 6365  param[in] "proce
-0000b8c0: 6475 7265 2865 7661 6c5f 696e 7465 7266  dure(eval_interf
-0000b8d0: 6163 6529 203a 3a20 6576 616c 220a 0a20  ace) :: eval".. 
-0000b8e0: 2021 2020 2020 5245 5455 524e 0a20 2021   !    RETURN.  !
-0000b8f0: 3e20 2020 2020 2020 5c72 6574 7572 6e20  >       \return 
-0000b900: 7265 616c 2864 7029 203a 3a20 6f62 6a65  real(dp) :: obje
-0000b910: 6374 6976 655f 736d 5f73 7365 5f73 7461  ctive_sm_sse_sta
-0000b920: 6e64 6172 645f 7363 6f72 6520 266d 6461  ndard_score &mda
-0000b930: 7368 3b20 6f62 6a65 6374 6976 6520 6675  sh; objective fu
-0000b940: 6e63 7469 6f6e 2076 616c 7565 0a20 2021  nction value.  !
-0000b950: 3e20 2020 2020 2020 2877 6869 6368 2077  >       (which w
-0000b960: 696c 6c20 6265 2065 2e67 2e20 6d69 6e69  ill be e.g. mini
-0000b970: 6d69 7a65 6420 6279 2061 6e20 6f70 7469  mized by an opti
-0000b980: 6d69 7a61 7469 6f6e 2072 6f75 7469 6e65  mization routine
-0000b990: 206c 696b 6520 4444 5329 0a0a 2020 2120   like DDS)..  ! 
-0000b9a0: 2020 2048 4953 544f 5259 0a20 2021 3e20     HISTORY.  !> 
-0000b9b0: 2020 2020 2020 5c61 7574 686f 7273 204d        \authors M
-0000b9c0: 6174 7468 6961 7320 5a69 6e6b 0a0a 2020  atthias Zink..  
-0000b9d0: 213e 2020 2020 2020 205c 6461 7465 204d  !>       \date M
-0000b9e0: 6172 6368 2032 3031 350a 0a20 2021 204d  arch 2015..  ! M
-0000b9f0: 6f64 6966 6963 6174 696f 6e73 3a0a 2020  odifications:.  
-0000ba00: 2120 526f 6265 7274 2053 6368 7765 7070  ! Robert Schwepp
-0000ba10: 6520 4a75 6e20 3230 3138 202d 2072 6566  e Jun 2018 - ref
-0000ba20: 6163 746f 7269 6e67 2061 6e64 2072 6566  actoring and ref
-0000ba30: 6f72 6d61 7474 696e 670a 0a20 2046 554e  ormatting..  FUN
-0000ba40: 4354 494f 4e20 6f62 6a65 6374 6976 655f  CTION objective_
-0000ba50: 736d 5f73 7365 5f73 7461 6e64 6172 645f  sm_sse_standard_
-0000ba60: 7363 6f72 6528 7061 7261 6d65 7465 7273  score(parameters
-0000ba70: 6574 2c20 6576 616c 290a 0a20 2020 2075  et, eval)..    u
-0000ba80: 7365 206d 6f5f 6f70 7469 6d69 7a61 7469  se mo_optimizati
-0000ba90: 6f6e 5f74 7970 6573 2c20 6f6e 6c79 203a  on_types, only :
-0000baa0: 206f 7074 6964 6174 615f 7369 6d0a 2020   optidata_sim.  
-0000bab0: 2020 7573 6520 6d6f 5f63 6f6d 6d6f 6e5f    use mo_common_
-0000bac0: 7661 7269 6162 6c65 732c 206f 6e6c 7920  variables, only 
-0000bad0: 3a20 6c65 7665 6c31 2c20 646f 6d61 696e  : level1, domain
-0000bae0: 4d65 7461 0a20 2020 2075 7365 206d 6f5f  Meta.    use mo_
-0000baf0: 6572 726f 726d 6561 7375 7265 732c 206f  errormeasures, o
-0000bb00: 6e6c 7920 3a20 5353 450a 2020 2020 7573  nly : SSE.    us
-0000bb10: 6520 6d6f 5f67 6c6f 6261 6c5f 7661 7269  e mo_global_vari
-0000bb20: 6162 6c65 732c 206f 6e6c 7920 3a20 4c31  ables, only : L1
-0000bb30: 5f73 6d4f 6273 0a20 2020 2075 7365 206d  _smObs.    use m
-0000bb40: 6f5f 6d65 7373 6167 652c 206f 6e6c 7920  o_message, only 
-0000bb50: 3a20 6d65 7373 6167 650a 2020 2020 7573  : message.    us
-0000bb60: 6520 6d6f 5f73 7461 6e64 6172 645f 7363  e mo_standard_sc
-0000bb70: 6f72 652c 206f 6e6c 7920 3a20 7374 616e  ore, only : stan
-0000bb80: 6461 7264 5f73 636f 7265 0a20 2020 2075  dard_score.    u
-0000bb90: 7365 206d 6f5f 7374 7269 6e67 5f75 7469  se mo_string_uti
-0000bba0: 6c73 2c20 6f6e 6c79 203a 206e 756d 3273  ls, only : num2s
-0000bbb0: 7472 0a0a 2020 2020 696d 706c 6963 6974  tr..    implicit
-0000bbc0: 206e 6f6e 650a 0a20 2020 2072 6561 6c28   none..    real(
-0000bbd0: 6470 292c 2064 696d 656e 7369 6f6e 283a  dp), dimension(:
-0000bbe0: 292c 2069 6e74 656e 7428 696e 2920 3a3a  ), intent(in) ::
-0000bbf0: 2070 6172 616d 6574 6572 7365 740a 0a20   parameterset.. 
-0000bc00: 2020 2070 726f 6365 6475 7265 2865 7661     procedure(eva
-0000bc10: 6c5f 696e 7465 7266 6163 6529 2c20 494e  l_interface), IN
-0000bc20: 5445 4e54 2849 4e29 2c20 504f 494e 5445  TENT(IN), POINTE
-0000bc30: 5220 3a3a 2065 7661 6c0a 0a20 2020 2072  R :: eval..    r
-0000bc40: 6561 6c28 6470 2920 3a3a 206f 626a 6563  eal(dp) :: objec
-0000bc50: 7469 7665 5f73 6d5f 7373 655f 7374 616e  tive_sm_sse_stan
-0000bc60: 6461 7264 5f73 636f 7265 0a0a 2020 2020  dard_score..    
-0000bc70: 2120 646f 6d61 696e 206c 6f6f 7020 636f  ! domain loop co
-0000bc80: 756e 7465 720a 2020 2020 696e 7465 6765  unter.    intege
-0000bc90: 7228 6934 2920 3a3a 2069 446f 6d61 696e  r(i4) :: iDomain
-0000bca0: 0a0a 2020 2020 2120 6365 6c6c 206c 6f6f  ..    ! cell loo
-0000bcb0: 7020 636f 756e 7465 720a 2020 2020 696e  p counter.    in
-0000bcc0: 7465 6765 7228 6934 2920 3a3a 2069 4365  teger(i4) :: iCe
-0000bcd0: 6c6c 0a0a 2020 2020 2120 6e63 656c 6c73  ll..    ! ncells
-0000bce0: 3120 6f66 206c 6576 656c 2031 0a20 2020  1 of level 1.   
-0000bcf0: 2069 6e74 6567 6572 2869 3429 203a 3a20   integer(i4) :: 
-0000bd00: 6e63 656c 6c73 310a 0a20 2020 2021 206e  ncells1..    ! n
-0000bd10: 756d 6265 7220 6f66 2069 6e76 616c 6964  umber of invalid
-0000bd20: 2063 656c 6c73 2069 6e20 6361 7463 686d   cells in catchm
-0000bd30: 656e 740a 2020 2020 7265 616c 2864 7029  ent.    real(dp)
-0000bd40: 203a 3a20 696e 7661 6c69 645f 6365 6c6c   :: invalid_cell
-0000bd50: 730a 0a20 2020 2021 2064 6f6d 6169 6e73  s..    ! domains
-0000bd60: 2077 6973 6520 6f62 6a65 6374 6976 6573   wise objectives
-0000bd70: 0a20 2020 2072 6561 6c28 6470 2920 3a3a  .    real(dp) ::
-0000bd80: 206f 626a 6563 7469 7665 5f73 6d5f 7373   objective_sm_ss
-0000bd90: 655f 7374 616e 6461 7264 5f73 636f 7265  e_standard_score
-0000bda0: 5f64 6f6d 6169 6e0a 0a23 6966 6e64 6566  _domain..#ifndef
-0000bdb0: 204d 5049 0a20 2020 2072 6561 6c28 6470   MPI.    real(dp
-0000bdc0: 292c 2070 6172 616d 6574 6572 203a 3a20  ), parameter :: 
-0000bdd0: 6f6e 6573 6978 7468 203d 2031 2e30 5f64  onesixth = 1.0_d
-0000bde0: 7020 2f20 362e 305f 6470 0a23 656e 6469  p / 6.0_dp.#endi
-0000bdf0: 660a 0a20 2020 2021 2073 696d 756c 6174  f..    ! simulat
-0000be00: 6564 2073 6f69 6c20 6d6f 6973 7475 7265  ed soil moisture
-0000be10: 0a20 2020 2074 7970 6528 6f70 7469 6461  .    type(optida
-0000be20: 7461 5f73 696d 292c 2064 696d 656e 7369  ta_sim), dimensi
-0000be30: 6f6e 283a 292c 2061 6c6c 6f63 6174 6162  on(:), allocatab
-0000be40: 6c65 203a 3a20 736d 4f70 7469 5369 6d0a  le :: smOptiSim.
-0000be50: 0a0a 2020 2020 6361 6c6c 2065 7661 6c28  ..    call eval(
-0000be60: 7061 7261 6d65 7465 7273 6574 2c20 736d  parameterset, sm
-0000be70: 4f70 7469 5369 6d20 3d20 736d 4f70 7469  OptiSim = smOpti
-0000be80: 5369 6d29 0a0a 2020 2020 2120 696e 6974  Sim)..    ! init
-0000be90: 6961 6c69 7a65 2073 6f6d 6520 7661 7269  ialize some vari
-0000bea0: 6162 6c65 730a 2020 2020 6f62 6a65 6374  ables.    object
-0000beb0: 6976 655f 736d 5f73 7365 5f73 7461 6e64  ive_sm_sse_stand
-0000bec0: 6172 645f 7363 6f72 6520 3d20 302e 305f  ard_score = 0.0_
-0000bed0: 6470 0a0a 2020 2020 2120 6c6f 6f70 206f  dp..    ! loop o
-0000bee0: 7665 7220 646f 6d61 696e 202d 2066 6f72  ver domain - for
-0000bef0: 2061 7070 6c79 696e 6720 706f 7765 7220   applying power 
-0000bf00: 6c61 7720 6c61 7465 7220 6f6e 0a20 2020  law later on.   
-0000bf10: 2064 6f20 6944 6f6d 6169 6e20 3d20 312c   do iDomain = 1,
-0000bf20: 2064 6f6d 6169 6e4d 6574 6125 6e44 6f6d   domainMeta%nDom
-0000bf30: 6169 6e73 0a0a 2020 2020 2020 2120 696e  ains..      ! in
-0000bf40: 6974 0a20 2020 2020 206f 626a 6563 7469  it.      objecti
-0000bf50: 7665 5f73 6d5f 7373 655f 7374 616e 6461  ve_sm_sse_standa
-0000bf60: 7264 5f73 636f 7265 5f64 6f6d 6169 6e20  rd_score_domain 
-0000bf70: 3d20 302e 305f 6470 0a20 2020 2020 2021  = 0.0_dp.      !
-0000bf80: 2067 6574 2064 6f6d 6169 6e20 696e 666f   get domain info
-0000bf90: 726d 6174 696f 6e0a 2020 2020 2020 6e43  rmation.      nC
-0000bfa0: 656c 6c73 3120 3d20 6c65 7665 6c31 2869  ells1 = level1(i
-0000bfb0: 446f 6d61 696e 2925 6e43 656c 6c73 0a0a  Domain)%nCells..
-0000bfc0: 2020 2020 2020 696e 7661 6c69 645f 6365        invalid_ce
-0000bfd0: 6c6c 7320 3d20 302e 305f 6470 0a20 2020  lls = 0.0_dp.   
-0000bfe0: 2020 2021 2073 7461 6e64 6172 645f 7363     ! standard_sc
-0000bff0: 6f72 6520 7369 676e 616c 2069 7320 6361  ore signal is ca
-0000c000: 6c63 756c 6174 6564 206f 6e20 696e 6469  lculated on indi
-0000c010: 7669 6475 616c 2067 7269 6420 6365 6c6c  vidual grid cell
-0000c020: 730a 2020 2020 2020 646f 2069 4365 6c6c  s.      do iCell
-0000c030: 203d 2031 2c20 7369 7a65 284c 315f 736d   = 1, size(L1_sm
-0000c040: 4f62 7328 6944 6f6d 6169 6e29 256d 6173  Obs(iDomain)%mas
-0000c050: 6b4f 6273 283a 2c20 3a29 2c20 6469 6d20  kObs(:, :), dim 
-0000c060: 3d20 3129 0a0a 2020 2020 2020 2020 2120  = 1)..        ! 
-0000c070: 6368 6563 6b20 666f 7220 656e 6f75 6768  check for enough
-0000c080: 2064 6174 6120 706f 696e 7473 2069 6e20   data points in 
-0000c090: 7469 6d65 2066 6f72 2073 7461 7469 7374  time for statist
-0000c0a0: 6963 616c 2063 616c 6375 6c61 7469 6f6e  ical calculation
-0000c0b0: 7320 2865 2e67 2e20 6d65 616e 2c20 7374  s (e.g. mean, st
-0000c0c0: 6464 6576 290a 2020 2020 2020 2020 6966  ddev).        if
-0000c0d0: 2028 636f 756e 7428 4c31 5f73 6d4f 6273   (count(L1_smObs
-0000c0e0: 2869 446f 6d61 696e 2925 6d61 736b 4f62  (iDomain)%maskOb
-0000c0f0: 7328 6943 656c 6c2c 203a 2929 202e 4c45  s(iCell, :)) .LE
-0000c100: 2e20 2830 2e31 305f 6470 202a 2072 6561  . (0.10_dp * rea
-0000c110: 6c28 7369 7a65 284c 315f 736d 4f62 7328  l(size(L1_smObs(
-0000c120: 6944 6f6d 6169 6e29 2564 6174 614f 6273  iDomain)%dataObs
-0000c130: 2c20 6469 6d20 3d20 3229 2c20 6470 2929  , dim = 2), dp))
-0000c140: 2920 7468 656e 0a20 2020 2020 2020 2020  ) then.         
-0000c150: 2069 6e76 616c 6964 5f63 656c 6c73 203d   invalid_cells =
-0000c160: 2069 6e76 616c 6964 5f63 656c 6c73 202b   invalid_cells +
-0000c170: 2031 2e30 5f64 700a 2020 2020 2020 2020   1.0_dp.        
-0000c180: 2020 6379 636c 650a 2020 2020 2020 2020    cycle.        
-0000c190: 656e 6420 6966 0a20 2020 2020 2020 206f  end if.        o
-0000c1a0: 626a 6563 7469 7665 5f73 6d5f 7373 655f  bjective_sm_sse_
-0000c1b0: 7374 616e 6461 7264 5f73 636f 7265 5f64  standard_score_d
-0000c1c0: 6f6d 6169 6e20 3d20 6f62 6a65 6374 6976  omain = objectiv
-0000c1d0: 655f 736d 5f73 7365 5f73 7461 6e64 6172  e_sm_sse_standar
-0000c1e0: 645f 7363 6f72 655f 646f 6d61 696e 202b  d_score_domain +
-0000c1f0: 2026 0a20 2020 2020 2020 2020 2020 2020   &.             
-0000c200: 2020 2053 5345 2873 7461 6e64 6172 645f     SSE(standard_
-0000c210: 7363 6f72 6528 4c31 5f73 6d4f 6273 2869  score(L1_smObs(i
-0000c220: 446f 6d61 696e 2925 6461 7461 4f62 7328  Domain)%dataObs(
-0000c230: 6943 656c 6c2c 203a 292c 206d 6173 6b20  iCell, :), mask 
-0000c240: 3d20 4c31 5f73 6d4f 6273 2869 446f 6d61  = L1_smObs(iDoma
-0000c250: 696e 2925 6d61 736b 4f62 7328 6943 656c  in)%maskObs(iCel
-0000c260: 6c2c 203a 2929 2c20 260a 2020 2020 2020  l, :)), &.      
-0000c270: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c280: 2020 7374 616e 6461 7264 5f73 636f 7265    standard_score
-0000c290: 2873 6d4f 7074 6953 696d 2869 446f 6d61  (smOptiSim(iDoma
-0000c2a0: 696e 2925 6461 7461 5369 6d28 6943 656c  in)%dataSim(iCel
-0000c2b0: 6c2c 203a 292c 206d 6173 6b20 3d20 4c31  l, :), mask = L1
-0000c2c0: 5f73 6d4f 6273 2869 446f 6d61 696e 2925  _smObs(iDomain)%
-0000c2d0: 6d61 736b 4f62 7328 6943 656c 6c2c 203a  maskObs(iCell, :
-0000c2e0: 2929 2c20 260a 2020 2020 2020 2020 2020  )), &.          
-0000c2f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c300: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c310: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c320: 6d61 736b 203d 204c 315f 736d 4f62 7328  mask = L1_smObs(
-0000c330: 6944 6f6d 6169 6e29 256d 6173 6b4f 6273  iDomain)%maskObs
-0000c340: 2869 4365 6c6c 2c20 3a29 290a 0a20 2020  (iCell, :))..   
-0000c350: 2020 2065 6e64 2064 6f0a 0a20 2020 2020     end do..     
-0000c360: 2021 2075 7365 7220 696e 666f 726d 6174   ! user informat
-0000c370: 696f 6e20 6162 6f75 7420 696e 7661 6c69  ion about invali
-0000c380: 6420 6365 6c6c 730a 2020 2020 2020 6966  d cells.      if
-0000c390: 2028 696e 7661 6c69 645f 6365 6c6c 7320   (invalid_cells 
-0000c3a0: 2e47 542e 2030 2e35 5f64 7029 2074 6865  .GT. 0.5_dp) the
-0000c3b0: 6e0a 2020 2020 2020 2020 6361 6c6c 206d  n.        call m
-0000c3c0: 6573 7361 6765 2827 2020 2057 4152 4e49  essage('   WARNI
-0000c3d0: 4e47 3a20 6f62 6a65 6374 6976 655f 736d  NG: objective_sm
-0000c3e0: 3a20 4465 7465 6374 6564 2069 6e76 616c  : Detected inval
-0000c3f0: 6964 2063 656c 6c73 2069 6e20 7374 7564  id cells in stud
-0000c400: 7920 6172 6561 2028 2e4c 542e 2031 3020  y area (.LT. 10 
-0000c410: 7661 6c69 6420 6461 7461 2070 6f69 6e74  valid data point
-0000c420: 7329 2e27 290a 2020 2020 2020 2020 6361  s).').        ca
-0000c430: 6c6c 206d 6573 7361 6765 2827 2020 2020  ll message('    
-0000c440: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c450: 2020 2020 2020 4672 6163 7469 6f6e 206f        Fraction o
-0000c460: 6620 696e 7661 6c69 6420 6365 6c6c 733a  f invalid cells:
-0000c470: 2027 2c20 260a 2020 2020 2020 2020 2020   ', &.          
-0000c480: 2020 2020 2020 6e75 6d32 7374 7228 696e        num2str(in
-0000c490: 7661 6c69 645f 6365 6c6c 7320 2f20 7265  valid_cells / re
-0000c4a0: 616c 286e 4365 6c6c 7331 2c20 6470 292c  al(nCells1, dp),
-0000c4b0: 2027 2846 342e 3229 2729 290a 2020 2020   '(F4.2)')).    
-0000c4c0: 2020 656e 6420 6966 0a0a 2020 2020 2020    end if..      
-0000c4d0: 2120 6361 6c63 756c 6174 6520 6176 6572  ! calculate aver
-0000c4e0: 6167 6520 736f 696c 206d 6f69 7374 7572  age soil moistur
-0000c4f0: 6520 636f 7272 656c 6174 696f 6e20 6f76  e correlation ov
-0000c500: 6572 2061 6c6c 2064 6f6d 6169 6e73 2077  er all domains w
-0000c510: 6974 6820 706f 7765 7220 6c61 770a 2020  ith power law.  
-0000c520: 2020 2020 2120 646f 6d61 696e 7320 6172      ! domains ar
-0000c530: 6520 7765 6967 6874 6564 2065 7175 616c  e weighted equal
-0000c540: 6c79 2028 2031 202f 2072 6561 6c28 646f  ly ( 1 / real(do
-0000c550: 6d61 696e 4d65 7461 256f 7665 7261 6c6c  mainMeta%overall
-0000c560: 4e75 6d62 6572 4f66 446f 6d61 696e 732c  NumberOfDomains,
-0000c570: 6470 2929 2a2a 360a 2020 2020 2020 6f62  dp))**6.      ob
-0000c580: 6a65 6374 6976 655f 736d 5f73 7365 5f73  jective_sm_sse_s
-0000c590: 7461 6e64 6172 645f 7363 6f72 6520 3d20  tandard_score = 
-0000c5a0: 6f62 6a65 6374 6976 655f 736d 5f73 7365  objective_sm_sse
-0000c5b0: 5f73 7461 6e64 6172 645f 7363 6f72 6520  _standard_score 
-0000c5c0: 2b20 260a 2020 2020 2020 2020 2020 2020  + &.            
-0000c5d0: 2020 286f 626a 6563 7469 7665 5f73 6d5f    (objective_sm_
-0000c5e0: 7373 655f 7374 616e 6461 7264 5f73 636f  sse_standard_sco
-0000c5f0: 7265 5f64 6f6d 6169 6e20 2f20 7265 616c  re_domain / real
-0000c600: 2864 6f6d 6169 6e4d 6574 6125 6f76 6572  (domainMeta%over
-0000c610: 616c 6c4e 756d 6265 724f 6644 6f6d 6169  allNumberOfDomai
-0000c620: 6e73 2c20 6470 2929 2a2a 360a 2020 2020  ns, dp))**6.    
-0000c630: 656e 6420 646f 0a0a 2369 666e 6465 6620  end do..#ifndef 
-0000c640: 4d50 490a 2020 2020 6f62 6a65 6374 6976  MPI.    objectiv
-0000c650: 655f 736d 5f73 7365 5f73 7461 6e64 6172  e_sm_sse_standar
-0000c660: 645f 7363 6f72 6520 3d20 6f62 6a65 6374  d_score = object
-0000c670: 6976 655f 736d 5f73 7365 5f73 7461 6e64  ive_sm_sse_stand
-0000c680: 6172 645f 7363 6f72 652a 2a6f 6e65 7369  ard_score**onesi
-0000c690: 7874 680a 0a20 2020 2063 616c 6c20 6d65  xth..    call me
-0000c6a0: 7373 6167 6528 2720 2020 206f 626a 6563  ssage('    objec
-0000c6b0: 7469 7665 5f73 6d5f 7373 655f 7374 616e  tive_sm_sse_stan
-0000c6c0: 6461 7264 5f73 636f 7265 203d 2027 2c20  dard_score = ', 
-0000c6d0: 6e75 6d32 7374 7228 6f62 6a65 6374 6976  num2str(objectiv
-0000c6e0: 655f 736d 5f73 7365 5f73 7461 6e64 6172  e_sm_sse_standar
-0000c6f0: 645f 7363 6f72 652c 2027 2845 3132 2e35  d_score, '(E12.5
-0000c700: 2927 2929 0a23 656e 6469 660a 0a20 2045  )')).#endif..  E
-0000c710: 4e44 2046 554e 4354 494f 4e20 6f62 6a65  ND FUNCTION obje
-0000c720: 6374 6976 655f 736d 5f73 7365 5f73 7461  ctive_sm_sse_sta
-0000c730: 6e64 6172 645f 7363 6f72 650a 0a0a 2020  ndard_score...  
-0000c740: 2120 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ! --------------
-0000c750: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0000c760: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0000c770: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0000c780: 2d2d 2d0a 0a20 2021 2020 2020 4e41 4d45  ---..  !    NAME
-0000c790: 0a20 2021 2020 2020 2020 2020 6f62 6a65  .  !        obje
-0000c7a0: 6374 6976 655f 6b67 655f 715f 726d 7365  ctive_kge_q_rmse
-0000c7b0: 5f74 7773 0a0a 2020 2120 2020 2050 5552  _tws..  !    PUR
-0000c7c0: 504f 5345 0a20 2021 3e20 2020 2020 2020  POSE.  !>       
-0000c7d0: 5c62 7269 6566 204f 626a 6563 7469 7665  \brief Objective
-0000c7e0: 2066 756e 6374 696f 6e20 6f66 204b 4745   function of KGE
-0000c7f0: 2066 6f72 2072 756e 6f66 6620 616e 6420   for runoff and 
-0000c800: 524d 5345 2066 6f72 2064 6f6d 6169 6e5f  RMSE for domain_
-0000c810: 6176 6720 5457 5320 2873 7461 6e64 6172  avg TWS (standar
-0000c820: 697a 6564 2073 636f 7265 7329 0a0a 2020  ized scores)..  
-0000c830: 213e 2020 2020 2020 205c 6465 7461 696c  !>       \detail
-0000c840: 7320 4f62 6a65 6374 6976 6520 6675 6e63  s Objective func
-0000c850: 7469 6f6e 206f 6620 4b47 4520 666f 7220  tion of KGE for 
-0000c860: 7275 6e6f 6666 2061 6e64 2052 4d53 4520  runoff and RMSE 
-0000c870: 666f 7220 646f 6d61 696e 5f61 7667 2054  for domain_avg T
-0000c880: 5753 2028 7374 616e 6461 7269 7a65 6420  WS (standarized 
-0000c890: 7363 6f72 6573 290a 0a20 2021 2020 2020  scores)..  !    
-0000c8a0: 494e 5445 4e54 2849 4e29 0a20 2021 3e20  INTENT(IN).  !> 
-0000c8b0: 2020 2020 2020 5c70 6172 616d 5b69 6e5d        \param[in]
-0000c8c0: 2022 7265 616c 2864 7029 2c20 6469 6d65   "real(dp), dime
-0000c8d0: 6e73 696f 6e28 3a29 203a 3a20 7061 7261  nsion(:) :: para
-0000c8e0: 6d65 7465 7273 6574 220a 2020 213e 2020  meterset".  !>  
-0000c8f0: 2020 2020 205c 7061 7261 6d5b 696e 5d20       \param[in] 
-0000c900: 2270 726f 6365 6475 7265 2865 7661 6c5f  "procedure(eval_
-0000c910: 696e 7465 7266 6163 6529 203a 3a20 6576  interface) :: ev
-0000c920: 616c 220a 0a20 2021 2020 2020 5245 5455  al"..  !    RETU
-0000c930: 524e 0a20 2021 3e20 2020 2020 2020 5c72  RN.  !>       \r
-0000c940: 6574 7572 6e20 7265 616c 2864 7029 203a  eturn real(dp) :
-0000c950: 3a20 6f62 6a65 6374 6976 655f 6b67 655f  : objective_kge_
-0000c960: 715f 726d 7365 5f74 7773 2026 6d64 6173  q_rmse_tws &mdas
-0000c970: 683b 206f 626a 6563 7469 7665 2066 756e  h; objective fun
-0000c980: 6374 696f 6e20 7661 6c75 650a 2020 213e  ction value.  !>
-0000c990: 2020 2020 2020 2028 7768 6963 6820 7769         (which wi
-0000c9a0: 6c6c 2062 6520 652e 672e 206d 696e 696d  ll be e.g. minim
-0000c9b0: 697a 6564 2062 7920 616e 206f 7074 696d  ized by an optim
-0000c9c0: 697a 6174 696f 6e20 726f 7574 696e 6520  ization routine 
-0000c9d0: 6c69 6b65 2044 4453 290a 0a20 2021 2020  like DDS)..  !  
-0000c9e0: 2020 4849 5354 4f52 590a 2020 213e 2020    HISTORY.  !>  
-0000c9f0: 2020 2020 205c 6175 7468 6f72 7320 4f6c       \authors Ol
-0000ca00: 6472 6963 6820 5261 6b6f 7665 632c 2052  drich Rakovec, R
-0000ca10: 6f68 696e 6920 4b75 6d61 720a 0a20 2021  ohini Kumar..  !
-0000ca20: 3e20 2020 2020 2020 5c64 6174 6520 4f63  >       \date Oc
-0000ca30: 742e 2032 3031 350a 0a20 2021 204d 6f64  t. 2015..  ! Mod
-0000ca40: 6966 6963 6174 696f 6e73 3a0a 2020 2120  ifications:.  ! 
-0000ca50: 5374 6570 6861 6e20 5468 6f62 6572 204f  Stephan Thober O
-0000ca60: 6374 2032 3031 3520 2d20 6d6f 7665 6420  ct 2015 - moved 
-0000ca70: 7477 7320 6f70 7469 6d69 7a61 7469 6f6e  tws optimization
-0000ca80: 2066 726f 6d20 6d6f 5f6d 726d 5f6f 626a   from mo_mrm_obj
-0000ca90: 6563 7469 7665 5f66 756e 6374 696f 6e5f  ective_function_
-0000caa0: 7275 6e6f 6666 2068 6572 650a 2020 2120  runoff here.  ! 
-0000cab0: 526f 6265 7274 2053 6368 7765 7070 6520  Robert Schweppe 
-0000cac0: 4a75 6e20 3230 3138 202d 2072 6566 6163  Jun 2018 - refac
-0000cad0: 746f 7269 6e67 2061 6e64 2072 6566 6f72  toring and refor
-0000cae0: 6d61 7474 696e 670a 2020 2120 4d61 7265  matting.  ! Mare
-0000caf0: 6e20 4b61 6c75 7a61 204f 6374 2032 3031  n Kaluza Oct 201
-0000cb00: 3920 2d20 6368 616e 6765 6420 6176 6572  9 - changed aver
-0000cb10: 6167 696e 6720 6675 6e63 7469 6f6e 2066  aging function f
-0000cb20: 6f72 2074 7773 2c20 7468 6973 2077 696c  or tws, this wil
-0000cb30: 6c20 6e6f 7420 7072 6f64 7563 6520 7468  l not produce th
-0000cb40: 6520 7361 6d65 206f 7574 7075 7420 6173  e same output as
-0000cb50: 2062 6566 6f72 650a 0a20 2046 554e 4354   before..  FUNCT
-0000cb60: 494f 4e20 6f62 6a65 6374 6976 655f 6b67  ION objective_kg
-0000cb70: 655f 715f 726d 7365 5f74 7773 2870 6172  e_q_rmse_tws(par
-0000cb80: 616d 6574 6572 7365 742c 2065 7661 6c29  ameterset, eval)
-0000cb90: 0a0a 2020 2020 7573 6520 6d6f 5f6f 7074  ..    use mo_opt
-0000cba0: 696d 697a 6174 696f 6e5f 7479 7065 732c  imization_types,
-0000cbb0: 206f 6e6c 7920 3a20 6f70 7469 6461 7461   only : optidata
-0000cbc0: 5f73 696d 0a20 2020 2075 7365 206d 6f5f  _sim.    use mo_
-0000cbd0: 636f 6d6d 6f6e 5f63 6f6e 7374 616e 7473  common_constants
-0000cbe0: 2c20 6f6e 6c79 203a 2065 7073 5f64 702c  , only : eps_dp,
-0000cbf0: 206e 6f64 6174 615f 6470 0a20 2020 2075   nodata_dp.    u
-0000cc00: 7365 206d 6f5f 636f 6d6d 6f6e 5f6d 686d  se mo_common_mhm
-0000cc10: 5f6d 726d 5f76 6172 6961 626c 6573 2c20  _mrm_variables, 
-0000cc20: 6f6e 6c79 203a 2065 7661 6c50 6572 0a20  only : evalPer. 
-0000cc30: 2020 2075 7365 206d 6f5f 636f 6d6d 6f6e     use mo_common
-0000cc40: 5f76 6172 6961 626c 6573 2c20 6f6e 6c79  _variables, only
-0000cc50: 203a 2064 6f6d 6169 6e4d 6574 610a 2020   : domainMeta.  
-0000cc60: 2020 7573 6520 6d6f 5f67 6c6f 6261 6c5f    use mo_global_
-0000cc70: 7661 7269 6162 6c65 732c 206f 6e6c 7920  variables, only 
-0000cc80: 3a20 4c31 5f74 7773 614f 6273 0a20 2020  : L1_twsaObs.   
-0000cc90: 2075 7365 206d 6f5f 6572 726f 726d 6561   use mo_errormea
-0000cca0: 7375 7265 732c 206f 6e6c 7920 3a20 726d  sures, only : rm
-0000ccb0: 7365 0a20 2020 2075 7365 206d 6f5f 6a75  se.    use mo_ju
-0000ccc0: 6c69 616e 2c20 6f6e 6c79 203a 2063 616c  lian, only : cal
-0000ccd0: 6461 740a 2020 2020 7573 6520 6d6f 5f6d  dat.    use mo_m
-0000cce0: 6573 7361 6765 2c20 6f6e 6c79 203a 206d  essage, only : m
-0000ccf0: 6573 7361 6765 0a20 2020 2075 7365 206d  essage.    use m
-0000cd00: 6f5f 6d6f 6d65 6e74 2c20 6f6e 6c79 203a  o_moment, only :
-0000cd10: 206d 6561 6e0a 2020 2020 7573 6520 6d6f   mean.    use mo
-0000cd20: 5f73 7461 6e64 6172 645f 7363 6f72 652c  _standard_score,
-0000cd30: 206f 6e6c 7920 3a20 636c 6173 7369 6669   only : classifi
-0000cd40: 6564 5f73 7461 6e64 6172 645f 7363 6f72  ed_standard_scor
-0000cd50: 650a 2020 2020 7573 6520 6d6f 5f73 7472  e.    use mo_str
-0000cd60: 696e 675f 7574 696c 732c 206f 6e6c 7920  ing_utils, only 
-0000cd70: 3a20 6e75 6d32 7374 720a 2020 2020 7573  : num2str.    us
-0000cd80: 6520 6d6f 5f74 656d 706f 7261 6c5f 6167  e mo_temporal_ag
-0000cd90: 6772 6567 6174 696f 6e2c 206f 6e6c 7920  gregation, only 
-0000cda0: 3a20 6461 7932 6d6f 6e5f 6176 6572 6167  : day2mon_averag
-0000cdb0: 650a 2020 2020 7573 6520 6d6f 5f65 7272  e.    use mo_err
-0000cdc0: 6f72 6d65 6173 7572 6573 2c20 6f6e 6c79  ormeasures, only
-0000cdd0: 203a 206b 6765 0a20 2020 2075 7365 206d   : kge.    use m
-0000cde0: 6f5f 6d72 6d5f 6f62 6a65 6374 6976 655f  o_mrm_objective_
-0000cdf0: 6675 6e63 7469 6f6e 5f72 756e 6f66 662c  function_runoff,
-0000ce00: 206f 6e6c 7920 3a20 6578 7472 6163 745f   only : extract_
-0000ce10: 7275 6e6f 6666 0a0a 2020 2020 696d 706c  runoff..    impl
-0000ce20: 6963 6974 206e 6f6e 650a 0a20 2020 2072  icit none..    r
-0000ce30: 6561 6c28 6470 292c 2064 696d 656e 7369  eal(dp), dimensi
-0000ce40: 6f6e 283a 292c 2069 6e74 656e 7428 696e  on(:), intent(in
-0000ce50: 2920 3a3a 2070 6172 616d 6574 6572 7365  ) :: parameterse
-0000ce60: 740a 0a20 2020 2070 726f 6365 6475 7265  t..    procedure
-0000ce70: 2865 7661 6c5f 696e 7465 7266 6163 6529  (eval_interface)
-0000ce80: 2c20 494e 5445 4e54 2849 4e29 2c20 504f  , INTENT(IN), PO
-0000ce90: 494e 5445 5220 3a3a 2065 7661 6c0a 0a20  INTER :: eval.. 
-0000cea0: 2020 2072 6561 6c28 6470 2920 3a3a 206f     real(dp) :: o
-0000ceb0: 626a 6563 7469 7665 5f6b 6765 5f71 5f72  bjective_kge_q_r
-0000cec0: 6d73 655f 7477 730a 0a20 2020 2021 206d  mse_tws..    ! m
-0000ced0: 6f64 656c 6c65 6420 7275 6e6f 6666 2066  odelled runoff f
-0000cee0: 6f72 2061 2067 6976 656e 2070 6172 616d  or a given param
-0000cef0: 6574 6572 2073 6574 0a20 2020 2021 2064  eter set.    ! d
-0000cf00: 696d 313d 6e54 696d 6553 7465 7073 2c20  im1=nTimeSteps, 
-0000cf10: 6469 6d32 3d6e 4761 7567 6573 0a20 2020  dim2=nGauges.   
-0000cf20: 2072 6561 6c28 6470 292c 2061 6c6c 6f63   real(dp), alloc
-0000cf30: 6174 6162 6c65 2c20 6469 6d65 6e73 696f  atable, dimensio
-0000cf40: 6e28 3a2c 203a 2920 3a3a 2072 756e 6f66  n(:, :) :: runof
-0000cf50: 660a 0a20 2020 2021 3e20 7369 6d75 6c61  f..    !> simula
-0000cf60: 7465 6420 7477 730a 2020 2020 7479 7065  ted tws.    type
-0000cf70: 286f 7074 6964 6174 615f 7369 6d29 2c20  (optidata_sim), 
-0000cf80: 6469 6d65 6e73 696f 6e28 3a29 2c20 616c  dimension(:), al
-0000cf90: 6c6f 6361 7461 626c 6520 3a3a 2074 7773  locatable :: tws
-0000cfa0: 4f70 7469 5369 6d0a 0a20 2020 2021 2064  OptiSim..    ! d
-0000cfb0: 6f6d 6169 6e20 636f 756e 7465 722c 206d  omain counter, m
-0000cfc0: 6f6e 7468 2063 6f75 6e74 6572 730a 2020  onth counters.  
-0000cfd0: 2020 696e 7465 6765 7228 6934 2920 3a3a    integer(i4) ::
-0000cfe0: 2064 6f6d 6169 6e49 442c 2069 446f 6d61   domainID, iDoma
-0000cff0: 696e 2c20 7070 2c20 6d6d 6d0a 0a20 2020  in, pp, mmm..   
-0000d000: 2069 6e74 6567 6572 2869 3429 203a 3a20   integer(i4) :: 
-0000d010: 7965 6172 2c20 6d6f 6e74 682c 2064 6179  year, month, day
-0000d020: 0a0a 2020 2020 7265 616c 2864 7029 2c20  ..    real(dp), 
-0000d030: 6469 6d65 6e73 696f 6e28 646f 6d61 696e  dimension(domain
-0000d040: 4d65 7461 256e 446f 6d61 696e 7329 203a  Meta%nDomains) :
-0000d050: 3a20 696e 6974 5469 6d65 0a0a 2020 2020  : initTime..    
-0000d060: 2120 7369 6d75 6c61 7465 6420 7477 730a  ! simulated tws.
-0000d070: 2020 2020 7265 616c 2864 7029 2c20 6469      real(dp), di
-0000d080: 6d65 6e73 696f 6e28 3a29 2c20 616c 6c6f  mension(:), allo
-0000d090: 6361 7461 626c 6520 3a3a 2074 7773 5f63  catable :: tws_c
-0000d0a0: 6174 6368 5f61 7667 5f64 6f6d 6169 6e0a  atch_avg_domain.
-0000d0b0: 0a20 2020 2021 206d 6561 7375 7265 6420  .    ! measured 
-0000d0c0: 7477 730a 2020 2020 7265 616c 2864 7029  tws.    real(dp)
-0000d0d0: 2c20 6469 6d65 6e73 696f 6e28 3a29 2c20  , dimension(:), 
-0000d0e0: 616c 6c6f 6361 7461 626c 6520 3a3a 2074  allocatable :: t
-0000d0f0: 7773 5f6f 7074 695f 6361 7463 685f 6176  ws_opti_catch_av
-0000d100: 675f 646f 6d61 696e 0a0a 2020 2020 2120  g_domain..    ! 
-0000d110: 6d61 736b 2066 6f72 206d 6561 7375 7265  mask for measure
-0000d120: 6420 7477 730a 2020 2020 6c6f 6769 6361  d tws.    logica
-0000d130: 6c2c 2064 696d 656e 7369 6f6e 283a 292c  l, dimension(:),
-0000d140: 2061 6c6c 6f63 6174 6162 6c65 203a 3a20   allocatable :: 
-0000d150: 7477 735f 6f62 735f 6d61 736b 0a0a 2020  tws_obs_mask..  
-0000d160: 2020 2120 746f 7461 6c20 6e75 6d62 6572    ! total number
-0000d170: 206f 6620 6d6f 6e74 6873 0a20 2020 2069   of months.    i
-0000d180: 6e74 6567 6572 2869 3429 203a 3a20 6e4d  nteger(i4) :: nM
-0000d190: 6f6e 7468 730a 0a20 2020 2021 2076 6563  onths..    ! vec
-0000d1a0: 746f 7220 7769 7468 206d 6f6e 7468 7327  tor with months'
-0000d1b0: 2063 6c61 7373 6573 0a20 2020 2069 6e74   classes.    int
-0000d1c0: 6567 6572 2869 3429 2c20 6469 6d65 6e73  eger(i4), dimens
-0000d1d0: 696f 6e28 3a29 2c20 616c 6c6f 6361 7461  ion(:), allocata
-0000d1e0: 626c 6520 3a3a 206d 6f6e 7468 5f63 6c61  ble :: month_cla
-0000d1f0: 7373 6573 0a0a 2020 2020 2120 6d6f 6e74  sses..    ! mont
-0000d200: 686c 7920 7661 6c75 6573 2061 6e6f 6d61  hly values anoma
-0000d210: 6c79 2074 696d 6520 7365 7269 6573 0a20  ly time series. 
-0000d220: 2020 2072 6561 6c28 6470 292c 2044 494d     real(dp), DIM
-0000d230: 454e 5349 4f4e 283a 292c 2061 6c6c 6f63  ENSION(:), alloc
-0000d240: 6174 6162 6c65 203a 3a20 7477 735f 7369  atable :: tws_si
-0000d250: 6d5f 6d5f 616e 6f6d 2c20 7477 735f 6f62  m_m_anom, tws_ob
-0000d260: 735f 6d5f 616e 6f6d 0a0a 2020 2020 2120  s_m_anom..    ! 
-0000d270: 726d 7365 5f74 7773 2864 6f6d 6169 6e4d  rmse_tws(domainM
-0000d280: 6574 6125 6e44 6f6d 6169 6e73 290a 2020  eta%nDomains).  
-0000d290: 2020 7265 616c 2864 7029 2c20 6469 6d65    real(dp), dime
-0000d2a0: 6e73 696f 6e28 3a29 2c20 616c 6c6f 6361  nsion(:), alloca
-0000d2b0: 7461 626c 6520 3a3a 2072 6d73 655f 7477  table :: rmse_tw
-0000d2c0: 730a 0a20 2020 2021 206f 626a 2e20 6675  s..    ! obj. fu
-0000d2d0: 6e63 7469 6f6e 730a 2020 2020 7265 616c  nctions.    real
-0000d2e0: 2864 7029 203a 3a20 726d 7365 5f74 7773  (dp) :: rmse_tws
-0000d2f0: 5f61 7667 2c20 6b67 655f 715f 6176 670a  _avg, kge_q_avg.
-0000d300: 0a20 2020 2069 6e74 6567 6572 2869 3429  .    integer(i4)
-0000d310: 203a 3a20 6e47 6175 6765 7354 6f74 616c   :: nGaugesTotal
-0000d320: 0a0a 2020 2020 2120 6167 6772 6567 6174  ..    ! aggregat
-0000d330: 6564 2073 696d 756c 6174 6564 2072 756e  ed simulated run
-0000d340: 6f66 660a 2020 2020 7265 616c 2864 7029  off.    real(dp)
-0000d350: 2c20 6469 6d65 6e73 696f 6e28 3a29 2c20  , dimension(:), 
-0000d360: 616c 6c6f 6361 7461 626c 6520 3a3a 2072  allocatable :: r
-0000d370: 756e 6f66 665f 6167 670a 0a20 2020 2021  unoff_agg..    !
-0000d380: 206d 6561 7375 7265 6420 7275 6e6f 6666   measured runoff
-0000d390: 0a20 2020 2072 6561 6c28 6470 292c 2064  .    real(dp), d
-0000d3a0: 696d 656e 7369 6f6e 283a 292c 2061 6c6c  imension(:), all
-0000d3b0: 6f63 6174 6162 6c65 203a 3a20 7275 6e6f  ocatable :: runo
-0000d3c0: 6666 5f6f 6273 0a0a 2020 2020 2120 6d61  ff_obs..    ! ma
-0000d3d0: 736b 2066 6f72 206d 6561 7375 7265 6420  sk for measured 
-0000d3e0: 7275 6e6f 6666 0a20 2020 206c 6f67 6963  runoff.    logic
-0000d3f0: 616c 2c20 6469 6d65 6e73 696f 6e28 3a29  al, dimension(:)
-0000d400: 2c20 616c 6c6f 6361 7461 626c 6520 3a3a  , allocatable ::
-0000d410: 2072 756e 6f66 665f 6f62 735f 6d61 736b   runoff_obs_mask
-0000d420: 0a0a 2020 2020 2120 6b67 655f 7128 6e47  ..    ! kge_q(nG
-0000d430: 6175 6765 7354 6f74 616c 290a 2020 2020  augesTotal).    
-0000d440: 7265 616c 2864 7029 2c20 6469 6d65 6e73  real(dp), dimens
-0000d450: 696f 6e28 3a29 2c20 616c 6c6f 6361 7461  ion(:), allocata
-0000d460: 626c 6520 3a3a 206b 6765 5f71 0a0a 2020  ble :: kge_q..  
-0000d470: 2020 2120 6761 7567 6573 2063 6f75 6e74    ! gauges count
-0000d480: 6572 0a20 2020 2069 6e74 6567 6572 2869  er.    integer(i
-0000d490: 3429 203a 3a20 6767 0a0a 2020 2020 2120  4) :: gg..    ! 
-0000d4a0: 6f62 7461 696e 2068 6f75 726c 7920 7661  obtain hourly va
-0000d4b0: 6c75 6573 206f 6620 7275 6e6f 6666 2061  lues of runoff a
-0000d4c0: 6e64 2074 7773 3a0a 2020 2020 616c 6c6f  nd tws:.    allo
-0000d4d0: 6361 7465 2874 7773 4f70 7469 5369 6d28  cate(twsOptiSim(
-0000d4e0: 646f 6d61 696e 4d65 7461 256e 446f 6d61  domainMeta%nDoma
-0000d4f0: 696e 7329 290a 2020 2020 6361 6c6c 2065  ins)).    call e
-0000d500: 7661 6c28 7061 7261 6d65 7465 7273 6574  val(parameterset
-0000d510: 2c20 7275 6e6f 6666 203d 2072 756e 6f66  , runoff = runof
-0000d520: 662c 2074 7773 4f70 7469 5369 6d20 3d20  f, twsOptiSim = 
-0000d530: 7477 734f 7074 6953 696d 290a 0a20 2020  twsOptiSim)..   
-0000d540: 2021 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d   !--------------
-0000d550: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0000d560: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a20  --------------. 
-0000d570: 2020 2021 2120 5457 530a 2020 2020 212d     !! TWS.    !-
+00002a70: 6976 655f 6574 5f6b 6765 5f63 6174 6368  ive_et_kge_catch
+00002a80: 6d65 6e74 5f61 7667 203d 2027 2c20 6e75  ment_avg = ', nu
+00002a90: 6d32 7374 7228 6f62 6a65 6374 6976 655f  m2str(objective_
+00002aa0: 6d61 7374 6572 2c20 2728 4639 2e35 2927  master, '(F9.5)'
+00002ab0: 2929 0a20 2020 2063 6173 6528 3238 290a  )).    case(28).
+00002ac0: 2020 2020 2020 6361 6c6c 206d 6573 7361        call messa
+00002ad0: 6765 2827 2020 2020 6f62 6a65 6374 6976  ge('    objectiv
+00002ae0: 655f 6b67 655f 715f 736d 5f63 6f72 7220  e_kge_q_sm_corr 
+00002af0: 3d20 272c 206e 756d 3273 7472 286f 626a  = ', num2str(obj
+00002b00: 6563 7469 7665 5f6d 6173 7465 722c 2027  ective_master, '
+00002b10: 2846 392e 3529 2729 290a 2020 2020 6361  (F9.5)')).    ca
+00002b20: 7365 2832 3929 0a20 2020 2020 2063 616c  se(29).      cal
+00002b30: 6c20 6d65 7373 6167 6528 2720 2020 206f  l message('    o
+00002b40: 626a 6563 7469 7665 5f6b 6765 5f71 5f65  bjective_kge_q_e
+00002b50: 7420 3d20 272c 206e 756d 3273 7472 286f  t = ', num2str(o
+00002b60: 626a 6563 7469 7665 5f6d 6173 7465 722c  bjective_master,
+00002b70: 2027 2846 392e 3529 2729 290a 2020 2020   '(F9.5)')).    
+00002b80: 6361 7365 2833 3329 0a20 2020 2020 2063  case(33).      c
+00002b90: 616c 6c20 6d65 7373 6167 6528 2720 2020  all message('   
+00002ba0: 206f 626a 6563 7469 7665 5f71 5f65 745f   objective_q_et_
+00002bb0: 7477 735f 6b67 655f 6361 7463 686d 656e  tws_kge_catchmen
+00002bc0: 745f 6176 6720 3d20 272c 206e 756d 3273  t_avg = ', num2s
+00002bd0: 7472 286f 626a 6563 7469 7665 5f6d 6173  tr(objective_mas
+00002be0: 7465 722c 2027 2846 392e 3529 2729 290a  ter, '(F9.5)')).
+00002bf0: 2020 2020 6361 7365 2064 6566 6175 6c74      case default
+00002c00: 0a20 2020 2020 2063 616c 6c20 6572 726f  .      call erro
+00002c10: 725f 6d65 7373 6167 6528 2245 7272 6f72  r_message("Error
+00002c20: 206f 626a 6563 7469 7665 5f6d 6173 7465   objective_maste
+00002c30: 723a 206f 7074 695f 6675 6e63 7469 6f6e  r: opti_function
+00002c40: 206e 6f74 2069 6d70 6c65 6d65 6e74 6564   not implemented
+00002c50: 2079 6574 2c20 7468 6973 2070 6172 7420   yet, this part 
+00002c60: 6f66 2074 6865 2063 6f64 6520 7368 6f75  of the code shou
+00002c70: 6c64 206e 6576 6572 2065 7865 6375 7465  ld never execute
+00002c80: 2e22 290a 2020 2020 656e 6420 7365 6c65  .").    end sele
+00002c90: 6374 0a0a 2020 454e 4420 4655 4e43 5449  ct..  END FUNCTI
+00002ca0: 4f4e 206f 626a 6563 7469 7665 5f6d 6173  ON objective_mas
+00002cb0: 7465 720a 0a20 2021 202d 2d2d 2d2d 2d2d  ter..  ! -------
+00002cc0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00002cd0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00002ce0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00002cf0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 0a20 2021  -----------..  !
+00002d00: 2020 2020 4e41 4d45 0a20 2021 2020 2020      NAME.  !    
+00002d10: 2020 2020 6f62 6a65 6374 6976 655f 7375      objective_su
+00002d20: 6270 726f 6365 7373 0a0a 2020 2120 2020  bprocess..  !   
+00002d30: 2050 5552 504f 5345 0a20 2021 3e20 2020   PURPOSE.  !>   
+00002d40: 2020 2020 5c62 7269 6566 2057 7261 7070      \brief Wrapp
+00002d50: 6572 2066 6f72 206f 626a 6563 7469 7665  er for objective
+00002d60: 2066 756e 6374 696f 6e73 2e0a 0a20 2021   functions...  !
+00002d70: 3e20 2020 2020 2020 5c64 6574 6169 6c73  >       \details
+00002d80: 2054 6865 2066 756e 6374 696f 6e20 7265   The function re
+00002d90: 6365 6976 6573 2074 6865 2070 6172 616d  ceives the param
+00002da0: 6574 6572 7365 7420 6672 6f6d 2074 6865  eterset from the
+00002db0: 206d 6173 7465 720a 2020 213e 2020 2020   master.  !>    
+00002dc0: 2020 2070 726f 6365 7373 2c20 7365 6c65     process, sele
+00002dd0: 6374 7320 7468 6520 6f62 6a65 6374 6976  cts the objectiv
+00002de0: 6520 6675 6e63 7469 6f6e 2063 6173 6520  e function case 
+00002df0: 6465 6669 6e65 6420 696e 2061 206e 616d  defined in a nam
+00002e00: 656c 6973 742c 0a20 2021 3e20 2020 2020  elist,.  !>     
+00002e10: 2020 692e 652e 2074 6865 2067 6c6f 6261    i.e. the globa
+00002e20: 6c20 7661 7269 6162 6c65 205c 6520 6f70  l variable \e op
+00002e30: 7469 5c5f 6675 6e63 7469 6f6e 2e0a 2020  ti\_function..  
+00002e40: 213e 2020 2020 2020 2049 7420 7265 7475  !>       It retu
+00002e50: 726e 7320 7468 6520 7061 7274 6961 6c20  rns the partial 
+00002e60: 6f62 6a65 6374 6976 6520 6675 6e63 7469  objective functi
+00002e70: 6f6e 2076 616c 7565 2066 6f72 2061 2073  on value for a s
+00002e80: 7065 6369 6669 6320 7061 7261 6d65 7465  pecific paramete
+00002e90: 7220 7365 742e 0a0a 2020 2120 2020 2049  r set...  !    I
+00002ea0: 4e54 454e 5428 494e 290a 2020 213e 2020  NTENT(IN).  !>  
+00002eb0: 2020 2020 205c 7061 7261 6d5b 696e 5d20       \param[in] 
+00002ec0: 2252 4541 4c28 6470 292c 2044 494d 454e  "REAL(dp), DIMEN
+00002ed0: 5349 4f4e 283a 2920 3a3a 2070 6172 616d  SION(:) :: param
+00002ee0: 6574 6572 7365 7422 0a20 2021 3e20 2020  eterset".  !>   
+00002ef0: 2020 2020 5c70 6172 616d 5b69 6e5d 2022      \param[in] "
+00002f00: 7072 6f63 6564 7572 6528 6576 616c 5f69  procedure(eval_i
+00002f10: 6e74 6572 6661 6365 2920 3a3a 2065 7661  nterface) :: eva
+00002f20: 6c22 0a0a 2020 2120 2020 2049 4e54 454e  l"..  !    INTEN
+00002f30: 5428 494e 292c 204f 5054 494f 4e41 4c0a  T(IN), OPTIONAL.
+00002f40: 2020 213e 2020 2020 2020 205c 7061 7261    !>       \para
+00002f50: 6d5b 696e 5d20 2272 6561 6c28 6470 292c  m[in] "real(dp),
+00002f60: 206f 7074 696f 6e61 6c20 3a3a 2061 7267   optional :: arg
+00002f70: 3122 0a0a 2020 2120 2020 2049 4e54 454e  1"..  !    INTEN
+00002f80: 5428 4f55 5429 2c20 4f50 5449 4f4e 414c  T(OUT), OPTIONAL
+00002f90: 0a20 2021 3e20 2020 2020 2020 5c70 6172  .  !>       \par
+00002fa0: 616d 5b6f 7574 5d20 2272 6561 6c28 6470  am[out] "real(dp
+00002fb0: 292c 206f 7074 696f 6e61 6c20 3a3a 2061  ), optional :: a
+00002fc0: 7267 3222 0a20 2021 3e20 2020 2020 2020  rg2".  !>       
+00002fd0: 5c70 6172 616d 5b6f 7574 5d20 2272 6561  \param[out] "rea
+00002fe0: 6c28 6470 292c 206f 7074 696f 6e61 6c20  l(dp), optional 
+00002ff0: 3a3a 2061 7267 3322 0a0a 2020 2120 2020  :: arg3"..  !   
+00003000: 2052 4554 5552 4e0a 2020 213e 2020 2020   RETURN.  !>    
+00003010: 2020 205c 7265 7475 726e 2072 6561 6c28     \return real(
+00003020: 6470 2920 3a3a 206f 626a 6563 7469 7665  dp) :: objective
+00003030: 2026 6d64 6173 683b 206f 626a 6563 7469   &mdash; objecti
+00003040: 7665 2066 756e 6374 696f 6e20 7661 6c75  ve function valu
+00003050: 650a 2020 213e 2020 2020 2020 2028 7768  e.  !>       (wh
+00003060: 6963 6820 7769 6c6c 2062 6520 652e 672e  ich will be e.g.
+00003070: 206d 696e 696d 697a 6564 2062 7920 616e   minimized by an
+00003080: 206f 7074 696d 697a 6174 696f 6e20 726f   optimization ro
+00003090: 7574 696e 6520 6c69 6b65 2044 4453 290a  utine like DDS).
+000030a0: 0a20 2021 2020 2020 4849 5354 4f52 590a  .  !    HISTORY.
+000030b0: 2020 213e 2020 2020 2020 205c 6175 7468    !>       \auth
+000030c0: 6f72 7320 4a75 6c69 616e 6520 4d61 690a  ors Juliane Mai.
+000030d0: 0a20 2021 3e20 2020 2020 2020 5c64 6174  .  !>       \dat
+000030e0: 6520 4465 6320 3230 3132 0a0a 2020 2120  e Dec 2012..  ! 
+000030f0: 4d6f 6469 6669 6361 7469 6f6e 733a 0a20  Modifications:. 
+00003100: 2021 2053 7465 7068 616e 2054 686f 6265   ! Stephan Thobe
+00003110: 7220 4f63 7420 3230 3135 202d 206d 6f76  r Oct 2015 - mov
+00003120: 6564 2061 6c6c 2072 756e 6f66 6620 7265  ed all runoff re
+00003130: 6c61 7465 6420 6f62 6a65 6374 6976 6520  lated objective 
+00003140: 6675 6e63 7469 6f6e 7320 746f 206d 524d  functions to mRM
+00003150: 0a20 2021 2052 6f62 6572 7420 5363 6877  .  ! Robert Schw
+00003160: 6570 7065 204a 756e 2032 3031 3820 2d20  eppe Jun 2018 - 
+00003170: 7265 6661 6374 6f72 696e 6720 616e 6420  refactoring and 
+00003180: 7265 666f 726d 6174 7469 6e67 0a20 2021  reformatting.  !
+00003190: 204d 6172 656e 204b 616c 757a 6120 4a75   Maren Kaluza Ju
+000031a0: 6e20 3230 3139 202d 2070 6172 616c 6c65  n 2019 - paralle
+000031b0: 6c20 7665 7273 696f 6e0a 0a20 2073 7562  l version..  sub
+000031c0: 726f 7574 696e 6520 6f62 6a65 6374 6976  routine objectiv
+000031d0: 655f 7375 6270 726f 6365 7373 2865 7661  e_subprocess(eva
+000031e0: 6c2c 2061 7267 312c 2061 7267 322c 2061  l, arg1, arg2, a
+000031f0: 7267 3329 0a0a 2020 2020 7573 6520 6d6f  rg3)..    use mo
+00003200: 5f63 6f6d 6d6f 6e5f 636f 6e73 7461 6e74  _common_constant
+00003210: 732c 206f 6e6c 7920 3a20 6e6f 6461 7461  s, only : nodata
+00003220: 5f64 700a 2020 2020 7573 6520 6d6f 5f63  _dp.    use mo_c
+00003230: 6f6d 6d6f 6e5f 6d48 4d5f 6d52 4d5f 7661  ommon_mHM_mRM_va
+00003240: 7269 6162 6c65 732c 206f 6e6c 7920 3a20  riables, only : 
+00003250: 6f70 7469 5f66 756e 6374 696f 6e0a 2020  opti_function.  
+00003260: 2020 7573 6520 6d6f 5f63 6f6d 6d6f 6e5f    use mo_common_
+00003270: 6d70 695f 746f 6f6c 732c 206f 6e6c 7920  mpi_tools, only 
+00003280: 3a20 6765 745f 7061 7261 6d65 7465 7273  : get_parameters
+00003290: 6574 0a20 2020 2075 7365 206d 6f5f 636f  et.    use mo_co
+000032a0: 6d6d 6f6e 5f76 6172 6961 626c 6573 2c20  mmon_variables, 
+000032b0: 6f6e 6c79 203a 2064 6f6d 6169 6e4d 6574  only : domainMet
+000032c0: 610a 2020 2020 7573 6520 6d70 695f 6630  a.    use mpi_f0
+000032d0: 380a 0a20 2020 2069 6d70 6c69 6369 7420  8..    implicit 
+000032e0: 6e6f 6e65 0a0a 2020 2020 7072 6f63 6564  none..    proced
+000032f0: 7572 6528 6576 616c 5f69 6e74 6572 6661  ure(eval_interfa
+00003300: 6365 292c 2049 4e54 454e 5428 494e 292c  ce), INTENT(IN),
+00003310: 2050 4f49 4e54 4552 203a 3a20 6576 616c   POINTER :: eval
+00003320: 0a0a 2020 2020 7265 616c 2864 7029 2c20  ..    real(dp), 
+00003330: 6f70 7469 6f6e 616c 2c20 696e 7465 6e74  optional, intent
+00003340: 2869 6e29 203a 3a20 6172 6731 0a0a 2020  (in) :: arg1..  
+00003350: 2020 7265 616c 2864 7029 2c20 6f70 7469    real(dp), opti
+00003360: 6f6e 616c 2c20 696e 7465 6e74 286f 7574  onal, intent(out
+00003370: 2920 3a3a 2061 7267 320a 0a20 2020 2072  ) :: arg2..    r
+00003380: 6561 6c28 6470 292c 206f 7074 696f 6e61  eal(dp), optiona
+00003390: 6c2c 2069 6e74 656e 7428 6f75 7429 203a  l, intent(out) :
+000033a0: 3a20 6172 6733 0a0a 2020 2020 5245 414c  : arg3..    REAL
+000033b0: 2864 7029 203a 3a20 7061 7274 6961 6c5f  (dp) :: partial_
+000033c0: 6f62 6a65 6374 6976 650a 0a20 2020 2072  objective..    r
+000033d0: 6561 6c28 6470 292c 2064 696d 656e 7369  eal(dp), dimensi
+000033e0: 6f6e 2836 2920 3a3a 206d 756c 7469 706c  on(6) :: multipl
+000033f0: 655f 7061 7274 6961 6c5f 6f62 6a65 6374  e_partial_object
+00003400: 6976 650a 0a20 2020 2052 4541 4c28 6470  ive..    REAL(dp
+00003410: 292c 2044 494d 454e 5349 4f4e 283a 292c  ), DIMENSION(:),
+00003420: 2061 6c6c 6f63 6174 6162 6c65 203a 3a20   allocatable :: 
+00003430: 7061 7261 6d65 7465 7273 6574 0a0a 2020  parameterset..  
+00003440: 2020 696e 7465 6765 7228 6934 2920 3a3a    integer(i4) ::
+00003450: 2069 6572 726f 720a 0a20 2020 2074 7970   ierror..    typ
+00003460: 6528 4d50 495f 5374 6174 7573 2920 3a3a  e(MPI_Status) ::
+00003470: 2073 7461 7475 730a 0a20 2020 206c 6f67   status..    log
+00003480: 6963 616c 203a 3a20 646f 5f6f 626a 5f6c  ical :: do_obj_l
+00003490: 6f6f 700a 0a20 2020 2064 6f20 2120 6120  oop..    do ! a 
+000034a0: 646f 206c 6f6f 7020 7769 7468 6f75 7420  do loop without 
+000034b0: 636f 6e64 6974 696f 6e20 7275 6e73 2075  condition runs u
+000034c0: 6e74 696c 2065 7869 740a 2020 2020 2020  ntil exit.      
+000034d0: 6361 6c6c 204d 5049 5f52 6563 7628 646f  call MPI_Recv(do
+000034e0: 5f6f 626a 5f6c 6f6f 702c 2031 2c20 4d50  _obj_loop, 1, MP
+000034f0: 495f 4c4f 4749 4341 4c2c 2030 2c20 302c  I_LOGICAL, 0, 0,
+00003500: 2064 6f6d 6169 6e4d 6574 6125 636f 6d4d   domainMeta%comM
+00003510: 6173 7465 722c 2073 7461 7475 732c 2069  aster, status, i
+00003520: 6572 726f 7229 0a0a 2020 2020 2020 6966  error)..      if
+00003530: 2028 2e6e 6f74 2e20 646f 5f6f 626a 5f6c   (.not. do_obj_l
+00003540: 6f6f 7029 2065 7869 740a 0a20 2020 2020  oop) exit..     
+00003550: 2069 6620 2870 7265 7365 6e74 2861 7267   if (present(arg
+00003560: 3129 202e 6f72 2e20 7072 6573 656e 7428  1) .or. present(
+00003570: 6172 6732 2920 2e6f 722e 2070 7265 7365  arg2) .or. prese
+00003580: 6e74 2861 7267 3329 2920 7468 656e 0a20  nt(arg3)) then. 
+00003590: 2020 2020 2020 2063 616c 6c20 6572 726f         call erro
+000035a0: 725f 6d65 7373 6167 6528 2245 7272 6f72  r_message("Error
+000035b0: 206d 6f5f 6f62 6a65 6374 6976 655f 6675   mo_objective_fu
+000035c0: 6e63 7469 6f6e 3a20 5265 6365 6976 6564  nction: Received
+000035d0: 2075 6e65 7870 6563 7465 6420 6172 6775   unexpected argu
+000035e0: 6d65 6e74 2c20 6368 6563 6b20 6f70 7469  ment, check opti
+000035f0: 6d69 7a61 7469 6f6e 2073 6574 7469 6e67  mization setting
+00003600: 7322 290a 2020 2020 2020 656e 6420 6966  s").      end if
+00003610: 0a0a 2020 2020 2020 2120 7365 7420 7468  ..      ! set th
+00003620: 6573 6520 746f 206e 616e 2073 6f20 636f  ese to nan so co
+00003630: 6d70 696c 6572 2064 6f65 7320 6e6f 7420  mpiler does not 
+00003640: 636f 6d70 6c61 696e 0a20 2020 2020 2069  complain.      i
+00003650: 6620 2870 7265 7365 6e74 2861 7267 3229  f (present(arg2)
+00003660: 2920 7468 656e 0a20 2020 2020 2020 2061  ) then.        a
+00003670: 7267 3220 3d20 6e6f 6461 7461 5f64 700a  rg2 = nodata_dp.
+00003680: 2020 2020 2020 656e 6420 6966 0a20 2020        end if.   
+00003690: 2020 2069 6620 2870 7265 7365 6e74 2861     if (present(a
+000036a0: 7267 3329 2920 7468 656e 0a20 2020 2020  rg3)) then.     
+000036b0: 2020 2061 7267 3320 3d20 6e6f 6461 7461     arg3 = nodata
+000036c0: 5f64 700a 2020 2020 2020 656e 6420 6966  _dp.      end if
+000036d0: 0a20 2020 2020 2063 616c 6c20 6765 745f  .      call get_
+000036e0: 7061 7261 6d65 7465 7273 6574 2870 6172  parameterset(par
+000036f0: 616d 6574 6572 7365 7429 0a20 2020 2020  ameterset).     
+00003700: 2073 656c 6563 7420 6361 7365 2028 6f70   select case (op
+00003710: 7469 5f66 756e 6374 696f 6e29 0a20 2020  ti_function).   
+00003720: 2020 2063 6173 6520 2831 3029 0a20 2020     case (10).   
+00003730: 2020 2020 2021 204b 4745 206f 6620 6361       ! KGE of ca
+00003740: 7463 686d 656e 7420 6176 6572 6167 6520  tchment average 
+00003750: 534d 0a20 2020 2020 2020 2070 6172 7469  SM.        parti
+00003760: 616c 5f6f 626a 6563 7469 7665 203d 206f  al_objective = o
+00003770: 626a 6563 7469 7665 5f73 6d5f 6b67 655f  bjective_sm_kge_
+00003780: 6361 7463 686d 656e 745f 6176 6728 7061  catchment_avg(pa
+00003790: 7261 6d65 7465 7273 6574 2c20 6576 616c  rameterset, eval
+000037a0: 290a 2020 2020 2020 6361 7365 2028 3131  ).      case (11
+000037b0: 290a 2020 2020 2020 2020 2120 7061 7474  ).        ! patt
+000037c0: 6572 6e20 6469 7373 696d 696c 6172 6974  ern dissimilarit
+000037d0: 7920 2850 4429 206f 6620 534d 2066 6965  y (PD) of SM fie
+000037e0: 6c64 730a 2020 2020 2020 2020 7061 7274  lds.        part
+000037f0: 6961 6c5f 6f62 6a65 6374 6976 6520 3d20  ial_objective = 
+00003800: 6f62 6a65 6374 6976 655f 736d 5f70 6428  objective_sm_pd(
+00003810: 7061 7261 6d65 7465 7273 6574 2c20 6576  parameterset, ev
+00003820: 616c 290a 2020 2020 2020 6361 7365 2028  al).      case (
+00003830: 3132 290a 2020 2020 2020 2020 2120 7375  12).        ! su
+00003840: 6d20 6f66 2073 7175 6172 6564 2065 7272  m of squared err
+00003850: 6f72 7320 6f66 2073 7461 6e64 6172 645f  ors of standard_
+00003860: 7363 6f72 6520 534d 0a20 2020 2020 2020  score SM.       
+00003870: 2070 6172 7469 616c 5f6f 626a 6563 7469   partial_objecti
+00003880: 7665 203d 206f 626a 6563 7469 7665 5f73  ve = objective_s
+00003890: 6d5f 7373 655f 7374 616e 6461 7264 5f73  m_sse_standard_s
+000038a0: 636f 7265 2870 6172 616d 6574 6572 7365  core(parameterse
+000038b0: 742c 2065 7661 6c29 0a20 2020 2020 2063  t, eval).      c
+000038c0: 6173 6520 2831 3329 0a20 2020 2020 2020  ase (13).       
+000038d0: 2021 2073 6f69 6c20 6d6f 6973 7475 7265   ! soil moisture
+000038e0: 2063 6f72 7265 6c61 7469 6f6e 202d 2074   correlation - t
+000038f0: 656d 706f 7261 6c0a 2020 2020 2020 2020  emporal.        
+00003900: 7061 7274 6961 6c5f 6f62 6a65 6374 6976  partial_objectiv
+00003910: 6520 3d20 6f62 6a65 6374 6976 655f 736d  e = objective_sm
+00003920: 5f63 6f72 7228 7061 7261 6d65 7465 7273  _corr(parameters
+00003930: 6574 2c20 6576 616c 290a 2020 2020 2020  et, eval).      
+00003940: 6361 7365 2028 3135 290a 2020 2020 2020  case (15).      
+00003950: 2020 2120 4b47 4520 666f 7220 5120 2a20    ! KGE for Q * 
+00003960: 524d 5345 2066 6f72 2064 6f6d 6169 6e5f  RMSE for domain_
+00003970: 6176 6720 5457 5320 2873 7461 6e64 6172  avg TWS (standar
+00003980: 697a 6564 2073 636f 7265 6429 0a20 2020  ized scored).   
+00003990: 2020 2020 2021 2070 6172 7469 616c 5f6f       ! partial_o
+000039a0: 626a 6563 7469 7665 203d 206f 626a 6563  bjective = objec
+000039b0: 7469 7665 5f6b 6765 5f71 5f72 6d73 655f  tive_kge_q_rmse_
+000039c0: 7477 7328 7061 7261 6d65 7465 7273 6574  tws(parameterset
+000039d0: 2c20 6576 616c 290a 2020 2020 2020 2020  , eval).        
+000039e0: 6361 6c6c 2065 7272 6f72 5f6d 6573 7361  call error_messa
+000039f0: 6765 2822 4572 726f 7220 6f62 6a65 6374  ge("Error object
+00003a00: 6976 655f 7375 6270 726f 6365 7373 3a20  ive_subprocess: 
+00003a10: 6361 7365 2031 3520 6e6f 7420 7375 7070  case 15 not supp
+00003a20: 6f72 7465 6420 7769 7468 204d 5049 2e22  orted with MPI."
+00003a30: 290a 2020 2020 2020 6361 7365 2028 3137  ).      case (17
+00003a40: 290a 2020 2020 2020 2020 2120 4b47 4520  ).        ! KGE 
+00003a50: 6f66 2063 6174 6368 6d65 6e74 2061 7665  of catchment ave
+00003a60: 7261 6765 2053 4d0a 2020 2020 2020 2020  rage SM.        
+00003a70: 7061 7274 6961 6c5f 6f62 6a65 6374 6976  partial_objectiv
+00003a80: 6520 3d20 6f62 6a65 6374 6976 655f 6e65  e = objective_ne
+00003a90: 7574 726f 6e73 5f6b 6765 5f63 6174 6368  utrons_kge_catch
+00003aa0: 6d65 6e74 5f61 7667 2870 6172 616d 6574  ment_avg(paramet
+00003ab0: 6572 7365 742c 2065 7661 6c29 0a20 2020  erset, eval).   
+00003ac0: 2020 2063 6173 6520 2832 3729 0a20 2020     case (27).   
+00003ad0: 2020 2020 2021 204b 4745 206f 6620 6361       ! KGE of ca
+00003ae0: 7463 686d 656e 7420 6176 6572 6167 6520  tchment average 
+00003af0: 4554 0a20 2020 2020 2020 2070 6172 7469  ET.        parti
+00003b00: 616c 5f6f 626a 6563 7469 7665 203d 206f  al_objective = o
+00003b10: 626a 6563 7469 7665 5f65 745f 6b67 655f  bjective_et_kge_
+00003b20: 6361 7463 686d 656e 745f 6176 6728 7061  catchment_avg(pa
+00003b30: 7261 6d65 7465 7273 6574 2c20 6576 616c  rameterset, eval
+00003b40: 290a 2020 2020 2020 6361 7365 2028 3238  ).      case (28
+00003b50: 290a 2020 2020 2020 2020 2120 204b 4745  ).        !  KGE
+00003b60: 2066 6f72 2051 202b 2053 5345 2066 6f72   for Q + SSE for
+00003b70: 2053 4d20 2873 7461 6e64 6172 697a 6564   SM (standarized
+00003b80: 2073 636f 7265 6429 0a20 2020 2020 2020   scored).       
+00003b90: 2070 6172 7469 616c 5f6f 626a 6563 7469   partial_objecti
+00003ba0: 7665 203d 206f 626a 6563 7469 7665 5f6b  ve = objective_k
+00003bb0: 6765 5f71 5f73 6d5f 636f 7272 2870 6172  ge_q_sm_corr(par
+00003bc0: 616d 6574 6572 7365 742c 2065 7661 6c29  ameterset, eval)
+00003bd0: 0a20 2020 2020 2063 6173 6520 2832 3929  .      case (29)
+00003be0: 0a20 2020 2020 2020 2021 2020 4b47 4520  .        !  KGE 
+00003bf0: 666f 7220 5120 2b20 4b47 4520 6f66 2063  for Q + KGE of c
+00003c00: 6174 6368 6d65 6e74 2061 7665 7261 6765  atchment average
+00003c10: 2045 540a 2020 2020 2020 2020 7061 7274   ET.        part
+00003c20: 6961 6c5f 6f62 6a65 6374 6976 6520 3d20  ial_objective = 
+00003c30: 6f62 6a65 6374 6976 655f 6b67 655f 715f  objective_kge_q_
+00003c40: 6574 2870 6172 616d 6574 6572 7365 742c  et(parameterset,
+00003c50: 2065 7661 6c29 0a20 2020 2020 2063 6173   eval).      cas
+00003c60: 6520 2833 3029 0a20 2020 2020 2020 2021  e (30).        !
+00003c70: 204b 4745 2066 6f72 2051 202a 2052 4d53   KGE for Q * RMS
+00003c80: 4520 666f 7220 646f 6d61 696e 5f61 7667  E for domain_avg
+00003c90: 2045 5420 2873 7461 6e64 6172 697a 6564   ET (standarized
+00003ca0: 2073 636f 7265 6429 0a20 2020 2020 2020   scored).       
+00003cb0: 2021 2070 6172 7469 616c 5f6f 626a 6563   ! partial_objec
+00003cc0: 7469 7665 203d 206f 626a 6563 7469 7665  tive = objective
+00003cd0: 5f6b 6765 5f71 5f72 6d73 655f 6574 2870  _kge_q_rmse_et(p
+00003ce0: 6172 616d 6574 6572 7365 742c 2065 7661  arameterset, eva
+00003cf0: 6c29 0a20 2020 2020 2020 2063 616c 6c20  l).        call 
+00003d00: 6572 726f 725f 6d65 7373 6167 6528 2245  error_message("E
+00003d10: 7272 6f72 206f 626a 6563 7469 7665 5f73  rror objective_s
+00003d20: 7562 7072 6f63 6573 733a 2063 6173 6520  ubprocess: case 
+00003d30: 3330 206e 6f74 2073 7570 706f 7274 6564  30 not supported
+00003d40: 2077 6974 6820 4d50 492e 2229 0a20 2020   with MPI.").   
+00003d50: 2020 2063 6173 6528 3333 290a 2020 2020     case(33).    
+00003d60: 2020 2020 6d75 6c74 6970 6c65 5f70 6172      multiple_par
+00003d70: 7469 616c 5f6f 626a 6563 7469 7665 203d  tial_objective =
+00003d80: 206f 626a 6563 7469 7665 5f71 5f65 745f   objective_q_et_
+00003d90: 7477 735f 6b67 655f 6361 7463 686d 656e  tws_kge_catchmen
+00003da0: 745f 6176 6728 7061 7261 6d65 7465 7273  t_avg(parameters
+00003db0: 6574 2c20 6576 616c 290a 2020 2020 2020  et, eval).      
+00003dc0: 6361 7365 2064 6566 6175 6c74 0a20 2020  case default.   
+00003dd0: 2020 2020 2063 616c 6c20 6572 726f 725f       call error_
+00003de0: 6d65 7373 6167 6528 2245 7272 6f72 206f  message("Error o
+00003df0: 626a 6563 7469 7665 5f73 7562 7072 6f63  bjective_subproc
+00003e00: 6573 733a 206f 7074 695f 6675 6e63 7469  ess: opti_functi
+00003e10: 6f6e 206e 6f74 2069 6d70 6c65 6d65 6e74  on not implement
+00003e20: 6564 2079 6574 2e22 290a 2020 2020 2020  ed yet.").      
+00003e30: 656e 6420 7365 6c65 6374 0a0a 2020 2020  end select..    
+00003e40: 2020 7365 6c65 6374 2063 6173 6520 286f    select case (o
+00003e50: 7074 695f 6675 6e63 7469 6f6e 290a 2020  pti_function).  
+00003e60: 2020 2020 6361 7365 2028 3130 203a 2031      case (10 : 1
+00003e70: 332c 2031 372c 2032 3720 3a20 3239 290a  3, 17, 27 : 29).
+00003e80: 2020 2020 2020 2020 6361 6c6c 204d 5049          call MPI
+00003e90: 5f53 656e 6428 7061 7274 6961 6c5f 6f62  _Send(partial_ob
+00003ea0: 6a65 6374 6976 652c 312c 204d 5049 5f44  jective,1, MPI_D
+00003eb0: 4f55 424c 455f 5052 4543 4953 494f 4e2c  OUBLE_PRECISION,
+00003ec0: 302c 302c 646f 6d61 696e 4d65 7461 2563  0,0,domainMeta%c
+00003ed0: 6f6d 4d61 7374 6572 2c69 6572 726f 7229  omMaster,ierror)
+00003ee0: 0a20 2020 2020 2063 6173 6528 3333 290a  .      case(33).
+00003ef0: 2020 2020 2020 2020 6361 6c6c 204d 5049          call MPI
+00003f00: 5f53 656e 6428 6d75 6c74 6970 6c65 5f70  _Send(multiple_p
+00003f10: 6172 7469 616c 5f6f 626a 6563 7469 7665  artial_objective
+00003f20: 2c20 362c 204d 5049 5f44 4f55 424c 455f  , 6, MPI_DOUBLE_
+00003f30: 5052 4543 4953 494f 4e2c 302c 302c 646f  PRECISION,0,0,do
+00003f40: 6d61 696e 4d65 7461 2563 6f6d 4d61 7374  mainMeta%comMast
+00003f50: 6572 2c69 6572 726f 7229 0a20 2020 2020  er,ierror).     
+00003f60: 2063 6173 6520 6465 6661 756c 740a 2020   case default.  
+00003f70: 2020 2020 2020 6361 6c6c 2065 7272 6f72        call error
+00003f80: 5f6d 6573 7361 6765 2822 4572 726f 7220  _message("Error 
+00003f90: 6f62 6a65 6374 6976 655f 7375 6270 726f  objective_subpro
+00003fa0: 6365 7373 3a20 7468 6973 2070 6172 7420  cess: this part 
+00003fb0: 7368 6f75 6c64 206e 6f74 2062 6520 6578  should not be ex
+00003fc0: 6563 7574 6564 202d 3e20 6572 726f 7220  ecuted -> error 
+00003fd0: 696e 2074 6865 2063 6f64 652e 2229 0a20  in the code."). 
+00003fe0: 2020 2020 2065 6e64 2073 656c 6563 740a       end select.
+00003ff0: 0a20 2020 2020 2064 6561 6c6c 6f63 6174  .      deallocat
+00004000: 6528 7061 7261 6d65 7465 7273 6574 290a  e(parameterset).
+00004010: 2020 2020 656e 6420 646f 0a0a 2020 454e      end do..  EN
+00004020: 4420 7375 6272 6f75 7469 6e65 206f 626a  D subroutine obj
+00004030: 6563 7469 7665 5f73 7562 7072 6f63 6573  ective_subproces
+00004040: 730a 0a23 656e 6469 660a 2020 2120 2d2d  s..#endif.  ! --
+00004050: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00004060: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00004070: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00004080: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00004090: 0a0a 2020 2120 2020 204e 414d 450a 2020  ..  !    NAME.  
+000040a0: 2120 2020 2020 2020 206f 626a 6563 7469  !        objecti
+000040b0: 7665 5f73 6d5f 6b67 655f 6361 7463 686d  ve_sm_kge_catchm
+000040c0: 656e 745f 6176 670a 0a20 2021 2020 2020  ent_avg..  !    
+000040d0: 5055 5250 4f53 450a 2020 213e 2020 2020  PURPOSE.  !>    
+000040e0: 2020 205c 6272 6965 6620 4f62 6a65 6374     \brief Object
+000040f0: 6976 6520 6675 6e63 7469 6f6e 2066 6f72  ive function for
+00004100: 2073 6f69 6c20 6d6f 6973 7475 7265 2e0a   soil moisture..
+00004110: 0a20 2021 3e20 2020 2020 2020 5c64 6574  .  !>       \det
+00004120: 6169 6c73 2054 6865 206f 626a 6563 7469  ails The objecti
+00004130: 7665 2066 756e 6374 696f 6e20 6f6e 6c79  ve function only
+00004140: 2064 6570 656e 6473 206f 6e20 6120 7061   depends on a pa
+00004150: 7261 6d65 7465 7220 7665 6374 6f72 2e0a  rameter vector..
+00004160: 2020 213e 2020 2020 2020 2054 6865 206d    !>       The m
+00004170: 6f64 656c 2077 696c 6c20 6265 2063 616c  odel will be cal
+00004180: 6c65 6420 7769 7468 2074 6861 7420 7061  led with that pa
+00004190: 7261 6d65 7465 7220 7665 6374 6f72 2061  rameter vector a
+000041a0: 6e64 0a20 2021 3e20 2020 2020 2020 7468  nd.  !>       th
+000041b0: 6520 6d6f 6465 6c20 6f75 7470 7574 2069  e model output i
+000041c0: 7320 7375 6273 6571 7565 6e74 6c79 2063  s subsequently c
+000041d0: 6f6d 7061 7265 6420 746f 206f 6273 6572  ompared to obser
+000041e0: 7665 6420 6461 7461 2e0a 0a20 2021 3e20  ved data...  !> 
+000041f0: 2020 2020 2020 5468 6572 6566 6f72 652c        Therefore,
+00004200: 2074 6865 204b 6c69 6e67 2d47 7570 7461   the Kling-Gupta
+00004210: 206d 6f64 656c 2065 6666 6963 6965 6e63   model efficienc
+00004220: 7920 5c66 2420 4b47 4520 5c66 2420 6f66  y \f$ KGE \f$ of
+00004230: 2074 6865 2063 6174 6368 6d65 6e74 2061   the catchment a
+00004240: 7665 7261 6765 0a20 2021 3e20 2020 2020  verage.  !>     
+00004250: 2020 736f 696c 206d 6c6f 6973 7475 7265    soil mloisture
+00004260: 2028 534d 2920 6973 2063 616c 6375 6c61   (SM) is calcula
+00004270: 7465 640a 2020 213e 2020 2020 2020 205c  ted.  !>       \
+00004280: 665b 204b 4745 203d 2031 2e30 202d 205c  f[ KGE = 1.0 - \
+00004290: 7371 7274 7b28 2028 312d 7229 5e32 202b  sqrt{( (1-r)^2 +
+000042a0: 2028 312d 5c61 6c70 6861 295e 3220 2b20   (1-\alpha)^2 + 
+000042b0: 2831 2d5c 6265 7461 295e 3220 297d 205c  (1-\beta)^2 )} \
+000042c0: 665d 0a20 2021 3e20 2020 2020 2020 7768  f].  !>       wh
+000042d0: 6572 650a 2020 213e 2020 2020 2020 205c  ere.  !>       \
+000042e0: 6624 2072 205c 6624 203d 2050 6561 7273  f$ r \f$ = Pears
+000042f0: 6f6e 2070 726f 6475 6374 2d6d 6f6d 656e  on product-momen
+00004300: 7420 636f 7272 656c 6174 696f 6e20 636f  t correlation co
+00004310: 6566 6669 6369 656e 740a 2020 213e 2020  efficient.  !>  
+00004320: 2020 2020 205c 6624 205c 616c 7068 6120       \f$ \alpha 
+00004330: 5c66 2420 3d20 7261 7469 6f20 6f66 2073  \f$ = ratio of s
+00004340: 696d 756c 6174 6564 206d 6561 6e20 746f  imulated mean to
+00004350: 206f 6273 6572 7665 6420 6d65 616e 2053   observed mean S
+00004360: 4d0a 2020 213e 2020 2020 2020 205c 6624  M.  !>       \f$
+00004370: 205c 6265 7461 2020 5c66 2420 3d20 7261   \beta  \f$ = ra
+00004380: 7469 6f20 6f66 2073 696d 696c 6174 6564  tio of similated
+00004390: 2073 7461 6e64 6172 6420 6465 7669 6174   standard deviat
+000043a0: 696f 6e20 746f 206f 6273 6572 7665 6420  ion to observed 
+000043b0: 7374 616e 6461 7264 2064 6576 6961 7469  standard deviati
+000043c0: 6f6e 0a20 2021 3e20 2020 2020 2020 6973  on.  !>       is
+000043d0: 2063 616c 6375 6c61 7465 6420 616e 6420   calculated and 
+000043e0: 7468 6520 6f62 6a65 6374 6976 6520 6675  the objective fu
+000043f0: 6e63 7469 6f6e 2066 6f72 2061 2067 6976  nction for a giv
+00004400: 656e 2064 6f6d 6169 6e20 5c66 2420 6920  en domain \f$ i 
+00004410: 5c66 2420 6973 0a20 2021 3e20 2020 2020  \f$ is.  !>     
+00004420: 2020 5c66 5b20 5c70 6869 5f7b 697d 203d    \f[ \phi_{i} =
+00004430: 2031 2e30 202d 204b 4745 5f7b 697d 205c   1.0 - KGE_{i} \
+00004440: 665d 0a20 2021 3e20 2020 2020 2020 5c66  f].  !>       \f
+00004450: 2420 5c70 6869 5f7b 697d 205c 6624 2069  $ \phi_{i} \f$ i
+00004460: 7320 7468 6520 6f62 6a65 6374 6976 6520  s the objective 
+00004470: 7369 6e63 6520 7765 2061 6c77 6179 7320  since we always 
+00004480: 6170 706c 7920 6d69 6e69 6d69 7a61 7469  apply minimizati
+00004490: 6f6e 206d 6574 686f 6473 2e0a 2020 213e  on methods..  !>
+000044a0: 2020 2020 2020 2054 6865 206d 696e 696d         The minim
+000044b0: 616c 2076 616c 7565 206f 6620 5c66 2420  al value of \f$ 
+000044c0: 5c70 6869 5f7b 697d 205c 6624 2069 7320  \phi_{i} \f$ is 
+000044d0: 3020 666f 7220 7468 6520 6f70 7469 6d61  0 for the optima
+000044e0: 6c20 4b47 4520 6f66 2031 2e30 2e0a 0a20  l KGE of 1.0... 
+000044f0: 2021 3e20 2020 2020 2020 4669 6e61 6c6c   !>       Finall
+00004500: 792c 2074 6865 206f 7665 7261 6c6c 206f  y, the overall o
+00004510: 626a 6563 7469 7665 2066 756e 6374 696f  bjective functio
+00004520: 6e20 7661 6c75 6520 5c66 2420 4f46 205c  n value \f$ OF \
+00004530: 6624 2069 7320 6573 7469 6d61 7465 6420  f$ is estimated 
+00004540: 6261 7365 6420 6f6e 2074 6865 2070 6f77  based on the pow
+00004550: 6572 2d36 0a20 2021 3e20 2020 2020 2020  er-6.  !>       
+00004560: 6e6f 726d 2074 6f20 636f 6d62 696e 6520  norm to combine 
+00004570: 7468 6520 5c66 2420 5c70 6869 5f7b 697d  the \f$ \phi_{i}
+00004580: 205c 6624 2066 726f 6d20 616c 6c20 646f   \f$ from all do
+00004590: 6d61 696e 7320 5c66 2420 4e20 5c66 242e  mains \f$ N \f$.
+000045a0: 0a20 2021 3e20 2020 2020 2020 5c66 5b20  .  !>       \f[ 
+000045b0: 4f46 203d 205c 7371 7274 5b36 5d7b 5c73  OF = \sqrt[6]{\s
+000045c0: 756d 2828 312e 3020 2d20 4b47 455f 7b69  um((1.0 - KGE_{i
+000045d0: 7d29 2f4e 295e 3620 7d2e 2020 5c66 5d0a  })/N)^6 }.  \f].
+000045e0: 2020 213e 2020 2020 2020 2054 6865 206f    !>       The o
+000045f0: 6273 6572 7665 6420 6461 7461 204c 315f  bserved data L1_
+00004600: 736d 2c20 4c31 5f73 6d5f 6d61 736b 2061  sm, L1_sm_mask a
+00004610: 7265 2067 6c6f 6261 6c20 696e 2074 6869  re global in thi
+00004620: 7320 6d6f 6475 6c65 2e0a 0a20 2021 2020  s module...  !  
+00004630: 2020 494e 5445 4e54 2849 4e29 0a20 2021    INTENT(IN).  !
+00004640: 3e20 2020 2020 2020 5c70 6172 616d 5b69  >       \param[i
+00004650: 6e5d 2022 7265 616c 2864 7029 2c20 6469  n] "real(dp), di
+00004660: 6d65 6e73 696f 6e28 3a29 203a 3a20 7061  mension(:) :: pa
+00004670: 7261 6d65 7465 7273 6574 220a 2020 213e  rameterset".  !>
+00004680: 2020 2020 2020 205c 7061 7261 6d5b 696e         \param[in
+00004690: 5d20 2270 726f 6365 6475 7265 2865 7661  ] "procedure(eva
+000046a0: 6c5f 696e 7465 7266 6163 6529 203a 3a20  l_interface) :: 
+000046b0: 6576 616c 220a 0a20 2021 2020 2020 5245  eval"..  !    RE
+000046c0: 5455 524e 0a20 2021 3e20 2020 2020 2020  TURN.  !>       
+000046d0: 5c72 6574 7572 6e20 7265 616c 2864 7029  \return real(dp)
+000046e0: 203a 3a20 6f62 6a65 6374 6976 655f 736d   :: objective_sm
+000046f0: 5f6b 6765 5f63 6174 6368 6d65 6e74 5f61  _kge_catchment_a
+00004700: 7667 2026 6d64 6173 683b 206f 626a 6563  vg &mdash; objec
+00004710: 7469 7665 2066 756e 6374 696f 6e20 7661  tive function va
+00004720: 6c75 650a 2020 213e 2020 2020 2020 2028  lue.  !>       (
+00004730: 7768 6963 6820 7769 6c6c 2062 6520 652e  which will be e.
+00004740: 672e 206d 696e 696d 697a 6564 2062 7920  g. minimized by 
+00004750: 616e 206f 7074 696d 697a 6174 696f 6e20  an optimization 
+00004760: 726f 7574 696e 6520 6c69 6b65 2044 4453  routine like DDS
+00004770: 290a 0a20 2021 2020 2020 4849 5354 4f52  )..  !    HISTOR
+00004780: 590a 2020 213e 2020 2020 2020 205c 6175  Y.  !>       \au
+00004790: 7468 6f72 7320 4d61 7474 6869 6173 205a  thors Matthias Z
+000047a0: 696e 6b0a 0a20 2021 3e20 2020 2020 2020  ink..  !>       
+000047b0: 5c64 6174 6520 4d61 7920 3230 3135 0a0a  \date May 2015..
+000047c0: 2020 2120 4d6f 6469 6669 6361 7469 6f6e    ! Modification
+000047d0: 733a 0a20 2021 2052 6f62 6572 7420 5363  s:.  ! Robert Sc
+000047e0: 6877 6570 7065 204a 756e 2032 3031 3820  hweppe Jun 2018 
+000047f0: 2d20 7265 6661 6374 6f72 696e 6720 616e  - refactoring an
+00004800: 6420 7265 666f 726d 6174 7469 6e67 0a0a  d reformatting..
+00004810: 2020 4655 4e43 5449 4f4e 206f 626a 6563    FUNCTION objec
+00004820: 7469 7665 5f73 6d5f 6b67 655f 6361 7463  tive_sm_kge_catc
+00004830: 686d 656e 745f 6176 6728 7061 7261 6d65  hment_avg(parame
+00004840: 7465 7273 6574 2c20 6576 616c 290a 0a20  terset, eval).. 
+00004850: 2020 2075 7365 206d 6f5f 6f70 7469 6d69     use mo_optimi
+00004860: 7a61 7469 6f6e 5f74 7970 6573 2c20 6f6e  zation_types, on
+00004870: 6c79 203a 206f 7074 6964 6174 615f 7369  ly : optidata_si
+00004880: 6d0a 2020 2020 7573 6520 6d6f 5f63 6f6d  m.    use mo_com
+00004890: 6d6f 6e5f 636f 6e73 7461 6e74 732c 206f  mon_constants, o
+000048a0: 6e6c 7920 3a20 6e6f 6461 7461 5f64 700a  nly : nodata_dp.
+000048b0: 2020 2020 7573 6520 6d6f 5f63 6f6d 6d6f      use mo_commo
+000048c0: 6e5f 7661 7269 6162 6c65 732c 206f 6e6c  n_variables, onl
+000048d0: 7920 3a20 6c65 7665 6c31 2c20 646f 6d61  y : level1, doma
+000048e0: 696e 4d65 7461 0a20 2020 2075 7365 206d  inMeta.    use m
+000048f0: 6f5f 6572 726f 726d 6561 7375 7265 732c  o_errormeasures,
+00004900: 206f 6e6c 7920 3a20 4b47 450a 2020 2020   only : KGE.    
+00004910: 7573 6520 6d6f 5f67 6c6f 6261 6c5f 7661  use mo_global_va
+00004920: 7269 6162 6c65 732c 206f 6e6c 7920 3a20  riables, only : 
+00004930: 4c31 5f73 6d4f 6273 0a20 2020 2075 7365  L1_smObs.    use
+00004940: 206d 6f5f 6d6f 6d65 6e74 2c20 6f6e 6c79   mo_moment, only
+00004950: 203a 2061 7665 7261 6765 0a20 2020 2075   : average.    u
+00004960: 7365 206d 6f5f 7374 7269 6e67 5f75 7469  se mo_string_uti
+00004970: 6c73 2c20 6f6e 6c79 203a 206e 756d 3273  ls, only : num2s
+00004980: 7472 0a0a 2020 2020 696d 706c 6963 6974  tr..    implicit
+00004990: 206e 6f6e 650a 0a20 2020 2072 6561 6c28   none..    real(
+000049a0: 6470 292c 2064 696d 656e 7369 6f6e 283a  dp), dimension(:
+000049b0: 292c 2069 6e74 656e 7428 696e 2920 3a3a  ), intent(in) ::
+000049c0: 2070 6172 616d 6574 6572 7365 740a 0a20   parameterset.. 
+000049d0: 2020 2070 726f 6365 6475 7265 2865 7661     procedure(eva
+000049e0: 6c5f 696e 7465 7266 6163 6529 2c20 494e  l_interface), IN
+000049f0: 5445 4e54 2849 4e29 2c20 504f 494e 5445  TENT(IN), POINTE
+00004a00: 5220 3a3a 2065 7661 6c0a 0a20 2020 2072  R :: eval..    r
+00004a10: 6561 6c28 6470 2920 3a3a 206f 626a 6563  eal(dp) :: objec
+00004a20: 7469 7665 5f73 6d5f 6b67 655f 6361 7463  tive_sm_kge_catc
+00004a30: 686d 656e 745f 6176 670a 0a20 2020 2021  hment_avg..    !
+00004a40: 2064 6f6d 6169 6e20 6c6f 6f70 2063 6f75   domain loop cou
+00004a50: 6e74 6572 0a20 2020 2069 6e74 6567 6572  nter.    integer
+00004a60: 2869 3429 203a 3a20 6944 6f6d 6169 6e0a  (i4) :: iDomain.
+00004a70: 0a20 2020 2021 2074 696d 6520 6c6f 6f70  .    ! time loop
+00004a80: 2063 6f75 6e74 6572 0a20 2020 2069 6e74   counter.    int
+00004a90: 6567 6572 2869 3429 203a 3a20 6954 696d  eger(i4) :: iTim
+00004aa0: 650a 0a20 2020 2021 206e 756d 6265 7220  e..    ! number 
+00004ab0: 6f66 2074 696d 6520 7374 6570 7320 696e  of time steps in
+00004ac0: 2073 696d 756c 6174 6564 2053 4d0a 2020   simulated SM.  
+00004ad0: 2020 696e 7465 6765 7228 6934 2920 3a3a    integer(i4) ::
+00004ae0: 206e 5f74 696d 655f 7374 6570 730a 0a20   n_time_steps.. 
+00004af0: 2020 2021 206e 6365 6c6c 7331 206f 6620     ! ncells1 of 
+00004b00: 6c65 7665 6c20 310a 2020 2020 696e 7465  level 1.    inte
+00004b10: 6765 7228 6934 2920 3a3a 206e 6365 6c6c  ger(i4) :: ncell
+00004b20: 7331 0a0a 2020 2020 2120 6e75 6d62 6572  s1..    ! number
+00004b30: 206f 6620 696e 7661 6c69 6420 7469 6d65   of invalid time
+00004b40: 7374 6570 730a 2020 2020 7265 616c 2864  steps.    real(d
+00004b50: 7029 203a 3a20 696e 7661 6c69 645f 7469  p) :: invalid_ti
+00004b60: 6d65 730a 2369 666e 6465 6620 4d50 490a  mes.#ifndef MPI.
+00004b70: 2020 2020 2120 666f 7220 7369 7874 6820      ! for sixth 
+00004b80: 726f 6f74 0a20 2020 2072 6561 6c28 6470  root.    real(dp
+00004b90: 292c 2070 6172 616d 6574 6572 203a 3a20  ), parameter :: 
+00004ba0: 6f6e 6573 6978 7468 203d 2031 2e30 5f64  onesixth = 1.0_d
+00004bb0: 7020 2f20 362e 305f 6470 0a23 656e 6469  p / 6.0_dp.#endi
+00004bc0: 660a 0a20 2020 2021 2073 7061 7469 616c  f..    ! spatial
+00004bd0: 2061 7665 7261 6765 206f 6620 6f62 7365   average of obse
+00004be0: 7276 6564 2073 6f69 6c20 6d6f 6973 7475  rved soil moistu
+00004bf0: 7265 0a20 2020 2072 6561 6c28 6470 292c  re.    real(dp),
+00004c00: 2064 696d 656e 7369 6f6e 283a 292c 2061   dimension(:), a
+00004c10: 6c6c 6f63 6174 6162 6c65 203a 3a20 736d  llocatable :: sm
+00004c20: 5f63 6174 6368 5f61 7667 5f64 6f6d 6169  _catch_avg_domai
+00004c30: 6e0a 0a20 2020 2021 2073 7061 7469 616c  n..    ! spatial
+00004c40: 2061 7665 7267 6165 206f 6620 6d6f 6465   avergae of mode
+00004c50: 6c65 6420 2073 6f69 6c20 6d6f 6973 7475  led  soil moistu
+00004c60: 7265 0a20 2020 2072 6561 6c28 6470 292c  re.    real(dp),
+00004c70: 2064 696d 656e 7369 6f6e 283a 292c 2061   dimension(:), a
+00004c80: 6c6c 6f63 6174 6162 6c65 203a 3a20 736d  llocatable :: sm
+00004c90: 5f6f 7074 695f 6361 7463 685f 6176 675f  _opti_catch_avg_
+00004ca0: 646f 6d61 696e 0a0a 2020 2020 7479 7065  domain..    type
+00004cb0: 286f 7074 6964 6174 615f 7369 6d29 2c20  (optidata_sim), 
+00004cc0: 6469 6d65 6e73 696f 6e28 3a29 2c20 616c  dimension(:), al
+00004cd0: 6c6f 6361 7461 626c 6520 3a3a 2073 6d4f  locatable :: smO
+00004ce0: 7074 6953 696d 0a0a 2020 2020 2120 6d61  ptiSim..    ! ma
+00004cf0: 736b 2066 6f72 2076 616c 6964 2073 6d20  sk for valid sm 
+00004d00: 6361 7463 686d 656e 7420 6176 6720 7469  catchment avg ti
+00004d10: 6d65 2073 7465 7073 0a20 2020 206c 6f67  me steps.    log
+00004d20: 6963 616c 2c20 6469 6d65 6e73 696f 6e28  ical, dimension(
+00004d30: 3a29 2c20 616c 6c6f 6361 7461 626c 6520  :), allocatable 
+00004d40: 3a3a 206d 6173 6b5f 7469 6d65 730a 0a0a  :: mask_times...
+00004d50: 2020 2020 616c 6c6f 6361 7465 2873 6d4f      allocate(smO
+00004d60: 7074 6953 696d 2864 6f6d 6169 6e4d 6574  ptiSim(domainMet
+00004d70: 6125 6e44 6f6d 6169 6e73 2929 0a20 2020  a%nDomains)).   
+00004d80: 2063 616c 6c20 6576 616c 2870 6172 616d   call eval(param
+00004d90: 6574 6572 7365 742c 2073 6d4f 7074 6953  eterset, smOptiS
+00004da0: 696d 203d 2073 6d4f 7074 6953 696d 290a  im = smOptiSim).
+00004db0: 0a20 2020 2021 2069 6e69 7469 616c 697a  .    ! initializ
+00004dc0: 6520 736f 6d65 2076 6172 6961 626c 6573  e some variables
+00004dd0: 0a20 2020 206f 626a 6563 7469 7665 5f73  .    objective_s
+00004de0: 6d5f 6b67 655f 6361 7463 686d 656e 745f  m_kge_catchment_
+00004df0: 6176 6720 3d20 302e 305f 6470 0a0a 2020  avg = 0.0_dp..  
+00004e00: 2020 2120 6c6f 6f70 206f 7665 7220 646f    ! loop over do
+00004e10: 6d61 696e 202d 2066 6f72 2061 7070 6c79  main - for apply
+00004e20: 696e 6720 706f 7765 7220 6c61 7720 6c61  ing power law la
+00004e30: 7465 7220 6f6e 0a20 2020 2064 6f20 6944  ter on.    do iD
+00004e40: 6f6d 6169 6e20 3d20 312c 2064 6f6d 6169  omain = 1, domai
+00004e50: 6e4d 6574 6125 6e44 6f6d 6169 6e73 0a0a  nMeta%nDomains..
+00004e60: 2020 2020 2020 2120 6765 7420 646f 6d61        ! get doma
+00004e70: 696e 2069 6e66 6f72 6d61 7469 6f6e 0a20  in information. 
+00004e80: 2020 2020 206e 6365 6c6c 7331 203d 206c       ncells1 = l
+00004e90: 6576 656c 3128 6944 6f6d 6169 6e29 256e  evel1(iDomain)%n
+00004ea0: 6365 6c6c 730a 0a20 2020 2020 2021 2061  cells..      ! a
+00004eb0: 6c6c 6f63 6174 650a 2020 2020 2020 616c  llocate.      al
+00004ec0: 6c6f 6361 7465 286d 6173 6b5f 7469 6d65  locate(mask_time
+00004ed0: 7320 2020 2020 2020 2020 2020 2020 2028  s              (
+00004ee0: 7369 7a65 2873 6d4f 7074 6953 696d 2869  size(smOptiSim(i
+00004ef0: 446f 6d61 696e 2925 6461 7461 5369 6d2c  Domain)%dataSim,
+00004f00: 2064 696d 203d 2032 2929 290a 2020 2020   dim = 2))).    
+00004f10: 2020 616c 6c6f 6361 7465 2873 6d5f 6361    allocate(sm_ca
+00004f20: 7463 685f 6176 675f 646f 6d61 696e 2020  tch_avg_domain  
+00004f30: 2020 2028 7369 7a65 2873 6d4f 7074 6953     (size(smOptiS
+00004f40: 696d 2869 446f 6d61 696e 2925 6461 7461  im(iDomain)%data
+00004f50: 5369 6d2c 2064 696d 203d 2032 2929 290a  Sim, dim = 2))).
+00004f60: 2020 2020 2020 616c 6c6f 6361 7465 2873        allocate(s
+00004f70: 6d5f 6f70 7469 5f63 6174 6368 5f61 7667  m_opti_catch_avg
+00004f80: 5f64 6f6d 6169 6e28 7369 7a65 2873 6d4f  _domain(size(smO
+00004f90: 7074 6953 696d 2869 446f 6d61 696e 2925  ptiSim(iDomain)%
+00004fa0: 6461 7461 5369 6d2c 2064 696d 203d 2032  dataSim, dim = 2
+00004fb0: 2929 290a 0a20 2020 2020 2021 2069 6e69  )))..      ! ini
+00004fc0: 7461 6c69 7a65 0a20 2020 2020 206d 6173  talize.      mas
+00004fd0: 6b5f 7469 6d65 7320 3d20 2e54 5255 452e  k_times = .TRUE.
+00004fe0: 0a20 2020 2020 2073 6d5f 6361 7463 685f  .      sm_catch_
+00004ff0: 6176 675f 646f 6d61 696e 203d 206e 6f64  avg_domain = nod
+00005000: 6174 615f 6470 0a20 2020 2020 2073 6d5f  ata_dp.      sm_
+00005010: 6f70 7469 5f63 6174 6368 5f61 7667 5f64  opti_catch_avg_d
+00005020: 6f6d 6169 6e20 3d20 6e6f 6461 7461 5f64  omain = nodata_d
+00005030: 700a 0a20 2020 2020 2069 6e76 616c 6964  p..      invalid
+00005040: 5f74 696d 6573 203d 2030 2e30 5f64 700a  _times = 0.0_dp.
+00005050: 2020 2020 2020 2120 6361 6c63 756c 6174        ! calculat
+00005060: 6520 6361 7463 686d 656e 7420 6176 6572  e catchment aver
+00005070: 6167 6520 736f 696c 206d 6f69 7374 7572  age soil moistur
+00005080: 650a 2020 2020 2020 6e5f 7469 6d65 5f73  e.      n_time_s
+00005090: 7465 7073 203d 2073 697a 6528 736d 4f70  teps = size(smOp
+000050a0: 7469 5369 6d28 6944 6f6d 6169 6e29 2564  tiSim(iDomain)%d
+000050b0: 6174 6153 696d 2c20 6469 6d20 3d20 3229  ataSim, dim = 2)
+000050c0: 0a20 2020 2020 2064 6f20 6954 696d 6520  .      do iTime 
+000050d0: 3d20 312c 206e 5f74 696d 655f 7374 6570  = 1, n_time_step
+000050e0: 730a 0a20 2020 2020 2020 2021 2063 6865  s..        ! che
+000050f0: 636b 2066 6f72 2065 6e6f 7567 6820 6461  ck for enough da
+00005100: 7461 2070 6f69 6e74 7320 696e 2074 696d  ta points in tim
+00005110: 6573 7465 7073 2066 6f72 204b 4745 2063  esteps for KGE c
+00005120: 616c 6375 6c61 7469 6f6e 0a20 2020 2020  alculation.     
+00005130: 2020 2021 206d 6f72 6520 7468 656e 2031     ! more then 1
+00005140: 3020 7065 7263 656e 7420 6176 6169 6162  0 percent avaiab
+00005150: 6c65 2069 6e20 6375 7272 656e 7420 6669  le in current fi
+00005160: 656c 640a 2020 2020 2020 2020 6966 2028  eld.        if (
+00005170: 636f 756e 7428 4c31 5f73 6d4f 6273 2869  count(L1_smObs(i
+00005180: 446f 6d61 696e 2925 6d61 736b 4f62 7328  Domain)%maskObs(
+00005190: 3a2c 2069 5469 6d65 2929 202e 4c45 2e20  :, iTime)) .LE. 
+000051a0: 2830 2e31 305f 6470 202a 2072 6561 6c28  (0.10_dp * real(
+000051b0: 6e43 656c 6c73 312c 2064 7029 2929 2074  nCells1, dp))) t
+000051c0: 6865 6e0a 2020 2020 2020 2020 2020 696e  hen.          in
+000051d0: 7661 6c69 645f 7469 6d65 7320 3d20 696e  valid_times = in
+000051e0: 7661 6c69 645f 7469 6d65 7320 2b20 312e  valid_times + 1.
+000051f0: 305f 6470 0a20 2020 2020 2020 2020 206d  0_dp.          m
+00005200: 6173 6b5f 7469 6d65 7328 6954 696d 6529  ask_times(iTime)
+00005210: 203d 202e 4641 4c53 452e 0a20 2020 2020   = .FALSE..     
+00005220: 2020 2020 2063 7963 6c65 0a20 2020 2020       cycle.     
+00005230: 2020 2065 6e64 2069 660a 2020 2020 2020     end if.      
+00005240: 2020 736d 5f63 6174 6368 5f61 7667 5f64    sm_catch_avg_d
+00005250: 6f6d 6169 6e28 6954 696d 6529 203d 2061  omain(iTime) = a
+00005260: 7665 7261 6765 284c 315f 736d 4f62 7328  verage(L1_smObs(
+00005270: 6944 6f6d 6169 6e29 2564 6174 614f 6273  iDomain)%dataObs
+00005280: 283a 2c20 6954 696d 6529 2c20 6d61 736b  (:, iTime), mask
+00005290: 203d 204c 315f 736d 4f62 7328 6944 6f6d   = L1_smObs(iDom
+000052a0: 6169 6e29 256d 6173 6b4f 6273 283a 2c20  ain)%maskObs(:, 
+000052b0: 6954 696d 6529 290a 2020 2020 2020 2020  iTime)).        
+000052c0: 736d 5f6f 7074 695f 6361 7463 685f 6176  sm_opti_catch_av
+000052d0: 675f 646f 6d61 696e 2869 5469 6d65 2920  g_domain(iTime) 
+000052e0: 3d20 6176 6572 6167 6528 736d 4f70 7469  = average(smOpti
+000052f0: 5369 6d28 6944 6f6d 6169 6e29 2564 6174  Sim(iDomain)%dat
+00005300: 6153 696d 283a 2c20 6954 696d 6529 2c20  aSim(:, iTime), 
+00005310: 6d61 736b 203d 204c 315f 736d 4f62 7328  mask = L1_smObs(
+00005320: 6944 6f6d 6169 6e29 256d 6173 6b4f 6273  iDomain)%maskObs
+00005330: 283a 2c20 6954 696d 6529 290a 2020 2020  (:, iTime)).    
+00005340: 2020 656e 6420 646f 0a0a 2020 2020 2020    end do..      
+00005350: 2120 7573 6572 2069 6e66 6f72 6d61 7469  ! user informati
+00005360: 6f6e 2061 626f 7574 2069 6e76 616c 6964  on about invalid
+00005370: 2074 696d 6573 0a20 2020 2020 2069 6620   times.      if 
+00005380: 2869 6e76 616c 6964 5f74 696d 6573 202e  (invalid_times .
+00005390: 4754 2e20 302e 355f 6470 2920 7468 656e  GT. 0.5_dp) then
+000053a0: 0a20 2020 2020 2020 2063 616c 6c20 6d65  .        call me
+000053b0: 7373 6167 6528 2720 2020 5741 524e 494e  ssage('   WARNIN
+000053c0: 473a 206f 626a 6563 7469 7665 5f73 6d3a  G: objective_sm:
+000053d0: 2044 6574 6563 7465 6420 696e 7661 6c69   Detected invali
+000053e0: 6420 7469 6d65 7374 6570 7320 282e 4c54  d timesteps (.LT
+000053f0: 2e20 3130 2076 616c 6964 2064 6174 6120  . 10 valid data 
+00005400: 706f 696e 7473 292e 2729 0a20 2020 2020  points).').     
+00005410: 2020 2063 616c 6c20 6d65 7373 6167 6528     call message(
+00005420: 2720 2020 2020 2020 2020 2020 2020 2020  '               
+00005430: 2020 2020 2020 2020 2020 2046 7261 6374             Fract
+00005440: 696f 6e20 6f66 2069 6e76 616c 6964 2074  ion of invalid t
+00005450: 696d 6573 7465 7073 3a20 272c 2026 0a20  imesteps: ', &. 
+00005460: 2020 2020 2020 2020 2020 2020 2020 206e                 n
+00005470: 756d 3273 7472 2869 6e76 616c 6964 5f74  um2str(invalid_t
+00005480: 696d 6573 202f 2072 6561 6c28 6e5f 7469  imes / real(n_ti
+00005490: 6d65 5f73 7465 7073 2c20 6470 292c 2027  me_steps, dp), '
+000054a0: 2846 342e 3229 2729 290a 2020 2020 2020  (F4.2)')).      
+000054b0: 656e 6420 6966 0a0a 0a20 2020 2020 2021  end if...      !
+000054c0: 2063 616c 6375 6c61 7465 2061 7665 7261   calculate avera
+000054d0: 6765 2073 6f69 6c20 6d6f 6973 7475 7265  ge soil moisture
+000054e0: 204b 4745 206f 7665 7220 616c 6c20 646f   KGE over all do
+000054f0: 6d61 696e 7320 7769 7468 2070 6f77 6572  mains with power
+00005500: 206c 6177 0a20 2020 2020 2021 2064 6f6d   law.      ! dom
+00005510: 6169 6e73 2061 7265 2077 6569 6768 7465  ains are weighte
+00005520: 6420 6571 7561 6c6c 7920 2820 3120 2f20  d equally ( 1 / 
+00005530: 7265 616c 2864 6f6d 6169 6e4d 6574 6125  real(domainMeta%
+00005540: 6f76 6572 616c 6c4e 756d 6265 724f 6644  overallNumberOfD
+00005550: 6f6d 6169 6e73 2c64 7029 292a 2a36 0a20  omains,dp))**6. 
+00005560: 2020 2020 206f 626a 6563 7469 7665 5f73       objective_s
+00005570: 6d5f 6b67 655f 6361 7463 686d 656e 745f  m_kge_catchment_
+00005580: 6176 6720 3d20 6f62 6a65 6374 6976 655f  avg = objective_
+00005590: 736d 5f6b 6765 5f63 6174 6368 6d65 6e74  sm_kge_catchment
+000055a0: 5f61 7667 202b 2026 0a20 2020 2020 2020  _avg + &.       
+000055b0: 2020 2020 2020 2028 2831 2e30 5f64 7020         ((1.0_dp 
+000055c0: 2d20 4b47 4528 736d 5f63 6174 6368 5f61  - KGE(sm_catch_a
+000055d0: 7667 5f64 6f6d 6169 6e2c 2073 6d5f 6f70  vg_domain, sm_op
+000055e0: 7469 5f63 6174 6368 5f61 7667 5f64 6f6d  ti_catch_avg_dom
+000055f0: 6169 6e2c 206d 6173 6b20 3d20 6d61 736b  ain, mask = mask
+00005600: 5f74 696d 6573 2929 202f 2026 0a20 2020  _times)) / &.   
+00005610: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005620: 2020 2020 2072 6561 6c28 646f 6d61 696e       real(domain
+00005630: 4d65 7461 256f 7665 7261 6c6c 4e75 6d62  Meta%overallNumb
+00005640: 6572 4f66 446f 6d61 696e 732c 2064 7029  erOfDomains, dp)
+00005650: 292a 2a36 0a0a 2020 2020 2020 2120 6465  )**6..      ! de
+00005660: 616c 6c6f 6361 7465 0a20 2020 2020 2064  allocate.      d
+00005670: 6561 6c6c 6f63 6174 6528 6d61 736b 5f74  eallocate(mask_t
+00005680: 696d 6573 290a 2020 2020 2020 6465 616c  imes).      deal
+00005690: 6c6f 6361 7465 2873 6d5f 6361 7463 685f  locate(sm_catch_
+000056a0: 6176 675f 646f 6d61 696e 290a 2020 2020  avg_domain).    
+000056b0: 2020 6465 616c 6c6f 6361 7465 2873 6d5f    deallocate(sm_
+000056c0: 6f70 7469 5f63 6174 6368 5f61 7667 5f64  opti_catch_avg_d
+000056d0: 6f6d 6169 6e29 0a20 2020 2020 2063 616c  omain).      cal
+000056e0: 6c20 736d 4f70 7469 5369 6d28 6944 6f6d  l smOptiSim(iDom
+000056f0: 6169 6e29 2564 6573 7472 6f79 2829 0a20  ain)%destroy(). 
+00005700: 2020 2065 6e64 2064 6f0a 2020 2020 6465     end do.    de
+00005710: 616c 6c6f 6361 7465 2873 6d4f 7074 6953  allocate(smOptiS
+00005720: 696d 290a 0a23 6966 6e64 6566 204d 5049  im)..#ifndef MPI
+00005730: 0a20 2020 206f 626a 6563 7469 7665 5f73  .    objective_s
+00005740: 6d5f 6b67 655f 6361 7463 686d 656e 745f  m_kge_catchment_
+00005750: 6176 6720 3d20 6f62 6a65 6374 6976 655f  avg = objective_
+00005760: 736d 5f6b 6765 5f63 6174 6368 6d65 6e74  sm_kge_catchment
+00005770: 5f61 7667 2a2a 6f6e 6573 6978 7468 0a0a  _avg**onesixth..
+00005780: 2020 2020 6361 6c6c 206d 6573 7361 6765      call message
+00005790: 2827 2020 2020 6f62 6a65 6374 6976 655f  ('    objective_
+000057a0: 736d 5f6b 6765 5f63 6174 6368 6d65 6e74  sm_kge_catchment
+000057b0: 5f61 7667 203d 2027 2c20 6e75 6d32 7374  _avg = ', num2st
+000057c0: 7228 6f62 6a65 6374 6976 655f 736d 5f6b  r(objective_sm_k
+000057d0: 6765 5f63 6174 6368 6d65 6e74 5f61 7667  ge_catchment_avg
+000057e0: 2c20 2728 4639 2e35 2927 2929 0a23 656e  , '(F9.5)')).#en
+000057f0: 6469 660a 0a0a 2020 454e 4420 4655 4e43  dif...  END FUNC
+00005800: 5449 4f4e 206f 626a 6563 7469 7665 5f73  TION objective_s
+00005810: 6d5f 6b67 655f 6361 7463 686d 656e 745f  m_kge_catchment_
+00005820: 6176 670a 0a20 2021 202d 2d2d 2d2d 2d2d  avg..  ! -------
+00005830: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00005840: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00005850: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00005860: 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 0a20 2021  -----------..  !
+00005870: 2020 2020 4e41 4d45 0a20 2021 2020 2020      NAME.  !    
+00005880: 2020 2020 6f62 6a65 6374 6976 655f 715f      objective_q_
+00005890: 6574 5f74 7773 5f6b 6765 5f63 6174 6368  et_tws_kge_catch
+000058a0: 6d65 6e74 5f61 7667 0a0a 2020 2120 2020  ment_avg..  !   
+000058b0: 2050 5552 504f 5345 0a20 2021 3e20 2020   PURPOSE.  !>   
+000058c0: 2020 2020 5c62 7269 6566 204f 626a 6563      \brief Objec
+000058d0: 7469 7665 2066 756e 6374 696f 6e20 666f  tive function fo
+000058e0: 7220 6574 2c20 7477 7320 616e 6420 712e  r et, tws and q.
+000058f0: 0a0a 2020 213e 2020 2020 2020 205c 6465  ..  !>       \de
+00005900: 7461 696c 7320 5468 6520 6665 6174 7572  tails The featur
+00005910: 6520 6f66 2074 6869 7320 6f62 6a65 6374  e of this object
+00005920: 6976 6520 6675 6e63 7469 6f6e 2069 7320  ive function is 
+00005930: 7468 650a 2020 213e 2020 2020 2020 2020  the.  !>        
+00005940: 2020 2020 2020 2020 7365 7061 7261 7469          separati
+00005950: 6f6e 206f 6620 7468 6520 6576 616c 2063  on of the eval c
+00005960: 616c 6c20 696e 746f 2066 6f75 720a 2020  all into four.  
+00005970: 213e 2020 2020 2020 2020 2020 2020 2020  !>              
+00005980: 2020 6361 6c6c 732c 2065 6163 6820 7769    calls, each wi
+00005990: 7468 2061 6e6f 7468 6572 2069 6e64 6578  th another index
+000059a0: 206c 6973 742e 2054 6865 2073 7562 726f   list. The subro
+000059b0: 7574 696e 6520 6576 616c 2074 6865 6e20  utine eval then 
+000059c0: 6f6e 6c79 0a20 2021 3e20 2020 2020 2020  only.  !>       
+000059d0: 2020 2020 2020 2020 2075 7365 7320 7468           uses th
+000059e0: 6520 696e 6469 6365 7320 6672 6f6d 2074  e indices from t
+000059f0: 6861 7420 696e 6465 7820 6c69 7374 2069  hat index list i
+00005a00: 6e74 6572 6e61 6c6c 7920 696e 7374 6561  nternally instea
+00005a10: 6420 6f66 2068 6176 696e 6720 6c6f 6f70  d of having loop
+00005a20: 730a 2020 213e 2020 2020 2020 2020 2020  s.  !>          
+00005a30: 2020 2020 2020 6f76 6572 2061 6c6c 2064        over all d
+00005a40: 6f6d 6169 6e73 2e20 5468 6520 696e 7465  omains. The inte
+00005a50: 6765 7220 6172 7261 7920 646f 6d61 696e  ger array domain
+00005a60: 4d65 7461 256f 7074 6964 6174 6120 6465  Meta%optidata de
+00005a70: 6369 6465 7320 7768 6963 680a 2020 213e  cides which.  !>
+00005a80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005a90: 696e 6469 6365 7320 746f 2075 7365 2e20  indices to use. 
+00005aa0: 5468 6572 6566 6f72 6520 7468 6520 6172  Therefore the ar
+00005ab0: 7261 7920 6973 2073 706c 6974 2069 6e74  ray is split int
+00005ac0: 6f20 6469 736a 756e 6374 2073 7562 7365  o disjunct subse
+00005ad0: 7473 2c20 616e 642c 0a20 2021 3e20 2020  ts, and,.  !>   
+00005ae0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+00005af0: 6368 6f73 656e 2077 6973 656c 7920 696e  chosen wisely in
+00005b00: 2074 6865 206e 616d 656c 6973 742c 2061   the namelist, a
+00005b10: 6c73 6f20 636f 7665 7273 2061 6c6c 2064  lso covers all d
+00005b20: 6f6d 6169 6e73 2e0a 2020 213e 0a20 2021  omains..  !>.  !
+00005b30: 3e20 2020 2020 2020 2020 2020 2020 2020  >               
+00005b40: 2057 6974 6820 7468 6973 2074 6865 2065   With this the e
+00005b50: 7661 6c20 6361 6c6c 7320 7375 6d20 7570  val calls sum up
+00005b60: 2069 6e20 6120 7761 7920 7468 6174 2066   in a way that f
+00005b70: 6f72 2065 6163 6820 646f 6d61 696e 2065  or each domain e
+00005b80: 7661 6c20 7761 730a 2020 213e 2020 2020  val was.  !>    
+00005b90: 2020 2020 2020 2020 2020 2020 6361 6c6c              call
+00005ba0: 6564 2061 7420 6d6f 7374 206f 6e63 652c  ed at most once,
+00005bb0: 2062 7574 2066 6f72 2064 6966 6665 7265   but for differe
+00005bc0: 6e74 206f 7074 695f 6461 7461 2e0a 0a20  nt opti_data... 
+00005bd0: 2021 2020 2020 4849 5354 4f52 590a 2020   !    HISTORY.  
+00005be0: 213e 2020 2020 2020 205c 6175 7468 6f72  !>       \author
+00005bf0: 7320 4d61 7265 6e20 4b61 6c75 7a61 0a0a  s Maren Kaluza..
+00005c00: 2020 213e 2020 2020 2020 205c 6461 7465    !>       \date
+00005c10: 204a 756c 7920 3230 3139 0a0a 2020 2120   July 2019..  ! 
+00005c20: 4d6f 6469 6669 6361 7469 6f6e 733a 0a0a  Modifications:..
+00005c30: 2020 4655 4e43 5449 4f4e 206f 626a 6563    FUNCTION objec
+00005c40: 7469 7665 5f71 5f65 745f 7477 735f 6b67  tive_q_et_tws_kg
+00005c50: 655f 6361 7463 686d 656e 745f 6176 6728  e_catchment_avg(
+00005c60: 7061 7261 6d65 7465 7273 6574 2c20 6576  parameterset, ev
+00005c70: 616c 290a 0a20 2020 2075 7365 206d 6f5f  al)..    use mo_
+00005c80: 6f70 7469 6d69 7a61 7469 6f6e 5f74 7970  optimization_typ
+00005c90: 6573 2c20 6f6e 6c79 203a 206f 7074 6964  es, only : optid
+00005ca0: 6174 615f 7369 6d0a 2020 2020 7573 6520  ata_sim.    use 
+00005cb0: 6d6f 5f63 6f6d 6d6f 6e5f 636f 6e73 7461  mo_common_consta
+00005cc0: 6e74 732c 206f 6e6c 7920 3a20 6e6f 6461  nts, only : noda
+00005cd0: 7461 5f64 700a 2020 2020 7573 6520 6d6f  ta_dp.    use mo
+00005ce0: 5f63 6f6d 6d6f 6e5f 7661 7269 6162 6c65  _common_variable
+00005cf0: 732c 206f 6e6c 7920 3a20 646f 6d61 696e  s, only : domain
+00005d00: 4d65 7461 0a20 2020 2075 7365 206d 6f5f  Meta.    use mo_
+00005d10: 676c 6f62 616c 5f76 6172 6961 626c 6573  global_variables
+00005d20: 2c20 6f6e 6c79 203a 204c 315f 6574 4f62  , only : L1_etOb
+00005d30: 732c 204c 315f 7477 7361 4f62 730a 2020  s, L1_twsaObs.  
+00005d40: 2020 7573 6520 6d6f 5f65 7272 6f72 6d65    use mo_errorme
+00005d50: 6173 7572 6573 2c20 6f6e 6c79 203a 206b  asures, only : k
+00005d60: 6765 0a20 2020 2075 7365 206d 6f5f 6d6f  ge.    use mo_mo
+00005d70: 6d65 6e74 2c20 6f6e 6c79 203a 2061 7665  ment, only : ave
+00005d80: 7261 6765 0a20 2020 2075 7365 206d 6f5f  rage.    use mo_
+00005d90: 7374 7269 6e67 5f75 7469 6c73 2c20 6f6e  string_utils, on
+00005da0: 6c79 203a 206e 756d 3273 7472 0a20 2020  ly : num2str.   
+00005db0: 2075 7365 206d 6f5f 6d72 6d5f 6f62 6a65   use mo_mrm_obje
+00005dc0: 6374 6976 655f 6675 6e63 7469 6f6e 5f72  ctive_function_r
+00005dd0: 756e 6f66 662c 206f 6e6c 7920 3a20 6578  unoff, only : ex
+00005de0: 7472 6163 745f 7275 6e6f 6666 0a0a 2020  tract_runoff..  
+00005df0: 2020 696d 706c 6963 6974 206e 6f6e 650a    implicit none.
+00005e00: 0a20 2020 2021 3e20 7468 6520 7061 7261  .    !> the para
+00005e10: 6d65 7465 7273 6574 2070 6173 7365 6420  meterset passed 
+00005e20: 746f 2074 6865 2065 7661 6c20 7375 6272  to the eval subr
+00005e30: 6f75 7469 6e65 0a20 2020 2072 6561 6c28  outine.    real(
+00005e40: 6470 292c 2064 696d 656e 7369 6f6e 283a  dp), dimension(:
+00005e50: 292c 2069 6e74 656e 7428 696e 2920 3a3a  ), intent(in) ::
+00005e60: 2070 6172 616d 6574 6572 7365 740a 2020   parameterset.  
+00005e70: 2020 213e 2074 6865 2065 7661 6c20 7375    !> the eval su
+00005e80: 6272 6f75 7469 6e65 2063 616c 6c65 6420  broutine called 
+00005e90: 6279 2074 6869 7320 6f62 6a65 6374 6976  by this objectiv
+00005ea0: 6520 6675 6e63 7469 6f6e 0a20 2020 2070  e function.    p
+00005eb0: 726f 6365 6475 7265 2865 7661 6c5f 696e  rocedure(eval_in
+00005ec0: 7465 7266 6163 6529 2c20 494e 5445 4e54  terface), INTENT
+00005ed0: 2849 4e29 2c20 504f 494e 5445 5220 3a3a  (IN), POINTER ::
+00005ee0: 2065 7661 6c0a 2020 2020 213e 2074 6865   eval.    !> the
+00005ef0: 2072 6574 7572 6e20 7661 6c75 6520 6f66   return value of
+00005f00: 2074 6865 206f 626a 6563 7469 7665 2066   the objective f
+00005f10: 756e 6374 696f 6e2e 2049 6e20 7468 6973  unction. In this
+00005f20: 2063 6173 6520 6974 2069 730a 2020 2020   case it is.    
+00005f30: 213e 2061 6e20 6172 7261 7920 746f 2070  !> an array to p
+00005f40: 726f 7669 6465 2074 6865 2070 6f73 7369  rovide the possi
+00005f50: 6269 6c69 7479 2074 6f20 7765 6967 6874  bility to weight
+00005f60: 2074 6865 206f 7574 636f 6d65 2061 6363   the outcome acc
+00005f70: 6f72 6469 6e67 6c79 0a20 2020 2072 6561  ordingly.    rea
+00005f80: 6c28 6470 292c 2064 696d 656e 7369 6f6e  l(dp), dimension
+00005f90: 2836 2920 3a3a 206f 626a 6563 7469 7665  (6) :: objective
+00005fa0: 5f71 5f65 745f 7477 735f 6b67 655f 6361  _q_et_tws_kge_ca
+00005fb0: 7463 686d 656e 745f 6176 670a 0a20 2020  tchment_avg..   
+00005fc0: 2021 3e20 646f 6d61 696e 206c 6f6f 7020   !> domain loop 
+00005fd0: 636f 756e 7465 720a 2020 2020 696e 7465  counter.    inte
+00005fe0: 6765 7228 6934 2920 3a3a 2069 446f 6d61  ger(i4) :: iDoma
+00005ff0: 696e 0a0a 2020 2020 213e 2063 6f75 6e74  in..    !> count
+00006000: 6572 2066 6f72 2073 686f 7274 206c 6f6f  er for short loo
+00006010: 7073 0a20 2020 2069 6e74 6567 6572 2869  ps.    integer(i
+00006020: 3429 203a 3a20 690a 2369 666e 6465 6620  4) :: i.#ifndef 
+00006030: 4d50 490a 2020 2020 213e 2066 6f72 2073  MPI.    !> for s
+00006040: 6978 7468 2072 6f6f 740a 2020 2020 7265  ixth root.    re
+00006050: 616c 2864 7029 2c20 7061 7261 6d65 7465  al(dp), paramete
+00006060: 7220 3a3a 206f 6e65 7369 7874 6820 3d20  r :: onesixth = 
+00006070: 312e 305f 6470 202f 2036 2e30 5f64 700a  1.0_dp / 6.0_dp.
+00006080: 2365 6e64 6966 0a0a 2020 2020 213e 206d  #endif..    !> m
+00006090: 6f64 656c 6c65 6420 7275 6e6f 6666 2066  odelled runoff f
+000060a0: 6f72 2061 2067 6976 656e 2070 6172 616d  or a given param
+000060b0: 6574 6572 2073 6574 0a20 2020 2021 2064  eter set.    ! d
+000060c0: 696d 313d 6e54 696d 6553 7465 7073 2c20  im1=nTimeSteps, 
+000060d0: 6469 6d32 3d6e 4761 7567 6573 0a20 2020  dim2=nGauges.   
+000060e0: 2072 6561 6c28 6470 292c 2061 6c6c 6f63   real(dp), alloc
+000060f0: 6174 6162 6c65 2c20 6469 6d65 6e73 696f  atable, dimensio
+00006100: 6e28 3a2c 203a 2920 3a3a 2072 756e 6f66  n(:, :) :: runof
+00006110: 660a 2020 2020 213e 206e 756d 6265 7220  f.    !> number 
+00006120: 6f66 2061 6c6c 2067 6175 6765 732c 2061  of all gauges, a
+00006130: 7175 6972 6564 2076 6961 2072 756e 6f66  quired via runof
+00006140: 660a 2020 2020 696e 7465 6765 7228 6934  f.    integer(i4
+00006150: 2920 3a3a 206e 4761 7567 6573 546f 7461  ) :: nGaugesTota
+00006160: 6c0a 0a20 2020 2021 3e20 6167 6772 6567  l..    !> aggreg
+00006170: 6174 6564 2073 696d 756c 6174 6564 2072  ated simulated r
+00006180: 756e 6f66 660a 2020 2020 7265 616c 2864  unoff.    real(d
+00006190: 7029 2c20 6469 6d65 6e73 696f 6e28 3a29  p), dimension(:)
+000061a0: 2c20 616c 6c6f 6361 7461 626c 6520 3a3a  , allocatable ::
+000061b0: 2072 756e 6f66 665f 6167 670a 0a20 2020   runoff_agg..   
+000061c0: 2021 3e20 6d65 6173 7572 6564 2072 756e   !> measured run
+000061d0: 6f66 660a 2020 2020 7265 616c 2864 7029  off.    real(dp)
+000061e0: 2c20 6469 6d65 6e73 696f 6e28 3a29 2c20  , dimension(:), 
+000061f0: 616c 6c6f 6361 7461 626c 6520 3a3a 2072  allocatable :: r
+00006200: 756e 6f66 665f 6f62 730a 0a20 2020 2021  unoff_obs..    !
+00006210: 3e20 6d61 736b 2066 6f72 206d 6561 7375  > mask for measu
+00006220: 7265 6420 7275 6e6f 6666 0a20 2020 206c  red runoff.    l
+00006230: 6f67 6963 616c 2c20 6469 6d65 6e73 696f  ogical, dimensio
+00006240: 6e28 3a29 2c20 616c 6c6f 6361 7461 626c  n(:), allocatabl
+00006250: 6520 3a3a 2072 756e 6f66 665f 6f62 735f  e :: runoff_obs_
+00006260: 6d61 736b 0a0a 2020 2020 213e 206b 6765  mask..    !> kge
+00006270: 5f71 286e 4761 7567 6573 546f 7461 6c29  _q(nGaugesTotal)
+00006280: 0a20 2020 2072 6561 6c28 6470 2920 3a3a  .    real(dp) ::
+00006290: 206b 6765 5f71 0a0a 2020 2020 213e 2067   kge_q..    !> g
+000062a0: 6175 6765 7320 636f 756e 7465 720a 2020  auges counter.  
+000062b0: 2020 696e 7465 6765 7228 6934 2920 3a3a    integer(i4) ::
+000062c0: 2067 672c 2069 4365 6c6c 0a0a 2020 2020   gg, iCell..    
+000062d0: 213e 206e 756d 6265 7220 6f66 2071 2064  !> number of q d
+000062e0: 6f6d 6169 6e73 0a20 2020 2069 6e74 6567  omains.    integ
+000062f0: 6572 2869 3429 203a 3a20 6e51 446f 6d61  er(i4) :: nQDoma
+00006300: 696e 730a 0a20 2020 2021 3e20 6e75 6d62  ins..    !> numb
+00006310: 6572 206f 6620 6574 2064 6f6d 6169 6e73  er of et domains
+00006320: 0a20 2020 2069 6e74 6567 6572 2869 3429  .    integer(i4)
+00006330: 203a 3a20 6e45 7444 6f6d 6169 6e73 0a0a   :: nEtDomains..
+00006340: 2020 2020 213e 206e 756d 6265 7220 6f66      !> number of
+00006350: 2074 7773 2064 6f6d 6169 6e73 0a20 2020   tws domains.   
+00006360: 2069 6e74 6567 6572 2869 3429 203a 3a20   integer(i4) :: 
+00006370: 6e54 7773 446f 6d61 696e 730a 0a20 2020  nTwsDomains..   
+00006380: 2021 3e20 6e75 6d62 6572 206f 6620 5457   !> number of TW
+00006390: 5320 616e 6420 4554 2064 6f6d 6169 6e73  S and ET domains
+000063a0: 2028 7072 6f76 6964 696e 6720 626f 7468   (providing both
+000063b0: 290a 2020 2020 696e 7465 6765 7228 6934  ).    integer(i4
+000063c0: 2920 3a3a 206e 4574 5477 7344 6f6d 6169  ) :: nEtTwsDomai
+000063d0: 6e73 0a0a 2020 2020 213e 2069 6e64 6578  ns..    !> index
+000063e0: 2061 7272 6179 206f 6620 4554 2064 6f6d   array of ET dom
+000063f0: 6169 6e73 0a20 2020 2069 6e74 6567 6572  ains.    integer
+00006400: 2869 3429 2c20 6469 6d65 6e73 696f 6e28  (i4), dimension(
+00006410: 3a29 2c20 616c 6c6f 6361 7461 626c 6520  :), allocatable 
+00006420: 3a3a 206f 7074 695f 646f 6d61 696e 5f69  :: opti_domain_i
+00006430: 6e64 6963 6573 5f45 540a 0a20 2020 2021  ndices_ET..    !
+00006440: 3e20 696e 6465 7820 6172 7261 7920 6f66  > index array of
+00006450: 2054 5753 2064 6f6d 6169 6e73 0a20 2020   TWS domains.   
+00006460: 2069 6e74 6567 6572 2869 3429 2c20 6469   integer(i4), di
+00006470: 6d65 6e73 696f 6e28 3a29 2c20 616c 6c6f  mension(:), allo
+00006480: 6361 7461 626c 6520 3a3a 206f 7074 695f  catable :: opti_
+00006490: 646f 6d61 696e 5f69 6e64 6963 6573 5f54  domain_indices_T
+000064a0: 5753 0a0a 2020 2020 213e 2069 6e64 6578  WS..    !> index
+000064b0: 2061 7272 6179 206f 6620 5457 5320 616e   array of TWS an
+000064c0: 6420 4554 2064 6f6d 6169 6e73 2028 7072  d ET domains (pr
+000064d0: 6f76 6964 696e 6720 626f 7468 290a 2020  oviding both).  
+000064e0: 2020 696e 7465 6765 7228 6934 292c 2064    integer(i4), d
+000064f0: 696d 656e 7369 6f6e 283a 292c 2061 6c6c  imension(:), all
+00006500: 6f63 6174 6162 6c65 203a 3a20 6f70 7469  ocatable :: opti
+00006510: 5f64 6f6d 6169 6e5f 696e 6469 6365 735f  _domain_indices_
+00006520: 4554 5f54 5753 0a0a 2020 2020 213e 2069  ET_TWS..    !> i
+00006530: 6e64 6578 2061 7272 6179 206f 6620 4554  ndex array of ET
+00006540: 2064 6f6d 6169 6e73 0a20 2020 2069 6e74   domains.    int
+00006550: 6567 6572 2869 3429 2c20 6469 6d65 6e73  eger(i4), dimens
+00006560: 696f 6e28 3a29 2c20 616c 6c6f 6361 7461  ion(:), allocata
+00006570: 626c 6520 3a3a 206f 7074 695f 646f 6d61  ble :: opti_doma
+00006580: 696e 5f69 6e64 6963 6573 5f51 0a0a 2020  in_indices_Q..  
+00006590: 2020 213e 2073 696d 756c 6174 6564 2065    !> simulated e
+000065a0: 740a 2020 2020 7479 7065 286f 7074 6964  t.    type(optid
+000065b0: 6174 615f 7369 6d29 2c20 6469 6d65 6e73  ata_sim), dimens
+000065c0: 696f 6e28 3a29 2c20 616c 6c6f 6361 7461  ion(:), allocata
+000065d0: 626c 6520 3a3a 2065 744f 7074 6953 696d  ble :: etOptiSim
+000065e0: 0a0a 2020 2020 213e 2073 696d 756c 6174  ..    !> simulat
+000065f0: 6564 2074 7773 0a20 2020 2074 7970 6528  ed tws.    type(
+00006600: 6f70 7469 6461 7461 5f73 696d 292c 2064  optidata_sim), d
+00006610: 696d 656e 7369 6f6e 283a 292c 2061 6c6c  imension(:), all
+00006620: 6f63 6174 6162 6c65 203a 3a20 7477 734f  ocatable :: twsO
+00006630: 7074 6953 696d 0a0a 2020 2020 213e 2073  ptiSim..    !> s
+00006640: 696d 756c 6174 6564 2074 7773 6120 2861  imulated twsa (a
+00006650: 6e6f 6d61 6c79 290a 2020 2020 7479 7065  nomaly).    type
+00006660: 286f 7074 6964 6174 615f 7369 6d29 2c20  (optidata_sim), 
+00006670: 6469 6d65 6e73 696f 6e28 3a29 2c20 616c  dimension(:), al
+00006680: 6c6f 6361 7461 626c 6520 3a3a 2074 7773  locatable :: tws
+00006690: 614f 7074 6953 696d 0a0a 2020 2020 7265  aOptiSim..    re
+000066a0: 616c 2864 7029 203a 3a20 6b67 655f 7477  al(dp) :: kge_tw
+000066b0: 730a 0a20 2020 2072 6561 6c28 6470 2920  s..    real(dp) 
+000066c0: 3a3a 206b 6765 5f65 740a 0a20 2020 2069  :: kge_et..    i
+000066d0: 6e74 6567 6572 2869 3429 203a 3a20 6e75  nteger(i4) :: nu
+000066e0: 6d62 6572 4f66 5375 6d6d 616e 6473 0a0a  mberOfSummands..
+000066f0: 0a20 2020 2021 2069 6e69 7469 616c 697a  .    ! initializ
+00006700: 6520 736f 6d65 2076 6172 6961 626c 6573  e some variables
+00006710: 0a20 2020 206f 626a 6563 7469 7665 5f71  .    objective_q
+00006720: 5f65 745f 7477 735f 6b67 655f 6361 7463  _et_tws_kge_catc
+00006730: 686d 656e 745f 6176 6728 3a29 203d 2030  hment_avg(:) = 0
+00006740: 2e30 5f64 700a 2020 2020 6b67 655f 7477  .0_dp.    kge_tw
+00006750: 7320 3d20 302e 305f 6470 0a20 2020 206b  s = 0.0_dp.    k
+00006760: 6765 5f65 7420 3d20 302e 305f 6470 0a20  ge_et = 0.0_dp. 
+00006770: 2020 206b 6765 5f71 203d 2030 2e30 5f64     kge_q = 0.0_d
+00006780: 700a 2020 2020 6e75 6d62 6572 4f66 5375  p.    numberOfSu
+00006790: 6d6d 616e 6473 203d 2030 0a20 2020 2021  mmands = 0.    !
+000067a0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000067b0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000067c0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2020  ------------.   
+000067d0: 2021 2045 5420 2620 5457 530a 2020 2020   ! ET & TWS.    
+000067e0: 212d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  !---------------
+000067f0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00006800: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 2020  -------------.  
+00006810: 2020 2120 6576 616c 2072 756e 7320 746f    ! eval runs to
+00006820: 2067 6574 2073 696d 756c 6174 6564 206f   get simulated o
+00006830: 7574 7075 7420 666f 7220 6574 2061 6e64  utput for et and
+00006840: 2074 7773 0a20 2020 2021 2062 6566 6f72   tws.    ! befor
+00006850: 6520 6561 6368 2065 7661 6c20 6361 6c6c  e each eval call
+00006860: 2077 6520 6765 6e65 7261 7465 2061 6e20   we generate an 
+00006870: 696e 6465 7820 6c69 7374 206f 6620 7468  index list of th
+00006880: 6520 646f 6d61 696e 7320 666f 7220 7768  e domains for wh
+00006890: 6963 680a 2020 2020 2120 6576 616c 2073  ich.    ! eval s
+000068a0: 686f 756c 6420 6265 2063 616c 6c65 642e  hould be called.
+000068b0: 2052 6561 6420 6465 7461 696c 7320 666f   Read details fo
+000068c0: 7220 6675 7274 6865 7220 696e 666f 726d  r further inform
+000068d0: 6174 696f 6e0a 2020 2020 6361 6c6c 2069  ation.    call i
+000068e0: 6e69 745f 696e 6465 7861 7272 6179 5f66  nit_indexarray_f
+000068f0: 6f72 5f6f 7074 695f 6461 7461 2864 6f6d  or_opti_data(dom
+00006900: 6169 6e4d 6574 612c 2036 2c20 6e45 7454  ainMeta, 6, nEtT
+00006910: 7773 446f 6d61 696e 732c 206f 7074 695f  wsDomains, opti_
+00006920: 646f 6d61 696e 5f69 6e64 6963 6573 5f45  domain_indices_E
+00006930: 545f 5457 5329 0a20 2020 2069 6620 286e  T_TWS).    if (n
+00006940: 4574 5477 7344 6f6d 6169 6e73 203e 2030  EtTwsDomains > 0
+00006950: 2920 7468 656e 0a20 2020 2020 2061 6c6c  ) then.      all
+00006960: 6f63 6174 6528 2065 744f 7074 6953 696d  ocate( etOptiSim
+00006970: 2864 6f6d 6169 6e4d 6574 6125 6e44 6f6d  (domainMeta%nDom
+00006980: 6169 6e73 2929 0a20 2020 2020 2061 6c6c  ains)).      all
+00006990: 6f63 6174 6528 7477 734f 7074 6953 696d  ocate(twsOptiSim
+000069a0: 2864 6f6d 6169 6e4d 6574 6125 6e44 6f6d  (domainMeta%nDom
+000069b0: 6169 6e73 2929 0a20 2020 2020 2061 6c6c  ains)).      all
+000069c0: 6f63 6174 6528 7477 7361 4f70 7469 5369  ocate(twsaOptiSi
+000069d0: 6d28 646f 6d61 696e 4d65 7461 256e 446f  m(domainMeta%nDo
+000069e0: 6d61 696e 7329 290a 2020 2020 2020 6361  mains)).      ca
+000069f0: 6c6c 2065 7661 6c28 7061 7261 6d65 7465  ll eval(paramete
+00006a00: 7273 6574 2c20 6f70 7469 5f64 6f6d 6169  rset, opti_domai
+00006a10: 6e5f 696e 6469 6365 7320 3d20 6f70 7469  n_indices = opti
+00006a20: 5f64 6f6d 6169 6e5f 696e 6469 6365 735f  _domain_indices_
+00006a30: 4554 5f54 5753 2c20 260a 2020 2020 2020  ET_TWS, &.      
+00006a40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006a50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006a60: 2020 2020 2020 2020 2020 2074 7773 4f70             twsOp
+00006a70: 7469 5369 6d20 3d20 7477 734f 7074 6953  tiSim = twsOptiS
+00006a80: 696d 2c20 6574 4f70 7469 5369 6d20 3d20  im, etOptiSim = 
+00006a90: 6574 4f70 7469 5369 6d29 0a20 2020 2020  etOptiSim).     
+00006aa0: 2021 2066 6f72 2061 6c6c 2064 6f6d 6169   ! for all domai
+00006ab0: 6e73 2074 6861 7420 6861 7665 2045 5420  ns that have ET 
+00006ac0: 616e 6420 5457 530a 2020 2020 2020 646f  and TWS.      do
+00006ad0: 2069 203d 2031 2c20 7369 7a65 286f 7074   i = 1, size(opt
+00006ae0: 695f 646f 6d61 696e 5f69 6e64 6963 6573  i_domain_indices
+00006af0: 5f45 545f 5457 5329 0a20 2020 2020 2020  _ET_TWS).       
+00006b00: 2069 446f 6d61 696e 203d 206f 7074 695f   iDomain = opti_
+00006b10: 646f 6d61 696e 5f69 6e64 6963 6573 5f45  domain_indices_E
+00006b20: 545f 5457 5328 6929 0a20 2020 2020 2020  T_TWS(i).       
+00006b30: 2063 616c 6c20 636f 6e76 6572 745f 7477   call convert_tw
+00006b40: 735f 746f 5f74 7773 6128 7477 734f 7074  s_to_twsa(twsOpt
+00006b50: 6953 696d 2869 446f 6d61 696e 292c 204c  iSim(iDomain), L
+00006b60: 315f 7477 7361 4f62 7328 6944 6f6d 6169  1_twsaObs(iDomai
+00006b70: 6e29 2c20 7477 7361 4f70 7469 5369 6d28  n), twsaOptiSim(
+00006b80: 6944 6f6d 6169 6e29 290a 2020 2020 2020  iDomain)).      
+00006b90: 2020 646f 2069 4365 6c6c 203d 2031 2c20    do iCell = 1, 
+00006ba0: 7369 7a65 284c 315f 6574 4f62 7328 6944  size(L1_etObs(iD
+00006bb0: 6f6d 6169 6e29 256d 6173 6b4f 6273 283a  omain)%maskObs(:
+00006bc0: 2c20 3a29 2c20 6469 6d20 3d20 3129 0a20  , :), dim = 1). 
+00006bd0: 2020 2020 2020 2020 206b 6765 5f65 7420           kge_et 
+00006be0: 3d20 6b67 655f 6574 202b 2026 0a20 2020  = kge_et + &.   
+00006bf0: 2020 2020 2020 2020 2028 312e 305f 6470           (1.0_dp
+00006c00: 202d 204b 4745 284c 315f 6574 4f62 7328   - KGE(L1_etObs(
+00006c10: 6944 6f6d 6169 6e29 2564 6174 614f 6273  iDomain)%dataObs
+00006c20: 2869 4365 6c6c 2c20 3a29 2c20 6574 4f70  (iCell, :), etOp
+00006c30: 7469 5369 6d28 6944 6f6d 6169 6e29 2564  tiSim(iDomain)%d
+00006c40: 6174 6153 696d 2869 4365 6c6c 2c20 3a29  ataSim(iCell, :)
+00006c50: 2c26 0a20 2020 2020 2020 2020 2020 2020  ,&.             
+00006c60: 2020 2020 2020 2020 2020 2020 2020 6d61                ma
+00006c70: 736b 203d 204c 315f 6574 4f62 7328 6944  sk = L1_etObs(iD
+00006c80: 6f6d 6169 6e29 256d 6173 6b4f 6273 2869  omain)%maskObs(i
+00006c90: 4365 6c6c 2c20 3a29 2929 2a2a 360a 2020  Cell, :)))**6.  
+00006ca0: 2020 2020 2020 2020 6e75 6d62 6572 4f66          numberOf
+00006cb0: 5375 6d6d 616e 6473 203d 206e 756d 6265  Summands = numbe
+00006cc0: 724f 6653 756d 6d61 6e64 7320 2b20 310a  rOfSummands + 1.
+00006cd0: 2020 2020 2020 2020 656e 6420 646f 0a20          end do. 
+00006ce0: 2020 2020 2020 2064 6f20 6943 656c 6c20         do iCell 
+00006cf0: 3d20 312c 2073 697a 6528 4c31 5f74 7773  = 1, size(L1_tws
+00006d00: 614f 6273 2869 446f 6d61 696e 2925 6d61  aObs(iDomain)%ma
+00006d10: 736b 4f62 7328 3a2c 203a 292c 2064 696d  skObs(:, :), dim
+00006d20: 203d 2031 290a 2020 2020 2020 2020 2020   = 1).          
+00006d30: 6b67 655f 7477 7320 3d20 6b67 655f 7477  kge_tws = kge_tw
+00006d40: 7320 2b20 260a 2020 2020 2020 2020 2020  s + &.          
+00006d50: 2020 2831 2e30 5f64 7020 2d20 4b47 4528    (1.0_dp - KGE(
+00006d60: 4c31 5f74 7773 614f 6273 2869 446f 6d61  L1_twsaObs(iDoma
+00006d70: 696e 2925 6461 7461 4f62 7328 6943 656c  in)%dataObs(iCel
+00006d80: 6c2c 203a 292c 2074 7773 614f 7074 6953  l, :), twsaOptiS
+00006d90: 696d 2869 446f 6d61 696e 2925 6461 7461  im(iDomain)%data
+00006da0: 5369 6d28 6943 656c 6c2c 203a 292c 260a  Sim(iCell, :),&.
+00006db0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006dc0: 2020 2020 2020 2020 2020 206d 6173 6b20             mask 
+00006dd0: 3d20 4c31 5f74 7773 614f 6273 2869 446f  = L1_twsaObs(iDo
+00006de0: 6d61 696e 2925 6d61 736b 4f62 7328 6943  main)%maskObs(iC
+00006df0: 656c 6c2c 203a 2929 292a 2a36 0a20 2020  ell, :)))**6.   
+00006e00: 2020 2020 2020 206e 756d 6265 724f 6653         numberOfS
+00006e10: 756d 6d61 6e64 7320 3d20 6e75 6d62 6572  ummands = number
+00006e20: 4f66 5375 6d6d 616e 6473 202b 2031 0a20  OfSummands + 1. 
+00006e30: 2020 2020 2020 2065 6e64 2064 6f0a 2020         end do.  
+00006e40: 2020 2020 2020 2120 6465 616c 6c6f 6361        ! dealloca
+00006e50: 7465 0a20 2020 2020 2020 2063 616c 6c20  te.        call 
+00006e60: 6574 4f70 7469 5369 6d28 6944 6f6d 6169  etOptiSim(iDomai
+00006e70: 6e29 2564 6573 7472 6f79 2829 0a20 2020  n)%destroy().   
+00006e80: 2020 2020 2063 616c 6c20 7477 734f 7074       call twsOpt
+00006e90: 6953 696d 2869 446f 6d61 696e 2925 6465  iSim(iDomain)%de
+00006ea0: 7374 726f 7928 290a 2020 2020 2020 2020  stroy().        
+00006eb0: 6361 6c6c 2074 7773 614f 7074 6953 696d  call twsaOptiSim
+00006ec0: 2869 446f 6d61 696e 2925 6465 7374 726f  (iDomain)%destro
+00006ed0: 7928 290a 2020 2020 2020 656e 6420 646f  y().      end do
+00006ee0: 0a20 2020 2020 2064 6561 6c6c 6f63 6174  .      deallocat
+00006ef0: 6528 6574 4f70 7469 5369 6d29 0a20 2020  e(etOptiSim).   
+00006f00: 2020 2064 6561 6c6c 6f63 6174 6528 7477     deallocate(tw
+00006f10: 734f 7074 6953 696d 290a 2020 2020 2020  sOptiSim).      
+00006f20: 6465 616c 6c6f 6361 7465 2874 7773 614f  deallocate(twsaO
+00006f30: 7074 6953 696d 290a 2020 2020 2021 2077  ptiSim).     ! w
+00006f40: 7269 7465 2830 2c2a 2920 276e 4574 5477  rite(0,*) 'nEtTw
+00006f50: 7344 6f6d 6169 6e73 2c20 6b67 655f 7477  sDomains, kge_tw
+00006f60: 7327 2c20 6e45 7454 7773 446f 6d61 696e  s', nEtTwsDomain
+00006f70: 732c 206b 6765 5f74 7773 0a20 2020 2020  s, kge_tws.     
+00006f80: 2120 7772 6974 6528 302c 2a29 2027 6e45  ! write(0,*) 'nE
+00006f90: 7454 7773 446f 6d61 696e 732c 206b 6765  tTwsDomains, kge
+00006fa0: 5f65 7427 2c20 6e45 7454 7773 446f 6d61  _et', nEtTwsDoma
+00006fb0: 696e 732c 206b 6765 5f65 740a 2020 2020  ins, kge_et.    
+00006fc0: 656e 6420 6966 0a20 2020 2021 2d2d 2d2d  end if.    !----
+00006fd0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00006fe0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00006ff0: 2d2d 2d2d 2d2d 2d2d 0a20 2020 2021 2054  --------.    ! T
+00007000: 5753 0a20 2020 2021 2d2d 2d2d 2d2d 2d2d  WS.    !--------
+00007010: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00007020: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00007030: 2d2d 2d2d 0a20 2020 2021 2065 7661 6c20  ----.    ! eval 
+00007040: 7275 6e73 2074 6f20 6765 7420 7369 6d75  runs to get simu
+00007050: 6c61 7465 6420 6f75 7470 7574 2066 6f72  lated output for
+00007060: 2074 7773 0a20 2020 2021 2062 6566 6f72   tws.    ! befor
+00007070: 6520 6561 6368 2065 7661 6c20 6361 6c6c  e each eval call
+00007080: 2077 6520 6765 6e65 7261 7465 2061 6e20   we generate an 
+00007090: 696e 6465 7820 6c69 7374 206f 6620 7468  index list of th
+000070a0: 6520 646f 6d61 696e 7320 666f 7220 7768  e domains for wh
+000070b0: 6963 680a 2020 2020 2120 6576 616c 2073  ich.    ! eval s
+000070c0: 686f 756c 6420 6265 2063 616c 6c65 642e  hould be called.
+000070d0: 2052 6561 6420 6465 7461 696c 7320 666f   Read details fo
+000070e0: 7220 6675 7274 6865 7220 696e 666f 726d  r further inform
+000070f0: 6174 696f 6e0a 2020 2020 6361 6c6c 2069  ation.    call i
+00007100: 6e69 745f 696e 6465 7861 7272 6179 5f66  nit_indexarray_f
+00007110: 6f72 5f6f 7074 695f 6461 7461 2864 6f6d  or_opti_data(dom
+00007120: 6169 6e4d 6574 612c 2033 2c20 6e54 7773  ainMeta, 3, nTws
+00007130: 446f 6d61 696e 732c 206f 7074 695f 646f  Domains, opti_do
+00007140: 6d61 696e 5f69 6e64 6963 6573 5f54 5753  main_indices_TWS
+00007150: 290a 2020 2020 6966 2028 6e54 7773 446f  ).    if (nTwsDo
+00007160: 6d61 696e 7320 3e20 3029 2074 6865 6e0a  mains > 0) then.
+00007170: 2020 2020 2020 616c 6c6f 6361 7465 2874        allocate(t
+00007180: 7773 4f70 7469 5369 6d28 646f 6d61 696e  wsOptiSim(domain
+00007190: 4d65 7461 256e 446f 6d61 696e 7329 290a  Meta%nDomains)).
+000071a0: 2020 2020 2020 616c 6c6f 6361 7465 2874        allocate(t
+000071b0: 7773 614f 7074 6953 696d 2864 6f6d 6169  wsaOptiSim(domai
+000071c0: 6e4d 6574 6125 6e44 6f6d 6169 6e73 2929  nMeta%nDomains))
+000071d0: 0a20 2020 2020 2063 616c 6c20 6576 616c  .      call eval
+000071e0: 2870 6172 616d 6574 6572 7365 742c 206f  (parameterset, o
+000071f0: 7074 695f 646f 6d61 696e 5f69 6e64 6963  pti_domain_indic
+00007200: 6573 203d 206f 7074 695f 646f 6d61 696e  es = opti_domain
+00007210: 5f69 6e64 6963 6573 5f54 5753 2c20 7477  _indices_TWS, tw
+00007220: 734f 7074 6953 696d 203d 2074 7773 4f70  sOptiSim = twsOp
+00007230: 7469 5369 6d29 0a20 2020 2020 2021 2066  tiSim).      ! f
+00007240: 6f72 2061 6c6c 2064 6f6d 6169 6e73 2074  or all domains t
+00007250: 6861 7420 6861 7665 2045 5420 616e 6420  hat have ET and 
+00007260: 5457 530a 2020 2020 2020 646f 2069 203d  TWS.      do i =
+00007270: 2031 2c20 7369 7a65 286f 7074 695f 646f   1, size(opti_do
+00007280: 6d61 696e 5f69 6e64 6963 6573 5f54 5753  main_indices_TWS
+00007290: 290a 2020 2020 2020 2020 6944 6f6d 6169  ).        iDomai
+000072a0: 6e20 3d20 6f70 7469 5f64 6f6d 6169 6e5f  n = opti_domain_
+000072b0: 696e 6469 6365 735f 5457 5328 6929 0a20  indices_TWS(i). 
+000072c0: 2020 2020 2020 2063 616c 6c20 636f 6e76         call conv
+000072d0: 6572 745f 7477 735f 746f 5f74 7773 6128  ert_tws_to_twsa(
+000072e0: 7477 734f 7074 6953 696d 2869 446f 6d61  twsOptiSim(iDoma
+000072f0: 696e 292c 204c 315f 7477 7361 4f62 7328  in), L1_twsaObs(
+00007300: 6944 6f6d 6169 6e29 2c20 7477 7361 4f70  iDomain), twsaOp
+00007310: 7469 5369 6d28 6944 6f6d 6169 6e29 290a  tiSim(iDomain)).
+00007320: 2020 2020 2020 2020 646f 2069 4365 6c6c          do iCell
+00007330: 203d 2031 2c20 7369 7a65 284c 315f 7477   = 1, size(L1_tw
+00007340: 7361 4f62 7328 6944 6f6d 6169 6e29 256d  saObs(iDomain)%m
+00007350: 6173 6b4f 6273 283a 2c20 3a29 2c20 6469  askObs(:, :), di
+00007360: 6d20 3d20 3129 0a20 2020 2020 2020 2020  m = 1).         
+00007370: 206b 6765 5f74 7773 203d 206b 6765 5f74   kge_tws = kge_t
+00007380: 7773 202b 2026 0a20 2020 2020 2020 2020  ws + &.         
+00007390: 2020 2028 312e 305f 6470 202d 204b 4745     (1.0_dp - KGE
+000073a0: 284c 315f 7477 7361 4f62 7328 6944 6f6d  (L1_twsaObs(iDom
+000073b0: 6169 6e29 2564 6174 614f 6273 2869 4365  ain)%dataObs(iCe
+000073c0: 6c6c 2c20 3a29 2c20 7477 7361 4f70 7469  ll, :), twsaOpti
+000073d0: 5369 6d28 6944 6f6d 6169 6e29 2564 6174  Sim(iDomain)%dat
+000073e0: 6153 696d 2869 4365 6c6c 2c20 3a29 2c26  aSim(iCell, :),&
+000073f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00007400: 2020 2020 2020 2020 2020 2020 6d61 736b              mask
+00007410: 203d 204c 315f 7477 7361 4f62 7328 6944   = L1_twsaObs(iD
+00007420: 6f6d 6169 6e29 256d 6173 6b4f 6273 2869  omain)%maskObs(i
+00007430: 4365 6c6c 2c20 3a29 2929 2a2a 360a 2020  Cell, :)))**6.  
+00007440: 2020 2020 2020 2020 6e75 6d62 6572 4f66          numberOf
+00007450: 5375 6d6d 616e 6473 203d 206e 756d 6265  Summands = numbe
+00007460: 724f 6653 756d 6d61 6e64 7320 2b20 310a  rOfSummands + 1.
+00007470: 2020 2020 2020 2020 656e 6420 646f 0a20          end do. 
+00007480: 2020 2020 2020 2063 616c 6c20 7477 734f         call twsO
+00007490: 7074 6953 696d 2869 446f 6d61 696e 2925  ptiSim(iDomain)%
+000074a0: 6465 7374 726f 7928 290a 2020 2020 2020  destroy().      
+000074b0: 656e 6420 646f 0a20 2020 2020 2064 6561  end do.      dea
+000074c0: 6c6c 6f63 6174 6528 7477 734f 7074 6953  llocate(twsOptiS
+000074d0: 696d 290a 2020 2020 2120 2077 7269 7465  im).    !  write
+000074e0: 2830 2c2a 2920 276e 5477 7344 6f6d 6169  (0,*) 'nTwsDomai
+000074f0: 6e73 2c20 6b67 655f 7477 7327 2c20 6e54  ns, kge_tws', nT
+00007500: 7773 446f 6d61 696e 732c 206b 6765 5f74  wsDomains, kge_t
+00007510: 7773 0a20 2020 2065 6e64 2069 660a 2020  ws.    end if.  
+00007520: 2020 6f62 6a65 6374 6976 655f 715f 6574    objective_q_et
+00007530: 5f74 7773 5f6b 6765 5f63 6174 6368 6d65  _tws_kge_catchme
+00007540: 6e74 5f61 7667 2832 2920 3d20 6b67 655f  nt_avg(2) = kge_
+00007550: 7477 730a 0a20 2020 2021 2d2d 2d2d 2d2d  tws..    !------
+00007560: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00007570: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00007580: 2d2d 2d2d 2d2d 0a20 2020 2021 2045 540a  ------.    ! ET.
+00007590: 2020 2020 212d 2d2d 2d2d 2d2d 2d2d 2d2d      !-----------
+000075a0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000075b0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000075c0: 2d0a 2020 2020 2120 6576 616c 2072 756e  -.    ! eval run
+000075d0: 7320 746f 2067 6574 2073 696d 756c 6174  s to get simulat
+000075e0: 6564 206f 7574 7075 7420 666f 7220 6574  ed output for et
+000075f0: 0a20 2020 2021 2062 6566 6f72 6520 6561  .    ! before ea
+00007600: 6368 2065 7661 6c20 6361 6c6c 2077 6520  ch eval call we 
+00007610: 6765 6e65 7261 7465 2061 6e20 696e 6465  generate an inde
+00007620: 7820 6c69 7374 206f 6620 7468 6520 646f  x list of the do
+00007630: 6d61 696e 7320 666f 7220 7768 6963 680a  mains for which.
+00007640: 2020 2020 2120 6576 616c 2073 686f 756c      ! eval shoul
+00007650: 6420 6265 2063 616c 6c65 642e 2052 6561  d be called. Rea
+00007660: 6420 6465 7461 696c 7320 666f 7220 6675  d details for fu
+00007670: 7274 6865 7220 696e 666f 726d 6174 696f  rther informatio
+00007680: 6e0a 2020 2020 6361 6c6c 2069 6e69 745f  n.    call init_
+00007690: 696e 6465 7861 7272 6179 5f66 6f72 5f6f  indexarray_for_o
+000076a0: 7074 695f 6461 7461 2864 6f6d 6169 6e4d  pti_data(domainM
+000076b0: 6574 612c 2035 2c20 6e45 7444 6f6d 6169  eta, 5, nEtDomai
+000076c0: 6e73 2c20 6f70 7469 5f64 6f6d 6169 6e5f  ns, opti_domain_
+000076d0: 696e 6469 6365 735f 4554 290a 2020 2020  indices_ET).    
+000076e0: 6966 2028 6e45 7444 6f6d 6169 6e73 203e  if (nEtDomains >
+000076f0: 2030 2920 7468 656e 0a20 2020 2020 2061   0) then.      a
+00007700: 6c6c 6f63 6174 6528 6574 4f70 7469 5369  llocate(etOptiSi
+00007710: 6d28 646f 6d61 696e 4d65 7461 256e 446f  m(domainMeta%nDo
+00007720: 6d61 696e 7329 290a 2020 2020 2020 6361  mains)).      ca
+00007730: 6c6c 2065 7661 6c28 7061 7261 6d65 7465  ll eval(paramete
+00007740: 7273 6574 2c20 6f70 7469 5f64 6f6d 6169  rset, opti_domai
+00007750: 6e5f 696e 6469 6365 7320 3d20 6f70 7469  n_indices = opti
+00007760: 5f64 6f6d 6169 6e5f 696e 6469 6365 735f  _domain_indices_
+00007770: 4554 2c20 6574 4f70 7469 5369 6d20 3d20  ET, etOptiSim = 
+00007780: 6574 4f70 7469 5369 6d29 0a20 2020 2020  etOptiSim).     
+00007790: 2021 2066 6f72 2061 6c6c 2064 6f6d 6169   ! for all domai
+000077a0: 6e73 2074 6861 7420 6861 7665 2045 5420  ns that have ET 
+000077b0: 616e 6420 5457 530a 2020 2020 2020 646f  and TWS.      do
+000077c0: 2069 203d 2031 2c20 7369 7a65 286f 7074   i = 1, size(opt
+000077d0: 695f 646f 6d61 696e 5f69 6e64 6963 6573  i_domain_indices
+000077e0: 5f45 5429 0a20 2020 2020 2020 2069 446f  _ET).        iDo
+000077f0: 6d61 696e 203d 206f 7074 695f 646f 6d61  main = opti_doma
+00007800: 696e 5f69 6e64 6963 6573 5f45 5428 6929  in_indices_ET(i)
+00007810: 0a20 2020 2020 2020 2064 6f20 6943 656c  .        do iCel
+00007820: 6c20 3d20 312c 2073 697a 6528 4c31 5f65  l = 1, size(L1_e
+00007830: 744f 6273 2869 446f 6d61 696e 2925 6d61  tObs(iDomain)%ma
+00007840: 736b 4f62 7328 3a2c 203a 292c 2064 696d  skObs(:, :), dim
+00007850: 203d 2031 290a 2020 2020 2020 2020 2020   = 1).          
+00007860: 6b67 655f 6574 203d 206b 6765 5f65 7420  kge_et = kge_et 
+00007870: 2b20 260a 2020 2020 2020 2020 2020 2020  + &.            
+00007880: 2831 2e30 5f64 7020 2d20 4b47 4528 4c31  (1.0_dp - KGE(L1
+00007890: 5f65 744f 6273 2869 446f 6d61 696e 2925  _etObs(iDomain)%
+000078a0: 6461 7461 4f62 7328 6943 656c 6c2c 203a  dataObs(iCell, :
+000078b0: 292c 2065 744f 7074 6953 696d 2869 446f  ), etOptiSim(iDo
+000078c0: 6d61 696e 2925 6461 7461 5369 6d28 6943  main)%dataSim(iC
+000078d0: 656c 6c2c 203a 292c 260a 2020 2020 2020  ell, :),&.      
+000078e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000078f0: 2020 2020 206d 6173 6b20 3d20 4c31 5f65       mask = L1_e
+00007900: 744f 6273 2869 446f 6d61 696e 2925 6d61  tObs(iDomain)%ma
+00007910: 736b 4f62 7328 6943 656c 6c2c 203a 2929  skObs(iCell, :))
+00007920: 292a 2a36 0a20 2020 2020 2020 2020 206e  )**6.          n
+00007930: 756d 6265 724f 6653 756d 6d61 6e64 7320  umberOfSummands 
+00007940: 3d20 6e75 6d62 6572 4f66 5375 6d6d 616e  = numberOfSumman
+00007950: 6473 202b 2031 0a20 2020 2020 2020 2065  ds + 1.        e
+00007960: 6e64 2064 6f0a 2020 2020 2020 2020 6361  nd do.        ca
+00007970: 6c6c 2065 744f 7074 6953 696d 2869 446f  ll etOptiSim(iDo
+00007980: 6d61 696e 2925 6465 7374 726f 7928 290a  main)%destroy().
+00007990: 2020 2020 2020 656e 6420 646f 0a20 2020        end do.   
+000079a0: 2020 2064 6561 6c6c 6f63 6174 6528 6574     deallocate(et
+000079b0: 4f70 7469 5369 6d29 0a20 2020 2020 2120  OptiSim).     ! 
+000079c0: 7772 6974 6528 302c 2a29 2027 6e45 7444  write(0,*) 'nEtD
+000079d0: 6f6d 6169 6e73 2c20 6b67 655f 6574 272c  omains, kge_et',
+000079e0: 206e 4574 446f 6d61 696e 732c 206b 6765   nEtDomains, kge
+000079f0: 5f65 740a 2020 2020 656e 6420 6966 0a20  _et.    end if. 
+00007a00: 2020 206f 626a 6563 7469 7665 5f71 5f65     objective_q_e
+00007a10: 745f 7477 735f 6b67 655f 6361 7463 686d  t_tws_kge_catchm
+00007a20: 656e 745f 6176 6728 3329 203d 206b 6765  ent_avg(3) = kge
+00007a30: 5f65 740a 0a20 2020 2021 2d2d 2d2d 2d2d  _et..    !------
+00007a40: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00007a50: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00007a60: 2d2d 2d2d 2d2d 0a20 2020 2021 2052 554e  ------.    ! RUN
+00007a70: 4f46 460a 2020 2020 212d 2d2d 2d2d 2d2d  OFF.    !-------
+00007a80: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00007a90: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00007aa0: 2d2d 2d2d 2d0a 2020 2020 2120 6576 616c  -----.    ! eval
+00007ab0: 2072 756e 7320 746f 2067 6574 2073 696d   runs to get sim
+00007ac0: 756c 6174 6564 206f 7574 7075 7420 666f  ulated output fo
+00007ad0: 7220 7275 6e6f 6666 0a20 2020 2021 2062  r runoff.    ! b
+00007ae0: 6566 6f72 6520 7468 6520 6576 616c 2063  efore the eval c
+00007af0: 616c 6c20 7765 2067 656e 6572 6174 6520  all we generate 
+00007b00: 616e 2069 6e64 6578 206c 6973 7420 6f66  an index list of
+00007b10: 2074 6865 2064 6f6d 6169 6e73 2066 6f72   the domains for
+00007b20: 2077 6869 6368 0a20 2020 2021 2065 7661   which.    ! eva
+00007b30: 6c20 7368 6f75 6c64 2062 6520 6361 6c6c  l should be call
+00007b40: 6564 2e20 5265 6164 2064 6574 6169 6c73  ed. Read details
+00007b50: 2066 6f72 2066 7572 7468 6572 2069 6e66   for further inf
+00007b60: 6f72 6d61 7469 6f6e 0a20 2020 2021 2054  ormation.    ! T
+00007b70: 6f44 6f3a 2020 5468 6520 6172 7261 7973  oDo:  The arrays
+00007b80: 2066 6f72 2071 5469 6e2c 2071 546f 7574   for qTin, qTout
+00007b90: 2c20 7769 6c6c 2062 6520 7265 7772 6974  , will be rewrit
+00007ba0: 7465 6e20 696e 2074 6865 206f 7468 6572  ten in the other
+00007bb0: 2063 616c 6c73 2077 6865 6e0a 2020 2020   calls when.    
+00007bc0: 2120 5120 6973 206e 6f74 2063 616c 6c65  ! Q is not calle
+00007bd0: 6420 6c61 7374 2e20 4368 616e 6765 2074  d last. Change t
+00007be0: 6861 7420 666f 7220 6d6f 7265 2066 6c65  hat for more fle
+00007bf0: 7869 6269 6c69 7479 0a20 2020 2063 616c  xibility.    cal
+00007c00: 6c20 696e 6974 5f69 6e64 6578 6172 7261  l init_indexarra
+00007c10: 795f 666f 725f 6f70 7469 5f64 6174 6128  y_for_opti_data(
+00007c20: 646f 6d61 696e 4d65 7461 2c20 312c 206e  domainMeta, 1, n
+00007c30: 5144 6f6d 6169 6e73 2c20 6f70 7469 5f64  QDomains, opti_d
+00007c40: 6f6d 6169 6e5f 696e 6469 6365 735f 5129  omain_indices_Q)
+00007c50: 0a0a 2020 2020 6966 2028 6e51 446f 6d61  ..    if (nQDoma
+00007c60: 696e 7320 3e20 3029 2074 6865 6e0a 2020  ins > 0) then.  
+00007c70: 2020 2020 6361 6c6c 2065 7661 6c28 7061      call eval(pa
+00007c80: 7261 6d65 7465 7273 6574 2c20 6f70 7469  rameterset, opti
+00007c90: 5f64 6f6d 6169 6e5f 696e 6469 6365 7320  _domain_indices 
+00007ca0: 3d20 6f70 7469 5f64 6f6d 6169 6e5f 696e  = opti_domain_in
+00007cb0: 6469 6365 735f 512c 2072 756e 6f66 6620  dices_Q, runoff 
+00007cc0: 3d20 7275 6e6f 6666 290a 2020 2020 2020  = runoff).      
+00007cd0: 6e47 6175 6765 7354 6f74 616c 203d 2073  nGaugesTotal = s
+00007ce0: 697a 6528 7275 6e6f 6666 2c20 6469 6d20  ize(runoff, dim 
+00007cf0: 3d20 3229 0a20 2020 2020 2064 6f20 6767  = 2).      do gg
+00007d00: 203d 2031 2c20 6e47 6175 6765 7354 6f74   = 1, nGaugesTot
+00007d10: 616c 0a0a 2020 2020 2020 2020 2120 6578  al..        ! ex
+00007d20: 7472 6163 7420 7275 6e6f 6666 0a20 2020  tract runoff.   
+00007d30: 2020 2020 2063 616c 6c20 6578 7472 6163       call extrac
+00007d40: 745f 7275 6e6f 6666 2867 672c 2072 756e  t_runoff(gg, run
+00007d50: 6f66 662c 2072 756e 6f66 665f 6167 672c  off, runoff_agg,
+00007d60: 2072 756e 6f66 665f 6f62 732c 2072 756e   runoff_obs, run
+00007d70: 6f66 665f 6f62 735f 6d61 736b 290a 0a20  off_obs_mask).. 
+00007d80: 2020 2020 2020 206b 6765 5f71 203d 206b         kge_q = k
+00007d90: 6765 5f71 202b 2026 0a20 2020 2020 2020  ge_q + &.       
+00007da0: 2020 2020 2020 2028 312e 305f 6470 202d         (1.0_dp -
+00007db0: 206b 6765 2872 756e 6f66 665f 6f62 732c   kge(runoff_obs,
+00007dc0: 2072 756e 6f66 665f 6167 672c 206d 6173   runoff_agg, mas
+00007dd0: 6b20 3d20 7275 6e6f 6666 5f6f 6273 5f6d  k = runoff_obs_m
+00007de0: 6173 6b29 292a 2a36 0a20 2020 2020 2020  ask))**6.       
+00007df0: 206e 756d 6265 724f 6653 756d 6d61 6e64   numberOfSummand
+00007e00: 7320 3d20 6e75 6d62 6572 4f66 5375 6d6d  s = numberOfSumm
+00007e10: 616e 6473 202b 2031 0a20 2020 2020 2020  ands + 1.       
+00007e20: 2064 6561 6c6c 6f63 6174 6520 2872 756e   deallocate (run
+00007e30: 6f66 665f 6167 672c 2072 756e 6f66 665f  off_agg, runoff_
+00007e40: 6f62 732c 2072 756e 6f66 665f 6f62 735f  obs, runoff_obs_
+00007e50: 6d61 736b 290a 2020 2020 2020 656e 6420  mask).      end 
+00007e60: 646f 0a20 2020 2020 2120 7772 6974 6528  do.     ! write(
+00007e70: 302c 2a29 2027 6e51 446f 6d61 696e 732c  0,*) 'nQDomains,
+00007e80: 206b 6765 5f71 272c 206e 5144 6f6d 6169   kge_q', nQDomai
+00007e90: 6e73 2c20 6b67 655f 710a 2020 2020 656e  ns, kge_q.    en
+00007ea0: 6420 6966 0a20 2020 206f 626a 6563 7469  d if.    objecti
+00007eb0: 7665 5f71 5f65 745f 7477 735f 6b67 655f  ve_q_et_tws_kge_
+00007ec0: 6361 7463 686d 656e 745f 6176 6728 3129  catchment_avg(1)
+00007ed0: 203d 206b 6765 5f71 0a0a 2020 2020 6f62   = kge_q..    ob
+00007ee0: 6a65 6374 6976 655f 715f 6574 5f74 7773  jective_q_et_tws
+00007ef0: 5f6b 6765 5f63 6174 6368 6d65 6e74 5f61  _kge_catchment_a
+00007f00: 7667 2834 2920 3d20 7265 616c 286e 756d  vg(4) = real(num
+00007f10: 6265 724f 6653 756d 6d61 6e64 732c 2064  berOfSummands, d
+00007f20: 7029 0a0a 0a23 6966 6e64 6566 204d 5049  p)...#ifndef MPI
+00007f30: 0a20 2020 206f 626a 6563 7469 7665 5f71  .    objective_q
+00007f40: 5f65 745f 7477 735f 6b67 655f 6361 7463  _et_tws_kge_catc
+00007f50: 686d 656e 745f 6176 6728 3129 203d 2028  hment_avg(1) = (
+00007f60: 286b 6765 5f71 2b6b 6765 5f65 742b 6b67  (kge_q+kge_et+kg
+00007f70: 655f 7477 7329 2f72 6561 6c28 6e75 6d62  e_tws)/real(numb
+00007f80: 6572 4f66 5375 6d6d 616e 6473 2c20 6470  erOfSummands, dp
+00007f90: 2929 2a2a 6f6e 6573 6978 7468 0a0a 2020  ))**onesixth..  
+00007fa0: 2020 6361 6c6c 206d 6573 7361 6765 2827    call message('
+00007fb0: 2020 2020 6f62 6a65 6374 6976 655f 715f      objective_q_
+00007fc0: 6574 5f74 7773 5f6b 6765 5f63 6174 6368  et_tws_kge_catch
+00007fd0: 6d65 6e74 5f61 7667 203d 2027 2c20 260a  ment_avg = ', &.
+00007fe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007ff0: 2020 2020 2020 6e75 6d32 7374 7228 6f62        num2str(ob
+00008000: 6a65 6374 6976 655f 715f 6574 5f74 7773  jective_q_et_tws
+00008010: 5f6b 6765 5f63 6174 6368 6d65 6e74 5f61  _kge_catchment_a
+00008020: 7667 2831 292c 2027 2846 392e 3529 2729  vg(1), '(F9.5)')
+00008030: 290a 2365 6e64 6966 0a0a 2020 454e 4420  ).#endif..  END 
+00008040: 4655 4e43 5449 4f4e 206f 626a 6563 7469  FUNCTION objecti
+00008050: 7665 5f71 5f65 745f 7477 735f 6b67 655f  ve_q_et_tws_kge_
+00008060: 6361 7463 686d 656e 745f 6176 670a 0a20  catchment_avg.. 
+00008070: 2021 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d   ! -------------
+00008080: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00008090: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000080a0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000080b0: 2d2d 2d2d 2d0a 0a20 2021 2020 2020 4e41  -----..  !    NA
+000080c0: 4d45 0a20 2021 2020 2020 2020 2020 696e  ME.  !        in
+000080d0: 6974 5f69 6e64 6578 6172 7261 795f 666f  it_indexarray_fo
+000080e0: 725f 6f70 7469 5f64 6174 610a 0a20 2021  r_opti_data..  !
+000080f0: 2020 2020 5055 5250 4f53 450a 2020 213e      PURPOSE.  !>
+00008100: 2020 2020 2020 205c 6272 6965 6620 6372         \brief cr
+00008110: 6561 7465 7320 616e 2069 6e64 6578 2061  eates an index a
+00008120: 7272 6179 206f 6620 7468 6520 696e 6964  rray of the inid
+00008130: 6963 6573 206f 6620 7468 6520 646f 6d61  ices of the doma
+00008140: 696e 7320 6576 616c 0a20 2021 3e20 2020  ins eval.  !>   
+00008150: 2020 2020 2020 2020 2020 2073 686f 756c             shoul
+00008160: 6420 4d50 4920 7072 6f63 6573 732e 0a20  d MPI process.. 
+00008170: 2021 0a20 2021 3e20 2020 2020 2020 5c64   !.  !>       \d
+00008180: 6574 6169 6c73 2054 6865 2064 6174 6120  etails The data 
+00008190: 7479 7065 2064 6f6d 6169 6e4d 6574 6120  type domainMeta 
+000081a0: 636f 6e74 6169 6e73 2061 6e20 6172 7261  contains an arra
+000081b0: 7920 6f70 7469 6461 7461 206f 6620 7369  y optidata of si
+000081c0: 7a65 0a20 2021 3e20 2020 2020 2020 2020  ze.  !>         
+000081d0: 2020 2020 2020 2064 6f6d 6169 6e4d 6574         domainMet
+000081e0: 6125 6e44 6f6d 6169 6e73 2c20 7465 6c6c  a%nDomains, tell
+000081f0: 696e 6720 7573 2c20 7768 6963 6820 646f  ing us, which do
+00008200: 6d61 696e 7320 7368 6f75 6c64 2062 650a  mains should be.
+00008210: 2020 213e 2020 2020 2020 2020 2020 2020    !>            
+00008220: 2020 2020 6f70 7469 6d69 7a65 6420 7769      optimized wi
+00008230: 7468 2077 6869 6368 206f 7074 695f 6461  th which opti_da
+00008240: 7461 2e20 5468 6973 2073 7562 726f 7574  ta. This subrout
+00008250: 696e 6520 7370 6c69 7473 2061 6c6c 0a20  ine splits all. 
+00008260: 2021 3e20 2020 2020 2020 2020 2020 2020   !>             
+00008270: 2020 2064 6f6d 6169 6e73 2061 7373 6967     domains assig
+00008280: 6e65 6420 746f 2061 2070 726f 6365 7373  ned to a process
+00008290: 2061 6e64 2072 6574 7572 6e73 2061 6e20   and returns an 
+000082a0: 696e 6465 7820 6c69 7374 0a20 2021 3e20  index list.  !> 
+000082b0: 2020 2020 2020 2020 2020 2020 2020 2063                 c
+000082c0: 6f72 7265 7370 6f6e 6469 6e67 2074 6f20  orresponding to 
+000082d0: 7468 6520 7661 6c75 6520 6f66 2064 6f6d  the value of dom
+000082e0: 6169 6e4d 6574 6125 6f70 7469 6461 7461  ainMeta%optidata
+000082f0: 2e0a 2020 213e 0a20 2021 3e20 2020 2020  ..  !>.  !>     
+00008300: 2020 2020 2020 2020 2020 2054 6865 2069             The i
+00008310: 6e64 6578 2061 7272 6179 206f 7074 695f  ndex array opti_
+00008320: 646f 6d61 696e 5f69 6e64 6963 6573 2063  domain_indices c
+00008330: 616e 2074 6865 6e20 6265 2070 6173 7365  an then be passe
+00008340: 640a 2020 213e 2020 2020 2020 2020 2020  d.  !>          
+00008350: 2020 2020 2020 6173 2061 6e20 6f70 7469        as an opti
+00008360: 6f6e 616c 2061 7267 756d 656e 7420 746f  onal argument to
+00008370: 2074 6865 2065 7661 6c20 7375 6272 6f75   the eval subrou
+00008380: 7469 6e65 2e20 5468 650a 2020 213e 2020  tine. The.  !>  
+00008390: 2020 2020 2020 2020 2020 2020 2020 6576                ev
+000083a0: 616c 2074 6865 6e20 696e 7374 6561 6420  al then instead 
+000083b0: 6f66 2075 7369 6e67 206c 6f6f 7073 206f  of using loops o
+000083c0: 7665 7220 616c 6c20 646f 6d61 696e 7320  ver all domains 
+000083d0: 6f6e 6c79 0a20 2021 3e20 2020 2020 2020  only.  !>       
+000083e0: 2020 2020 2020 2020 2075 7365 7320 7468           uses th
+000083f0: 6520 7061 7373 6564 2069 6e64 6963 6573  e passed indices
+00008400: 2e0a 2020 213e 0a20 2021 3e20 2020 2020  ..  !>.  !>     
+00008410: 2020 2020 2020 2020 2020 2054 6869 7320             This 
+00008420: 7375 6272 6f75 7469 6e65 2061 6c73 6f20  subroutine also 
+00008430: 7265 7475 726e 7320 7468 6520 7369 7a65  returns the size
+00008440: 206f 6620 7468 6174 2061 7272 6179 2073   of that array s
+00008450: 696e 6365 2069 740a 2020 213e 2020 2020  ince it.  !>    
+00008460: 2020 2020 2020 2020 2020 2020 6865 6c70              help
+00008470: 7320 7769 7468 2074 6865 2063 616c 6375  s with the calcu
+00008480: 6c61 7469 6f6e 7320 6f66 2074 6865 206f  lations of the o
+00008490: 7074 696d 697a 6174 696f 6e20 696e 2074  ptimization in t
+000084a0: 6865 2065 6e64 2e0a 0a20 2021 2020 2020  he end...  !    
+000084b0: 4849 5354 4f52 590a 2020 213e 2020 2020  HISTORY.  !>    
+000084c0: 2020 205c 6175 7468 6f72 7320 4d61 7265     \authors Mare
+000084d0: 6e20 4b61 6c75 7a61 0a0a 2020 213e 2020  n Kaluza..  !>  
+000084e0: 2020 2020 205c 6461 7465 204a 756c 7920       \date July 
+000084f0: 3230 3139 0a20 2073 7562 726f 7574 696e  2019.  subroutin
+00008500: 6520 696e 6974 5f69 6e64 6578 6172 7261  e init_indexarra
+00008510: 795f 666f 725f 6f70 7469 5f64 6174 6128  y_for_opti_data(
+00008520: 646f 6d61 696e 4d65 7461 2c20 6f70 7469  domainMeta, opti
+00008530: 6461 7461 4f70 7469 6f6e 2c20 6e4f 7074  dataOption, nOpt
+00008540: 6944 6f6d 6169 6e73 2c20 6f70 7469 5f64  iDomains, opti_d
+00008550: 6f6d 6169 6e5f 696e 6469 6365 7329 0a20  omain_indices). 
+00008560: 2020 2075 7365 206d 6f5f 636f 6d6d 6f6e     use mo_common
+00008570: 5f74 7970 6573 2c20 6f6e 6c79 3a20 646f  _types, only: do
+00008580: 6d61 696e 5f6d 6574 610a 2020 2020 213e  main_meta.    !>
+00008590: 206d 6574 6120 6461 7461 2066 6f72 2061   meta data for a
+000085a0: 6c6c 2064 6f6d 6169 6e73 2061 7373 6967  ll domains assig
+000085b0: 6e65 6420 746f 2074 6861 7420 7072 6f63  ned to that proc
+000085c0: 6573 730a 2020 2020 7479 7065 2864 6f6d  ess.    type(dom
+000085d0: 6169 6e5f 6d65 7461 292c 2020 2020 2020  ain_meta),      
+000085e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000085f0: 2020 2020 2020 2020 2020 696e 7465 6e74            intent
+00008600: 2869 6e29 2020 2020 3a3a 2064 6f6d 6169  (in)    :: domai
+00008610: 6e4d 6574 610a 2020 2020 213e 2077 6869  nMeta.    !> whi
+00008620: 6368 206f 7074 6920 6461 7461 2073 686f  ch opti data sho
+00008630: 756c 6420 6265 2075 7365 6420 696e 2074  uld be used in t
+00008640: 6865 2065 7661 6c20 6361 6c6c 6564 2061  he eval called a
+00008650: 6674 6572 2063 616c 6c69 6e67 2074 6869  fter calling thi
+00008660: 7320 7375 6272 6f75 7469 6e65 0a20 2020  s subroutine.   
+00008670: 2069 6e74 6567 6572 2869 3429 2c20 2020   integer(i4),   
+00008680: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008690: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000086a0: 2020 2069 6e74 656e 7428 696e 2920 2020     intent(in)   
+000086b0: 203a 3a20 6f70 7469 6461 7461 4f70 7469   :: optidataOpti
+000086c0: 6f6e 0a20 2020 2021 3e20 6e75 6d62 6572  on.    !> number
+000086d0: 206f 6620 646f 6d61 696e 7320 7468 6174   of domains that
+000086e0: 2077 696c 6c20 6265 206f 7074 696d 697a   will be optimiz
+000086f0: 6564 2069 6e20 7468 6520 666f 6c6c 6f77  ed in the follow
+00008700: 696e 6720 6576 616c 2063 616c 6c0a 2020  ing eval call.  
+00008710: 2020 696e 7465 6765 7228 6934 292c 2020    integer(i4),  
+00008720: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008730: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008740: 2020 2020 696e 7465 6e74 286f 7574 2920      intent(out) 
+00008750: 2020 3a3a 206e 4f70 7469 446f 6d61 696e    :: nOptiDomain
+00008760: 730a 2020 2020 213e 2074 6865 2069 6e64  s.    !> the ind
+00008770: 6963 6573 206f 6620 7468 6520 646f 6d61  ices of the doma
+00008780: 696e 7320 7468 6174 2061 7265 2074 6f20  ins that are to 
+00008790: 6265 2070 726f 6365 7373 6564 2069 6e20  be processed in 
+000087a0: 7468 6520 666f 6c6c 6f77 696e 6720 6576  the following ev
+000087b0: 616c 2063 616c 6c0a 2020 2020 696e 7465  al call.    inte
+000087c0: 6765 7228 6934 292c 2064 696d 656e 7369  ger(i4), dimensi
+000087d0: 6f6e 283a 292c 2061 6c6c 6f63 6174 6162  on(:), allocatab
+000087e0: 6c65 2c20 2020 2020 2020 2020 2020 696e  le,           in
+000087f0: 7465 6e74 286f 7574 2920 2020 3a3a 206f  tent(out)   :: o
+00008800: 7074 695f 646f 6d61 696e 5f69 6e64 6963  pti_domain_indic
+00008810: 6573 0a0a 2020 2020 213e 2064 6f6d 6169  es..    !> domai
+00008820: 6e20 6c6f 6f70 2063 6f75 6e74 6572 0a20  n loop counter. 
+00008830: 2020 2069 6e74 6567 6572 2869 3429 203a     integer(i4) :
+00008840: 3a20 6944 6f6d 6169 6e2c 2069 0a0a 2020  : iDomain, i..  
+00008850: 2020 6966 2028 616c 6c6f 6361 7465 6428    if (allocated(
+00008860: 6f70 7469 5f64 6f6d 6169 6e5f 696e 6469  opti_domain_indi
+00008870: 6365 7329 2920 6465 616c 6c6f 6361 7465  ces)) deallocate
+00008880: 286f 7074 695f 646f 6d61 696e 5f69 6e64  (opti_domain_ind
+00008890: 6963 6573 290a 2020 2020 2120 636f 756e  ices).    ! coun
+000088a0: 7420 646f 6d61 696e 7320 6f6e 204d 5049  t domains on MPI
+000088b0: 2070 726f 6365 7373 2074 6861 7420 7573   process that us
+000088c0: 6520 6f70 7469 6461 7461 0a20 2020 206e  e optidata.    n
+000088d0: 4f70 7469 446f 6d61 696e 7320 3d20 300a  OptiDomains = 0.
+000088e0: 2020 2020 646f 2069 446f 6d61 696e 203d      do iDomain =
+000088f0: 2031 2c20 646f 6d61 696e 4d65 7461 256e   1, domainMeta%n
+00008900: 446f 6d61 696e 730a 2020 2020 2020 6966  Domains.      if
+00008910: 2028 646f 6d61 696e 4d65 7461 256f 7074   (domainMeta%opt
+00008920: 6964 6174 6128 6944 6f6d 6169 6e29 203d  idata(iDomain) =
+00008930: 3d20 6f70 7469 6461 7461 4f70 7469 6f6e  = optidataOption
+00008940: 2920 6e4f 7074 6944 6f6d 6169 6e73 203d  ) nOptiDomains =
+00008950: 206e 4f70 7469 446f 6d61 696e 7320 2b20   nOptiDomains + 
+00008960: 310a 2020 2020 656e 6420 646f 0a20 2020  1.    end do.   
+00008970: 2021 2077 7269 7465 2069 6e64 6963 6573   ! write indices
+00008980: 206f 6620 7468 6573 6520 646f 6d61 696e   of these domain
+00008990: 7320 696e 746f 2061 6e20 6172 7261 790a  s into an array.
+000089a0: 2020 2020 6966 2028 6e4f 7074 6944 6f6d      if (nOptiDom
+000089b0: 6169 6e73 203e 2030 2920 7468 656e 0a20  ains > 0) then. 
+000089c0: 2020 2020 2061 6c6c 6f63 6174 6528 6f70       allocate(op
+000089d0: 7469 5f64 6f6d 6169 6e5f 696e 6469 6365  ti_domain_indice
+000089e0: 7328 6e4f 7074 6944 6f6d 6169 6e73 2929  s(nOptiDomains))
+000089f0: 0a20 2020 2020 2069 203d 2030 0a20 2020  .      i = 0.   
+00008a00: 2020 2064 6f20 6944 6f6d 6169 6e20 3d20     do iDomain = 
+00008a10: 312c 2064 6f6d 6169 6e4d 6574 6125 6e44  1, domainMeta%nD
+00008a20: 6f6d 6169 6e73 0a20 2020 2020 2020 2069  omains.        i
+00008a30: 6620 2864 6f6d 6169 6e4d 6574 6125 6f70  f (domainMeta%op
+00008a40: 7469 6461 7461 2869 446f 6d61 696e 2920  tidata(iDomain) 
+00008a50: 3d3d 206f 7074 6964 6174 614f 7074 696f  == optidataOptio
+00008a60: 6e29 2074 6865 6e0a 2020 2020 2020 2020  n) then.        
+00008a70: 2020 6920 3d20 6920 2b20 310a 2020 2020    i = i + 1.    
+00008a80: 2020 2020 2020 6f70 7469 5f64 6f6d 6169        opti_domai
+00008a90: 6e5f 696e 6469 6365 7328 6929 203d 2069  n_indices(i) = i
+00008aa0: 446f 6d61 696e 0a20 2020 2020 2020 2065  Domain.        e
+00008ab0: 6e64 2069 660a 2020 2020 2020 656e 6420  nd if.      end 
+00008ac0: 646f 0a20 2020 2065 6e64 2069 660a 2020  do.    end if.  
+00008ad0: 656e 6420 7375 6272 6f75 7469 6e65 2069  end subroutine i
+00008ae0: 6e69 745f 696e 6465 7861 7272 6179 5f66  nit_indexarray_f
+00008af0: 6f72 5f6f 7074 695f 6461 7461 0a20 2021  or_opti_data.  !
+00008b00: 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d   ---------------
+00008b10: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00008b20: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00008b30: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00008b40: 2d2d 2d0a 0a20 2021 2020 2020 4e41 4d45  ---..  !    NAME
+00008b50: 0a20 2021 2020 2020 2020 2020 6f62 6a65  .  !        obje
+00008b60: 6374 6976 655f 736d 5f63 6f72 720a 0a20  ctive_sm_corr.. 
+00008b70: 2021 2020 2020 5055 5250 4f53 450a 2020   !    PURPOSE.  
+00008b80: 213e 2020 2020 2020 205c 6272 6965 6620  !>       \brief 
+00008b90: 4f62 6a65 6374 6976 6520 6675 6e63 7469  Objective functi
+00008ba0: 6f6e 2066 6f72 2073 6f69 6c20 6d6f 6973  on for soil mois
+00008bb0: 7475 7265 2e0a 0a20 2021 3e20 2020 2020  ture...  !>     
+00008bc0: 2020 5c64 6574 6169 6c73 2054 6865 206f    \details The o
+00008bd0: 626a 6563 7469 7665 2066 756e 6374 696f  bjective functio
+00008be0: 6e20 6f6e 6c79 2064 6570 656e 6473 206f  n only depends o
+00008bf0: 6e20 6120 7061 7261 6d65 7465 7220 7665  n a parameter ve
+00008c00: 6374 6f72 2e0a 2020 213e 2020 2020 2020  ctor..  !>      
+00008c10: 2054 6865 206d 6f64 656c 2077 696c 6c20   The model will 
+00008c20: 6265 2063 616c 6c65 6420 7769 7468 2074  be called with t
+00008c30: 6861 7420 7061 7261 6d65 7465 7220 7665  hat parameter ve
+00008c40: 6374 6f72 2061 6e64 0a20 2021 3e20 2020  ctor and.  !>   
+00008c50: 2020 2020 7468 6520 6d6f 6465 6c20 6f75      the model ou
+00008c60: 7470 7574 2069 7320 7375 6273 6571 7565  tput is subseque
+00008c70: 6e74 6c79 2063 6f6d 7061 7265 6420 746f  ntly compared to
+00008c80: 206f 6273 6572 7665 6420 6461 7461 2e0a   observed data..
+00008c90: 0a20 2021 3e20 2020 2020 2020 5468 6572  .  !>       Ther
+00008ca0: 6566 6f72 6520 7468 6520 5065 6172 736f  efore the Pearso
+00008cb0: 6e20 636f 7272 656c 6174 696f 6e20 6265  n correlation be
+00008cc0: 7477 6565 6e20 6f62 7365 7276 6564 2061  tween observed a
+00008cd0: 6e64 206d 6f64 656c 6564 2073 6f69 6c0a  nd modeled soil.
+00008ce0: 2020 213e 2020 2020 2020 206d 6f69 7374    !>       moist
+00008cf0: 7572 6520 6f6e 2065 6163 6820 6772 6964  ure on each grid
+00008d00: 2063 656c 6c20 5c66 2420 6a20 5c66 2420   cell \f$ j \f$ 
+00008d10: 6973 2063 6f6d 7061 7265 640a 2020 213e  is compared.  !>
+00008d20: 2020 2020 2020 205c 665b 2072 5f6a 203d         \f[ r_j =
+00008d30: 2072 5e32 2853 4d5f 7b6f 6273 7d5e 6a2c   r^2(SM_{obs}^j,
+00008d40: 2053 4d5f 7b73 696d 7d5e 6a29 205c 665d   SM_{sim}^j) \f]
+00008d50: 0a20 2021 3e20 2020 2020 2020 7768 6572  .  !>       wher
+00008d60: 650a 2020 213e 2020 2020 2020 205c 6624  e.  !>       \f$
+00008d70: 2072 5e32 5c66 2420 2020 2020 2020 203d   r^2\f$        =
+00008d80: 2050 6561 7273 6f6e 2063 6f72 7265 6c61   Pearson correla
+00008d90: 7469 6f6e 2063 6f65 6666 6963 6965 6e74  tion coefficient
+00008da0: 2c0a 2020 213e 2020 2020 2020 205c 6624  ,.  !>       \f$
+00008db0: 2053 4d5f 7b6f 6273 7d20 5c66 2420 203d   SM_{obs} \f$  =
+00008dc0: 206f 6273 6572 7665 6420 736f 696c 206d   observed soil m
+00008dd0: 6f69 7374 7572 652c 0a20 2021 3e20 2020  oisture,.  !>   
+00008de0: 2020 2020 5c66 2420 534d 5f7b 7369 6d7d      \f$ SM_{sim}
+00008df0: 2020 5c66 2420 3d20 7369 6d75 6c61 7465    \f$ = simulate
+00008e00: 6420 736f 696c 206d 6f69 7374 7572 652e  d soil moisture.
+00008e10: 0a20 2021 3e20 2020 2020 2020 5468 6520  .  !>       The 
+00008e20: 6f62 7365 7276 6564 2064 6174 6120 5c66  observed data \f
+00008e30: 2420 534d 5f7b 6f62 737d 205c 6624 2061  $ SM_{obs} \f$ a
+00008e40: 7265 2067 6c6f 6261 6c20 696e 2074 6869  re global in thi
+00008e50: 7320 6d6f 6475 6c65 2e0a 0a20 2021 3e20  s module...  !> 
+00008e60: 2020 2020 2020 5468 6520 7468 6520 636f        The the co
+00008e70: 7272 656c 6174 696f 6e20 6973 2073 7061  rrelation is spa
+00008e80: 7469 616c 6c79 2061 7665 7261 6765 6420  tially averaged 
+00008e90: 6173 0a20 2021 3e20 2020 2020 2020 5c66  as.  !>       \f
+00008ea0: 5b20 5c70 6869 5f7b 697d 203d 205c 6672  [ \phi_{i} = \fr
+00008eb0: 6163 7b31 7d7b 4b7d 205c 6364 6f74 205c  ac{1}{K} \cdot \
+00008ec0: 7375 6d5f 7b6a 3d31 7d5e 4b20 725f 6a20  sum_{j=1}^K r_j 
+00008ed0: 5c66 5d0a 2020 213e 2020 2020 2020 2077  \f].  !>       w
+00008ee0: 6865 7265 205c 6624 204b 205c 6624 2064  here \f$ K \f$ d
+00008ef0: 656e 6f74 6573 2074 6865 206e 756d 6265  enotes the numbe
+00008f00: 7220 6f66 2076 616c 6964 2063 656c 6c73  r of valid cells
+00008f10: 2069 6e20 7468 6520 7374 7564 7920 646f   in the study do
+00008f20: 6d61 696e 2e0a 2020 213e 2020 2020 2020  main..  !>      
+00008f30: 2046 696e 616c 6c79 2c20 7468 6520 6f76   Finally, the ov
+00008f40: 6572 616c 6c20 6f62 6a65 6374 6976 6520  erall objective 
+00008f50: 6675 6e63 7469 6f6e 2076 616c 7565 205c  function value \
+00008f60: 6624 204f 4620 5c66 2420 6973 2065 7374  f$ OF \f$ is est
+00008f70: 696d 6174 6564 2062 6173 6564 206f 6e20  imated based on 
+00008f80: 7468 6520 706f 7765 722d 360a 2020 213e  the power-6.  !>
+00008f90: 2020 2020 2020 206e 6f72 6d20 746f 2063         norm to c
+00008fa0: 6f6d 6269 6e65 2074 6865 205c 6624 205c  ombine the \f$ \
+00008fb0: 7068 695f 7b69 7d20 5c66 2420 6672 6f6d  phi_{i} \f$ from
+00008fc0: 2061 6c6c 2064 6f6d 6169 6e73 205c 6624   all domains \f$
+00008fd0: 204e 205c 6624 2e0a 2020 213e 2020 2020   N \f$..  !>    
+00008fe0: 2020 205c 665b 204f 4620 3d20 5c73 7172     \f[ OF = \sqr
+00008ff0: 745b 365d 7b5c 7375 6d28 2831 2e30 202d  t[6]{\sum((1.0 -
+00009000: 205c 7068 695f 7b69 7d29 2f4e 295e 3620   \phi_{i})/N)^6 
+00009010: 7d2e 205c 665d 0a20 2021 3e20 2020 2020  }. \f].  !>     
+00009020: 2020 5468 6520 6f62 7365 7276 6564 2064    The observed d
+00009030: 6174 6120 4c31 5f73 6d2c 204c 315f 736d  ata L1_sm, L1_sm
+00009040: 5f6d 6173 6b20 6172 6520 676c 6f62 616c  _mask are global
+00009050: 2069 6e20 7468 6973 206d 6f64 756c 652e   in this module.
+00009060: 0a0a 2020 2120 2020 2049 4e54 454e 5428  ..  !    INTENT(
+00009070: 494e 290a 2020 213e 2020 2020 2020 205c  IN).  !>       \
+00009080: 7061 7261 6d5b 696e 5d20 2272 6561 6c28  param[in] "real(
+00009090: 6470 292c 2064 696d 656e 7369 6f6e 283a  dp), dimension(:
+000090a0: 2920 3a3a 2070 6172 616d 6574 6572 7365  ) :: parameterse
+000090b0: 7422 0a20 2021 3e20 2020 2020 2020 5c70  t".  !>       \p
+000090c0: 6172 616d 5b69 6e5d 2022 7072 6f63 6564  aram[in] "proced
+000090d0: 7572 6528 6576 616c 5f69 6e74 6572 6661  ure(eval_interfa
+000090e0: 6365 2920 3a3a 2065 7661 6c22 0a0a 2020  ce) :: eval"..  
+000090f0: 2120 2020 2052 4554 5552 4e0a 2020 213e  !    RETURN.  !>
+00009100: 2020 2020 2020 205c 7265 7475 726e 2072         \return r
+00009110: 6561 6c28 6470 2920 3a3a 206f 626a 6563  eal(dp) :: objec
+00009120: 7469 7665 5f73 6d5f 636f 7272 2026 6d64  tive_sm_corr &md
+00009130: 6173 683b 206f 626a 6563 7469 7665 2066  ash; objective f
+00009140: 756e 6374 696f 6e20 7661 6c75 650a 2020  unction value.  
+00009150: 213e 2020 2020 2020 2028 7768 6963 6820  !>       (which 
+00009160: 7769 6c6c 2062 6520 652e 672e 206d 696e  will be e.g. min
+00009170: 696d 697a 6564 2062 7920 616e 206f 7074  imized by an opt
+00009180: 696d 697a 6174 696f 6e20 726f 7574 696e  imization routin
+00009190: 6520 6c69 6b65 2044 4453 290a 0a20 2021  e like DDS)..  !
+000091a0: 2020 2020 4849 5354 4f52 590a 2020 213e      HISTORY.  !>
+000091b0: 2020 2020 2020 205c 6175 7468 6f72 7320         \authors 
+000091c0: 4d61 7474 6869 6173 205a 696e 6b0a 0a20  Matthias Zink.. 
+000091d0: 2021 3e20 2020 2020 2020 5c64 6174 6520   !>       \date 
+000091e0: 4d61 7263 6820 3230 3135 0a0a 2020 2120  March 2015..  ! 
+000091f0: 4d6f 6469 6669 6361 7469 6f6e 733a 0a20  Modifications:. 
+00009200: 2021 2052 6f62 6572 7420 5363 6877 6570   ! Robert Schwep
+00009210: 7065 204a 756e 2032 3031 3820 2d20 7265  pe Jun 2018 - re
+00009220: 6661 6374 6f72 696e 6720 616e 6420 7265  factoring and re
+00009230: 666f 726d 6174 7469 6e67 0a0a 2020 4655  formatting..  FU
+00009240: 4e43 5449 4f4e 206f 626a 6563 7469 7665  NCTION objective
+00009250: 5f73 6d5f 636f 7272 2870 6172 616d 6574  _sm_corr(paramet
+00009260: 6572 7365 742c 2065 7661 6c29 0a0a 2020  erset, eval)..  
+00009270: 2020 7573 6520 6d6f 5f6f 7074 696d 697a    use mo_optimiz
+00009280: 6174 696f 6e5f 7479 7065 732c 206f 6e6c  ation_types, onl
+00009290: 7920 3a20 6f70 7469 6461 7461 5f73 696d  y : optidata_sim
+000092a0: 0a20 2020 2075 7365 206d 6f5f 636f 6d6d  .    use mo_comm
+000092b0: 6f6e 5f76 6172 6961 626c 6573 2c20 6f6e  on_variables, on
+000092c0: 6c79 203a 206c 6576 656c 312c 2064 6f6d  ly : level1, dom
+000092d0: 6169 6e4d 6574 610a 2020 2020 7573 6520  ainMeta.    use 
+000092e0: 6d6f 5f67 6c6f 6261 6c5f 7661 7269 6162  mo_global_variab
+000092f0: 6c65 732c 206f 6e6c 7920 3a20 4c31 5f73  les, only : L1_s
+00009300: 6d4f 6273 0a20 2020 2075 7365 206d 6f5f  mObs.    use mo_
+00009310: 6d6f 6d65 6e74 2c20 6f6e 6c79 203a 2063  moment, only : c
+00009320: 6f72 7265 6c61 7469 6f6e 0a20 2020 2075  orrelation.    u
+00009330: 7365 206d 6f5f 7374 7269 6e67 5f75 7469  se mo_string_uti
+00009340: 6c73 2c20 6f6e 6c79 203a 206e 756d 3273  ls, only : num2s
+00009350: 7472 0a0a 2020 2020 696d 706c 6963 6974  tr..    implicit
+00009360: 206e 6f6e 650a 0a20 2020 2072 6561 6c28   none..    real(
+00009370: 6470 292c 2064 696d 656e 7369 6f6e 283a  dp), dimension(:
+00009380: 292c 2069 6e74 656e 7428 696e 2920 3a3a  ), intent(in) ::
+00009390: 2070 6172 616d 6574 6572 7365 740a 0a20   parameterset.. 
+000093a0: 2020 2070 726f 6365 6475 7265 2865 7661     procedure(eva
+000093b0: 6c5f 696e 7465 7266 6163 6529 2c20 494e  l_interface), IN
+000093c0: 5445 4e54 2849 4e29 2c20 504f 494e 5445  TENT(IN), POINTE
+000093d0: 5220 3a3a 2065 7661 6c0a 0a20 2020 2072  R :: eval..    r
+000093e0: 6561 6c28 6470 2920 3a3a 206f 626a 6563  eal(dp) :: objec
+000093f0: 7469 7665 5f73 6d5f 636f 7272 0a0a 2020  tive_sm_corr..  
+00009400: 2020 2120 646f 6d61 696e 206c 6f6f 7020    ! domain loop 
+00009410: 636f 756e 7465 720a 2020 2020 696e 7465  counter.    inte
+00009420: 6765 7228 6934 2920 3a3a 2069 446f 6d61  ger(i4) :: iDoma
+00009430: 696e 0a0a 2020 2020 2120 6365 6c6c 206c  in..    ! cell l
+00009440: 6f6f 7020 636f 756e 7465 720a 2020 2020  oop counter.    
+00009450: 696e 7465 6765 7228 6934 2920 3a3a 2069  integer(i4) :: i
+00009460: 4365 6c6c 0a0a 2020 2020 2120 6e63 656c  Cell..    ! ncel
+00009470: 6c73 3120 6f66 206c 6576 656c 2031 0a20  ls1 of level 1. 
+00009480: 2020 2069 6e74 6567 6572 2869 3429 203a     integer(i4) :
+00009490: 3a20 6e63 656c 6c73 310a 0a20 2020 2021  : ncells1..    !
+000094a0: 206e 756d 6265 7220 6f66 2069 6e76 616c   number of inval
+000094b0: 6964 2063 656c 6c73 2069 6e20 6361 7463  id cells in catc
+000094c0: 686d 656e 740a 2020 2020 7265 616c 2864  hment.    real(d
+000094d0: 7029 203a 3a20 696e 7661 6c69 645f 6365  p) :: invalid_ce
+000094e0: 6c6c 730a 0a20 2020 2021 2064 6f6d 6169  lls..    ! domai
+000094f0: 6e73 2077 6973 6520 6f62 6a65 6374 6976  ns wise objectiv
+00009500: 6573 0a20 2020 2072 6561 6c28 6470 2920  es.    real(dp) 
+00009510: 3a3a 206f 626a 6563 7469 7665 5f73 6d5f  :: objective_sm_
+00009520: 636f 7272 5f64 6f6d 6169 6e0a 0a23 6966  corr_domain..#if
+00009530: 6e64 6566 204d 5049 0a20 2020 2072 6561  ndef MPI.    rea
+00009540: 6c28 6470 292c 2070 6172 616d 6574 6572  l(dp), parameter
+00009550: 203a 3a20 6f6e 6573 6978 7468 203d 2031   :: onesixth = 1
+00009560: 2e30 5f64 7020 2f20 362e 305f 6470 0a23  .0_dp / 6.0_dp.#
+00009570: 656e 6469 660a 0a20 2020 2074 7970 6528  endif..    type(
+00009580: 6f70 7469 6461 7461 5f73 696d 292c 2064  optidata_sim), d
+00009590: 696d 656e 7369 6f6e 283a 292c 2061 6c6c  imension(:), all
+000095a0: 6f63 6174 6162 6c65 203a 3a20 736d 4f70  ocatable :: smOp
+000095b0: 7469 5369 6d0a 0a0a 2020 2020 616c 6c6f  tiSim...    allo
+000095c0: 6361 7465 2873 6d4f 7074 6953 696d 2864  cate(smOptiSim(d
+000095d0: 6f6d 6169 6e4d 6574 6125 6e44 6f6d 6169  omainMeta%nDomai
+000095e0: 6e73 2929 0a20 2020 2063 616c 6c20 6576  ns)).    call ev
+000095f0: 616c 2870 6172 616d 6574 6572 7365 742c  al(parameterset,
+00009600: 2073 6d4f 7074 6953 696d 203d 2073 6d4f   smOptiSim = smO
+00009610: 7074 6953 696d 290a 0a20 2020 2021 2069  ptiSim)..    ! i
+00009620: 6e69 7469 616c 697a 6520 736f 6d65 2076  nitialize some v
+00009630: 6172 6961 626c 6573 0a20 2020 206f 626a  ariables.    obj
+00009640: 6563 7469 7665 5f73 6d5f 636f 7272 203d  ective_sm_corr =
+00009650: 2030 2e30 5f64 700a 0a20 2020 2021 206c   0.0_dp..    ! l
+00009660: 6f6f 7020 6f76 6572 2064 6f6d 6169 6e20  oop over domain 
+00009670: 2d20 666f 7220 6170 706c 7969 6e67 2070  - for applying p
+00009680: 6f77 6572 206c 6177 206c 6174 6572 206f  ower law later o
+00009690: 6e0a 2020 2020 646f 2069 446f 6d61 696e  n.    do iDomain
+000096a0: 203d 2031 2c20 646f 6d61 696e 4d65 7461   = 1, domainMeta
+000096b0: 256e 446f 6d61 696e 730a 0a20 2020 2020  %nDomains..     
+000096c0: 2021 2069 6e69 740a 2020 2020 2020 6f62   ! init.      ob
+000096d0: 6a65 6374 6976 655f 736d 5f63 6f72 725f  jective_sm_corr_
+000096e0: 646f 6d61 696e 203d 2030 2e30 5f64 700a  domain = 0.0_dp.
+000096f0: 2020 2020 2020 2120 6765 7420 646f 6d61        ! get doma
+00009700: 696e 2069 6e66 6f72 6d61 7469 6f6e 0a20  in information. 
+00009710: 2020 2020 206e 6365 6c6c 7331 203d 206c       ncells1 = l
+00009720: 6576 656c 3128 6944 6f6d 6169 6e29 256e  evel1(iDomain)%n
+00009730: 6365 6c6c 730a 0a20 2020 2020 2069 6e76  cells..      inv
+00009740: 616c 6964 5f63 656c 6c73 203d 2030 2e30  alid_cells = 0.0
+00009750: 5f64 700a 2020 2020 2020 2120 7465 6d70  _dp.      ! temp
+00009760: 6f72 616c 2063 6f72 7265 6c61 7469 6f6e  oral correlation
+00009770: 2069 7320 6361 6c63 756c 6174 6564 206f   is calculated o
+00009780: 6e20 696e 6469 7669 6475 616c 2067 7269  n individual gri
+00009790: 6464 2063 656c 6c73 0a0a 2020 2020 2020  dd cells..      
+000097a0: 646f 2069 4365 6c6c 203d 2031 2c20 7369  do iCell = 1, si
+000097b0: 7a65 284c 315f 736d 4f62 7328 6944 6f6d  ze(L1_smObs(iDom
+000097c0: 6169 6e29 256d 6173 6b4f 6273 283a 2c20  ain)%maskObs(:, 
+000097d0: 3a29 2c20 6469 6d20 3d20 3129 0a0a 2020  :), dim = 1)..  
+000097e0: 2020 2020 2020 2120 6368 6563 6b20 666f        ! check fo
+000097f0: 7220 656e 6f75 6768 2064 6174 6120 706f  r enough data po
+00009800: 696e 7473 2069 6e20 7469 6d65 2066 6f72  ints in time for
+00009810: 2063 6f72 7265 6c61 7469 6f6e 0a20 2020   correlation.   
+00009820: 2020 2020 2069 6620 2863 6f75 6e74 284c       if (count(L
+00009830: 315f 736d 4f62 7328 6944 6f6d 6169 6e29  1_smObs(iDomain)
+00009840: 256d 6173 6b4f 6273 2869 4365 6c6c 2c20  %maskObs(iCell, 
+00009850: 3a29 2920 2e4c 452e 2030 2e31 305f 6470  :)) .LE. 0.10_dp
+00009860: 202a 2072 6561 6c28 7369 7a65 284c 315f   * real(size(L1_
+00009870: 736d 4f62 7328 6944 6f6d 6169 6e29 2564  smObs(iDomain)%d
+00009880: 6174 614f 6273 283a 2c20 3a29 2c20 6469  ataObs(:, :), di
+00009890: 6d20 3d20 3229 2c20 6470 2929 2074 6865  m = 2), dp)) the
+000098a0: 6e0a 2020 2020 2020 2020 2020 696e 7661  n.          inva
+000098b0: 6c69 645f 6365 6c6c 7320 3d20 696e 7661  lid_cells = inva
+000098c0: 6c69 645f 6365 6c6c 7320 2b20 312e 305f  lid_cells + 1.0_
+000098d0: 6470 0a20 2020 2020 2020 2020 2063 7963  dp.          cyc
+000098e0: 6c65 0a20 2020 2020 2020 2065 6e64 2069  le.        end i
+000098f0: 660a 2020 2020 2020 2020 6f62 6a65 6374  f.        object
+00009900: 6976 655f 736d 5f63 6f72 725f 646f 6d61  ive_sm_corr_doma
+00009910: 696e 203d 206f 626a 6563 7469 7665 5f73  in = objective_s
+00009920: 6d5f 636f 7272 5f64 6f6d 6169 6e20 2b20  m_corr_domain + 
+00009930: 260a 2020 2020 2020 2020 2020 2020 2020  &.              
+00009940: 2020 636f 7272 656c 6174 696f 6e28 4c31    correlation(L1
+00009950: 5f73 6d4f 6273 2869 446f 6d61 696e 2925  _smObs(iDomain)%
+00009960: 6461 7461 4f62 7328 6943 656c 6c2c 203a  dataObs(iCell, :
+00009970: 292c 2073 6d4f 7074 6953 696d 2869 446f  ), smOptiSim(iDo
+00009980: 6d61 696e 2925 6461 7461 5369 6d28 6943  main)%dataSim(iC
+00009990: 656c 6c2c 203a 292c 2026 0a20 2020 2020  ell, :), &.     
+000099a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000099b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000099c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000099d0: 2020 2020 2020 6d61 736b 203d 204c 315f        mask = L1_
+000099e0: 736d 4f62 7328 6944 6f6d 6169 6e29 256d  smObs(iDomain)%m
+000099f0: 6173 6b4f 6273 2869 4365 6c6c 2c20 3a29  askObs(iCell, :)
+00009a00: 290a 2020 2020 2020 656e 6420 646f 0a0a  ).      end do..
+00009a10: 2020 2020 2020 2120 7573 6572 2069 6e66        ! user inf
+00009a20: 6f72 6d61 7469 6f6e 2061 626f 7574 2069  ormation about i
+00009a30: 6e76 616c 6964 2063 656c 6c73 0a20 2020  nvalid cells.   
+00009a40: 2020 2069 6620 2869 6e76 616c 6964 5f63     if (invalid_c
+00009a50: 656c 6c73 202e 4754 2e20 302e 355f 6470  ells .GT. 0.5_dp
+00009a60: 2920 7468 656e 0a20 2020 2020 2020 2063  ) then.        c
+00009a70: 616c 6c20 6d65 7373 6167 6528 2720 2020  all message('   
+00009a80: 5741 524e 494e 473a 206f 626a 6563 7469  WARNING: objecti
+00009a90: 7665 5f73 6d3a 2044 6574 6563 7465 6420  ve_sm: Detected 
+00009aa0: 696e 7661 6c69 6420 6365 6c6c 7320 696e  invalid cells in
+00009ab0: 2073 7475 6479 2061 7265 6120 282e 4c54   study area (.LT
+00009ac0: 2e20 3130 2076 616c 6964 2064 6174 6120  . 10 valid data 
+00009ad0: 706f 696e 7473 292e 2729 0a20 2020 2020  points).').     
+00009ae0: 2020 2063 616c 6c20 6d65 7373 6167 6528     call message(
+00009af0: 2720 2020 2020 2020 2020 2020 2020 2020  '               
+00009b00: 2020 2020 2020 2020 2020 2046 7261 6374             Fract
+00009b10: 696f 6e20 6f66 2069 6e76 616c 6964 2063  ion of invalid c
+00009b20: 656c 6c73 3a20 272c 2026 0a20 2020 2020  ells: ', &.     
+00009b30: 2020 2020 2020 2020 2020 206e 756d 3273             num2s
+00009b40: 7472 2869 6e76 616c 6964 5f63 656c 6c73  tr(invalid_cells
+00009b50: 202f 2072 6561 6c28 6e43 656c 6c73 312c   / real(nCells1,
+00009b60: 2064 7029 2c20 2728 4634 2e32 2927 2929   dp), '(F4.2)'))
+00009b70: 0a20 2020 2020 2065 6e64 2069 660a 0a0a  .      end if...
+00009b80: 2020 2020 2020 2120 6361 6c63 756c 6174        ! calculat
+00009b90: 6520 6176 6572 6167 6520 736f 696c 206d  e average soil m
+00009ba0: 6f69 7374 7572 6520 636f 7272 656c 6174  oisture correlat
+00009bb0: 696f 6e20 6f76 6572 2061 6c6c 2064 6f6d  ion over all dom
+00009bc0: 6169 6e73 2077 6974 6820 706f 7765 7220  ains with power 
+00009bd0: 6c61 770a 2020 2020 2020 2120 646f 6d61  law.      ! doma
+00009be0: 696e 7320 6172 6520 7765 6967 6874 6564  ins are weighted
+00009bf0: 2065 7175 616c 6c79 2028 2031 202f 2072   equally ( 1 / r
+00009c00: 6561 6c28 646f 6d61 696e 4d65 7461 256f  eal(domainMeta%o
+00009c10: 7665 7261 6c6c 4e75 6d62 6572 4f66 446f  verallNumberOfDo
+00009c20: 6d61 696e 732c 6470 2929 2a2a 360a 2020  mains,dp))**6.  
+00009c30: 2020 2020 6f62 6a65 6374 6976 655f 736d      objective_sm
+00009c40: 5f63 6f72 7220 3d20 6f62 6a65 6374 6976  _corr = objectiv
+00009c50: 655f 736d 5f63 6f72 7220 2b20 260a 2020  e_sm_corr + &.  
+00009c60: 2020 2020 2020 2020 2020 2020 2828 312e              ((1.
+00009c70: 305f 6470 202d 206f 626a 6563 7469 7665  0_dp - objective
+00009c80: 5f73 6d5f 636f 7272 5f64 6f6d 6169 6e20  _sm_corr_domain 
+00009c90: 2f20 7265 616c 286e 4365 6c6c 7331 2c20  / real(nCells1, 
+00009ca0: 6470 2929 202f 2072 6561 6c28 646f 6d61  dp)) / real(doma
+00009cb0: 696e 4d65 7461 256f 7665 7261 6c6c 4e75  inMeta%overallNu
+00009cc0: 6d62 6572 4f66 446f 6d61 696e 732c 2064  mberOfDomains, d
+00009cd0: 7029 292a 2a36 0a20 2020 2065 6e64 2064  p))**6.    end d
+00009ce0: 6f0a 2369 666e 6465 6620 4d50 490a 2020  o.#ifndef MPI.  
+00009cf0: 2020 6f62 6a65 6374 6976 655f 736d 5f63    objective_sm_c
+00009d00: 6f72 7220 3d20 6f62 6a65 6374 6976 655f  orr = objective_
+00009d10: 736d 5f63 6f72 722a 2a6f 6e65 7369 7874  sm_corr**onesixt
+00009d20: 680a 0a20 2020 2063 616c 6c20 6d65 7373  h..    call mess
+00009d30: 6167 6528 2720 2020 206f 626a 6563 7469  age('    objecti
+00009d40: 7665 5f73 6d5f 636f 7272 203d 2027 2c20  ve_sm_corr = ', 
+00009d50: 6e75 6d32 7374 7228 6f62 6a65 6374 6976  num2str(objectiv
+00009d60: 655f 736d 5f63 6f72 722c 2027 2846 392e  e_sm_corr, '(F9.
+00009d70: 3529 2729 290a 2365 6e64 6966 0a0a 2020  5)')).#endif..  
+00009d80: 454e 4420 4655 4e43 5449 4f4e 206f 626a  END FUNCTION obj
+00009d90: 6563 7469 7665 5f73 6d5f 636f 7272 0a0a  ective_sm_corr..
+00009da0: 2020 2120 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d    ! ------------
+00009db0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00009dc0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00009dd0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00009de0: 2d2d 2d2d 2d2d 0a0a 2020 2120 2020 204e  ------..  !    N
+00009df0: 414d 450a 2020 2120 2020 2020 2020 206f  AME.  !        o
+00009e00: 626a 6563 7469 7665 5f73 6d5f 7064 0a0a  bjective_sm_pd..
+00009e10: 2020 2120 2020 2050 5552 504f 5345 0a20    !    PURPOSE. 
+00009e20: 2021 3e20 2020 2020 2020 5c62 7269 6566   !>       \brief
+00009e30: 204f 626a 6563 7469 7665 2066 756e 6374   Objective funct
+00009e40: 696f 6e20 666f 7220 736f 696c 206d 6f69  ion for soil moi
+00009e50: 7374 7572 652e 0a0a 2020 213e 2020 2020  sture...  !>    
+00009e60: 2020 205c 6465 7461 696c 7320 5468 6520     \details The 
+00009e70: 6f62 6a65 6374 6976 6520 6675 6e63 7469  objective functi
+00009e80: 6f6e 206f 6e6c 7920 6465 7065 6e64 7320  on only depends 
+00009e90: 6f6e 2061 2070 6172 616d 6574 6572 2076  on a parameter v
+00009ea0: 6563 746f 722e 0a20 2021 3e20 2020 2020  ector..  !>     
+00009eb0: 2020 5468 6520 6d6f 6465 6c20 7769 6c6c    The model will
+00009ec0: 2062 6520 6361 6c6c 6564 2077 6974 6820   be called with 
+00009ed0: 7468 6174 2070 6172 616d 6574 6572 2076  that parameter v
+00009ee0: 6563 746f 7220 616e 640a 2020 213e 2020  ector and.  !>  
+00009ef0: 2020 2020 2074 6865 206d 6f64 656c 206f       the model o
+00009f00: 7574 7075 7420 6973 2073 7562 7365 7175  utput is subsequ
+00009f10: 656e 746c 7920 636f 6d70 6172 6564 2074  ently compared t
+00009f20: 6f20 6f62 7365 7276 6564 2064 6174 612e  o observed data.
+00009f30: 0a0a 2020 213e 2020 2020 2020 2054 6865  ..  !>       The
+00009f40: 7265 666f 7265 2074 6865 2050 6174 7465  refore the Patte
+00009f50: 726e 2044 6973 7369 6d69 6c61 7269 7479  rn Dissimilarity
+00009f60: 2028 5044 2920 6f66 206f 6273 6572 7665   (PD) of observe
+00009f70: 6420 616e 6420 6d6f 6465 6c65 6420 736f  d and modeled so
+00009f80: 696c 0a20 2021 3e20 2020 2020 2020 6d6f  il.  !>       mo
+00009f90: 6973 7475 7265 2066 6965 6c64 7320 6973  isture fields is
+00009fa0: 2063 616c 6375 6c61 7465 6420 2d20 6169   calculated - ai
+00009fb0: 6d3a 206d 6174 6368 696e 6720 7370 6174  m: matching spat
+00009fc0: 6961 6c20 7061 7474 6572 730a 2020 213e  ial patters.  !>
+00009fd0: 2020 2020 2020 205c 665b 2045 2874 2920         \f[ E(t) 
+00009fe0: 3d20 5044 5c6c 6566 7428 2053 4d5f 7b6f  = PD\left( SM_{o
+00009ff0: 6273 7d28 7429 2c20 534d 5f7b 7369 6d7d  bs}(t), SM_{sim}
+0000a000: 2874 2920 5c72 6967 6874 2920 5c66 5d0a  (t) \right) \f].
+0000a010: 2020 213e 2020 2020 2020 2077 6865 7265    !>       where
+0000a020: 0a20 2021 3e20 2020 2020 2020 5c66 2420  .  !>       \f$ 
+0000a030: 5044 205c 6624 2020 2020 2020 2020 3d20  PD \f$        = 
+0000a040: 7061 7474 6572 6e20 6469 7373 696d 696c  pattern dissimil
+0000a050: 6172 6974 7920 6675 6e63 7469 6f6e 2c0a  arity function,.
+0000a060: 2020 213e 2020 2020 2020 205c 6624 2053    !>       \f$ S
+0000a070: 4d5f 7b6f 6273 7d20 5c66 2420 203d 206f  M_{obs} \f$  = o
+0000a080: 6273 6572 7665 6420 736f 696c 206d 6f69  bserved soil moi
+0000a090: 7374 7572 652c 0a20 2021 3e20 2020 2020  sture,.  !>     
+0000a0a0: 2020 5c66 2420 534d 5f7b 7369 6d7d 2020    \f$ SM_{sim}  
+0000a0b0: 5c66 2420 3d20 7369 6d75 6c61 7465 6420  \f$ = simulated 
+0000a0c0: 736f 696c 206d 6f69 7374 7572 652e 0a20  soil moisture.. 
+0000a0d0: 2021 3e20 2020 2020 2020 5c66 2420 4528   !>       \f$ E(
+0000a0e0: 7429 2020 5c66 2420 2020 2020 3d20 7061  t)  \f$     = pa
+0000a0f0: 7474 6572 6e20 6469 7373 696d 696c 6172  ttern dissimilar
+0000a100: 6974 7920 6174 2074 696d 6573 7465 7020  ity at timestep 
+0000a110: 5c66 2420 7420 5c66 242e 0a20 2021 3e20  \f$ t \f$..  !> 
+0000a120: 2020 2020 2020 5468 6520 7468 6520 7061        The the pa
+0000a130: 7474 6572 6e20 6469 7373 696d 696c 6169  ttern dissimilai
+0000a140: 7479 2028 4529 2069 7320 7370 6174 6961  ty (E) is spatia
+0000a150: 6c6c 7920 6176 6572 6167 6564 2061 730a  lly averaged as.
+0000a160: 2020 213e 2020 2020 2020 205c 665b 205c    !>       \f[ \
+0000a170: 7068 695f 7b69 7d20 3d20 5c66 7261 637b  phi_{i} = \frac{
+0000a180: 317d 7b54 7d20 5c63 646f 7420 5c73 756d  1}{T} \cdot \sum
+0000a190: 5f7b 743d 317d 5e54 2045 5f74 205c 665d  _{t=1}^T E_t \f]
+0000a1a0: 0a20 2021 3e20 2020 2020 2020 7768 6572  .  !>       wher
+0000a1b0: 6520 5c66 2420 5420 5c66 2420 6465 6e6f  e \f$ T \f$ deno
+0000a1c0: 7465 7320 7468 6520 6e75 6d62 6572 206f  tes the number o
+0000a1d0: 6620 7469 6d65 2073 7465 7073 2e0a 2020  f time steps..  
+0000a1e0: 213e 2020 2020 2020 2046 696e 616c 6c79  !>       Finally
+0000a1f0: 2c20 7468 6520 6f76 6572 616c 6c20 6f62  , the overall ob
+0000a200: 6a65 6374 6976 6520 6675 6e63 7469 6f6e  jective function
+0000a210: 2076 616c 7565 205c 6624 204f 4620 5c66   value \f$ OF \f
+0000a220: 2420 6973 2065 7374 696d 6174 6564 2062  $ is estimated b
+0000a230: 6173 6564 206f 6e20 7468 6520 706f 7765  ased on the powe
+0000a240: 722d 360a 2020 213e 2020 2020 2020 206e  r-6.  !>       n
+0000a250: 6f72 6d20 746f 2063 6f6d 6269 6e65 2074  orm to combine t
+0000a260: 6865 205c 6624 205c 7068 695f 7b69 7d20  he \f$ \phi_{i} 
+0000a270: 5c66 2420 6672 6f6d 2061 6c6c 2064 6f6d  \f$ from all dom
+0000a280: 6169 6e73 205c 6624 204e 205c 6624 2e0a  ains \f$ N \f$..
+0000a290: 2020 213e 2020 2020 2020 205c 665b 204f    !>       \f[ O
+0000a2a0: 4620 3d20 5c73 7172 745b 365d 7b5c 7375  F = \sqrt[6]{\su
+0000a2b0: 6d28 2831 2e30 202d 205c 7068 695f 7b69  m((1.0 - \phi_{i
+0000a2c0: 7d29 2f4e 295e 3620 7d20 2e20 5c66 5d0a  })/N)^6 } . \f].
+0000a2d0: 2020 213e 2020 2020 2020 2054 6865 206f    !>       The o
+0000a2e0: 6273 6572 7665 6420 6461 7461 204c 315f  bserved data L1_
+0000a2f0: 736d 2c20 4c31 5f73 6d5f 6d61 736b 2061  sm, L1_sm_mask a
+0000a300: 7265 2067 6c6f 6261 6c20 696e 2074 6869  re global in thi
+0000a310: 7320 6d6f 6475 6c65 2e0a 2020 213e 2020  s module..  !>  
+0000a320: 2020 2020 2054 6865 206f 6273 6572 7665       The observe
+0000a330: 6420 6461 7461 204c 315f 736d 2c20 4c31  d data L1_sm, L1
+0000a340: 5f73 6d5f 6d61 736b 2061 7265 2067 6c6f  _sm_mask are glo
+0000a350: 6261 6c20 696e 2074 6869 7320 6d6f 6475  bal in this modu
+0000a360: 6c65 2e0a 0a20 2021 2020 2020 494e 5445  le...  !    INTE
+0000a370: 4e54 2849 4e29 0a20 2021 3e20 2020 2020  NT(IN).  !>     
+0000a380: 2020 5c70 6172 616d 5b69 6e5d 2022 7265    \param[in] "re
+0000a390: 616c 2864 7029 2c20 6469 6d65 6e73 696f  al(dp), dimensio
+0000a3a0: 6e28 3a29 203a 3a20 7061 7261 6d65 7465  n(:) :: paramete
+0000a3b0: 7273 6574 220a 2020 213e 2020 2020 2020  rset".  !>      
+0000a3c0: 205c 7061 7261 6d5b 696e 5d20 2270 726f   \param[in] "pro
+0000a3d0: 6365 6475 7265 2865 7661 6c5f 696e 7465  cedure(eval_inte
+0000a3e0: 7266 6163 6529 203a 3a20 6576 616c 220a  rface) :: eval".
+0000a3f0: 0a20 2021 2020 2020 5245 5455 524e 0a20  .  !    RETURN. 
+0000a400: 2021 3e20 2020 2020 2020 5c72 6574 7572   !>       \retur
+0000a410: 6e20 7265 616c 2864 7029 203a 3a20 6f62  n real(dp) :: ob
+0000a420: 6a65 6369 7665 5f73 6d5f 7064 2026 6d64  jecive_sm_pd &md
+0000a430: 6173 683b 206f 626a 6563 7469 7665 2066  ash; objective f
+0000a440: 756e 6374 696f 6e20 7661 6c75 650a 2020  unction value.  
+0000a450: 213e 2020 2020 2020 2028 7768 6963 6820  !>       (which 
+0000a460: 7769 6c6c 2062 6520 652e 672e 206d 696e  will be e.g. min
+0000a470: 696d 697a 6564 2062 7920 616e 206f 7074  imized by an opt
+0000a480: 696d 697a 6174 696f 6e20 726f 7574 696e  imization routin
+0000a490: 6520 6c69 6b65 2044 4453 290a 0a20 2021  e like DDS)..  !
+0000a4a0: 2020 2020 4849 5354 4f52 590a 2020 213e      HISTORY.  !>
+0000a4b0: 2020 2020 2020 205c 6175 7468 6f72 7320         \authors 
+0000a4c0: 4d61 7474 6869 6173 205a 696e 6b0a 0a20  Matthias Zink.. 
+0000a4d0: 2021 3e20 2020 2020 2020 5c64 6174 6520   !>       \date 
+0000a4e0: 4d61 7920 3230 3135 0a0a 2020 2120 4d6f  May 2015..  ! Mo
+0000a4f0: 6469 6669 6361 7469 6f6e 733a 0a20 2021  difications:.  !
+0000a500: 2052 6f62 6572 7420 5363 6877 6570 7065   Robert Schweppe
+0000a510: 204a 756e 2032 3031 3820 2d20 7265 6661   Jun 2018 - refa
+0000a520: 6374 6f72 696e 6720 616e 6420 7265 666f  ctoring and refo
+0000a530: 726d 6174 7469 6e67 0a0a 2020 4655 4e43  rmatting..  FUNC
+0000a540: 5449 4f4e 206f 626a 6563 7469 7665 5f73  TION objective_s
+0000a550: 6d5f 7064 2870 6172 616d 6574 6572 7365  m_pd(parameterse
+0000a560: 742c 2065 7661 6c29 0a0a 2020 2020 7573  t, eval)..    us
+0000a570: 6520 6d6f 5f6f 7074 696d 697a 6174 696f  e mo_optimizatio
+0000a580: 6e5f 7479 7065 732c 206f 6e6c 7920 3a20  n_types, only : 
+0000a590: 6f70 7469 6461 7461 5f73 696d 0a20 2020  optidata_sim.   
+0000a5a0: 2075 7365 206d 6f5f 636f 6d6d 6f6e 5f63   use mo_common_c
+0000a5b0: 6f6e 7374 616e 7473 2c20 6f6e 6c79 203a  onstants, only :
+0000a5c0: 206e 6f64 6174 615f 6470 0a20 2020 2075   nodata_dp.    u
+0000a5d0: 7365 206d 6f5f 636f 6d6d 6f6e 5f76 6172  se mo_common_var
+0000a5e0: 6961 626c 6573 2c20 6f6e 6c79 203a 206c  iables, only : l
+0000a5f0: 6576 656c 312c 2064 6f6d 6169 6e4d 6574  evel1, domainMet
+0000a600: 610a 2020 2020 7573 6520 6d6f 5f67 6c6f  a.    use mo_glo
+0000a610: 6261 6c5f 7661 7269 6162 6c65 732c 206f  bal_variables, o
+0000a620: 6e6c 7920 3a20 4c31 5f73 6d4f 6273 0a20  nly : L1_smObs. 
+0000a630: 2020 2075 7365 206d 6f5f 7370 6174 6961     use mo_spatia
+0000a640: 6c73 696d 696c 6172 6974 792c 206f 6e6c  lsimilarity, onl
+0000a650: 7920 3a20 5044 0a20 2020 2075 7365 206d  y : PD.    use m
+0000a660: 6f5f 7374 7269 6e67 5f75 7469 6c73 2c20  o_string_utils, 
+0000a670: 6f6e 6c79 203a 206e 756d 3273 7472 0a0a  only : num2str..
+0000a680: 2020 2020 696d 706c 6963 6974 206e 6f6e      implicit non
+0000a690: 650a 0a20 2020 2072 6561 6c28 6470 292c  e..    real(dp),
+0000a6a0: 2064 696d 656e 7369 6f6e 283a 292c 2069   dimension(:), i
+0000a6b0: 6e74 656e 7428 696e 2920 3a3a 2070 6172  ntent(in) :: par
+0000a6c0: 616d 6574 6572 7365 740a 0a20 2020 2070  ameterset..    p
+0000a6d0: 726f 6365 6475 7265 2865 7661 6c5f 696e  rocedure(eval_in
+0000a6e0: 7465 7266 6163 6529 2c20 494e 5445 4e54  terface), INTENT
+0000a6f0: 2849 4e29 2c20 504f 494e 5445 5220 3a3a  (IN), POINTER ::
+0000a700: 2065 7661 6c0a 0a20 2020 2021 206f 626a   eval..    ! obj
+0000a710: 6563 7469 7665 2066 756e 6374 696f 6e20  ective function 
+0000a720: 7661 6c75 650a 2020 2020 7265 616c 2864  value.    real(d
+0000a730: 7029 203a 3a20 6f62 6a65 6374 6976 655f  p) :: objective_
+0000a740: 736d 5f70 640a 0a20 2020 2021 2064 6f6d  sm_pd..    ! dom
+0000a750: 6169 6e20 6c6f 6f70 2063 6f75 6e74 6572  ain loop counter
+0000a760: 0a20 2020 2069 6e74 6567 6572 2869 3429  .    integer(i4)
+0000a770: 203a 3a20 6944 6f6d 6169 6e0a 0a20 2020   :: iDomain..   
+0000a780: 2021 2074 696d 6520 6c6f 6f70 2063 6f75   ! time loop cou
+0000a790: 6e74 6572 0a20 2020 2069 6e74 6567 6572  nter.    integer
+0000a7a0: 2869 3429 203a 3a20 6954 696d 650a 0a20  (i4) :: iTime.. 
+0000a7b0: 2020 2021 206c 6576 656c 2031 206e 756d     ! level 1 num
+0000a7c0: 6265 7220 6f66 2063 756c 6f6d 6e73 2061  ber of culomns a
+0000a7d0: 6e64 2072 6f77 730a 2020 2020 696e 7465  nd rows.    inte
+0000a7e0: 6765 7228 6934 2920 3a3a 206e 726f 7773  ger(i4) :: nrows
+0000a7f0: 312c 206e 636f 6c73 310a 0a20 2020 2021  1, ncols1..    !
+0000a800: 2066 6f72 2073 6978 7468 2072 6f6f 740a   for sixth root.
+0000a810: 2369 666e 6465 6620 4d50 490a 2020 2020  #ifndef MPI.    
+0000a820: 7265 616c 2864 7029 2c20 7061 7261 6d65  real(dp), parame
+0000a830: 7465 7220 3a3a 206f 6e65 7369 7874 6820  ter :: onesixth 
+0000a840: 3d20 312e 305f 6470 202f 2036 2e30 5f64  = 1.0_dp / 6.0_d
+0000a850: 700a 2365 6e64 6966 0a0a 2020 2020 2120  p.#endif..    ! 
+0000a860: 6d61 7472 6963 6573 206f 6620 534d 2066  matrices of SM f
+0000a870: 726f 6d20 7665 6374 6f72 697a 6564 2061  rom vectorized a
+0000a880: 7272 6179 730a 2020 2020 7265 616c 2864  rrays.    real(d
+0000a890: 7029 2c20 6469 6d65 6e73 696f 6e28 3a2c  p), dimension(:,
+0000a8a0: 203a 292c 2061 6c6c 6f63 6174 6162 6c65   :), allocatable
+0000a8b0: 203a 3a20 6d61 7431 2c20 6d61 7432 0a0a   :: mat1, mat2..
+0000a8c0: 2020 2020 2120 7061 7474 6572 6e20 6469      ! pattern di
+0000a8d0: 7373 696d 696c 6172 6974 7920 2870 6429  ssimilarity (pd)
+0000a8e0: 2061 7420 6576 6572 7920 7469 6d65 2073   at every time s
+0000a8f0: 7465 700a 2020 2020 7265 616c 2864 7029  tep.    real(dp)
+0000a900: 2c20 6469 6d65 6e73 696f 6e28 3a29 2c20  , dimension(:), 
+0000a910: 616c 6c6f 6361 7461 626c 6520 3a3a 2070  allocatable :: p
+0000a920: 645f 7469 6d65 5f73 6572 6965 730a 0a20  d_time_series.. 
+0000a930: 2020 2021 2073 696d 756c 6174 6564 2073     ! simulated s
+0000a940: 6f69 6c20 6d6f 6973 7475 7265 0a20 2020  oil moisture.   
+0000a950: 2074 7970 6528 6f70 7469 6461 7461 5f73   type(optidata_s
+0000a960: 696d 292c 2064 696d 656e 7369 6f6e 283a  im), dimension(:
+0000a970: 292c 2061 6c6c 6f63 6174 6162 6c65 203a  ), allocatable :
+0000a980: 3a20 736d 4f70 7469 5369 6d0a 0a20 2020  : smOptiSim..   
+0000a990: 2021 206d 6173 6b20 6f66 2076 616c 6964   ! mask of valid
+0000a9a0: 2063 656c 6c73 2061 7420 6c65 7665 6c31   cells at level1
+0000a9b0: 0a20 2020 206c 6f67 6963 616c 2c20 6469  .    logical, di
+0000a9c0: 6d65 6e73 696f 6e28 3a2c 203a 292c 2061  mension(:, :), a
+0000a9d0: 6c6c 6f63 6174 6162 6c65 203a 3a20 6d61  llocatable :: ma
+0000a9e0: 736b 310a 0a20 2020 2021 206d 6173 6b20  sk1..    ! mask 
+0000a9f0: 6f66 2076 616c 6964 2073 6d20 6365 6c6c  of valid sm cell
+0000aa00: 730a 2020 2020 6c6f 6769 6361 6c2c 2064  s.    logical, d
+0000aa10: 696d 656e 7369 6f6e 283a 2c20 3a29 2c20  imension(:, :), 
+0000aa20: 616c 6c6f 6361 7461 626c 6520 3a3a 206d  allocatable :: m
+0000aa30: 6173 6b5f 736d 0a0a 2020 2020 2120 6d61  ask_sm..    ! ma
+0000aa40: 736b 2066 6f72 2076 616c 6964 2073 6d20  sk for valid sm 
+0000aa50: 6361 7463 686d 656e 7420 6176 6720 7469  catchment avg ti
+0000aa60: 6d65 2073 7465 7073 0a20 2020 206c 6f67  me steps.    log
+0000aa70: 6963 616c 2c20 6469 6d65 6e73 696f 6e28  ical, dimension(
+0000aa80: 3a29 2c20 616c 6c6f 6361 7461 626c 6520  :), allocatable 
+0000aa90: 3a3a 206d 6173 6b5f 7469 6d65 730a 0a0a  :: mask_times...
+0000aaa0: 2020 2020 616c 6c6f 6361 7465 2873 6d4f      allocate(smO
+0000aab0: 7074 6953 696d 2864 6f6d 6169 6e4d 6574  ptiSim(domainMet
+0000aac0: 6125 6e44 6f6d 6169 6e73 2929 0a20 2020  a%nDomains)).   
+0000aad0: 2063 616c 6c20 6576 616c 2870 6172 616d   call eval(param
+0000aae0: 6574 6572 7365 742c 2073 6d4f 7074 6953  eterset, smOptiS
+0000aaf0: 696d 203d 2073 6d4f 7074 6953 696d 290a  im = smOptiSim).
+0000ab00: 0a20 2020 2021 2069 6e69 7469 616c 697a  .    ! initializ
+0000ab10: 6520 736f 6d65 2076 6172 6961 626c 6573  e some variables
+0000ab20: 0a20 2020 206f 626a 6563 7469 7665 5f73  .    objective_s
+0000ab30: 6d5f 7064 203d 2030 2e30 5f64 700a 0a20  m_pd = 0.0_dp.. 
+0000ab40: 2020 2021 206c 6f6f 7020 6f76 6572 2064     ! loop over d
+0000ab50: 6f6d 6169 6e20 2d20 666f 7220 6170 706c  omain - for appl
+0000ab60: 7969 6e67 2070 6f77 6572 206c 6177 206c  ying power law l
+0000ab70: 6174 6572 206f 6e0a 2020 2020 646f 2069  ater on.    do i
+0000ab80: 446f 6d61 696e 203d 2031 2c20 646f 6d61  Domain = 1, doma
+0000ab90: 696e 4d65 7461 256e 446f 6d61 696e 730a  inMeta%nDomains.
+0000aba0: 0a20 2020 2020 2021 2067 6574 2064 6f6d  .      ! get dom
+0000abb0: 6169 6e20 696e 666f 726d 6174 696f 6e0a  ain information.
+0000abc0: 2020 2020 2020 6d61 736b 3120 3d20 6c65        mask1 = le
+0000abd0: 7665 6c31 2869 446f 6d61 696e 2925 6d61  vel1(iDomain)%ma
+0000abe0: 736b 0a20 2020 2020 206e 636f 6c73 3120  sk.      ncols1 
+0000abf0: 3d20 6c65 7665 6c31 2869 446f 6d61 696e  = level1(iDomain
+0000ac00: 2925 6e63 6f6c 730a 2020 2020 2020 6e72  )%ncols.      nr
+0000ac10: 6f77 7331 203d 206c 6576 656c 3128 6944  ows1 = level1(iD
+0000ac20: 6f6d 6169 6e29 256e 726f 7773 0a0a 2020  omain)%nrows..  
+0000ac30: 2020 2020 2120 616c 6c6f 6361 7465 0a20      ! allocate. 
+0000ac40: 2020 2020 2061 6c6c 6f63 6174 6528 6d61       allocate(ma
+0000ac50: 736b 5f74 696d 6573 2020 2020 2873 697a  sk_times    (siz
+0000ac60: 6528 736d 4f70 7469 5369 6d28 6944 6f6d  e(smOptiSim(iDom
+0000ac70: 6169 6e29 2564 6174 6153 696d 2c20 6469  ain)%dataSim, di
+0000ac80: 6d20 3d20 3229 2929 0a20 2020 2020 2061  m = 2))).      a
+0000ac90: 6c6c 6f63 6174 6528 7064 5f74 696d 655f  llocate(pd_time_
+0000aca0: 7365 7269 6573 2873 697a 6528 736d 4f70  series(size(smOp
+0000acb0: 7469 5369 6d28 6944 6f6d 6169 6e29 2564  tiSim(iDomain)%d
+0000acc0: 6174 6153 696d 2c20 6469 6d20 3d20 3229  ataSim, dim = 2)
+0000acd0: 2929 0a20 2020 2020 2061 6c6c 6f63 6174  )).      allocat
+0000ace0: 6528 6d61 7431 2020 2028 6e72 6f77 7331  e(mat1   (nrows1
+0000acf0: 2c20 6e63 6f6c 7331 2929 0a20 2020 2020  , ncols1)).     
+0000ad00: 2061 6c6c 6f63 6174 6528 6d61 7432 2020   allocate(mat2  
+0000ad10: 2028 6e72 6f77 7331 2c20 6e63 6f6c 7331   (nrows1, ncols1
+0000ad20: 2929 0a20 2020 2020 2061 6c6c 6f63 6174  )).      allocat
+0000ad30: 6528 6d61 736b 5f73 6d28 6e72 6f77 7331  e(mask_sm(nrows1
+0000ad40: 2c20 6e63 6f6c 7331 2929 0a0a 2020 2020  , ncols1))..    
+0000ad50: 2020 2120 696e 6974 616c 697a 650a 2020    ! initalize.  
+0000ad60: 2020 2020 6d61 736b 5f74 696d 6573 203d      mask_times =
+0000ad70: 202e 4641 4c53 452e 0a20 2020 2020 2070   .FALSE..      p
+0000ad80: 645f 7469 6d65 5f73 6572 6965 7320 3d20  d_time_series = 
+0000ad90: 302e 305f 6470 0a0a 2020 2020 2020 2120  0.0_dp..      ! 
+0000ada0: 6361 6c63 756c 6174 6520 7061 7474 6572  calculate patter
+0000adb0: 6e20 7369 6d69 6c61 7269 7479 2063 7269  n similarity cri
+0000adc0: 7465 7269 6f6e 0a20 2020 2020 2064 6f20  terion.      do 
+0000add0: 6954 696d 6520 3d20 312c 2073 697a 6528  iTime = 1, size(
+0000ade0: 736d 4f70 7469 5369 6d28 6944 6f6d 6169  smOptiSim(iDomai
+0000adf0: 6e29 2564 6174 6153 696d 2c20 6469 6d20  n)%dataSim, dim 
+0000ae00: 3d20 3229 0a20 2020 2020 2020 206d 6174  = 2).        mat
+0000ae10: 3120 3d20 756e 7061 636b 284c 315f 736d  1 = unpack(L1_sm
+0000ae20: 4f62 7328 6944 6f6d 6169 6e29 2564 6174  Obs(iDomain)%dat
+0000ae30: 614f 6273 283a 2c20 6954 696d 6529 2c20  aObs(:, iTime), 
+0000ae40: 6d61 736b 312c 206e 6f64 6174 615f 6470  mask1, nodata_dp
+0000ae50: 290a 2020 2020 2020 2020 6d61 7432 203d  ).        mat2 =
+0000ae60: 2075 6e70 6163 6b28 736d 4f70 7469 5369   unpack(smOptiSi
+0000ae70: 6d28 6944 6f6d 6169 6e29 2564 6174 6153  m(iDomain)%dataS
+0000ae80: 696d 283a 2c20 6954 696d 6529 2c20 6d61  im(:, iTime), ma
+0000ae90: 736b 312c 206e 6f64 6174 615f 6470 290a  sk1, nodata_dp).
+0000aea0: 2020 2020 2020 2020 6d61 736b 5f73 6d20          mask_sm 
+0000aeb0: 3d20 756e 7061 636b 284c 315f 736d 4f62  = unpack(L1_smOb
+0000aec0: 7328 6944 6f6d 6169 6e29 256d 6173 6b4f  s(iDomain)%maskO
+0000aed0: 6273 283a 2c20 6954 696d 6529 2c20 6d61  bs(:, iTime), ma
+0000aee0: 736b 312c 202e 4641 4c53 452e 290a 2020  sk1, .FALSE.).  
+0000aef0: 2020 2020 2020 7064 5f74 696d 655f 7365        pd_time_se
+0000af00: 7269 6573 203d 2050 4428 6d61 7431 2c20  ries = PD(mat1, 
+0000af10: 6d61 7432 2c20 6d61 736b 203d 206d 6173  mat2, mask = mas
+0000af20: 6b5f 736d 2c20 7661 6c69 6420 3d20 6d61  k_sm, valid = ma
+0000af30: 736b 5f74 696d 6573 2869 7469 6d65 2929  sk_times(itime))
+0000af40: 0a20 2020 2020 2065 6e64 2064 6f0a 0a20  .      end do.. 
+0000af50: 2020 2020 2069 6620 2863 6f75 6e74 286d       if (count(m
+0000af60: 6173 6b5f 7469 6d65 7329 203e 2030 5f69  ask_times) > 0_i
+0000af70: 3429 2074 6865 6e0a 2020 2020 2020 2020  4) then.        
+0000af80: 2120 6361 6c63 756c 6174 6520 6176 6572  ! calculate aver
+0000af90: 6761 6520 5044 206f 7665 7220 616c 6c20  gae PD over all 
+0000afa0: 646f 6d61 696e 7320 7769 7468 2070 6f77  domains with pow
+0000afb0: 6572 206c 6177 202d 646f 6d61 696e 7320  er law -domains 
+0000afc0: 6172 6520 7765 6967 6874 6564 2065 7175  are weighted equ
+0000afd0: 616c 6c79 2028 2031 202f 2072 6561 6c28  ally ( 1 / real(
+0000afe0: 646f 6d61 696e 4d65 7461 256f 7665 7261  domainMeta%overa
+0000aff0: 6c6c 4e75 6d62 6572 4f66 446f 6d61 696e  llNumberOfDomain
+0000b000: 732c 6470 2929 2a2a 360a 2020 2020 2020  s,dp))**6.      
+0000b010: 2020 6f62 6a65 6374 6976 655f 736d 5f70    objective_sm_p
+0000b020: 6420 3d20 6f62 6a65 6374 6976 655f 736d  d = objective_sm
+0000b030: 5f70 6420 2b20 260a 2020 2020 2020 2020  _pd + &.        
+0000b040: 2020 2020 2020 2020 2828 312e 305f 6470          ((1.0_dp
+0000b050: 202d 2073 756d 2870 645f 7469 6d65 5f73   - sum(pd_time_s
+0000b060: 6572 6965 732c 206d 6173 6b20 3d20 6d61  eries, mask = ma
+0000b070: 736b 5f74 696d 6573 2920 2f20 7265 616c  sk_times) / real
+0000b080: 2863 6f75 6e74 286d 6173 6b5f 7469 6d65  (count(mask_time
+0000b090: 7329 2c20 6470 2929 202f 2026 0a20 2020  s), dp)) / &.   
+0000b0a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b0b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b0c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b0d0: 2072 6561 6c28 646f 6d61 696e 4d65 7461   real(domainMeta
+0000b0e0: 256f 7665 7261 6c6c 4e75 6d62 6572 4f66  %overallNumberOf
+0000b0f0: 446f 6d61 696e 732c 2064 7029 292a 2a36  Domains, dp))**6
+0000b100: 0a20 2020 2020 2065 6c73 650a 2020 2020  .      else.    
+0000b110: 2020 2020 6361 6c6c 2065 7272 6f72 5f6d      call error_m
+0000b120: 6573 7361 6765 2827 2a2a 2a45 5252 4f52  essage('***ERROR
+0000b130: 3a20 6d6f 5f6f 626a 6563 7469 7665 5f66  : mo_objective_f
+0000b140: 756e 7469 6f6e 3a20 6f62 6a65 6374 6976  untion: objectiv
+0000b150: 655f 736d 5f70 643a 204e 6f20 736f 696c  e_sm_pd: No soil
+0000b160: 206d 6f69 7374 7572 6520 6f62 7365 7276   moisture observ
+0000b170: 6174 696f 6e73 2061 7661 696c 6162 6c65  ations available
+0000b180: 2127 290a 2020 2020 2020 656e 6420 6966  !').      end if
+0000b190: 0a0a 2020 2020 2020 2120 6465 616c 6c6f  ..      ! deallo
+0000b1a0: 6361 7465 0a20 2020 2020 2064 6561 6c6c  cate.      deall
+0000b1b0: 6f63 6174 6528 6d61 736b 5f74 696d 6573  ocate(mask_times
+0000b1c0: 290a 2020 2020 2020 6465 616c 6c6f 6361  ).      dealloca
+0000b1d0: 7465 2870 645f 7469 6d65 5f73 6572 6965  te(pd_time_serie
+0000b1e0: 7329 0a20 2020 2020 2064 6561 6c6c 6f63  s).      dealloc
+0000b1f0: 6174 6528 6d61 7431 290a 2020 2020 2020  ate(mat1).      
+0000b200: 6465 616c 6c6f 6361 7465 286d 6174 3229  deallocate(mat2)
+0000b210: 0a20 2020 2020 2064 6561 6c6c 6f63 6174  .      deallocat
+0000b220: 6528 6d61 736b 5f73 6d29 0a20 2020 2020  e(mask_sm).     
+0000b230: 2063 616c 6c20 736d 4f70 7469 5369 6d28   call smOptiSim(
+0000b240: 6944 6f6d 6169 6e29 2564 6573 7472 6f79  iDomain)%destroy
+0000b250: 2829 0a20 2020 2065 6e64 2064 6f0a 2020  ().    end do.  
+0000b260: 2020 6465 616c 6c6f 6361 7465 2873 6d4f    deallocate(smO
+0000b270: 7074 6953 696d 290a 0a23 6966 6e64 6566  ptiSim)..#ifndef
+0000b280: 204d 5049 0a20 2020 206f 626a 6563 7469   MPI.    objecti
+0000b290: 7665 5f73 6d5f 7064 203d 206f 626a 6563  ve_sm_pd = objec
+0000b2a0: 7469 7665 5f73 6d5f 7064 2a2a 6f6e 6573  tive_sm_pd**ones
+0000b2b0: 6978 7468 0a0a 2020 2020 6361 6c6c 206d  ixth..    call m
+0000b2c0: 6573 7361 6765 2827 2020 2020 6f62 6a65  essage('    obje
+0000b2d0: 6374 6976 655f 736d 5f70 6420 3d20 272c  ctive_sm_pd = ',
+0000b2e0: 206e 756d 3273 7472 286f 626a 6563 7469   num2str(objecti
+0000b2f0: 7665 5f73 6d5f 7064 2c20 2728 4639 2e35  ve_sm_pd, '(F9.5
+0000b300: 2927 2929 0a23 656e 6469 660a 0a20 2045  )')).#endif..  E
+0000b310: 4e44 2046 554e 4354 494f 4e20 6f62 6a65  ND FUNCTION obje
+0000b320: 6374 6976 655f 736d 5f70 640a 0a20 2021  ctive_sm_pd..  !
+0000b330: 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d   ---------------
+0000b340: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+0000b350: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+0000b360: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+0000b370: 2d2d 2d0a 0a20 2021 2020 2020 4e41 4d45  ---..  !    NAME
+0000b380: 0a20 2021 2020 2020 2020 2020 6f62 6a65  .  !        obje
+0000b390: 6374 6976 655f 736d 5f73 7365 5f73 7461  ctive_sm_sse_sta
+0000b3a0: 6e64 6172 645f 7363 6f72 650a 0a20 2021  ndard_score..  !
+0000b3b0: 2020 2020 5055 5250 4f53 450a 2020 213e      PURPOSE.  !>
+0000b3c0: 2020 2020 2020 205c 6272 6965 6620 4f62         \brief Ob
+0000b3d0: 6a65 6374 6976 6520 6675 6e63 7469 6f6e  jective function
+0000b3e0: 2066 6f72 2073 6f69 6c20 6d6f 6973 7475   for soil moistu
+0000b3f0: 7265 2e0a 0a20 2021 3e20 2020 2020 2020  re...  !>       
+0000b400: 5c64 6574 6169 6c73 2054 6865 206f 626a  \details The obj
+0000b410: 6563 7469 7665 2066 756e 6374 696f 6e20  ective function 
+0000b420: 6f6e 6c79 2064 6570 656e 6473 206f 6e20  only depends on 
+0000b430: 6120 7061 7261 6d65 7465 7220 7665 6374  a parameter vect
+0000b440: 6f72 2e0a 2020 213e 2020 2020 2020 2054  or..  !>       T
+0000b450: 6865 206d 6f64 656c 2077 696c 6c20 6265  he model will be
+0000b460: 2063 616c 6c65 6420 7769 7468 2074 6861   called with tha
+0000b470: 7420 7061 7261 6d65 7465 7220 7665 6374  t parameter vect
+0000b480: 6f72 2061 6e64 0a20 2021 3e20 2020 2020  or and.  !>     
+0000b490: 2020 7468 6520 6d6f 6465 6c20 6f75 7470    the model outp
+0000b4a0: 7574 2069 7320 7375 6273 6571 7565 6e74  ut is subsequent
+0000b4b0: 6c79 2063 6f6d 7061 7265 6420 746f 206f  ly compared to o
+0000b4c0: 6273 6572 7665 6420 6461 7461 2e0a 0a20  bserved data... 
+0000b4d0: 2021 3e20 2020 2020 2020 5468 6572 6566   !>       Theref
+0000b4e0: 6f72 6520 7468 6520 7375 6d20 6f66 2073  ore the sum of s
+0000b4f0: 7175 6172 6564 2065 7272 6f72 7320 2853  quared errors (S
+0000b500: 5345 2920 6f66 2074 6865 2073 7461 6e64  SE) of the stand
+0000b510: 6172 6420 7363 6f72 6520 6f66 206f 6273  ard score of obs
+0000b520: 6572 7665 6420 616e 640a 2020 213e 2020  erved and.  !>  
+0000b530: 2020 2020 206d 6f64 656c 6564 2073 6f69       modeled soi
+0000b540: 6c20 6d6f 6973 7475 7265 2069 7320 6361  l moisture is ca
+0000b550: 6c63 756c 6174 6564 2e20 5468 6520 7374  lculated. The st
+0000b560: 616e 6461 7264 2073 636f 7265 206f 7220  andard score or 
+0000b570: 6e6f 726d 616c 697a 6174 696f 6e20 2861  normalization (a
+0000b580: 6e6f 6d61 6c79 290a 2020 213e 2020 2020  nomaly).  !>    
+0000b590: 2020 206d 616b 6520 7468 6520 6f62 6a63     make the objc
+0000b5a0: 7469 7665 2066 756e 6374 696f 6e20 6269  tive function bi
+0000b5b0: 6173 2069 6e73 656e 7369 7469 7665 2061  as insensitive a
+0000b5c0: 6e64 2062 6173 6963 616c 6c79 2074 6865  nd basically the
+0000b5d0: 2064 796e 616d 6963 7320 6f66 2074 6865   dynamics of the
+0000b5e0: 2073 6f69 6c20 6d6f 6973 7475 7265 0a20   soil moisture. 
+0000b5f0: 2021 3e20 2020 2020 2020 6973 2074 7269   !>       is tri
+0000b600: 6564 2074 6f20 6361 7074 7572 6520 6279  ed to capture by
+0000b610: 2074 6869 7320 6f62 656a 6563 7469 7665   this obejective
+0000b620: 2066 756e 6374 696f 6e2e 0a20 2021 3e20   function..  !> 
+0000b630: 2020 2020 2020 5c66 5b20 7068 695f 6920        \f[ phi_i 
+0000b640: 3d20 5c73 756d 5f7b 6a3d 317d 5e4b 205c  = \sum_{j=1}^K \
+0000b650: 7b20 7374 616e 6461 7264 5c5f 7363 6f72  { standard\_scor
+0000b660: 6528 2053 4d5f 7b6f 6273 7d28 6a29 2029  e( SM_{obs}(j) )
+0000b670: 2d20 7374 616e 6461 7264 5c5f 7363 6f72  - standard\_scor
+0000b680: 6528 534d 5f7b 7369 6d7d 286a 2929 205c  e(SM_{sim}(j)) \
+0000b690: 7d5e 3220 5c66 5d0a 2020 213e 2020 2020  }^2 \f].  !>    
+0000b6a0: 2020 2077 6865 7265 0a20 2021 3e20 2020     where.  !>   
+0000b6b0: 2020 2020 5c66 2420 2073 7461 6e64 6172      \f$  standar
+0000b6c0: 645c 5f73 636f 7265 205c 6624 203d 2073  d\_score \f$ = s
+0000b6d0: 7461 6e64 6172 6420 7363 6f72 6520 6675  tandard score fu
+0000b6e0: 6e63 7469 6f6e 2c0a 2020 213e 2020 2020  nction,.  !>    
+0000b6f0: 2020 205c 6624 2053 4d5f 7b6f 6273 7d20     \f$ SM_{obs} 
+0000b700: 5c66 2420 203d 206f 6273 6572 7665 6420  \f$  = observed 
+0000b710: 736f 696c 206d 6f69 7374 7572 652c 0a20  soil moisture,. 
+0000b720: 2021 3e20 2020 2020 2020 5c66 2420 534d   !>       \f$ SM
+0000b730: 5f7b 7369 6d7d 2020 5c66 2420 3d20 7369  _{sim}  \f$ = si
+0000b740: 6d75 6c61 7465 6420 736f 696c 206d 6f69  mulated soil moi
+0000b750: 7374 7572 652e 0a20 2021 3e20 2020 2020  sture..  !>     
+0000b760: 2020 5c66 2420 4b20 205c 6624 203d 2076    \f$ K  \f$ = v
+0000b770: 616c 6964 2065 6c65 6d65 6e74 7320 696e  alid elements in
+0000b780: 2073 7475 6479 2064 6f6d 6169 6e2e 0a20   study domain.. 
+0000b790: 2021 3e20 2020 2020 2020 4669 6e61 6c6c   !>       Finall
+0000b7a0: 792c 2074 6865 206f 7665 7261 6c6c 206f  y, the overall o
+0000b7b0: 626a 6563 7469 7665 2066 756e 6374 696f  bjective functio
+0000b7c0: 6e20 7661 6c75 6520 5c66 2420 4f46 205c  n value \f$ OF \
+0000b7d0: 6624 2069 7320 6573 7469 6d61 7465 6420  f$ is estimated 
+0000b7e0: 6261 7365 6420 6f6e 2074 6865 2070 6f77  based on the pow
+0000b7f0: 6572 2d36 0a20 2021 3e20 2020 2020 2020  er-6.  !>       
+0000b800: 6e6f 726d 2074 6f20 636f 6d62 696e 6520  norm to combine 
+0000b810: 7468 6520 5c66 2420 5c70 6869 5f7b 697d  the \f$ \phi_{i}
+0000b820: 205c 6624 2066 726f 6d20 616c 6c20 646f   \f$ from all do
+0000b830: 6d61 696e 7320 5c66 2420 4e20 5c66 242e  mains \f$ N \f$.
+0000b840: 0a20 2021 3e20 2020 2020 2020 5c66 5b20  .  !>       \f[ 
+0000b850: 4f46 203d 205c 7371 7274 5b36 5d7b 5c73  OF = \sqrt[6]{\s
+0000b860: 756d 285c 7068 695f 7b69 7d2f 4e29 5e36  um(\phi_{i}/N)^6
+0000b870: 207d 2e20 205c 665d 0a20 2021 3e20 2020   }.  \f].  !>   
+0000b880: 2020 2020 5468 6520 6f62 7365 7276 6564      The observed
+0000b890: 2064 6174 6120 4c31 5f73 6d2c 204c 315f   data L1_sm, L1_
+0000b8a0: 736d 5f6d 6173 6b20 6172 6520 676c 6f62  sm_mask are glob
+0000b8b0: 616c 2069 6e20 7468 6973 206d 6f64 756c  al in this modul
+0000b8c0: 652e 0a0a 2020 2120 2020 2049 4e54 454e  e...  !    INTEN
+0000b8d0: 5428 494e 290a 2020 213e 2020 2020 2020  T(IN).  !>      
+0000b8e0: 205c 7061 7261 6d5b 696e 5d20 2272 6561   \param[in] "rea
+0000b8f0: 6c28 6470 292c 2064 696d 656e 7369 6f6e  l(dp), dimension
+0000b900: 283a 2920 3a3a 2070 6172 616d 6574 6572  (:) :: parameter
+0000b910: 7365 7422 0a20 2021 3e20 2020 2020 2020  set".  !>       
+0000b920: 5c70 6172 616d 5b69 6e5d 2022 7072 6f63  \param[in] "proc
+0000b930: 6564 7572 6528 6576 616c 5f69 6e74 6572  edure(eval_inter
+0000b940: 6661 6365 2920 3a3a 2065 7661 6c22 0a0a  face) :: eval"..
+0000b950: 2020 2120 2020 2052 4554 5552 4e0a 2020    !    RETURN.  
+0000b960: 213e 2020 2020 2020 205c 7265 7475 726e  !>       \return
+0000b970: 2072 6561 6c28 6470 2920 3a3a 206f 626a   real(dp) :: obj
+0000b980: 6563 7469 7665 5f73 6d5f 7373 655f 7374  ective_sm_sse_st
+0000b990: 616e 6461 7264 5f73 636f 7265 2026 6d64  andard_score &md
+0000b9a0: 6173 683b 206f 626a 6563 7469 7665 2066  ash; objective f
+0000b9b0: 756e 6374 696f 6e20 7661 6c75 650a 2020  unction value.  
+0000b9c0: 213e 2020 2020 2020 2028 7768 6963 6820  !>       (which 
+0000b9d0: 7769 6c6c 2062 6520 652e 672e 206d 696e  will be e.g. min
+0000b9e0: 696d 697a 6564 2062 7920 616e 206f 7074  imized by an opt
+0000b9f0: 696d 697a 6174 696f 6e20 726f 7574 696e  imization routin
+0000ba00: 6520 6c69 6b65 2044 4453 290a 0a20 2021  e like DDS)..  !
+0000ba10: 2020 2020 4849 5354 4f52 590a 2020 213e      HISTORY.  !>
+0000ba20: 2020 2020 2020 205c 6175 7468 6f72 7320         \authors 
+0000ba30: 4d61 7474 6869 6173 205a 696e 6b0a 0a20  Matthias Zink.. 
+0000ba40: 2021 3e20 2020 2020 2020 5c64 6174 6520   !>       \date 
+0000ba50: 4d61 7263 6820 3230 3135 0a0a 2020 2120  March 2015..  ! 
+0000ba60: 4d6f 6469 6669 6361 7469 6f6e 733a 0a20  Modifications:. 
+0000ba70: 2021 2052 6f62 6572 7420 5363 6877 6570   ! Robert Schwep
+0000ba80: 7065 204a 756e 2032 3031 3820 2d20 7265  pe Jun 2018 - re
+0000ba90: 6661 6374 6f72 696e 6720 616e 6420 7265  factoring and re
+0000baa0: 666f 726d 6174 7469 6e67 0a0a 2020 4655  formatting..  FU
+0000bab0: 4e43 5449 4f4e 206f 626a 6563 7469 7665  NCTION objective
+0000bac0: 5f73 6d5f 7373 655f 7374 616e 6461 7264  _sm_sse_standard
+0000bad0: 5f73 636f 7265 2870 6172 616d 6574 6572  _score(parameter
+0000bae0: 7365 742c 2065 7661 6c29 0a0a 2020 2020  set, eval)..    
+0000baf0: 7573 6520 6d6f 5f6f 7074 696d 697a 6174  use mo_optimizat
+0000bb00: 696f 6e5f 7479 7065 732c 206f 6e6c 7920  ion_types, only 
+0000bb10: 3a20 6f70 7469 6461 7461 5f73 696d 0a20  : optidata_sim. 
+0000bb20: 2020 2075 7365 206d 6f5f 636f 6d6d 6f6e     use mo_common
+0000bb30: 5f76 6172 6961 626c 6573 2c20 6f6e 6c79  _variables, only
+0000bb40: 203a 206c 6576 656c 312c 2064 6f6d 6169   : level1, domai
+0000bb50: 6e4d 6574 610a 2020 2020 7573 6520 6d6f  nMeta.    use mo
+0000bb60: 5f65 7272 6f72 6d65 6173 7572 6573 2c20  _errormeasures, 
+0000bb70: 6f6e 6c79 203a 2053 5345 0a20 2020 2075  only : SSE.    u
+0000bb80: 7365 206d 6f5f 676c 6f62 616c 5f76 6172  se mo_global_var
+0000bb90: 6961 626c 6573 2c20 6f6e 6c79 203a 204c  iables, only : L
+0000bba0: 315f 736d 4f62 730a 2020 2020 7573 6520  1_smObs.    use 
+0000bbb0: 6d6f 5f73 7461 6e64 6172 645f 7363 6f72  mo_standard_scor
+0000bbc0: 652c 206f 6e6c 7920 3a20 7374 616e 6461  e, only : standa
+0000bbd0: 7264 5f73 636f 7265 0a20 2020 2075 7365  rd_score.    use
+0000bbe0: 206d 6f5f 7374 7269 6e67 5f75 7469 6c73   mo_string_utils
+0000bbf0: 2c20 6f6e 6c79 203a 206e 756d 3273 7472  , only : num2str
+0000bc00: 0a0a 2020 2020 696d 706c 6963 6974 206e  ..    implicit n
+0000bc10: 6f6e 650a 0a20 2020 2072 6561 6c28 6470  one..    real(dp
+0000bc20: 292c 2064 696d 656e 7369 6f6e 283a 292c  ), dimension(:),
+0000bc30: 2069 6e74 656e 7428 696e 2920 3a3a 2070   intent(in) :: p
+0000bc40: 6172 616d 6574 6572 7365 740a 0a20 2020  arameterset..   
+0000bc50: 2070 726f 6365 6475 7265 2865 7661 6c5f   procedure(eval_
+0000bc60: 696e 7465 7266 6163 6529 2c20 494e 5445  interface), INTE
+0000bc70: 4e54 2849 4e29 2c20 504f 494e 5445 5220  NT(IN), POINTER 
+0000bc80: 3a3a 2065 7661 6c0a 0a20 2020 2072 6561  :: eval..    rea
+0000bc90: 6c28 6470 2920 3a3a 206f 626a 6563 7469  l(dp) :: objecti
+0000bca0: 7665 5f73 6d5f 7373 655f 7374 616e 6461  ve_sm_sse_standa
+0000bcb0: 7264 5f73 636f 7265 0a0a 2020 2020 2120  rd_score..    ! 
+0000bcc0: 646f 6d61 696e 206c 6f6f 7020 636f 756e  domain loop coun
+0000bcd0: 7465 720a 2020 2020 696e 7465 6765 7228  ter.    integer(
+0000bce0: 6934 2920 3a3a 2069 446f 6d61 696e 0a0a  i4) :: iDomain..
+0000bcf0: 2020 2020 2120 6365 6c6c 206c 6f6f 7020      ! cell loop 
+0000bd00: 636f 756e 7465 720a 2020 2020 696e 7465  counter.    inte
+0000bd10: 6765 7228 6934 2920 3a3a 2069 4365 6c6c  ger(i4) :: iCell
+0000bd20: 0a0a 2020 2020 2120 6e63 656c 6c73 3120  ..    ! ncells1 
+0000bd30: 6f66 206c 6576 656c 2031 0a20 2020 2069  of level 1.    i
+0000bd40: 6e74 6567 6572 2869 3429 203a 3a20 6e63  nteger(i4) :: nc
+0000bd50: 656c 6c73 310a 0a20 2020 2021 206e 756d  ells1..    ! num
+0000bd60: 6265 7220 6f66 2069 6e76 616c 6964 2063  ber of invalid c
+0000bd70: 656c 6c73 2069 6e20 6361 7463 686d 656e  ells in catchmen
+0000bd80: 740a 2020 2020 7265 616c 2864 7029 203a  t.    real(dp) :
+0000bd90: 3a20 696e 7661 6c69 645f 6365 6c6c 730a  : invalid_cells.
+0000bda0: 0a20 2020 2021 2064 6f6d 6169 6e73 2077  .    ! domains w
+0000bdb0: 6973 6520 6f62 6a65 6374 6976 6573 0a20  ise objectives. 
+0000bdc0: 2020 2072 6561 6c28 6470 2920 3a3a 206f     real(dp) :: o
+0000bdd0: 626a 6563 7469 7665 5f73 6d5f 7373 655f  bjective_sm_sse_
+0000bde0: 7374 616e 6461 7264 5f73 636f 7265 5f64  standard_score_d
+0000bdf0: 6f6d 6169 6e0a 0a23 6966 6e64 6566 204d  omain..#ifndef M
+0000be00: 5049 0a20 2020 2072 6561 6c28 6470 292c  PI.    real(dp),
+0000be10: 2070 6172 616d 6574 6572 203a 3a20 6f6e   parameter :: on
+0000be20: 6573 6978 7468 203d 2031 2e30 5f64 7020  esixth = 1.0_dp 
+0000be30: 2f20 362e 305f 6470 0a23 656e 6469 660a  / 6.0_dp.#endif.
+0000be40: 0a20 2020 2021 2073 696d 756c 6174 6564  .    ! simulated
+0000be50: 2073 6f69 6c20 6d6f 6973 7475 7265 0a20   soil moisture. 
+0000be60: 2020 2074 7970 6528 6f70 7469 6461 7461     type(optidata
+0000be70: 5f73 696d 292c 2064 696d 656e 7369 6f6e  _sim), dimension
+0000be80: 283a 292c 2061 6c6c 6f63 6174 6162 6c65  (:), allocatable
+0000be90: 203a 3a20 736d 4f70 7469 5369 6d0a 0a0a   :: smOptiSim...
+0000bea0: 2020 2020 6361 6c6c 2065 7661 6c28 7061      call eval(pa
+0000beb0: 7261 6d65 7465 7273 6574 2c20 736d 4f70  rameterset, smOp
+0000bec0: 7469 5369 6d20 3d20 736d 4f70 7469 5369  tiSim = smOptiSi
+0000bed0: 6d29 0a0a 2020 2020 2120 696e 6974 6961  m)..    ! initia
+0000bee0: 6c69 7a65 2073 6f6d 6520 7661 7269 6162  lize some variab
+0000bef0: 6c65 730a 2020 2020 6f62 6a65 6374 6976  les.    objectiv
+0000bf00: 655f 736d 5f73 7365 5f73 7461 6e64 6172  e_sm_sse_standar
+0000bf10: 645f 7363 6f72 6520 3d20 302e 305f 6470  d_score = 0.0_dp
+0000bf20: 0a0a 2020 2020 2120 6c6f 6f70 206f 7665  ..    ! loop ove
+0000bf30: 7220 646f 6d61 696e 202d 2066 6f72 2061  r domain - for a
+0000bf40: 7070 6c79 696e 6720 706f 7765 7220 6c61  pplying power la
+0000bf50: 7720 6c61 7465 7220 6f6e 0a20 2020 2064  w later on.    d
+0000bf60: 6f20 6944 6f6d 6169 6e20 3d20 312c 2064  o iDomain = 1, d
+0000bf70: 6f6d 6169 6e4d 6574 6125 6e44 6f6d 6169  omainMeta%nDomai
+0000bf80: 6e73 0a0a 2020 2020 2020 2120 696e 6974  ns..      ! init
+0000bf90: 0a20 2020 2020 206f 626a 6563 7469 7665  .      objective
+0000bfa0: 5f73 6d5f 7373 655f 7374 616e 6461 7264  _sm_sse_standard
+0000bfb0: 5f73 636f 7265 5f64 6f6d 6169 6e20 3d20  _score_domain = 
+0000bfc0: 302e 305f 6470 0a20 2020 2020 2021 2067  0.0_dp.      ! g
+0000bfd0: 6574 2064 6f6d 6169 6e20 696e 666f 726d  et domain inform
+0000bfe0: 6174 696f 6e0a 2020 2020 2020 6e43 656c  ation.      nCel
+0000bff0: 6c73 3120 3d20 6c65 7665 6c31 2869 446f  ls1 = level1(iDo
+0000c000: 6d61 696e 2925 6e43 656c 6c73 0a0a 2020  main)%nCells..  
+0000c010: 2020 2020 696e 7661 6c69 645f 6365 6c6c      invalid_cell
+0000c020: 7320 3d20 302e 305f 6470 0a20 2020 2020  s = 0.0_dp.     
+0000c030: 2021 2073 7461 6e64 6172 645f 7363 6f72   ! standard_scor
+0000c040: 6520 7369 676e 616c 2069 7320 6361 6c63  e signal is calc
+0000c050: 756c 6174 6564 206f 6e20 696e 6469 7669  ulated on indivi
+0000c060: 6475 616c 2067 7269 6420 6365 6c6c 730a  dual grid cells.
+0000c070: 2020 2020 2020 646f 2069 4365 6c6c 203d        do iCell =
+0000c080: 2031 2c20 7369 7a65 284c 315f 736d 4f62   1, size(L1_smOb
+0000c090: 7328 6944 6f6d 6169 6e29 256d 6173 6b4f  s(iDomain)%maskO
+0000c0a0: 6273 283a 2c20 3a29 2c20 6469 6d20 3d20  bs(:, :), dim = 
+0000c0b0: 3129 0a0a 2020 2020 2020 2020 2120 6368  1)..        ! ch
+0000c0c0: 6563 6b20 666f 7220 656e 6f75 6768 2064  eck for enough d
+0000c0d0: 6174 6120 706f 696e 7473 2069 6e20 7469  ata points in ti
+0000c0e0: 6d65 2066 6f72 2073 7461 7469 7374 6963  me for statistic
+0000c0f0: 616c 2063 616c 6375 6c61 7469 6f6e 7320  al calculations 
+0000c100: 2865 2e67 2e20 6d65 616e 2c20 7374 6464  (e.g. mean, stdd
+0000c110: 6576 290a 2020 2020 2020 2020 6966 2028  ev).        if (
+0000c120: 636f 756e 7428 4c31 5f73 6d4f 6273 2869  count(L1_smObs(i
+0000c130: 446f 6d61 696e 2925 6d61 736b 4f62 7328  Domain)%maskObs(
+0000c140: 6943 656c 6c2c 203a 2929 202e 4c45 2e20  iCell, :)) .LE. 
+0000c150: 2830 2e31 305f 6470 202a 2072 6561 6c28  (0.10_dp * real(
+0000c160: 7369 7a65 284c 315f 736d 4f62 7328 6944  size(L1_smObs(iD
+0000c170: 6f6d 6169 6e29 2564 6174 614f 6273 2c20  omain)%dataObs, 
+0000c180: 6469 6d20 3d20 3229 2c20 6470 2929 2920  dim = 2), dp))) 
+0000c190: 7468 656e 0a20 2020 2020 2020 2020 2069  then.          i
+0000c1a0: 6e76 616c 6964 5f63 656c 6c73 203d 2069  nvalid_cells = i
+0000c1b0: 6e76 616c 6964 5f63 656c 6c73 202b 2031  nvalid_cells + 1
+0000c1c0: 2e30 5f64 700a 2020 2020 2020 2020 2020  .0_dp.          
+0000c1d0: 6379 636c 650a 2020 2020 2020 2020 656e  cycle.        en
+0000c1e0: 6420 6966 0a20 2020 2020 2020 206f 626a  d if.        obj
+0000c1f0: 6563 7469 7665 5f73 6d5f 7373 655f 7374  ective_sm_sse_st
+0000c200: 616e 6461 7264 5f73 636f 7265 5f64 6f6d  andard_score_dom
+0000c210: 6169 6e20 3d20 6f62 6a65 6374 6976 655f  ain = objective_
+0000c220: 736d 5f73 7365 5f73 7461 6e64 6172 645f  sm_sse_standard_
+0000c230: 7363 6f72 655f 646f 6d61 696e 202b 2026  score_domain + &
+0000c240: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000c250: 2053 5345 2873 7461 6e64 6172 645f 7363   SSE(standard_sc
+0000c260: 6f72 6528 4c31 5f73 6d4f 6273 2869 446f  ore(L1_smObs(iDo
+0000c270: 6d61 696e 2925 6461 7461 4f62 7328 6943  main)%dataObs(iC
+0000c280: 656c 6c2c 203a 292c 206d 6173 6b20 3d20  ell, :), mask = 
+0000c290: 4c31 5f73 6d4f 6273 2869 446f 6d61 696e  L1_smObs(iDomain
+0000c2a0: 2925 6d61 736b 4f62 7328 6943 656c 6c2c  )%maskObs(iCell,
+0000c2b0: 203a 2929 2c20 260a 2020 2020 2020 2020   :)), &.        
+0000c2c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c2d0: 7374 616e 6461 7264 5f73 636f 7265 2873  standard_score(s
+0000c2e0: 6d4f 7074 6953 696d 2869 446f 6d61 696e  mOptiSim(iDomain
+0000c2f0: 2925 6461 7461 5369 6d28 6943 656c 6c2c  )%dataSim(iCell,
+0000c300: 203a 292c 206d 6173 6b20 3d20 4c31 5f73   :), mask = L1_s
+0000c310: 6d4f 6273 2869 446f 6d61 696e 2925 6d61  mObs(iDomain)%ma
+0000c320: 736b 4f62 7328 6943 656c 6c2c 203a 2929  skObs(iCell, :))
+0000c330: 2c20 260a 2020 2020 2020 2020 2020 2020  , &.            
+0000c340: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c350: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c360: 2020 2020 2020 2020 2020 2020 2020 6d61                ma
+0000c370: 736b 203d 204c 315f 736d 4f62 7328 6944  sk = L1_smObs(iD
+0000c380: 6f6d 6169 6e29 256d 6173 6b4f 6273 2869  omain)%maskObs(i
+0000c390: 4365 6c6c 2c20 3a29 290a 0a20 2020 2020  Cell, :))..     
+0000c3a0: 2065 6e64 2064 6f0a 0a20 2020 2020 2021   end do..      !
+0000c3b0: 2075 7365 7220 696e 666f 726d 6174 696f   user informatio
+0000c3c0: 6e20 6162 6f75 7420 696e 7661 6c69 6420  n about invalid 
+0000c3d0: 6365 6c6c 730a 2020 2020 2020 6966 2028  cells.      if (
+0000c3e0: 696e 7661 6c69 645f 6365 6c6c 7320 2e47  invalid_cells .G
+0000c3f0: 542e 2030 2e35 5f64 7029 2074 6865 6e0a  T. 0.5_dp) then.
+0000c400: 2020 2020 2020 2020 6361 6c6c 206d 6573          call mes
+0000c410: 7361 6765 2827 2020 2057 4152 4e49 4e47  sage('   WARNING
+0000c420: 3a20 6f62 6a65 6374 6976 655f 736d 3a20  : objective_sm: 
+0000c430: 4465 7465 6374 6564 2069 6e76 616c 6964  Detected invalid
+0000c440: 2063 656c 6c73 2069 6e20 7374 7564 7920   cells in study 
+0000c450: 6172 6561 2028 2e4c 542e 2031 3020 7661  area (.LT. 10 va
+0000c460: 6c69 6420 6461 7461 2070 6f69 6e74 7329  lid data points)
+0000c470: 2e27 290a 2020 2020 2020 2020 6361 6c6c  .').        call
+0000c480: 206d 6573 7361 6765 2827 2020 2020 2020   message('      
+0000c490: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c4a0: 2020 2020 4672 6163 7469 6f6e 206f 6620      Fraction of 
+0000c4b0: 696e 7661 6c69 6420 6365 6c6c 733a 2027  invalid cells: '
+0000c4c0: 2c20 260a 2020 2020 2020 2020 2020 2020  , &.            
+0000c4d0: 2020 2020 6e75 6d32 7374 7228 696e 7661      num2str(inva
+0000c4e0: 6c69 645f 6365 6c6c 7320 2f20 7265 616c  lid_cells / real
+0000c4f0: 286e 4365 6c6c 7331 2c20 6470 292c 2027  (nCells1, dp), '
+0000c500: 2846 342e 3229 2729 290a 2020 2020 2020  (F4.2)')).      
+0000c510: 656e 6420 6966 0a0a 2020 2020 2020 2120  end if..      ! 
+0000c520: 6361 6c63 756c 6174 6520 6176 6572 6167  calculate averag
+0000c530: 6520 736f 696c 206d 6f69 7374 7572 6520  e soil moisture 
+0000c540: 636f 7272 656c 6174 696f 6e20 6f76 6572  correlation over
+0000c550: 2061 6c6c 2064 6f6d 6169 6e73 2077 6974   all domains wit
+0000c560: 6820 706f 7765 7220 6c61 770a 2020 2020  h power law.    
+0000c570: 2020 2120 646f 6d61 696e 7320 6172 6520    ! domains are 
+0000c580: 7765 6967 6874 6564 2065 7175 616c 6c79  weighted equally
+0000c590: 2028 2031 202f 2072 6561 6c28 646f 6d61   ( 1 / real(doma
+0000c5a0: 696e 4d65 7461 256f 7665 7261 6c6c 4e75  inMeta%overallNu
+0000c5b0: 6d62 6572 4f66 446f 6d61 696e 732c 6470  mberOfDomains,dp
+0000c5c0: 2929 2a2a 360a 2020 2020 2020 6f62 6a65  ))**6.      obje
+0000c5d0: 6374 6976 655f 736d 5f73 7365 5f73 7461  ctive_sm_sse_sta
+0000c5e0: 6e64 6172 645f 7363 6f72 6520 3d20 6f62  ndard_score = ob
+0000c5f0: 6a65 6374 6976 655f 736d 5f73 7365 5f73  jective_sm_sse_s
+0000c600: 7461 6e64 6172 645f 7363 6f72 6520 2b20  tandard_score + 
+0000c610: 260a 2020 2020 2020 2020 2020 2020 2020  &.              
+0000c620: 286f 626a 6563 7469 7665 5f73 6d5f 7373  (objective_sm_ss
+0000c630: 655f 7374 616e 6461 7264 5f73 636f 7265  e_standard_score
+0000c640: 5f64 6f6d 6169 6e20 2f20 7265 616c 2864  _domain / real(d
+0000c650: 6f6d 6169 6e4d 6574 6125 6f76 6572 616c  omainMeta%overal
+0000c660: 6c4e 756d 6265 724f 6644 6f6d 6169 6e73  lNumberOfDomains
+0000c670: 2c20 6470 2929 2a2a 360a 2020 2020 656e  , dp))**6.    en
+0000c680: 6420 646f 0a0a 2369 666e 6465 6620 4d50  d do..#ifndef MP
+0000c690: 490a 2020 2020 6f62 6a65 6374 6976 655f  I.    objective_
+0000c6a0: 736d 5f73 7365 5f73 7461 6e64 6172 645f  sm_sse_standard_
+0000c6b0: 7363 6f72 6520 3d20 6f62 6a65 6374 6976  score = objectiv
+0000c6c0: 655f 736d 5f73 7365 5f73 7461 6e64 6172  e_sm_sse_standar
+0000c6d0: 645f 7363 6f72 652a 2a6f 6e65 7369 7874  d_score**onesixt
+0000c6e0: 680a 0a20 2020 2063 616c 6c20 6d65 7373  h..    call mess
+0000c6f0: 6167 6528 2720 2020 206f 626a 6563 7469  age('    objecti
+0000c700: 7665 5f73 6d5f 7373 655f 7374 616e 6461  ve_sm_sse_standa
+0000c710: 7264 5f73 636f 7265 203d 2027 2c20 6e75  rd_score = ', nu
+0000c720: 6d32 7374 7228 6f62 6a65 6374 6976 655f  m2str(objective_
+0000c730: 736d 5f73 7365 5f73 7461 6e64 6172 645f  sm_sse_standard_
+0000c740: 7363 6f72 652c 2027 2845 3132 2e35 2927  score, '(E12.5)'
+0000c750: 2929 0a23 656e 6469 660a 0a20 2045 4e44  )).#endif..  END
+0000c760: 2046 554e 4354 494f 4e20 6f62 6a65 6374   FUNCTION object
+0000c770: 6976 655f 736d 5f73 7365 5f73 7461 6e64  ive_sm_sse_stand
+0000c780: 6172 645f 7363 6f72 650a 0a0a 2020 2120  ard_score...  ! 
+0000c790: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+0000c7a0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+0000c7b0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+0000c7c0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+0000c7d0: 2d0a 0a20 2021 2020 2020 4e41 4d45 0a20  -..  !    NAME. 
+0000c7e0: 2021 2020 2020 2020 2020 6f62 6a65 6374   !        object
+0000c7f0: 6976 655f 6b67 655f 715f 726d 7365 5f74  ive_kge_q_rmse_t
+0000c800: 7773 0a0a 2020 2120 2020 2050 5552 504f  ws..  !    PURPO
+0000c810: 5345 0a20 2021 3e20 2020 2020 2020 5c62  SE.  !>       \b
+0000c820: 7269 6566 204f 626a 6563 7469 7665 2066  rief Objective f
+0000c830: 756e 6374 696f 6e20 6f66 204b 4745 2066  unction of KGE f
+0000c840: 6f72 2072 756e 6f66 6620 616e 6420 524d  or runoff and RM
+0000c850: 5345 2066 6f72 2064 6f6d 6169 6e5f 6176  SE for domain_av
+0000c860: 6720 5457 5320 2873 7461 6e64 6172 697a  g TWS (standariz
+0000c870: 6564 2073 636f 7265 7329 0a0a 2020 213e  ed scores)..  !>
+0000c880: 2020 2020 2020 205c 6465 7461 696c 7320         \details 
+0000c890: 4f62 6a65 6374 6976 6520 6675 6e63 7469  Objective functi
+0000c8a0: 6f6e 206f 6620 4b47 4520 666f 7220 7275  on of KGE for ru
+0000c8b0: 6e6f 6666 2061 6e64 2052 4d53 4520 666f  noff and RMSE fo
+0000c8c0: 7220 646f 6d61 696e 5f61 7667 2054 5753  r domain_avg TWS
+0000c8d0: 2028 7374 616e 6461 7269 7a65 6420 7363   (standarized sc
+0000c8e0: 6f72 6573 290a 0a20 2021 2020 2020 494e  ores)..  !    IN
+0000c8f0: 5445 4e54 2849 4e29 0a20 2021 3e20 2020  TENT(IN).  !>   
+0000c900: 2020 2020 5c70 6172 616d 5b69 6e5d 2022      \param[in] "
+0000c910: 7265 616c 2864 7029 2c20 6469 6d65 6e73  real(dp), dimens
+0000c920: 696f 6e28 3a29 203a 3a20 7061 7261 6d65  ion(:) :: parame
+0000c930: 7465 7273 6574 220a 2020 213e 2020 2020  terset".  !>    
+0000c940: 2020 205c 7061 7261 6d5b 696e 5d20 2270     \param[in] "p
+0000c950: 726f 6365 6475 7265 2865 7661 6c5f 696e  rocedure(eval_in
+0000c960: 7465 7266 6163 6529 203a 3a20 6576 616c  terface) :: eval
+0000c970: 220a 0a20 2021 2020 2020 5245 5455 524e  "..  !    RETURN
+0000c980: 0a20 2021 3e20 2020 2020 2020 5c72 6574  .  !>       \ret
+0000c990: 7572 6e20 7265 616c 2864 7029 203a 3a20  urn real(dp) :: 
+0000c9a0: 6f62 6a65 6374 6976 655f 6b67 655f 715f  objective_kge_q_
+0000c9b0: 726d 7365 5f74 7773 2026 6d64 6173 683b  rmse_tws &mdash;
+0000c9c0: 206f 626a 6563 7469 7665 2066 756e 6374   objective funct
+0000c9d0: 696f 6e20 7661 6c75 650a 2020 213e 2020  ion value.  !>  
+0000c9e0: 2020 2020 2028 7768 6963 6820 7769 6c6c       (which will
+0000c9f0: 2062 6520 652e 672e 206d 696e 696d 697a   be e.g. minimiz
+0000ca00: 6564 2062 7920 616e 206f 7074 696d 697a  ed by an optimiz
+0000ca10: 6174 696f 6e20 726f 7574 696e 6520 6c69  ation routine li
+0000ca20: 6b65 2044 4453 290a 0a20 2021 2020 2020  ke DDS)..  !    
+0000ca30: 4849 5354 4f52 590a 2020 213e 2020 2020  HISTORY.  !>    
+0000ca40: 2020 205c 6175 7468 6f72 7320 4f6c 6472     \authors Oldr
+0000ca50: 6963 6820 5261 6b6f 7665 632c 2052 6f68  ich Rakovec, Roh
+0000ca60: 696e 6920 4b75 6d61 720a 0a20 2021 3e20  ini Kumar..  !> 
+0000ca70: 2020 2020 2020 5c64 6174 6520 4f63 742e        \date Oct.
+0000ca80: 2032 3031 350a 0a20 2021 204d 6f64 6966   2015..  ! Modif
+0000ca90: 6963 6174 696f 6e73 3a0a 2020 2120 5374  ications:.  ! St
+0000caa0: 6570 6861 6e20 5468 6f62 6572 204f 6374  ephan Thober Oct
+0000cab0: 2032 3031 3520 2d20 6d6f 7665 6420 7477   2015 - moved tw
+0000cac0: 7320 6f70 7469 6d69 7a61 7469 6f6e 2066  s optimization f
+0000cad0: 726f 6d20 6d6f 5f6d 726d 5f6f 626a 6563  rom mo_mrm_objec
+0000cae0: 7469 7665 5f66 756e 6374 696f 6e5f 7275  tive_function_ru
+0000caf0: 6e6f 6666 2068 6572 650a 2020 2120 526f  noff here.  ! Ro
+0000cb00: 6265 7274 2053 6368 7765 7070 6520 4a75  bert Schweppe Ju
+0000cb10: 6e20 3230 3138 202d 2072 6566 6163 746f  n 2018 - refacto
+0000cb20: 7269 6e67 2061 6e64 2072 6566 6f72 6d61  ring and reforma
+0000cb30: 7474 696e 670a 2020 2120 4d61 7265 6e20  tting.  ! Maren 
+0000cb40: 4b61 6c75 7a61 204f 6374 2032 3031 3920  Kaluza Oct 2019 
+0000cb50: 2d20 6368 616e 6765 6420 6176 6572 6167  - changed averag
+0000cb60: 696e 6720 6675 6e63 7469 6f6e 2066 6f72  ing function for
+0000cb70: 2074 7773 2c20 7468 6973 2077 696c 6c20   tws, this will 
+0000cb80: 6e6f 7420 7072 6f64 7563 6520 7468 6520  not produce the 
+0000cb90: 7361 6d65 206f 7574 7075 7420 6173 2062  same output as b
+0000cba0: 6566 6f72 650a 0a20 2046 554e 4354 494f  efore..  FUNCTIO
+0000cbb0: 4e20 6f62 6a65 6374 6976 655f 6b67 655f  N objective_kge_
+0000cbc0: 715f 726d 7365 5f74 7773 2870 6172 616d  q_rmse_tws(param
+0000cbd0: 6574 6572 7365 742c 2065 7661 6c29 0a0a  eterset, eval)..
+0000cbe0: 2020 2020 7573 6520 6d6f 5f6f 7074 696d      use mo_optim
+0000cbf0: 697a 6174 696f 6e5f 7479 7065 732c 206f  ization_types, o
+0000cc00: 6e6c 7920 3a20 6f70 7469 6461 7461 5f73  nly : optidata_s
+0000cc10: 696d 0a20 2020 2075 7365 206d 6f5f 636f  im.    use mo_co
+0000cc20: 6d6d 6f6e 5f63 6f6e 7374 616e 7473 2c20  mmon_constants, 
+0000cc30: 6f6e 6c79 203a 2065 7073 5f64 702c 206e  only : eps_dp, n
+0000cc40: 6f64 6174 615f 6470 0a20 2020 2075 7365  odata_dp.    use
+0000cc50: 206d 6f5f 636f 6d6d 6f6e 5f6d 686d 5f6d   mo_common_mhm_m
+0000cc60: 726d 5f76 6172 6961 626c 6573 2c20 6f6e  rm_variables, on
+0000cc70: 6c79 203a 2065 7661 6c50 6572 0a20 2020  ly : evalPer.   
+0000cc80: 2075 7365 206d 6f5f 636f 6d6d 6f6e 5f76   use mo_common_v
+0000cc90: 6172 6961 626c 6573 2c20 6f6e 6c79 203a  ariables, only :
+0000cca0: 2064 6f6d 6169 6e4d 6574 610a 2020 2020   domainMeta.    
+0000ccb0: 7573 6520 6d6f 5f67 6c6f 6261 6c5f 7661  use mo_global_va
+0000ccc0: 7269 6162 6c65 732c 206f 6e6c 7920 3a20  riables, only : 
+0000ccd0: 4c31 5f74 7773 614f 6273 0a20 2020 2075  L1_twsaObs.    u
+0000cce0: 7365 206d 6f5f 6572 726f 726d 6561 7375  se mo_errormeasu
+0000ccf0: 7265 732c 206f 6e6c 7920 3a20 726d 7365  res, only : rmse
+0000cd00: 0a20 2020 2075 7365 206d 6f5f 6a75 6c69  .    use mo_juli
+0000cd10: 616e 2c20 6f6e 6c79 203a 2063 616c 6461  an, only : calda
+0000cd20: 740a 2020 2020 7573 6520 6d6f 5f6d 6f6d  t.    use mo_mom
+0000cd30: 656e 742c 206f 6e6c 7920 3a20 6d65 616e  ent, only : mean
+0000cd40: 0a20 2020 2075 7365 206d 6f5f 7374 616e  .    use mo_stan
+0000cd50: 6461 7264 5f73 636f 7265 2c20 6f6e 6c79  dard_score, only
+0000cd60: 203a 2063 6c61 7373 6966 6965 645f 7374   : classified_st
+0000cd70: 616e 6461 7264 5f73 636f 7265 0a20 2020  andard_score.   
+0000cd80: 2075 7365 206d 6f5f 7374 7269 6e67 5f75   use mo_string_u
+0000cd90: 7469 6c73 2c20 6f6e 6c79 203a 206e 756d  tils, only : num
+0000cda0: 3273 7472 0a20 2020 2075 7365 206d 6f5f  2str.    use mo_
+0000cdb0: 7465 6d70 6f72 616c 5f61 6767 7265 6761  temporal_aggrega
+0000cdc0: 7469 6f6e 2c20 6f6e 6c79 203a 2064 6179  tion, only : day
+0000cdd0: 326d 6f6e 5f61 7665 7261 6765 0a20 2020  2mon_average.   
+0000cde0: 2075 7365 206d 6f5f 6572 726f 726d 6561   use mo_errormea
+0000cdf0: 7375 7265 732c 206f 6e6c 7920 3a20 6b67  sures, only : kg
+0000ce00: 650a 2020 2020 7573 6520 6d6f 5f6d 726d  e.    use mo_mrm
+0000ce10: 5f6f 626a 6563 7469 7665 5f66 756e 6374  _objective_funct
+0000ce20: 696f 6e5f 7275 6e6f 6666 2c20 6f6e 6c79  ion_runoff, only
+0000ce30: 203a 2065 7874 7261 6374 5f72 756e 6f66   : extract_runof
+0000ce40: 660a 0a20 2020 2069 6d70 6c69 6369 7420  f..    implicit 
+0000ce50: 6e6f 6e65 0a0a 2020 2020 7265 616c 2864  none..    real(d
+0000ce60: 7029 2c20 6469 6d65 6e73 696f 6e28 3a29  p), dimension(:)
+0000ce70: 2c20 696e 7465 6e74 2869 6e29 203a 3a20  , intent(in) :: 
+0000ce80: 7061 7261 6d65 7465 7273 6574 0a0a 2020  parameterset..  
+0000ce90: 2020 7072 6f63 6564 7572 6528 6576 616c    procedure(eval
+0000cea0: 5f69 6e74 6572 6661 6365 292c 2049 4e54  _interface), INT
+0000ceb0: 454e 5428 494e 292c 2050 4f49 4e54 4552  ENT(IN), POINTER
+0000cec0: 203a 3a20 6576 616c 0a0a 2020 2020 7265   :: eval..    re
+0000ced0: 616c 2864 7029 203a 3a20 6f62 6a65 6374  al(dp) :: object
+0000cee0: 6976 655f 6b67 655f 715f 726d 7365 5f74  ive_kge_q_rmse_t
+0000cef0: 7773 0a0a 2020 2020 2120 6d6f 6465 6c6c  ws..    ! modell
+0000cf00: 6564 2072 756e 6f66 6620 666f 7220 6120  ed runoff for a 
+0000cf10: 6769 7665 6e20 7061 7261 6d65 7465 7220  given parameter 
+0000cf20: 7365 740a 2020 2020 2120 6469 6d31 3d6e  set.    ! dim1=n
+0000cf30: 5469 6d65 5374 6570 732c 2064 696d 323d  TimeSteps, dim2=
+0000cf40: 6e47 6175 6765 730a 2020 2020 7265 616c  nGauges.    real
+0000cf50: 2864 7029 2c20 616c 6c6f 6361 7461 626c  (dp), allocatabl
+0000cf60: 652c 2064 696d 656e 7369 6f6e 283a 2c20  e, dimension(:, 
+0000cf70: 3a29 203a 3a20 7275 6e6f 6666 0a0a 2020  :) :: runoff..  
+0000cf80: 2020 213e 2073 696d 756c 6174 6564 2074    !> simulated t
+0000cf90: 7773 0a20 2020 2074 7970 6528 6f70 7469  ws.    type(opti
+0000cfa0: 6461 7461 5f73 696d 292c 2064 696d 656e  data_sim), dimen
+0000cfb0: 7369 6f6e 283a 292c 2061 6c6c 6f63 6174  sion(:), allocat
+0000cfc0: 6162 6c65 203a 3a20 7477 734f 7074 6953  able :: twsOptiS
+0000cfd0: 696d 0a0a 2020 2020 2120 646f 6d61 696e  im..    ! domain
+0000cfe0: 2063 6f75 6e74 6572 2c20 6d6f 6e74 6820   counter, month 
+0000cff0: 636f 756e 7465 7273 0a20 2020 2069 6e74  counters.    int
+0000d000: 6567 6572 2869 3429 203a 3a20 646f 6d61  eger(i4) :: doma
+0000d010: 696e 4944 2c20 6944 6f6d 6169 6e2c 2070  inID, iDomain, p
+0000d020: 702c 206d 6d6d 0a0a 2020 2020 696e 7465  p, mmm..    inte
+0000d030: 6765 7228 6934 2920 3a3a 2079 6561 722c  ger(i4) :: year,
+0000d040: 206d 6f6e 7468 2c20 6461 790a 0a20 2020   month, day..   
+0000d050: 2072 6561 6c28 6470 292c 2064 696d 656e   real(dp), dimen
+0000d060: 7369 6f6e 2864 6f6d 6169 6e4d 6574 6125  sion(domainMeta%
+0000d070: 6e44 6f6d 6169 6e73 2920 3a3a 2069 6e69  nDomains) :: ini
+0000d080: 7454 696d 650a 0a20 2020 2021 2073 696d  tTime..    ! sim
+0000d090: 756c 6174 6564 2074 7773 0a20 2020 2072  ulated tws.    r
+0000d0a0: 6561 6c28 6470 292c 2064 696d 656e 7369  eal(dp), dimensi
+0000d0b0: 6f6e 283a 292c 2061 6c6c 6f63 6174 6162  on(:), allocatab
+0000d0c0: 6c65 203a 3a20 7477 735f 6361 7463 685f  le :: tws_catch_
+0000d0d0: 6176 675f 646f 6d61 696e 0a0a 2020 2020  avg_domain..    
+0000d0e0: 2120 6d65 6173 7572 6564 2074 7773 0a20  ! measured tws. 
+0000d0f0: 2020 2072 6561 6c28 6470 292c 2064 696d     real(dp), dim
+0000d100: 656e 7369 6f6e 283a 292c 2061 6c6c 6f63  ension(:), alloc
+0000d110: 6174 6162 6c65 203a 3a20 7477 735f 6f70  atable :: tws_op
+0000d120: 7469 5f63 6174 6368 5f61 7667 5f64 6f6d  ti_catch_avg_dom
+0000d130: 6169 6e0a 0a20 2020 2021 206d 6173 6b20  ain..    ! mask 
+0000d140: 666f 7220 6d65 6173 7572 6564 2074 7773  for measured tws
+0000d150: 0a20 2020 206c 6f67 6963 616c 2c20 6469  .    logical, di
+0000d160: 6d65 6e73 696f 6e28 3a29 2c20 616c 6c6f  mension(:), allo
+0000d170: 6361 7461 626c 6520 3a3a 2074 7773 5f6f  catable :: tws_o
+0000d180: 6273 5f6d 6173 6b0a 0a20 2020 2021 2074  bs_mask..    ! t
+0000d190: 6f74 616c 206e 756d 6265 7220 6f66 206d  otal number of m
+0000d1a0: 6f6e 7468 730a 2020 2020 696e 7465 6765  onths.    intege
+0000d1b0: 7228 6934 2920 3a3a 206e 4d6f 6e74 6873  r(i4) :: nMonths
+0000d1c0: 0a0a 2020 2020 2120 7665 6374 6f72 2077  ..    ! vector w
+0000d1d0: 6974 6820 6d6f 6e74 6873 2720 636c 6173  ith months' clas
+0000d1e0: 7365 730a 2020 2020 696e 7465 6765 7228  ses.    integer(
+0000d1f0: 6934 292c 2064 696d 656e 7369 6f6e 283a  i4), dimension(:
+0000d200: 292c 2061 6c6c 6f63 6174 6162 6c65 203a  ), allocatable :
+0000d210: 3a20 6d6f 6e74 685f 636c 6173 7365 730a  : month_classes.
+0000d220: 0a20 2020 2021 206d 6f6e 7468 6c79 2076  .    ! monthly v
+0000d230: 616c 7565 7320 616e 6f6d 616c 7920 7469  alues anomaly ti
+0000d240: 6d65 2073 6572 6965 730a 2020 2020 7265  me series.    re
+0000d250: 616c 2864 7029 2c20 4449 4d45 4e53 494f  al(dp), DIMENSIO
+0000d260: 4e28 3a29 2c20 616c 6c6f 6361 7461 626c  N(:), allocatabl
+0000d270: 6520 3a3a 2074 7773 5f73 696d 5f6d 5f61  e :: tws_sim_m_a
+0000d280: 6e6f 6d2c 2074 7773 5f6f 6273 5f6d 5f61  nom, tws_obs_m_a
+0000d290: 6e6f 6d0a 0a20 2020 2021 2072 6d73 655f  nom..    ! rmse_
+0000d2a0: 7477 7328 646f 6d61 696e 4d65 7461 256e  tws(domainMeta%n
+0000d2b0: 446f 6d61 696e 7329 0a20 2020 2072 6561  Domains).    rea
+0000d2c0: 6c28 6470 292c 2064 696d 656e 7369 6f6e  l(dp), dimension
+0000d2d0: 283a 292c 2061 6c6c 6f63 6174 6162 6c65  (:), allocatable
+0000d2e0: 203a 3a20 726d 7365 5f74 7773 0a0a 2020   :: rmse_tws..  
+0000d2f0: 2020 2120 6f62 6a2e 2066 756e 6374 696f    ! obj. functio
+0000d300: 6e73 0a20 2020 2072 6561 6c28 6470 2920  ns.    real(dp) 
+0000d310: 3a3a 2072 6d73 655f 7477 735f 6176 672c  :: rmse_tws_avg,
+0000d320: 206b 6765 5f71 5f61 7667 0a0a 2020 2020   kge_q_avg..    
+0000d330: 696e 7465 6765 7228 6934 2920 3a3a 206e  integer(i4) :: n
+0000d340: 4761 7567 6573 546f 7461 6c0a 0a20 2020  GaugesTotal..   
+0000d350: 2021 2061 6767 7265 6761 7465 6420 7369   ! aggregated si
+0000d360: 6d75 6c61 7465 6420 7275 6e6f 6666 0a20  mulated runoff. 
+0000d370: 2020 2072 6561 6c28 6470 292c 2064 696d     real(dp), dim
+0000d380: 656e 7369 6f6e 283a 292c 2061 6c6c 6f63  ension(:), alloc
+0000d390: 6174 6162 6c65 203a 3a20 7275 6e6f 6666  atable :: runoff
+0000d3a0: 5f61 6767 0a0a 2020 2020 2120 6d65 6173  _agg..    ! meas
+0000d3b0: 7572 6564 2072 756e 6f66 660a 2020 2020  ured runoff.    
+0000d3c0: 7265 616c 2864 7029 2c20 6469 6d65 6e73  real(dp), dimens
+0000d3d0: 696f 6e28 3a29 2c20 616c 6c6f 6361 7461  ion(:), allocata
+0000d3e0: 626c 6520 3a3a 2072 756e 6f66 665f 6f62  ble :: runoff_ob
+0000d3f0: 730a 0a20 2020 2021 206d 6173 6b20 666f  s..    ! mask fo
+0000d400: 7220 6d65 6173 7572 6564 2072 756e 6f66  r measured runof
+0000d410: 660a 2020 2020 6c6f 6769 6361 6c2c 2064  f.    logical, d
+0000d420: 696d 656e 7369 6f6e 283a 292c 2061 6c6c  imension(:), all
+0000d430: 6f63 6174 6162 6c65 203a 3a20 7275 6e6f  ocatable :: runo
+0000d440: 6666 5f6f 6273 5f6d 6173 6b0a 0a20 2020  ff_obs_mask..   
+0000d450: 2021 206b 6765 5f71 286e 4761 7567 6573   ! kge_q(nGauges
+0000d460: 546f 7461 6c29 0a20 2020 2072 6561 6c28  Total).    real(
+0000d470: 6470 292c 2064 696d 656e 7369 6f6e 283a  dp), dimension(:
+0000d480: 292c 2061 6c6c 6f63 6174 6162 6c65 203a  ), allocatable :
+0000d490: 3a20 6b67 655f 710a 0a20 2020 2021 2067  : kge_q..    ! g
+0000d4a0: 6175 6765 7320 636f 756e 7465 720a 2020  auges counter.  
+0000d4b0: 2020 696e 7465 6765 7228 6934 2920 3a3a    integer(i4) ::
+0000d4c0: 2067 670a 0a20 2020 2021 206f 6274 6169   gg..    ! obtai
+0000d4d0: 6e20 686f 7572 6c79 2076 616c 7565 7320  n hourly values 
+0000d4e0: 6f66 2072 756e 6f66 6620 616e 6420 7477  of runoff and tw
+0000d4f0: 733a 0a20 2020 2061 6c6c 6f63 6174 6528  s:.    allocate(
+0000d500: 7477 734f 7074 6953 696d 2864 6f6d 6169  twsOptiSim(domai
+0000d510: 6e4d 6574 6125 6e44 6f6d 6169 6e73 2929  nMeta%nDomains))
+0000d520: 0a20 2020 2063 616c 6c20 6576 616c 2870  .    call eval(p
+0000d530: 6172 616d 6574 6572 7365 742c 2072 756e  arameterset, run
+0000d540: 6f66 6620 3d20 7275 6e6f 6666 2c20 7477  off = runoff, tw
+0000d550: 734f 7074 6953 696d 203d 2074 7773 4f70  sOptiSim = twsOp
+0000d560: 7469 5369 6d29 0a0a 2020 2020 212d 2d2d  tiSim)..    !---
+0000d570: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
 0000d580: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0000d590: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0000d5a0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 0a20 2020  -----------..   
-0000d5b0: 2021 2061 6c6c 6f63 6174 650a 2020 2020   ! allocate.    
-0000d5c0: 616c 6c6f 6361 7465 2872 6d73 655f 7477  allocate(rmse_tw
-0000d5d0: 7328 646f 6d61 696e 4d65 7461 256e 446f  s(domainMeta%nDo
-0000d5e0: 6d61 696e 7329 290a 2020 2020 726d 7365  mains)).    rmse
-0000d5f0: 5f74 7773 283a 2920 3d20 6e6f 6461 7461  _tws(:) = nodata
-0000d600: 5f64 700a 0a20 2020 2064 6f20 6944 6f6d  _dp..    do iDom
-0000d610: 6169 6e20 3d20 312c 2064 6f6d 6169 6e4d  ain = 1, domainM
-0000d620: 6574 6125 6e44 6f6d 6169 6e73 0a20 2020  eta%nDomains.   
-0000d630: 2020 2069 6620 282e 6e6f 742e 2028 4c31     if (.not. (L1
-0000d640: 5f74 7773 614f 6273 2869 446f 6d61 696e  _twsaObs(iDomain
-0000d650: 2925 7469 6d65 5374 6570 496e 7075 7420  )%timeStepInput 
-0000d660: 3d3d 202d 3229 2920 7468 656e 0a20 2020  == -2)) then.   
-0000d670: 2020 2020 2063 616c 6c20 6d65 7373 6167       call messag
-0000d680: 6528 276f 626a 6563 7469 7665 5f6b 6765  e('objective_kge
-0000d690: 5f71 5f72 6d73 655f 7477 733a 2063 7572  _q_rmse_tws: cur
-0000d6a0: 7265 6e74 2069 6d70 6c65 6d65 6e74 6174  rent implementat
-0000d6b0: 696f 6e20 6f66 2074 6869 7320 7375 6272  ion of this subr
-0000d6c0: 6f75 7469 6e65 206f 6e6c 7920 616c 6c6f  outine only allo
-0000d6d0: 7773 206d 6f6e 7468 6c79 2074 696d 6573  ws monthly times
-0000d6e0: 7465 7073 2729 0a20 2020 2020 2065 6e64  teps').      end
-0000d6f0: 2069 660a 2020 2020 2020 646f 6d61 696e   if.      domain
-0000d700: 4944 203d 2064 6f6d 6169 6e4d 6574 6125  ID = domainMeta%
-0000d710: 696e 6469 6365 7328 6944 6f6d 6169 6e29  indices(iDomain)
-0000d720: 0a0a 2020 2020 2020 2120 6578 7472 6163  ..      ! extrac
-0000d730: 7420 7477 7320 7468 6520 7361 6d65 2077  t tws the same w
-0000d740: 6179 2061 7320 7275 6e6f 6666 2075 7369  ay as runoff usi
-0000d750: 6e67 206d 726d 0a20 2020 2020 2021 204e  ng mrm.      ! N
-0000d760: 6f74 6520 7468 6174 2077 6974 6820 7468  ote that with th
-0000d770: 6520 6368 616e 6765 2066 726f 6d20 7477  e change from tw
-0000d780: 7328 6944 6f6d 6169 6e2c 2074 7429 2074  s(iDomain, tt) t
-0000d790: 6f20 7477 7328 7474 2c20 3a29 2074 6869  o tws(tt, :) thi
-0000d7a0: 730a 2020 2020 2020 2120 7769 6c6c 206e  s.      ! will n
-0000d7b0: 6f74 2077 6f72 6b20 6c69 6b65 2062 6566  ot work like bef
-0000d7c0: 6f72 6520 616e 6420 616c 736f 2064 6f65  ore and also doe
-0000d7d0: 7320 6d61 7962 6520 6e6f 7420 6d61 6b65  s maybe not make
-0000d7e0: 2073 656e 7365 0a20 2020 2020 2063 616c   sense.      cal
-0000d7f0: 6c20 6372 6561 7465 5f64 6f6d 6169 6e5f  l create_domain_
-0000d800: 6176 675f 7477 7328 6944 6f6d 6169 6e2c  avg_tws(iDomain,
-0000d810: 2074 7773 4f70 7469 5369 6d2c 2074 7773   twsOptiSim, tws
-0000d820: 5f63 6174 6368 5f61 7667 5f64 6f6d 6169  _catch_avg_domai
-0000d830: 6e2c 2074 7773 5f6f 7074 695f 6361 7463  n, tws_opti_catc
-0000d840: 685f 6176 675f 646f 6d61 696e 2c20 7477  h_avg_domain, tw
-0000d850: 735f 6f62 735f 6d61 736b 290a 0a20 2020  s_obs_mask)..   
-0000d860: 2020 2021 2063 6865 636b 2066 6f72 2070     ! check for p
-0000d870: 6f74 656e 7469 616c 6c79 2032 2079 6561  otentially 2 yea
-0000d880: 7273 206f 6620 6461 7461 0a20 2020 2020  rs of data.     
-0000d890: 2069 6620 2863 6f75 6e74 2874 7773 5f6f   if (count(tws_o
-0000d8a0: 6273 5f6d 6173 6b29 202e 6c74 2e20 2031  bs_mask) .lt.  1
-0000d8b0: 3220 2a20 3229 2074 6865 6e0a 2020 2020  2 * 2) then.    
-0000d8c0: 2020 2020 6361 6c6c 206d 6573 7361 6765      call message
-0000d8d0: 2827 6f62 6a65 6374 6976 655f 6b67 655f  ('objective_kge_
-0000d8e0: 715f 726d 7365 5f74 7773 3a20 4c65 6e67  q_rmse_tws: Leng
-0000d8f0: 7468 206f 6620 5457 5320 6461 7461 206f  th of TWS data o
-0000d900: 6620 646f 6d61 696e 2027 2c20 7472 696d  f domain ', trim
-0000d910: 2861 646a 7573 746c 286e 756d 3273 7472  (adjustl(num2str
-0000d920: 2864 6f6d 6169 6e49 4429 2929 2c20 260a  (domainID))), &.
-0000d930: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d940: 2720 6c65 7373 2074 6861 6e20 3220 7965  ' less than 2 ye
-0000d950: 6172 733a 2074 6869 7320 6973 206e 6f74  ars: this is not
-0000d960: 2072 6563 6f6d 6d65 6e64 6564 2729 0a20   recommended'). 
-0000d970: 2020 2020 2065 6e64 2069 660a 0a20 2020       end if..   
-0000d980: 2020 2021 2067 6574 2069 6e69 7469 616c     ! get initial
-0000d990: 2074 696d 6520 6f66 2074 6865 2065 7661   time of the eva
-0000d9a0: 6c75 6174 696f 6e20 7065 7269 6f64 0a20  luation period. 
-0000d9b0: 2020 2020 2069 6e69 7454 696d 6528 6944       initTime(iD
-0000d9c0: 6f6d 6169 6e29 203d 2072 6561 6c28 6576  omain) = real(ev
-0000d9d0: 616c 5065 7228 6944 6f6d 6169 6e29 256a  alPer(iDomain)%j
-0000d9e0: 756c 5374 6172 742c 2064 7029 0a0a 2020  ulStart, dp)..  
-0000d9f0: 2020 2020 2120 6765 7420 6361 6c65 6e64      ! get calend
-0000da00: 6172 2064 6179 732c 206d 6f6e 7468 732c  ar days, months,
-0000da10: 2079 6561 720a 2020 2020 2020 6361 6c6c   year.      call
-0000da20: 2063 616c 6461 7428 696e 7428 696e 6974   caldat(int(init
-0000da30: 5469 6d65 2869 446f 6d61 696e 2929 2c20  Time(iDomain)), 
-0000da40: 7979 203d 2079 6561 722c 206d 6d20 3d20  yy = year, mm = 
-0000da50: 6d6f 6e74 682c 2064 6420 3d20 6461 7929  month, dd = day)
-0000da60: 0a0a 2020 2020 2020 6e4d 6f6e 7468 7320  ..      nMonths 
-0000da70: 3d20 7369 7a65 2874 7773 5f6f 6273 5f6d  = size(tws_obs_m
-0000da80: 6173 6b29 0a0a 2020 2020 2020 616c 6c6f  ask)..      allo
-0000da90: 6361 7465 2028 6d6f 6e74 685f 636c 6173  cate (month_clas
-0000daa0: 7365 7328 6e4d 6f6e 7468 7329 290a 2020  ses(nMonths)).  
-0000dab0: 2020 2020 616c 6c6f 6361 7465 2028 7477      allocate (tw
-0000dac0: 735f 6f62 735f 6d5f 616e 6f6d 286e 4d6f  s_obs_m_anom(nMo
-0000dad0: 6e74 6873 2929 0a20 2020 2020 2061 6c6c  nths)).      all
-0000dae0: 6f63 6174 6520 2874 7773 5f73 696d 5f6d  ocate (tws_sim_m
-0000daf0: 5f61 6e6f 6d28 6e4d 6f6e 7468 7329 290a  _anom(nMonths)).
-0000db00: 0a20 2020 2020 206d 6f6e 7468 5f63 6c61  .      month_cla
-0000db10: 7373 6573 283a 2920 3d20 300a 2020 2020  sses(:) = 0.    
-0000db20: 2020 7477 735f 6f62 735f 6d5f 616e 6f6d    tws_obs_m_anom
-0000db30: 283a 2920 3d20 6e6f 6461 7461 5f64 700a  (:) = nodata_dp.
-0000db40: 2020 2020 2020 7477 735f 7369 6d5f 6d5f        tws_sim_m_
-0000db50: 616e 6f6d 283a 2920 3d20 6e6f 6461 7461  anom(:) = nodata
-0000db60: 5f64 700a 0a20 2020 2020 2021 2064 6566  _dp..      ! def
-0000db70: 696e 6520 6d6f 6e74 6873 2720 636c 6173  ine months' clas
-0000db80: 7365 730a 2020 2020 2020 6d6d 6d20 3d20  ses.      mmm = 
-0000db90: 6d6f 6e74 680a 2020 2020 2020 646f 2070  month.      do p
-0000dba0: 7020 3d20 312c 206e 4d6f 6e74 6873 0a20  p = 1, nMonths. 
-0000dbb0: 2020 2020 2020 206d 6f6e 7468 5f63 6c61         month_cla
-0000dbc0: 7373 6573 2870 7029 203d 206d 6d6d 0a20  sses(pp) = mmm. 
-0000dbd0: 2020 2020 2020 2069 6620 286d 6d6d 202e         if (mmm .
-0000dbe0: 4c54 2e20 3132 2920 7468 656e 0a20 2020  LT. 12) then.   
-0000dbf0: 2020 2020 2020 206d 6d6d 203d 206d 6d6d         mmm = mmm
-0000dc00: 202b 2031 0a20 2020 2020 2020 2065 6c73   + 1.        els
-0000dc10: 650a 2020 2020 2020 2020 2020 6d6d 6d20  e.          mmm 
-0000dc20: 3d20 310a 2020 2020 2020 2020 656e 6420  = 1.        end 
-0000dc30: 6966 0a20 2020 2020 2065 6e64 2064 6f0a  if.      end do.
-0000dc40: 0a20 2020 2020 2021 2063 616c 6375 6c61  .      ! calcula
-0000dc50: 7465 2073 7461 6e64 6172 6420 7363 6f72  te standard scor
-0000dc60: 650a 2020 2020 2020 7477 735f 6f62 735f  e.      tws_obs_
-0000dc70: 6d5f 616e 6f6d 203d 2063 6c61 7373 6966  m_anom = classif
-0000dc80: 6965 645f 7374 616e 6461 7264 5f73 636f  ied_standard_sco
-0000dc90: 7265 2874 7773 5f6f 7074 695f 6361 7463  re(tws_opti_catc
-0000dca0: 685f 6176 675f 646f 6d61 696e 2c20 6d6f  h_avg_domain, mo
-0000dcb0: 6e74 685f 636c 6173 7365 732c 206d 6173  nth_classes, mas
-0000dcc0: 6b20 3d20 7477 735f 6f62 735f 6d61 736b  k = tws_obs_mask
-0000dcd0: 290a 2020 2020 2020 7477 735f 7369 6d5f  ).      tws_sim_
-0000dce0: 6d5f 616e 6f6d 203d 2063 6c61 7373 6966  m_anom = classif
-0000dcf0: 6965 645f 7374 616e 6461 7264 5f73 636f  ied_standard_sco
-0000dd00: 7265 2874 7773 5f63 6174 6368 5f61 7667  re(tws_catch_avg
-0000dd10: 5f64 6f6d 6169 6e2c 2020 2020 2020 6d6f  _domain,      mo
-0000dd20: 6e74 685f 636c 6173 7365 732c 206d 6173  nth_classes, mas
-0000dd30: 6b20 3d20 7477 735f 6f62 735f 6d61 736b  k = tws_obs_mask
-0000dd40: 290a 2020 2020 2020 726d 7365 5f74 7773  ).      rmse_tws
-0000dd50: 2869 446f 6d61 696e 2920 3d20 726d 7365  (iDomain) = rmse
-0000dd60: 2874 7773 5f73 696d 5f6d 5f61 6e6f 6d2c  (tws_sim_m_anom,
-0000dd70: 2074 7773 5f6f 6273 5f6d 5f61 6e6f 6d2c   tws_obs_m_anom,
-0000dd80: 206d 6173 6b20 3d20 7477 735f 6f62 735f   mask = tws_obs_
-0000dd90: 6d61 736b 290a 0a20 2020 2020 2064 6561  mask)..      dea
-0000dda0: 6c6c 6f63 6174 6520 286d 6f6e 7468 5f63  llocate (month_c
-0000ddb0: 6c61 7373 6573 290a 2020 2020 2020 6465  lasses).      de
-0000ddc0: 616c 6c6f 6361 7465 2028 7477 735f 7369  allocate (tws_si
-0000ddd0: 6d5f 6d5f 616e 6f6d 290a 2020 2020 2020  m_m_anom).      
-0000dde0: 6465 616c 6c6f 6361 7465 2028 7477 735f  deallocate (tws_
-0000ddf0: 6f62 735f 6d5f 616e 6f6d 290a 2020 2020  obs_m_anom).    
-0000de00: 2020 6465 616c 6c6f 6361 7465 2028 7477    deallocate (tw
-0000de10: 735f 6361 7463 685f 6176 675f 646f 6d61  s_catch_avg_doma
-0000de20: 696e 2c20 7477 735f 6f70 7469 5f63 6174  in, tws_opti_cat
-0000de30: 6368 5f61 7667 5f64 6f6d 6169 6e2c 2074  ch_avg_domain, t
-0000de40: 7773 5f6f 6273 5f6d 6173 6b29 0a0a 2020  ws_obs_mask)..  
-0000de50: 2020 2020 6361 6c6c 2074 7773 4f70 7469      call twsOpti
-0000de60: 5369 6d28 6944 6f6d 6169 6e29 2564 6573  Sim(iDomain)%des
-0000de70: 7472 6f79 2829 0a20 2020 2065 6e64 2064  troy().    end d
-0000de80: 6f0a 0a20 2020 2072 6d73 655f 7477 735f  o..    rmse_tws_
-0000de90: 6176 6720 3d20 7375 6d28 726d 7365 5f74  avg = sum(rmse_t
-0000dea0: 7773 283a 292c 2061 6273 2872 6d73 655f  ws(:), abs(rmse_
-0000deb0: 7477 7320 2d20 6e6f 6461 7461 5f64 7029  tws - nodata_dp)
-0000dec0: 202e 6774 2e20 6570 735f 6470 2920 2f20   .gt. eps_dp) / 
-0000ded0: 260a 2020 2020 2020 2020 2020 2020 7265  &.            re
-0000dee0: 616c 2863 6f75 6e74 2861 6273 2872 6d73  al(count(abs(rms
-0000def0: 655f 7477 7320 2d20 6e6f 6461 7461 5f64  e_tws - nodata_d
-0000df00: 7029 202e 6774 2e20 6570 735f 6470 292c  p) .gt. eps_dp),
-0000df10: 2064 7029 0a20 2020 2064 6561 6c6c 6f63   dp).    dealloc
-0000df20: 6174 6528 726d 7365 5f74 7773 290a 2020  ate(rmse_tws).  
-0000df30: 2020 6465 616c 6c6f 6361 7465 2874 7773    deallocate(tws
-0000df40: 4f70 7469 5369 6d29 0a0a 2020 2020 212d  OptiSim)..    !-
-0000df50: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0000df60: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0000df70: 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020  -----------.    
-0000df80: 2121 2052 554e 4f46 460a 2020 2020 212d  !! RUNOFF.    !-
+0000d590: 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020 2121  ---------.    !!
+0000d5a0: 2054 5753 0a20 2020 2021 2d2d 2d2d 2d2d   TWS.    !------
+0000d5b0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+0000d5c0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+0000d5d0: 2d2d 2d2d 2d2d 0a0a 2020 2020 2120 616c  ------..    ! al
+0000d5e0: 6c6f 6361 7465 0a20 2020 2061 6c6c 6f63  locate.    alloc
+0000d5f0: 6174 6528 726d 7365 5f74 7773 2864 6f6d  ate(rmse_tws(dom
+0000d600: 6169 6e4d 6574 6125 6e44 6f6d 6169 6e73  ainMeta%nDomains
+0000d610: 2929 0a20 2020 2072 6d73 655f 7477 7328  )).    rmse_tws(
+0000d620: 3a29 203d 206e 6f64 6174 615f 6470 0a0a  :) = nodata_dp..
+0000d630: 2020 2020 646f 2069 446f 6d61 696e 203d      do iDomain =
+0000d640: 2031 2c20 646f 6d61 696e 4d65 7461 256e   1, domainMeta%n
+0000d650: 446f 6d61 696e 730a 2020 2020 2020 6966  Domains.      if
+0000d660: 2028 2e6e 6f74 2e20 284c 315f 7477 7361   (.not. (L1_twsa
+0000d670: 4f62 7328 6944 6f6d 6169 6e29 2574 696d  Obs(iDomain)%tim
+0000d680: 6553 7465 7049 6e70 7574 203d 3d20 2d32  eStepInput == -2
+0000d690: 2929 2074 6865 6e0a 2020 2020 2020 2020  )) then.        
+0000d6a0: 6361 6c6c 206d 6573 7361 6765 2827 6f62  call message('ob
+0000d6b0: 6a65 6374 6976 655f 6b67 655f 715f 726d  jective_kge_q_rm
+0000d6c0: 7365 5f74 7773 3a20 6375 7272 656e 7420  se_tws: current 
+0000d6d0: 696d 706c 656d 656e 7461 7469 6f6e 206f  implementation o
+0000d6e0: 6620 7468 6973 2073 7562 726f 7574 696e  f this subroutin
+0000d6f0: 6520 6f6e 6c79 2061 6c6c 6f77 7320 6d6f  e only allows mo
+0000d700: 6e74 686c 7920 7469 6d65 7374 6570 7327  nthly timesteps'
+0000d710: 290a 2020 2020 2020 656e 6420 6966 0a20  ).      end if. 
+0000d720: 2020 2020 2064 6f6d 6169 6e49 4420 3d20       domainID = 
+0000d730: 646f 6d61 696e 4d65 7461 2569 6e64 6963  domainMeta%indic
+0000d740: 6573 2869 446f 6d61 696e 290a 0a20 2020  es(iDomain)..   
+0000d750: 2020 2021 2065 7874 7261 6374 2074 7773     ! extract tws
+0000d760: 2074 6865 2073 616d 6520 7761 7920 6173   the same way as
+0000d770: 2072 756e 6f66 6620 7573 696e 6720 6d72   runoff using mr
+0000d780: 6d0a 2020 2020 2020 2120 4e6f 7465 2074  m.      ! Note t
+0000d790: 6861 7420 7769 7468 2074 6865 2063 6861  hat with the cha
+0000d7a0: 6e67 6520 6672 6f6d 2074 7773 2869 446f  nge from tws(iDo
+0000d7b0: 6d61 696e 2c20 7474 2920 746f 2074 7773  main, tt) to tws
+0000d7c0: 2874 742c 203a 2920 7468 6973 0a20 2020  (tt, :) this.   
+0000d7d0: 2020 2021 2077 696c 6c20 6e6f 7420 776f     ! will not wo
+0000d7e0: 726b 206c 696b 6520 6265 666f 7265 2061  rk like before a
+0000d7f0: 6e64 2061 6c73 6f20 646f 6573 206d 6179  nd also does may
+0000d800: 6265 206e 6f74 206d 616b 6520 7365 6e73  be not make sens
+0000d810: 650a 2020 2020 2020 6361 6c6c 2063 7265  e.      call cre
+0000d820: 6174 655f 646f 6d61 696e 5f61 7667 5f74  ate_domain_avg_t
+0000d830: 7773 2869 446f 6d61 696e 2c20 7477 734f  ws(iDomain, twsO
+0000d840: 7074 6953 696d 2c20 7477 735f 6361 7463  ptiSim, tws_catc
+0000d850: 685f 6176 675f 646f 6d61 696e 2c20 7477  h_avg_domain, tw
+0000d860: 735f 6f70 7469 5f63 6174 6368 5f61 7667  s_opti_catch_avg
+0000d870: 5f64 6f6d 6169 6e2c 2074 7773 5f6f 6273  _domain, tws_obs
+0000d880: 5f6d 6173 6b29 0a0a 2020 2020 2020 2120  _mask)..      ! 
+0000d890: 6368 6563 6b20 666f 7220 706f 7465 6e74  check for potent
+0000d8a0: 6961 6c6c 7920 3220 7965 6172 7320 6f66  ially 2 years of
+0000d8b0: 2064 6174 610a 2020 2020 2020 6966 2028   data.      if (
+0000d8c0: 636f 756e 7428 7477 735f 6f62 735f 6d61  count(tws_obs_ma
+0000d8d0: 736b 2920 2e6c 742e 2020 3132 202a 2032  sk) .lt.  12 * 2
+0000d8e0: 2920 7468 656e 0a20 2020 2020 2020 2063  ) then.        c
+0000d8f0: 616c 6c20 6d65 7373 6167 6528 276f 626a  all message('obj
+0000d900: 6563 7469 7665 5f6b 6765 5f71 5f72 6d73  ective_kge_q_rms
+0000d910: 655f 7477 733a 204c 656e 6774 6820 6f66  e_tws: Length of
+0000d920: 2054 5753 2064 6174 6120 6f66 2064 6f6d   TWS data of dom
+0000d930: 6169 6e20 272c 2074 7269 6d28 6164 6a75  ain ', trim(adju
+0000d940: 7374 6c28 6e75 6d32 7374 7228 646f 6d61  stl(num2str(doma
+0000d950: 696e 4944 2929 292c 2026 0a20 2020 2020  inID))), &.     
+0000d960: 2020 2020 2020 2020 2020 2027 206c 6573             ' les
+0000d970: 7320 7468 616e 2032 2079 6561 7273 3a20  s than 2 years: 
+0000d980: 7468 6973 2069 7320 6e6f 7420 7265 636f  this is not reco
+0000d990: 6d6d 656e 6465 6427 290a 2020 2020 2020  mmended').      
+0000d9a0: 656e 6420 6966 0a0a 2020 2020 2020 2120  end if..      ! 
+0000d9b0: 6765 7420 696e 6974 6961 6c20 7469 6d65  get initial time
+0000d9c0: 206f 6620 7468 6520 6576 616c 7561 7469   of the evaluati
+0000d9d0: 6f6e 2070 6572 696f 640a 2020 2020 2020  on period.      
+0000d9e0: 696e 6974 5469 6d65 2869 446f 6d61 696e  initTime(iDomain
+0000d9f0: 2920 3d20 7265 616c 2865 7661 6c50 6572  ) = real(evalPer
+0000da00: 2869 446f 6d61 696e 2925 6a75 6c53 7461  (iDomain)%julSta
+0000da10: 7274 2c20 6470 290a 0a20 2020 2020 2021  rt, dp)..      !
+0000da20: 2067 6574 2063 616c 656e 6461 7220 6461   get calendar da
+0000da30: 7973 2c20 6d6f 6e74 6873 2c20 7965 6172  ys, months, year
+0000da40: 0a20 2020 2020 2063 616c 6c20 6361 6c64  .      call cald
+0000da50: 6174 2869 6e74 2869 6e69 7454 696d 6528  at(int(initTime(
+0000da60: 6944 6f6d 6169 6e29 292c 2079 7920 3d20  iDomain)), yy = 
+0000da70: 7965 6172 2c20 6d6d 203d 206d 6f6e 7468  year, mm = month
+0000da80: 2c20 6464 203d 2064 6179 290a 0a20 2020  , dd = day)..   
+0000da90: 2020 206e 4d6f 6e74 6873 203d 2073 697a     nMonths = siz
+0000daa0: 6528 7477 735f 6f62 735f 6d61 736b 290a  e(tws_obs_mask).
+0000dab0: 0a20 2020 2020 2061 6c6c 6f63 6174 6520  .      allocate 
+0000dac0: 286d 6f6e 7468 5f63 6c61 7373 6573 286e  (month_classes(n
+0000dad0: 4d6f 6e74 6873 2929 0a20 2020 2020 2061  Months)).      a
+0000dae0: 6c6c 6f63 6174 6520 2874 7773 5f6f 6273  llocate (tws_obs
+0000daf0: 5f6d 5f61 6e6f 6d28 6e4d 6f6e 7468 7329  _m_anom(nMonths)
+0000db00: 290a 2020 2020 2020 616c 6c6f 6361 7465  ).      allocate
+0000db10: 2028 7477 735f 7369 6d5f 6d5f 616e 6f6d   (tws_sim_m_anom
+0000db20: 286e 4d6f 6e74 6873 2929 0a0a 2020 2020  (nMonths))..    
+0000db30: 2020 6d6f 6e74 685f 636c 6173 7365 7328    month_classes(
+0000db40: 3a29 203d 2030 0a20 2020 2020 2074 7773  :) = 0.      tws
+0000db50: 5f6f 6273 5f6d 5f61 6e6f 6d28 3a29 203d  _obs_m_anom(:) =
+0000db60: 206e 6f64 6174 615f 6470 0a20 2020 2020   nodata_dp.     
+0000db70: 2074 7773 5f73 696d 5f6d 5f61 6e6f 6d28   tws_sim_m_anom(
+0000db80: 3a29 203d 206e 6f64 6174 615f 6470 0a0a  :) = nodata_dp..
+0000db90: 2020 2020 2020 2120 6465 6669 6e65 206d        ! define m
+0000dba0: 6f6e 7468 7327 2063 6c61 7373 6573 0a20  onths' classes. 
+0000dbb0: 2020 2020 206d 6d6d 203d 206d 6f6e 7468       mmm = month
+0000dbc0: 0a20 2020 2020 2064 6f20 7070 203d 2031  .      do pp = 1
+0000dbd0: 2c20 6e4d 6f6e 7468 730a 2020 2020 2020  , nMonths.      
+0000dbe0: 2020 6d6f 6e74 685f 636c 6173 7365 7328    month_classes(
+0000dbf0: 7070 2920 3d20 6d6d 6d0a 2020 2020 2020  pp) = mmm.      
+0000dc00: 2020 6966 2028 6d6d 6d20 2e4c 542e 2031    if (mmm .LT. 1
+0000dc10: 3229 2074 6865 6e0a 2020 2020 2020 2020  2) then.        
+0000dc20: 2020 6d6d 6d20 3d20 6d6d 6d20 2b20 310a    mmm = mmm + 1.
+0000dc30: 2020 2020 2020 2020 656c 7365 0a20 2020          else.   
+0000dc40: 2020 2020 2020 206d 6d6d 203d 2031 0a20         mmm = 1. 
+0000dc50: 2020 2020 2020 2065 6e64 2069 660a 2020         end if.  
+0000dc60: 2020 2020 656e 6420 646f 0a0a 2020 2020      end do..    
+0000dc70: 2020 2120 6361 6c63 756c 6174 6520 7374    ! calculate st
+0000dc80: 616e 6461 7264 2073 636f 7265 0a20 2020  andard score.   
+0000dc90: 2020 2074 7773 5f6f 6273 5f6d 5f61 6e6f     tws_obs_m_ano
+0000dca0: 6d20 3d20 636c 6173 7369 6669 6564 5f73  m = classified_s
+0000dcb0: 7461 6e64 6172 645f 7363 6f72 6528 7477  tandard_score(tw
+0000dcc0: 735f 6f70 7469 5f63 6174 6368 5f61 7667  s_opti_catch_avg
+0000dcd0: 5f64 6f6d 6169 6e2c 206d 6f6e 7468 5f63  _domain, month_c
+0000dce0: 6c61 7373 6573 2c20 6d61 736b 203d 2074  lasses, mask = t
+0000dcf0: 7773 5f6f 6273 5f6d 6173 6b29 0a20 2020  ws_obs_mask).   
+0000dd00: 2020 2074 7773 5f73 696d 5f6d 5f61 6e6f     tws_sim_m_ano
+0000dd10: 6d20 3d20 636c 6173 7369 6669 6564 5f73  m = classified_s
+0000dd20: 7461 6e64 6172 645f 7363 6f72 6528 7477  tandard_score(tw
+0000dd30: 735f 6361 7463 685f 6176 675f 646f 6d61  s_catch_avg_doma
+0000dd40: 696e 2c20 2020 2020 206d 6f6e 7468 5f63  in,      month_c
+0000dd50: 6c61 7373 6573 2c20 6d61 736b 203d 2074  lasses, mask = t
+0000dd60: 7773 5f6f 6273 5f6d 6173 6b29 0a20 2020  ws_obs_mask).   
+0000dd70: 2020 2072 6d73 655f 7477 7328 6944 6f6d     rmse_tws(iDom
+0000dd80: 6169 6e29 203d 2072 6d73 6528 7477 735f  ain) = rmse(tws_
+0000dd90: 7369 6d5f 6d5f 616e 6f6d 2c20 7477 735f  sim_m_anom, tws_
+0000dda0: 6f62 735f 6d5f 616e 6f6d 2c20 6d61 736b  obs_m_anom, mask
+0000ddb0: 203d 2074 7773 5f6f 6273 5f6d 6173 6b29   = tws_obs_mask)
+0000ddc0: 0a0a 2020 2020 2020 6465 616c 6c6f 6361  ..      dealloca
+0000ddd0: 7465 2028 6d6f 6e74 685f 636c 6173 7365  te (month_classe
+0000dde0: 7329 0a20 2020 2020 2064 6561 6c6c 6f63  s).      dealloc
+0000ddf0: 6174 6520 2874 7773 5f73 696d 5f6d 5f61  ate (tws_sim_m_a
+0000de00: 6e6f 6d29 0a20 2020 2020 2064 6561 6c6c  nom).      deall
+0000de10: 6f63 6174 6520 2874 7773 5f6f 6273 5f6d  ocate (tws_obs_m
+0000de20: 5f61 6e6f 6d29 0a20 2020 2020 2064 6561  _anom).      dea
+0000de30: 6c6c 6f63 6174 6520 2874 7773 5f63 6174  llocate (tws_cat
+0000de40: 6368 5f61 7667 5f64 6f6d 6169 6e2c 2074  ch_avg_domain, t
+0000de50: 7773 5f6f 7074 695f 6361 7463 685f 6176  ws_opti_catch_av
+0000de60: 675f 646f 6d61 696e 2c20 7477 735f 6f62  g_domain, tws_ob
+0000de70: 735f 6d61 736b 290a 0a20 2020 2020 2063  s_mask)..      c
+0000de80: 616c 6c20 7477 734f 7074 6953 696d 2869  all twsOptiSim(i
+0000de90: 446f 6d61 696e 2925 6465 7374 726f 7928  Domain)%destroy(
+0000dea0: 290a 2020 2020 656e 6420 646f 0a0a 2020  ).    end do..  
+0000deb0: 2020 726d 7365 5f74 7773 5f61 7667 203d    rmse_tws_avg =
+0000dec0: 2073 756d 2872 6d73 655f 7477 7328 3a29   sum(rmse_tws(:)
+0000ded0: 2c20 6162 7328 726d 7365 5f74 7773 202d  , abs(rmse_tws -
+0000dee0: 206e 6f64 6174 615f 6470 2920 2e67 742e   nodata_dp) .gt.
+0000def0: 2065 7073 5f64 7029 202f 2026 0a20 2020   eps_dp) / &.   
+0000df00: 2020 2020 2020 2020 2072 6561 6c28 636f           real(co
+0000df10: 756e 7428 6162 7328 726d 7365 5f74 7773  unt(abs(rmse_tws
+0000df20: 202d 206e 6f64 6174 615f 6470 2920 2e67   - nodata_dp) .g
+0000df30: 742e 2065 7073 5f64 7029 2c20 6470 290a  t. eps_dp), dp).
+0000df40: 2020 2020 6465 616c 6c6f 6361 7465 2872      deallocate(r
+0000df50: 6d73 655f 7477 7329 0a20 2020 2064 6561  mse_tws).    dea
+0000df60: 6c6c 6f63 6174 6528 7477 734f 7074 6953  llocate(twsOptiS
+0000df70: 696d 290a 0a20 2020 2021 2d2d 2d2d 2d2d  im)..    !------
+0000df80: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
 0000df90: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0000dfa0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0000dfb0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020  -----------.    
-0000dfc0: 6b67 655f 715f 6176 6720 3d20 305f 6470  kge_q_avg = 0_dp
-0000dfd0: 0a20 2020 206e 4761 7567 6573 546f 7461  .    nGaugesTota
-0000dfe0: 6c20 3d20 7369 7a65 2872 756e 6f66 662c  l = size(runoff,
-0000dff0: 2064 696d 203d 2032 290a 2020 2020 616c   dim = 2).    al
-0000e000: 6c6f 6361 7465 286b 6765 5f71 286e 4761  locate(kge_q(nGa
-0000e010: 7567 6573 546f 7461 6c29 290a 2020 2020  ugesTotal)).    
-0000e020: 6b67 655f 7128 3a29 203d 206e 6f64 6174  kge_q(:) = nodat
-0000e030: 615f 6470 0a0a 2020 2020 646f 2067 6720  a_dp..    do gg 
-0000e040: 3d20 312c 206e 4761 7567 6573 546f 7461  = 1, nGaugesTota
-0000e050: 6c0a 0a20 2020 2020 2021 2065 7874 7261  l..      ! extra
-0000e060: 6374 2072 756e 6f66 660a 2020 2020 2020  ct runoff.      
-0000e070: 6361 6c6c 2065 7874 7261 6374 5f72 756e  call extract_run
-0000e080: 6f66 6628 6767 2c20 7275 6e6f 6666 2c20  off(gg, runoff, 
-0000e090: 7275 6e6f 6666 5f61 6767 2c20 7275 6e6f  runoff_agg, runo
-0000e0a0: 6666 5f6f 6273 2c20 7275 6e6f 6666 5f6f  ff_obs, runoff_o
-0000e0b0: 6273 5f6d 6173 6b29 0a0a 2020 2020 2020  bs_mask)..      
-0000e0c0: 2120 6368 6563 6b20 666f 7220 706f 7465  ! check for pote
-0000e0d0: 6e74 6961 6c6c 7920 3220 7965 6172 7320  ntially 2 years 
-0000e0e0: 6f66 2064 6174 610a 2020 2020 2020 7070  of data.      pp
-0000e0f0: 203d 2063 6f75 6e74 2872 756e 6f66 665f   = count(runoff_
-0000e100: 6167 6720 2e67 652e 2030 2e30 5f64 7029  agg .ge. 0.0_dp)
-0000e110: 0a20 2020 2020 2069 6620 2870 7020 2e6c  .      if (pp .l
-0000e120: 742e 2020 3336 3520 2a20 3229 2074 6865  t.  365 * 2) the
-0000e130: 6e0a 2020 2020 2020 2020 6361 6c6c 206d  n.        call m
-0000e140: 6573 7361 6765 2827 6f62 6a65 6374 6976  essage('objectiv
-0000e150: 655f 6b67 655f 715f 726d 7365 5f74 7773  e_kge_q_rmse_tws
-0000e160: 3a20 5468 6520 7369 6d75 6c61 7469 6f6e  : The simulation
-0000e170: 2061 7420 6761 7567 6520 272c 2074 7269   at gauge ', tri
-0000e180: 6d28 6164 6a75 7374 6c28 6e75 6d32 7374  m(adjustl(num2st
-0000e190: 7228 6767 2929 292c 2026 0a20 2020 2020  r(gg))), &.     
-0000e1a0: 2020 2027 2069 7320 6e6f 7420 6c6f 6e67     ' is not long
-0000e1b0: 2065 6e6f 7567 682e 2050 6c65 6173 6520   enough. Please 
-0000e1c0: 7072 6f76 6964 6520 6174 206c 6561 7374  provide at least
-0000e1d0: 2037 3330 2064 6179 7320 6f66 2064 6174   730 days of dat
-0000e1e0: 612e 2729 0a20 2020 2020 2065 6e64 2069  a.').      end i
-0000e1f0: 660a 2020 2020 2020 2120 6361 6c63 756c  f.      ! calcul
-0000e200: 6174 6520 4b47 4520 666f 7220 6561 6368  ate KGE for each
-0000e210: 2064 6f6d 6169 6e3a 0a20 2020 2020 206b   domain:.      k
-0000e220: 6765 5f71 2867 6729 203d 206b 6765 2872  ge_q(gg) = kge(r
-0000e230: 756e 6f66 665f 6f62 732c 2072 756e 6f66  unoff_obs, runof
-0000e240: 665f 6167 672c 206d 6173 6b20 3d20 7275  f_agg, mask = ru
-0000e250: 6e6f 6666 5f6f 6273 5f6d 6173 6b29 0a20  noff_obs_mask). 
-0000e260: 2020 2020 2064 6561 6c6c 6f63 6174 6520       deallocate 
-0000e270: 2872 756e 6f66 665f 6167 672c 2072 756e  (runoff_agg, run
-0000e280: 6f66 665f 6f62 732c 2072 756e 6f66 665f  off_obs, runoff_
-0000e290: 6f62 735f 6d61 736b 290a 0a20 2020 2065  obs_mask)..    e
-0000e2a0: 6e64 2064 6f0a 0a20 2020 2021 2063 616c  nd do..    ! cal
-0000e2b0: 6375 6c61 7465 2061 7665 7261 6765 204b  culate average K
-0000e2c0: 4745 2076 616c 7565 2066 6f72 2072 756e  GE value for run
-0000e2d0: 6f66 660a 2020 2020 6b67 655f 715f 6176  off.    kge_q_av
-0000e2e0: 6720 3d20 7375 6d28 6b67 655f 7128 3a29  g = sum(kge_q(:)
-0000e2f0: 2c20 6162 7328 6b67 655f 7120 2d20 6e6f  , abs(kge_q - no
-0000e300: 6461 7461 5f64 7029 202e 6774 2e20 6570  data_dp) .gt. ep
-0000e310: 735f 6470 2920 2f20 260a 2020 2020 2020  s_dp) / &.      
-0000e320: 2020 2020 2020 7265 616c 2863 6f75 6e74        real(count
-0000e330: 2861 6273 286b 6765 5f71 202d 206e 6f64  (abs(kge_q - nod
-0000e340: 6174 615f 6470 2920 2e67 742e 2065 7073  ata_dp) .gt. eps
-0000e350: 5f64 7029 2c20 6470 290a 2020 2020 6465  _dp), dp).    de
-0000e360: 616c 6c6f 6361 7465 286b 6765 5f71 290a  allocate(kge_q).
-0000e370: 0a20 2020 2021 0a20 2020 206f 626a 6563  .    !.    objec
-0000e380: 7469 7665 5f6b 6765 5f71 5f72 6d73 655f  tive_kge_q_rmse_
-0000e390: 7477 7320 3d20 726d 7365 5f74 7773 5f61  tws = rmse_tws_a
-0000e3a0: 7667 202a 2028 312e 5f64 7020 2d20 6b67  vg * (1._dp - kg
-0000e3b0: 655f 715f 6176 6729 0a0a 2020 2020 6361  e_q_avg)..    ca
-0000e3c0: 6c6c 206d 6573 7361 6765 2827 2020 2020  ll message('    
-0000e3d0: 6f62 6a65 6374 6976 655f 6b67 655f 715f  objective_kge_q_
-0000e3e0: 726d 7365 5f74 7773 203d 2027 2c20 6e75  rmse_tws = ', nu
-0000e3f0: 6d32 7374 7228 6f62 6a65 6374 6976 655f  m2str(objective_
-0000e400: 6b67 655f 715f 726d 7365 5f74 7773 2c20  kge_q_rmse_tws, 
-0000e410: 2728 4639 2e35 2927 2929 0a0a 2020 454e  '(F9.5)'))..  EN
-0000e420: 4420 4655 4e43 5449 4f4e 206f 626a 6563  D FUNCTION objec
-0000e430: 7469 7665 5f6b 6765 5f71 5f72 6d73 655f  tive_kge_q_rmse_
-0000e440: 7477 730a 0a20 2021 202d 2d2d 2d2d 2d2d  tws..  ! -------
-0000e450: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0000e460: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0000e470: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0000e480: 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 0a20 2021  -----------..  !
-0000e490: 2020 2020 4e41 4d45 0a20 2021 2020 2020      NAME.  !    
-0000e4a0: 2020 2020 6f62 6a65 6374 6976 655f 6e65      objective_ne
-0000e4b0: 7574 726f 6e73 5f6b 6765 5f63 6174 6368  utrons_kge_catch
-0000e4c0: 6d65 6e74 5f61 7667 0a0a 2020 2120 2020  ment_avg..  !   
-0000e4d0: 2050 5552 504f 5345 0a20 2021 3e20 2020   PURPOSE.  !>   
-0000e4e0: 2020 2020 5c62 7269 6566 204f 626a 6563      \brief Objec
-0000e4f0: 7469 7665 2066 756e 6374 696f 6e20 666f  tive function fo
-0000e500: 7220 6e65 7574 726f 6e73 2e0a 0a20 2021  r neutrons...  !
-0000e510: 3e20 2020 2020 2020 5c64 6574 6169 6c73  >       \details
-0000e520: 2054 6865 206f 626a 6563 7469 7665 2066   The objective f
-0000e530: 756e 6374 696f 6e20 6f6e 6c79 2064 6570  unction only dep
-0000e540: 656e 6473 206f 6e20 6120 7061 7261 6d65  ends on a parame
-0000e550: 7465 7220 7665 6374 6f72 2e0a 2020 213e  ter vector..  !>
-0000e560: 2020 2020 2020 2054 6865 206d 6f64 656c         The model
-0000e570: 2077 696c 6c20 6265 2063 616c 6c65 6420   will be called 
-0000e580: 7769 7468 2074 6861 7420 7061 7261 6d65  with that parame
-0000e590: 7465 7220 7665 6374 6f72 2061 6e64 0a20  ter vector and. 
-0000e5a0: 2021 3e20 2020 2020 2020 7468 6520 6d6f   !>       the mo
-0000e5b0: 6465 6c20 6f75 7470 7574 2069 7320 7375  del output is su
-0000e5c0: 6273 6571 7565 6e74 6c79 2063 6f6d 7061  bsequently compa
-0000e5d0: 7265 6420 746f 206f 6273 6572 7665 6420  red to observed 
-0000e5e0: 6461 7461 2e0a 0a20 2021 3e20 2020 2020  data...  !>     
-0000e5f0: 2020 5468 6572 6566 6f72 652c 2074 6865    Therefore, the
-0000e600: 204b 6c69 6e67 2d47 7570 7461 206d 6f64   Kling-Gupta mod
-0000e610: 656c 2065 6666 6963 6965 6e63 7920 5c66  el efficiency \f
-0000e620: 2420 4b47 4520 5c66 2420 6f66 2074 6865  $ KGE \f$ of the
-0000e630: 2063 6174 6368 6d65 6e74 2061 7665 7261   catchment avera
-0000e640: 6765 0a20 2021 3e20 2020 2020 2020 6e65  ge.  !>       ne
-0000e650: 7574 726f 6e73 2028 4e29 2069 7320 6361  utrons (N) is ca
-0000e660: 6c63 756c 6174 6564 0a20 2021 3e20 2020  lculated.  !>   
-0000e670: 2020 2020 5c66 5b20 4b47 4520 3d20 312e      \f[ KGE = 1.
-0000e680: 3020 2d20 5c73 7172 747b 2820 2831 2d72  0 - \sqrt{( (1-r
-0000e690: 295e 3220 2b20 2831 2d5c 616c 7068 6129  )^2 + (1-\alpha)
-0000e6a0: 5e32 202b 2028 312d 5c62 6574 6129 5e32  ^2 + (1-\beta)^2
-0000e6b0: 2029 7d20 5c66 5d0a 2020 213e 2020 2020   )} \f].  !>    
-0000e6c0: 2020 2077 6865 7265 0a20 2021 3e20 2020     where.  !>   
-0000e6d0: 2020 2020 5c66 2420 7220 5c66 2420 3d20      \f$ r \f$ = 
-0000e6e0: 5065 6172 736f 6e20 7072 6f64 7563 742d  Pearson product-
-0000e6f0: 6d6f 6d65 6e74 2043 4f52 5245 4c41 5449  moment CORRELATI
-0000e700: 4f4e 2063 6f65 6666 6963 6965 6e74 0a20  ON coefficient. 
-0000e710: 2021 3e20 2020 2020 2020 5c66 2420 5c61   !>       \f$ \a
-0000e720: 6c70 6861 205c 6624 203d 2072 6174 696f  lpha \f$ = ratio
-0000e730: 206f 6620 7369 6d75 6c61 7465 6420 6d65   of simulated me
-0000e740: 616e 2074 6f20 6f62 7365 7276 6564 206d  an to observed m
-0000e750: 6561 6e20 534d 0a20 2021 3e20 2020 2020  ean SM.  !>     
-0000e760: 2020 5c66 2420 5c62 6574 6120 205c 6624    \f$ \beta  \f$
-0000e770: 203d 2072 6174 696f 206f 6620 7369 6d69   = ratio of simi
-0000e780: 6c61 7465 6420 7374 616e 6461 7264 2064  lated standard d
-0000e790: 6576 6961 7469 6f6e 2074 6f20 6f62 7365  eviation to obse
-0000e7a0: 7276 6564 2073 7461 6e64 6172 6420 6465  rved standard de
-0000e7b0: 7669 6174 696f 6e0a 2020 213e 2020 2020  viation.  !>    
-0000e7c0: 2020 2069 7320 6361 6c63 756c 6174 6564     is calculated
-0000e7d0: 2061 6e64 2074 6865 206f 626a 6563 7469   and the objecti
-0000e7e0: 7665 2066 756e 6374 696f 6e20 666f 7220  ve function for 
-0000e7f0: 6120 6769 7665 6e20 646f 6d61 696e 205c  a given domain \
-0000e800: 6624 2069 205c 6624 2069 730a 2020 213e  f$ i \f$ is.  !>
-0000e810: 2020 2020 2020 205c 665b 205c 7068 695f         \f[ \phi_
-0000e820: 7b69 7d20 3d20 312e 3020 2d20 4b47 455f  {i} = 1.0 - KGE_
-0000e830: 7b69 7d20 5c66 5d0a 2020 213e 2020 2020  {i} \f].  !>    
-0000e840: 2020 205c 6624 205c 7068 695f 7b69 7d20     \f$ \phi_{i} 
-0000e850: 5c66 2420 6973 2074 6865 206f 626a 6563  \f$ is the objec
-0000e860: 7469 7665 2073 696e 6365 2077 6520 616c  tive since we al
-0000e870: 7761 7973 2061 7070 6c79 206d 696e 696d  ways apply minim
-0000e880: 697a 6174 696f 6e20 6d65 7468 6f64 732e  ization methods.
-0000e890: 0a20 2021 3e20 2020 2020 2020 5468 6520  .  !>       The 
-0000e8a0: 6d69 6e69 6d61 6c20 7661 6c75 6520 6f66  minimal value of
-0000e8b0: 205c 6624 205c 7068 695f 7b69 7d20 5c66   \f$ \phi_{i} \f
-0000e8c0: 2420 6973 2030 2066 6f72 2074 6865 206f  $ is 0 for the o
-0000e8d0: 7074 696d 616c 204b 4745 206f 6620 312e  ptimal KGE of 1.
-0000e8e0: 302e 0a0a 2020 213e 2020 2020 2020 2046  0...  !>       F
-0000e8f0: 696e 616c 6c79 2c20 7468 6520 6f76 6572  inally, the over
-0000e900: 616c 6c20 6f62 6a65 6374 6976 6520 6675  all objective fu
-0000e910: 6e63 7469 6f6e 2076 616c 7565 205c 6624  nction value \f$
-0000e920: 204f 4620 5c66 2420 6973 2065 7374 696d   OF \f$ is estim
-0000e930: 6174 6564 2062 6173 6564 206f 6e20 7468  ated based on th
-0000e940: 6520 706f 7765 722d 360a 2020 213e 2020  e power-6.  !>  
-0000e950: 2020 2020 206e 6f72 6d20 746f 2063 6f6d       norm to com
-0000e960: 6269 6e65 2074 6865 205c 6624 205c 7068  bine the \f$ \ph
-0000e970: 695f 7b69 7d20 5c66 2420 6672 6f6d 2061  i_{i} \f$ from a
-0000e980: 6c6c 2064 6f6d 6169 6e73 205c 6624 204e  ll domains \f$ N
-0000e990: 205c 6624 2e0a 2020 213e 2020 2020 2020   \f$..  !>      
-0000e9a0: 205c 665b 204f 4620 3d20 5c73 7172 745b   \f[ OF = \sqrt[
-0000e9b0: 365d 7b5c 7375 6d28 2831 2e30 202d 204b  6]{\sum((1.0 - K
-0000e9c0: 4745 5f7b 697d 292f 4e29 5e36 207d 2e20  GE_{i})/N)^6 }. 
-0000e9d0: 205c 665d 0a20 2021 3e20 2020 2020 2020   \f].  !>       
-0000e9e0: 5468 6520 6f62 7365 7276 6564 2064 6174  The observed dat
-0000e9f0: 6120 4c31 5f6e 6575 7472 6f6e 7364 6174  a L1_neutronsdat
-0000ea00: 612c 204c 315f 6e65 7574 726f 6e73 6461  a, L1_neutronsda
-0000ea10: 7461 5f6d 6173 6b20 6172 6520 676c 6f62  ta_mask are glob
-0000ea20: 616c 2069 6e20 7468 6973 206d 6f64 756c  al in this modul
-0000ea30: 652e 0a0a 2020 2120 2020 2049 4e54 454e  e...  !    INTEN
-0000ea40: 5428 494e 290a 2020 213e 2020 2020 2020  T(IN).  !>      
-0000ea50: 205c 7061 7261 6d5b 696e 5d20 2272 6561   \param[in] "rea
-0000ea60: 6c28 6470 292c 2064 696d 656e 7369 6f6e  l(dp), dimension
-0000ea70: 283a 2920 3a3a 2070 6172 616d 6574 6572  (:) :: parameter
-0000ea80: 7365 7422 0a20 2021 3e20 2020 2020 2020  set".  !>       
-0000ea90: 5c70 6172 616d 5b69 6e5d 2022 7072 6f63  \param[in] "proc
-0000eaa0: 6564 7572 6528 6576 616c 5f69 6e74 6572  edure(eval_inter
-0000eab0: 6661 6365 2920 3a3a 2065 7661 6c22 0a0a  face) :: eval"..
-0000eac0: 2020 2120 2020 2052 4554 5552 4e0a 2020    !    RETURN.  
-0000ead0: 213e 2020 2020 2020 205c 7265 7475 726e  !>       \return
-0000eae0: 2072 6561 6c28 6470 2920 3a3a 206f 626a   real(dp) :: obj
-0000eaf0: 6563 7469 7665 5f6e 6575 7472 6f6e 735f  ective_neutrons_
-0000eb00: 6b67 655f 6361 7463 686d 656e 745f 6176  kge_catchment_av
-0000eb10: 6720 266d 6461 7368 3b20 6f62 6a65 6374  g &mdash; object
-0000eb20: 6976 6520 6675 6e63 7469 6f6e 2076 616c  ive function val
-0000eb30: 7565 0a20 2021 3e20 2020 2020 2020 2877  ue.  !>       (w
-0000eb40: 6869 6368 2077 696c 6c20 6265 2065 2e67  hich will be e.g
-0000eb50: 2e20 6d69 6e69 6d69 7a65 6420 6279 2061  . minimized by a
-0000eb60: 6e20 6f70 7469 6d69 7a61 7469 6f6e 2072  n optimization r
-0000eb70: 6f75 7469 6e65 290a 0a20 2021 2020 2020  outine)..  !    
-0000eb80: 4849 5354 4f52 590a 2020 213e 2020 2020  HISTORY.  !>    
-0000eb90: 2020 205c 6175 7468 6f72 7320 4d61 7274     \authors Mart
-0000eba0: 696e 2053 6368 726f 656e 0a0a 2020 213e  in Schroen..  !>
-0000ebb0: 2020 2020 2020 205c 6461 7465 204a 756e         \date Jun
-0000ebc0: 2032 3031 350a 0a20 2021 204d 6f64 6966   2015..  ! Modif
-0000ebd0: 6963 6174 696f 6e73 3a0a 2020 2120 4d61  ications:.  ! Ma
-0000ebe0: 7265 6e20 4b61 6c75 7a61 204d 6172 2032  ren Kaluza Mar 2
-0000ebf0: 3031 3820 2d20 6368 616e 6765 6420 666f  018 - changed fo
-0000ec00: 726d 6174 2073 7472 696e 6720 746f 2027  rmat string to '
-0000ec10: 2849 3130 2927 0a20 2021 2052 6f62 6572  (I10)'.  ! Rober
-0000ec20: 7420 5363 6877 6570 7065 204a 756e 2032  t Schweppe Jun 2
-0000ec30: 3031 3820 2d20 7265 6661 6374 6f72 696e  018 - refactorin
-0000ec40: 6720 616e 6420 7265 666f 726d 6174 7469  g and reformatti
-0000ec50: 6e67 0a0a 2020 4655 4e43 5449 4f4e 206f  ng..  FUNCTION o
-0000ec60: 626a 6563 7469 7665 5f6e 6575 7472 6f6e  bjective_neutron
-0000ec70: 735f 6b67 655f 6361 7463 686d 656e 745f  s_kge_catchment_
-0000ec80: 6176 6728 7061 7261 6d65 7465 7273 6574  avg(parameterset
-0000ec90: 2c20 6576 616c 290a 0a20 2020 2075 7365  , eval)..    use
-0000eca0: 206d 6f5f 6f70 7469 6d69 7a61 7469 6f6e   mo_optimization
-0000ecb0: 5f74 7970 6573 2c20 6f6e 6c79 203a 206f  _types, only : o
-0000ecc0: 7074 6964 6174 615f 7369 6d0a 2020 2020  ptidata_sim.    
-0000ecd0: 7573 6520 6d6f 5f63 6f6d 6d6f 6e5f 636f  use mo_common_co
-0000ece0: 6e73 7461 6e74 732c 206f 6e6c 7920 3a20  nstants, only : 
-0000ecf0: 6e6f 6461 7461 5f64 700a 2020 2020 7573  nodata_dp.    us
-0000ed00: 6520 6d6f 5f63 6f6d 6d6f 6e5f 7661 7269  e mo_common_vari
-0000ed10: 6162 6c65 732c 206f 6e6c 7920 3a20 646f  ables, only : do
-0000ed20: 6d61 696e 4d65 7461 0a20 2020 2075 7365  mainMeta.    use
-0000ed30: 206d 6f5f 6572 726f 726d 6561 7375 7265   mo_errormeasure
-0000ed40: 732c 206f 6e6c 7920 3a20 4b47 450a 2020  s, only : KGE.  
-0000ed50: 2020 7573 6520 6d6f 5f67 6c6f 6261 6c5f    use mo_global_
-0000ed60: 7661 7269 6162 6c65 732c 206f 6e6c 7920  variables, only 
-0000ed70: 3a20 4c31 5f6e 6575 7472 6f6e 734f 6273  : L1_neutronsObs
-0000ed80: 0a20 2020 2075 7365 206d 6f5f 6d65 7373  .    use mo_mess
-0000ed90: 6167 652c 206f 6e6c 7920 3a20 6d65 7373  age, only : mess
-0000eda0: 6167 650a 2020 2020 7573 6520 6d6f 5f6d  age.    use mo_m
-0000edb0: 6f6d 656e 742c 206f 6e6c 7920 3a20 6176  oment, only : av
-0000edc0: 6572 6167 650a 2020 2020 7573 6520 6d6f  erage.    use mo
-0000edd0: 5f73 7472 696e 675f 7574 696c 732c 206f  _string_utils, o
-0000ede0: 6e6c 7920 3a20 6e75 6d32 7374 720a 0a20  nly : num2str.. 
-0000edf0: 2020 2069 6d70 6c69 6369 7420 6e6f 6e65     implicit none
-0000ee00: 0a0a 2020 2020 7265 616c 2864 7029 2c20  ..    real(dp), 
-0000ee10: 6469 6d65 6e73 696f 6e28 3a29 2c20 696e  dimension(:), in
-0000ee20: 7465 6e74 2869 6e29 203a 3a20 7061 7261  tent(in) :: para
-0000ee30: 6d65 7465 7273 6574 0a0a 2020 2020 7072  meterset..    pr
-0000ee40: 6f63 6564 7572 6528 6576 616c 5f69 6e74  ocedure(eval_int
-0000ee50: 6572 6661 6365 292c 2049 4e54 454e 5428  erface), INTENT(
-0000ee60: 494e 292c 2050 4f49 4e54 4552 203a 3a20  IN), POINTER :: 
-0000ee70: 6576 616c 0a0a 2020 2020 7265 616c 2864  eval..    real(d
-0000ee80: 7029 203a 3a20 6f62 6a65 6374 6976 655f  p) :: objective_
-0000ee90: 6e65 7574 726f 6e73 5f6b 6765 5f63 6174  neutrons_kge_cat
-0000eea0: 6368 6d65 6e74 5f61 7667 0a0a 2020 2020  chment_avg..    
-0000eeb0: 2120 646f 6d61 696e 206c 6f6f 7020 636f  ! domain loop co
-0000eec0: 756e 7465 720a 2020 2020 696e 7465 6765  unter.    intege
-0000eed0: 7228 6934 2920 3a3a 2069 446f 6d61 696e  r(i4) :: iDomain
-0000eee0: 0a0a 2020 2020 2120 7469 6d65 206c 6f6f  ..    ! time loo
-0000eef0: 7020 636f 756e 7465 720a 2020 2020 696e  p counter.    in
-0000ef00: 7465 6765 7228 6934 2920 3a3a 2069 5469  teger(i4) :: iTi
-0000ef10: 6d65 0a0a 2020 2020 2120 666f 7220 7369  me..    ! for si
-0000ef20: 7874 6820 726f 6f74 0a23 6966 6e64 6566  xth root.#ifndef
-0000ef30: 204d 5049 0a20 2020 2072 6561 6c28 6470   MPI.    real(dp
-0000ef40: 292c 2070 6172 616d 6574 6572 203a 3a20  ), parameter :: 
-0000ef50: 6f6e 6573 6978 7468 203d 2031 2e30 5f64  onesixth = 1.0_d
-0000ef60: 7020 2f20 362e 305f 6470 0a23 656e 6469  p / 6.0_dp.#endi
-0000ef70: 660a 0a20 2020 2021 2073 7061 7469 616c  f..    ! spatial
-0000ef80: 2061 7665 7261 6765 206f 6620 6f62 7365   average of obse
-0000ef90: 7276 6564 206e 6575 7472 6f6e 730a 2020  rved neutrons.  
-0000efa0: 2020 7265 616c 2864 7029 2c20 6469 6d65    real(dp), dime
-0000efb0: 6e73 696f 6e28 3a29 2c20 616c 6c6f 6361  nsion(:), alloca
-0000efc0: 7461 626c 6520 3a3a 206e 6575 7472 6f6e  table :: neutron
-0000efd0: 735f 6361 7463 685f 6176 675f 646f 6d61  s_catch_avg_doma
-0000efe0: 696e 0a0a 2020 2020 2120 7370 6174 6961  in..    ! spatia
-0000eff0: 6c20 6176 6572 6761 6520 6f66 206d 6f64  l avergae of mod
-0000f000: 656c 6564 2020 6e65 7574 726f 6e73 0a20  eled  neutrons. 
-0000f010: 2020 2072 6561 6c28 6470 292c 2064 696d     real(dp), dim
-0000f020: 656e 7369 6f6e 283a 292c 2061 6c6c 6f63  ension(:), alloc
-0000f030: 6174 6162 6c65 203a 3a20 6e65 7574 726f  atable :: neutro
-0000f040: 6e73 5f6f 7074 695f 6361 7463 685f 6176  ns_opti_catch_av
-0000f050: 675f 646f 6d61 696e 0a0a 2020 2020 2120  g_domain..    ! 
-0000f060: 7369 6d75 6c61 7465 6420 6e65 7574 726f  simulated neutro
-0000f070: 6e73 0a20 2020 2074 7970 6528 6f70 7469  ns.    type(opti
-0000f080: 6461 7461 5f73 696d 292c 2064 696d 656e  data_sim), dimen
-0000f090: 7369 6f6e 283a 292c 2061 6c6c 6f63 6174  sion(:), allocat
-0000f0a0: 6162 6c65 203a 3a20 6e65 7574 726f 6e73  able :: neutrons
-0000f0b0: 4f70 7469 5369 6d0a 0a20 2020 2021 206d  OptiSim..    ! m
-0000f0c0: 6173 6b20 666f 7220 7661 6c69 6420 6e65  ask for valid ne
-0000f0d0: 7574 726f 6e73 2063 6174 6368 6d65 6e74  utrons catchment
-0000f0e0: 2061 7667 2074 696d 6520 7374 6570 730a   avg time steps.
-0000f0f0: 2020 2020 6c6f 6769 6361 6c2c 2064 696d      logical, dim
-0000f100: 656e 7369 6f6e 283a 292c 2061 6c6c 6f63  ension(:), alloc
-0000f110: 6174 6162 6c65 203a 3a20 6d61 736b 5f74  atable :: mask_t
-0000f120: 696d 6573 0a0a 0a20 2020 2061 6c6c 6f63  imes...    alloc
-0000f130: 6174 6528 6e65 7574 726f 6e73 4f70 7469  ate(neutronsOpti
-0000f140: 5369 6d28 646f 6d61 696e 4d65 7461 256e  Sim(domainMeta%n
-0000f150: 446f 6d61 696e 7329 290a 2020 2020 6361  Domains)).    ca
-0000f160: 6c6c 2065 7661 6c28 7061 7261 6d65 7465  ll eval(paramete
-0000f170: 7273 6574 2c20 6e65 7574 726f 6e73 4f70  rset, neutronsOp
-0000f180: 7469 5369 6d20 3d20 6e65 7574 726f 6e73  tiSim = neutrons
-0000f190: 4f70 7469 5369 6d29 0a0a 2020 2020 2120  OptiSim)..    ! 
-0000f1a0: 696e 6974 6961 6c69 7a65 2073 6f6d 6520  initialize some 
-0000f1b0: 7661 7269 6162 6c65 730a 2020 2020 6f62  variables.    ob
-0000f1c0: 6a65 6374 6976 655f 6e65 7574 726f 6e73  jective_neutrons
-0000f1d0: 5f6b 6765 5f63 6174 6368 6d65 6e74 5f61  _kge_catchment_a
-0000f1e0: 7667 203d 2030 2e30 5f64 700a 0a20 2020  vg = 0.0_dp..   
-0000f1f0: 2021 206c 6f6f 7020 6f76 6572 2064 6f6d   ! loop over dom
-0000f200: 6169 6e20 2d20 666f 7220 6170 706c 7969  ain - for applyi
-0000f210: 6e67 2070 6f77 6572 206c 6177 206c 6174  ng power law lat
-0000f220: 6572 206f 6e0a 2020 2020 646f 2069 446f  er on.    do iDo
-0000f230: 6d61 696e 203d 2031 2c20 646f 6d61 696e  main = 1, domain
-0000f240: 4d65 7461 256e 446f 6d61 696e 730a 0a20  Meta%nDomains.. 
-0000f250: 2020 2020 2021 2061 6c6c 6f63 6174 650a       ! allocate.
-0000f260: 2020 2020 2020 616c 6c6f 6361 7465 286d        allocate(m
-0000f270: 6173 6b5f 7469 6d65 7320 2020 2020 2020  ask_times       
-0000f280: 2020 2020 2020 2020 2020 2020 2028 7369               (si
-0000f290: 7a65 286e 6575 7472 6f6e 734f 7074 6953  ze(neutronsOptiS
-0000f2a0: 696d 2869 446f 6d61 696e 2925 6461 7461  im(iDomain)%data
-0000f2b0: 5369 6d2c 2064 696d 203d 2032 2929 290a  Sim, dim = 2))).
-0000f2c0: 2020 2020 2020 616c 6c6f 6361 7465 286e        allocate(n
-0000f2d0: 6575 7472 6f6e 735f 6361 7463 685f 6176  eutrons_catch_av
-0000f2e0: 675f 646f 6d61 696e 2020 2020 2028 7369  g_domain     (si
-0000f2f0: 7a65 286e 6575 7472 6f6e 734f 7074 6953  ze(neutronsOptiS
-0000f300: 696d 2869 446f 6d61 696e 2925 6461 7461  im(iDomain)%data
-0000f310: 5369 6d2c 2064 696d 203d 2032 2929 290a  Sim, dim = 2))).
-0000f320: 2020 2020 2020 616c 6c6f 6361 7465 286e        allocate(n
-0000f330: 6575 7472 6f6e 735f 6f70 7469 5f63 6174  eutrons_opti_cat
-0000f340: 6368 5f61 7667 5f64 6f6d 6169 6e28 7369  ch_avg_domain(si
-0000f350: 7a65 286e 6575 7472 6f6e 734f 7074 6953  ze(neutronsOptiS
-0000f360: 696d 2869 446f 6d61 696e 2925 6461 7461  im(iDomain)%data
-0000f370: 5369 6d2c 2064 696d 203d 2032 2929 290a  Sim, dim = 2))).
-0000f380: 0a20 2020 2020 2021 2069 6e69 7461 6c69  .      ! initali
-0000f390: 7a65 0a20 2020 2020 206d 6173 6b5f 7469  ze.      mask_ti
-0000f3a0: 6d65 7320 3d20 2e54 5255 452e 0a20 2020  mes = .TRUE..   
-0000f3b0: 2020 206e 6575 7472 6f6e 735f 6361 7463     neutrons_catc
-0000f3c0: 685f 6176 675f 646f 6d61 696e 203d 206e  h_avg_domain = n
-0000f3d0: 6f64 6174 615f 6470 0a20 2020 2020 206e  odata_dp.      n
-0000f3e0: 6575 7472 6f6e 735f 6f70 7469 5f63 6174  eutrons_opti_cat
-0000f3f0: 6368 5f61 7667 5f64 6f6d 6169 6e20 3d20  ch_avg_domain = 
-0000f400: 6e6f 6461 7461 5f64 700a 0a20 2020 2020  nodata_dp..     
-0000f410: 2021 2063 616c 6375 6c61 7465 2063 6174   ! calculate cat
-0000f420: 6368 6d65 6e74 2061 7665 7261 6765 2073  chment average s
-0000f430: 6f69 6c20 6d6f 6973 7475 7265 0a20 2020  oil moisture.   
-0000f440: 2020 2064 6f20 6954 696d 6520 3d20 312c     do iTime = 1,
-0000f450: 2073 697a 6528 6e65 7574 726f 6e73 4f70   size(neutronsOp
-0000f460: 7469 5369 6d28 6944 6f6d 6169 6e29 2564  tiSim(iDomain)%d
-0000f470: 6174 6153 696d 2c20 6469 6d20 3d20 3229  ataSim, dim = 2)
-0000f480: 0a0a 2020 2020 2020 2020 2120 6368 6563  ..        ! chec
-0000f490: 6b20 666f 7220 656e 6f75 6768 2064 6174  k for enough dat
-0000f4a0: 6120 706f 696e 7473 2069 6e20 7469 6d65  a points in time
-0000f4b0: 2066 6f72 2063 6f72 7265 6c61 7469 6f6e   for correlation
-0000f4c0: 0a20 2020 2020 2020 2069 6620 2861 6c6c  .        if (all
-0000f4d0: 282e 4e4f 542e 204c 315f 6e65 7574 726f  (.NOT. L1_neutro
-0000f4e0: 6e73 4f62 7328 6944 6f6d 6169 6e29 256d  nsObs(iDomain)%m
-0000f4f0: 6173 6b4f 6273 283a 2c20 6954 696d 6529  askObs(:, iTime)
-0000f500: 2929 2074 6865 6e0a 2020 2020 2020 2020  )) then.        
-0000f510: 2020 6361 6c6c 206d 6573 7361 6765 2827    call message('
-0000f520: 5741 524e 494e 473a 206e 6575 7472 6f6e  WARNING: neutron
-0000f530: 7320 6461 7461 2061 7420 7469 6d65 2027  s data at time '
-0000f540: 2c20 6e75 6d32 7374 7228 6954 696d 652c  , num2str(iTime,
-0000f550: 2027 2849 3130 2927 292c 2027 2069 7320   '(I10)'), ' is 
-0000f560: 656d 7074 792e 2729 0a20 2020 2020 2020  empty.').       
-0000f570: 2020 2021 6361 6c6c 206d 6573 7361 6765     !call message
-0000f580: 2827 5741 524e 494e 473a 206f 626a 6563  ('WARNING: objec
-0000f590: 7469 7665 5f6e 6575 7472 6f6e 735f 6b67  tive_neutrons_kg
-0000f5a0: 655f 6361 7463 686d 656e 745f 6176 673a  e_catchment_avg:
-0000f5b0: 2069 676e 6f72 6564 2063 7572 7265 6e74   ignored current
-0000f5c0: 2074 696d 6520 7374 6570 2073 696e 6365   time step since
-0000f5d0: 206c 6573 7320 7468 616e 2729 0a20 2020   less than').   
-0000f5e0: 2020 2020 2020 2021 6361 6c6c 206d 6573         !call mes
-0000f5f0: 7361 6765 2827 2020 2020 2020 2020 2031  sage('         1
-0000f600: 3020 7661 6c69 6420 6365 6c6c 7320 6176  0 valid cells av
-0000f610: 6169 6c61 626c 6520 696e 2073 6f69 6c20  ailable in soil 
-0000f620: 6d6f 6973 7475 7265 206f 6273 6572 7661  moisture observa
-0000f630: 7469 6f6e 2729 0a20 2020 2020 2020 2020  tion').         
-0000f640: 206d 6173 6b5f 7469 6d65 7328 6954 696d   mask_times(iTim
-0000f650: 6529 203d 202e 4641 4c53 452e 0a20 2020  e) = .FALSE..   
-0000f660: 2020 2020 2020 2063 7963 6c65 0a20 2020         cycle.   
-0000f670: 2020 2020 2065 6e64 2069 660a 2020 2020       end if.    
-0000f680: 2020 2020 6e65 7574 726f 6e73 5f63 6174      neutrons_cat
-0000f690: 6368 5f61 7667 5f64 6f6d 6169 6e28 6954  ch_avg_domain(iT
-0000f6a0: 696d 6529 203d 2061 7665 7261 6765 284c  ime) = average(L
-0000f6b0: 315f 6e65 7574 726f 6e73 4f62 7328 6944  1_neutronsObs(iD
-0000f6c0: 6f6d 6169 6e29 2564 6174 614f 6273 283a  omain)%dataObs(:
-0000f6d0: 2c20 6954 696d 6529 2c20 260a 2020 2020  , iTime), &.    
-0000f6e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dfa0: 2d2d 2d2d 2d2d 0a20 2020 2021 2120 5255  ------.    !! RU
+0000dfb0: 4e4f 4646 0a20 2020 2021 2d2d 2d2d 2d2d  NOFF.    !------
+0000dfc0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+0000dfd0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+0000dfe0: 2d2d 2d2d 2d2d 0a20 2020 206b 6765 5f71  ------.    kge_q
+0000dff0: 5f61 7667 203d 2030 5f64 700a 2020 2020  _avg = 0_dp.    
+0000e000: 6e47 6175 6765 7354 6f74 616c 203d 2073  nGaugesTotal = s
+0000e010: 697a 6528 7275 6e6f 6666 2c20 6469 6d20  ize(runoff, dim 
+0000e020: 3d20 3229 0a20 2020 2061 6c6c 6f63 6174  = 2).    allocat
+0000e030: 6528 6b67 655f 7128 6e47 6175 6765 7354  e(kge_q(nGaugesT
+0000e040: 6f74 616c 2929 0a20 2020 206b 6765 5f71  otal)).    kge_q
+0000e050: 283a 2920 3d20 6e6f 6461 7461 5f64 700a  (:) = nodata_dp.
+0000e060: 0a20 2020 2064 6f20 6767 203d 2031 2c20  .    do gg = 1, 
+0000e070: 6e47 6175 6765 7354 6f74 616c 0a0a 2020  nGaugesTotal..  
+0000e080: 2020 2020 2120 6578 7472 6163 7420 7275      ! extract ru
+0000e090: 6e6f 6666 0a20 2020 2020 2063 616c 6c20  noff.      call 
+0000e0a0: 6578 7472 6163 745f 7275 6e6f 6666 2867  extract_runoff(g
+0000e0b0: 672c 2072 756e 6f66 662c 2072 756e 6f66  g, runoff, runof
+0000e0c0: 665f 6167 672c 2072 756e 6f66 665f 6f62  f_agg, runoff_ob
+0000e0d0: 732c 2072 756e 6f66 665f 6f62 735f 6d61  s, runoff_obs_ma
+0000e0e0: 736b 290a 0a20 2020 2020 2021 2063 6865  sk)..      ! che
+0000e0f0: 636b 2066 6f72 2070 6f74 656e 7469 616c  ck for potential
+0000e100: 6c79 2032 2079 6561 7273 206f 6620 6461  ly 2 years of da
+0000e110: 7461 0a20 2020 2020 2070 7020 3d20 636f  ta.      pp = co
+0000e120: 756e 7428 7275 6e6f 6666 5f61 6767 202e  unt(runoff_agg .
+0000e130: 6765 2e20 302e 305f 6470 290a 2020 2020  ge. 0.0_dp).    
+0000e140: 2020 6966 2028 7070 202e 6c74 2e20 2033    if (pp .lt.  3
+0000e150: 3635 202a 2032 2920 7468 656e 0a20 2020  65 * 2) then.   
+0000e160: 2020 2020 2063 616c 6c20 6d65 7373 6167       call messag
+0000e170: 6528 276f 626a 6563 7469 7665 5f6b 6765  e('objective_kge
+0000e180: 5f71 5f72 6d73 655f 7477 733a 2054 6865  _q_rmse_tws: The
+0000e190: 2073 696d 756c 6174 696f 6e20 6174 2067   simulation at g
+0000e1a0: 6175 6765 2027 2c20 7472 696d 2861 646a  auge ', trim(adj
+0000e1b0: 7573 746c 286e 756d 3273 7472 2867 6729  ustl(num2str(gg)
+0000e1c0: 2929 2c20 260a 2020 2020 2020 2020 2720  )), &.        ' 
+0000e1d0: 6973 206e 6f74 206c 6f6e 6720 656e 6f75  is not long enou
+0000e1e0: 6768 2e20 506c 6561 7365 2070 726f 7669  gh. Please provi
+0000e1f0: 6465 2061 7420 6c65 6173 7420 3733 3020  de at least 730 
+0000e200: 6461 7973 206f 6620 6461 7461 2e27 290a  days of data.').
+0000e210: 2020 2020 2020 656e 6420 6966 0a20 2020        end if.   
+0000e220: 2020 2021 2063 616c 6375 6c61 7465 204b     ! calculate K
+0000e230: 4745 2066 6f72 2065 6163 6820 646f 6d61  GE for each doma
+0000e240: 696e 3a0a 2020 2020 2020 6b67 655f 7128  in:.      kge_q(
+0000e250: 6767 2920 3d20 6b67 6528 7275 6e6f 6666  gg) = kge(runoff
+0000e260: 5f6f 6273 2c20 7275 6e6f 6666 5f61 6767  _obs, runoff_agg
+0000e270: 2c20 6d61 736b 203d 2072 756e 6f66 665f  , mask = runoff_
+0000e280: 6f62 735f 6d61 736b 290a 2020 2020 2020  obs_mask).      
+0000e290: 6465 616c 6c6f 6361 7465 2028 7275 6e6f  deallocate (runo
+0000e2a0: 6666 5f61 6767 2c20 7275 6e6f 6666 5f6f  ff_agg, runoff_o
+0000e2b0: 6273 2c20 7275 6e6f 6666 5f6f 6273 5f6d  bs, runoff_obs_m
+0000e2c0: 6173 6b29 0a0a 2020 2020 656e 6420 646f  ask)..    end do
+0000e2d0: 0a0a 2020 2020 2120 6361 6c63 756c 6174  ..    ! calculat
+0000e2e0: 6520 6176 6572 6167 6520 4b47 4520 7661  e average KGE va
+0000e2f0: 6c75 6520 666f 7220 7275 6e6f 6666 0a20  lue for runoff. 
+0000e300: 2020 206b 6765 5f71 5f61 7667 203d 2073     kge_q_avg = s
+0000e310: 756d 286b 6765 5f71 283a 292c 2061 6273  um(kge_q(:), abs
+0000e320: 286b 6765 5f71 202d 206e 6f64 6174 615f  (kge_q - nodata_
+0000e330: 6470 2920 2e67 742e 2065 7073 5f64 7029  dp) .gt. eps_dp)
+0000e340: 202f 2026 0a20 2020 2020 2020 2020 2020   / &.           
+0000e350: 2072 6561 6c28 636f 756e 7428 6162 7328   real(count(abs(
+0000e360: 6b67 655f 7120 2d20 6e6f 6461 7461 5f64  kge_q - nodata_d
+0000e370: 7029 202e 6774 2e20 6570 735f 6470 292c  p) .gt. eps_dp),
+0000e380: 2064 7029 0a20 2020 2064 6561 6c6c 6f63   dp).    dealloc
+0000e390: 6174 6528 6b67 655f 7129 0a0a 2020 2020  ate(kge_q)..    
+0000e3a0: 210a 2020 2020 6f62 6a65 6374 6976 655f  !.    objective_
+0000e3b0: 6b67 655f 715f 726d 7365 5f74 7773 203d  kge_q_rmse_tws =
+0000e3c0: 2072 6d73 655f 7477 735f 6176 6720 2a20   rmse_tws_avg * 
+0000e3d0: 2831 2e5f 6470 202d 206b 6765 5f71 5f61  (1._dp - kge_q_a
+0000e3e0: 7667 290a 0a20 2020 2063 616c 6c20 6d65  vg)..    call me
+0000e3f0: 7373 6167 6528 2720 2020 206f 626a 6563  ssage('    objec
+0000e400: 7469 7665 5f6b 6765 5f71 5f72 6d73 655f  tive_kge_q_rmse_
+0000e410: 7477 7320 3d20 272c 206e 756d 3273 7472  tws = ', num2str
+0000e420: 286f 626a 6563 7469 7665 5f6b 6765 5f71  (objective_kge_q
+0000e430: 5f72 6d73 655f 7477 732c 2027 2846 392e  _rmse_tws, '(F9.
+0000e440: 3529 2729 290a 0a20 2045 4e44 2046 554e  5)'))..  END FUN
+0000e450: 4354 494f 4e20 6f62 6a65 6374 6976 655f  CTION objective_
+0000e460: 6b67 655f 715f 726d 7365 5f74 7773 0a0a  kge_q_rmse_tws..
+0000e470: 2020 2120 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d    ! ------------
+0000e480: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+0000e490: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+0000e4a0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+0000e4b0: 2d2d 2d2d 2d2d 0a0a 2020 2120 2020 204e  ------..  !    N
+0000e4c0: 414d 450a 2020 2120 2020 2020 2020 206f  AME.  !        o
+0000e4d0: 626a 6563 7469 7665 5f6e 6575 7472 6f6e  bjective_neutron
+0000e4e0: 735f 6b67 655f 6361 7463 686d 656e 745f  s_kge_catchment_
+0000e4f0: 6176 670a 0a20 2021 2020 2020 5055 5250  avg..  !    PURP
+0000e500: 4f53 450a 2020 213e 2020 2020 2020 205c  OSE.  !>       \
+0000e510: 6272 6965 6620 4f62 6a65 6374 6976 6520  brief Objective 
+0000e520: 6675 6e63 7469 6f6e 2066 6f72 206e 6575  function for neu
+0000e530: 7472 6f6e 732e 0a0a 2020 213e 2020 2020  trons...  !>    
+0000e540: 2020 205c 6465 7461 696c 7320 5468 6520     \details The 
+0000e550: 6f62 6a65 6374 6976 6520 6675 6e63 7469  objective functi
+0000e560: 6f6e 206f 6e6c 7920 6465 7065 6e64 7320  on only depends 
+0000e570: 6f6e 2061 2070 6172 616d 6574 6572 2076  on a parameter v
+0000e580: 6563 746f 722e 0a20 2021 3e20 2020 2020  ector..  !>     
+0000e590: 2020 5468 6520 6d6f 6465 6c20 7769 6c6c    The model will
+0000e5a0: 2062 6520 6361 6c6c 6564 2077 6974 6820   be called with 
+0000e5b0: 7468 6174 2070 6172 616d 6574 6572 2076  that parameter v
+0000e5c0: 6563 746f 7220 616e 640a 2020 213e 2020  ector and.  !>  
+0000e5d0: 2020 2020 2074 6865 206d 6f64 656c 206f       the model o
+0000e5e0: 7574 7075 7420 6973 2073 7562 7365 7175  utput is subsequ
+0000e5f0: 656e 746c 7920 636f 6d70 6172 6564 2074  ently compared t
+0000e600: 6f20 6f62 7365 7276 6564 2064 6174 612e  o observed data.
+0000e610: 0a0a 2020 213e 2020 2020 2020 2054 6865  ..  !>       The
+0000e620: 7265 666f 7265 2c20 7468 6520 4b6c 696e  refore, the Klin
+0000e630: 672d 4775 7074 6120 6d6f 6465 6c20 6566  g-Gupta model ef
+0000e640: 6669 6369 656e 6379 205c 6624 204b 4745  ficiency \f$ KGE
+0000e650: 205c 6624 206f 6620 7468 6520 6361 7463   \f$ of the catc
+0000e660: 686d 656e 7420 6176 6572 6167 650a 2020  hment average.  
+0000e670: 213e 2020 2020 2020 206e 6575 7472 6f6e  !>       neutron
+0000e680: 7320 284e 2920 6973 2063 616c 6375 6c61  s (N) is calcula
+0000e690: 7465 640a 2020 213e 2020 2020 2020 205c  ted.  !>       \
+0000e6a0: 665b 204b 4745 203d 2031 2e30 202d 205c  f[ KGE = 1.0 - \
+0000e6b0: 7371 7274 7b28 2028 312d 7229 5e32 202b  sqrt{( (1-r)^2 +
+0000e6c0: 2028 312d 5c61 6c70 6861 295e 3220 2b20   (1-\alpha)^2 + 
+0000e6d0: 2831 2d5c 6265 7461 295e 3220 297d 205c  (1-\beta)^2 )} \
+0000e6e0: 665d 0a20 2021 3e20 2020 2020 2020 7768  f].  !>       wh
+0000e6f0: 6572 650a 2020 213e 2020 2020 2020 205c  ere.  !>       \
+0000e700: 6624 2072 205c 6624 203d 2050 6561 7273  f$ r \f$ = Pears
+0000e710: 6f6e 2070 726f 6475 6374 2d6d 6f6d 656e  on product-momen
+0000e720: 7420 434f 5252 454c 4154 494f 4e20 636f  t CORRELATION co
+0000e730: 6566 6669 6369 656e 740a 2020 213e 2020  efficient.  !>  
+0000e740: 2020 2020 205c 6624 205c 616c 7068 6120       \f$ \alpha 
+0000e750: 5c66 2420 3d20 7261 7469 6f20 6f66 2073  \f$ = ratio of s
+0000e760: 696d 756c 6174 6564 206d 6561 6e20 746f  imulated mean to
+0000e770: 206f 6273 6572 7665 6420 6d65 616e 2053   observed mean S
+0000e780: 4d0a 2020 213e 2020 2020 2020 205c 6624  M.  !>       \f$
+0000e790: 205c 6265 7461 2020 5c66 2420 3d20 7261   \beta  \f$ = ra
+0000e7a0: 7469 6f20 6f66 2073 696d 696c 6174 6564  tio of similated
+0000e7b0: 2073 7461 6e64 6172 6420 6465 7669 6174   standard deviat
+0000e7c0: 696f 6e20 746f 206f 6273 6572 7665 6420  ion to observed 
+0000e7d0: 7374 616e 6461 7264 2064 6576 6961 7469  standard deviati
+0000e7e0: 6f6e 0a20 2021 3e20 2020 2020 2020 6973  on.  !>       is
+0000e7f0: 2063 616c 6375 6c61 7465 6420 616e 6420   calculated and 
+0000e800: 7468 6520 6f62 6a65 6374 6976 6520 6675  the objective fu
+0000e810: 6e63 7469 6f6e 2066 6f72 2061 2067 6976  nction for a giv
+0000e820: 656e 2064 6f6d 6169 6e20 5c66 2420 6920  en domain \f$ i 
+0000e830: 5c66 2420 6973 0a20 2021 3e20 2020 2020  \f$ is.  !>     
+0000e840: 2020 5c66 5b20 5c70 6869 5f7b 697d 203d    \f[ \phi_{i} =
+0000e850: 2031 2e30 202d 204b 4745 5f7b 697d 205c   1.0 - KGE_{i} \
+0000e860: 665d 0a20 2021 3e20 2020 2020 2020 5c66  f].  !>       \f
+0000e870: 2420 5c70 6869 5f7b 697d 205c 6624 2069  $ \phi_{i} \f$ i
+0000e880: 7320 7468 6520 6f62 6a65 6374 6976 6520  s the objective 
+0000e890: 7369 6e63 6520 7765 2061 6c77 6179 7320  since we always 
+0000e8a0: 6170 706c 7920 6d69 6e69 6d69 7a61 7469  apply minimizati
+0000e8b0: 6f6e 206d 6574 686f 6473 2e0a 2020 213e  on methods..  !>
+0000e8c0: 2020 2020 2020 2054 6865 206d 696e 696d         The minim
+0000e8d0: 616c 2076 616c 7565 206f 6620 5c66 2420  al value of \f$ 
+0000e8e0: 5c70 6869 5f7b 697d 205c 6624 2069 7320  \phi_{i} \f$ is 
+0000e8f0: 3020 666f 7220 7468 6520 6f70 7469 6d61  0 for the optima
+0000e900: 6c20 4b47 4520 6f66 2031 2e30 2e0a 0a20  l KGE of 1.0... 
+0000e910: 2021 3e20 2020 2020 2020 4669 6e61 6c6c   !>       Finall
+0000e920: 792c 2074 6865 206f 7665 7261 6c6c 206f  y, the overall o
+0000e930: 626a 6563 7469 7665 2066 756e 6374 696f  bjective functio
+0000e940: 6e20 7661 6c75 6520 5c66 2420 4f46 205c  n value \f$ OF \
+0000e950: 6624 2069 7320 6573 7469 6d61 7465 6420  f$ is estimated 
+0000e960: 6261 7365 6420 6f6e 2074 6865 2070 6f77  based on the pow
+0000e970: 6572 2d36 0a20 2021 3e20 2020 2020 2020  er-6.  !>       
+0000e980: 6e6f 726d 2074 6f20 636f 6d62 696e 6520  norm to combine 
+0000e990: 7468 6520 5c66 2420 5c70 6869 5f7b 697d  the \f$ \phi_{i}
+0000e9a0: 205c 6624 2066 726f 6d20 616c 6c20 646f   \f$ from all do
+0000e9b0: 6d61 696e 7320 5c66 2420 4e20 5c66 242e  mains \f$ N \f$.
+0000e9c0: 0a20 2021 3e20 2020 2020 2020 5c66 5b20  .  !>       \f[ 
+0000e9d0: 4f46 203d 205c 7371 7274 5b36 5d7b 5c73  OF = \sqrt[6]{\s
+0000e9e0: 756d 2828 312e 3020 2d20 4b47 455f 7b69  um((1.0 - KGE_{i
+0000e9f0: 7d29 2f4e 295e 3620 7d2e 2020 5c66 5d0a  })/N)^6 }.  \f].
+0000ea00: 2020 213e 2020 2020 2020 2054 6865 206f    !>       The o
+0000ea10: 6273 6572 7665 6420 6461 7461 204c 315f  bserved data L1_
+0000ea20: 6e65 7574 726f 6e73 6461 7461 2c20 4c31  neutronsdata, L1
+0000ea30: 5f6e 6575 7472 6f6e 7364 6174 615f 6d61  _neutronsdata_ma
+0000ea40: 736b 2061 7265 2067 6c6f 6261 6c20 696e  sk are global in
+0000ea50: 2074 6869 7320 6d6f 6475 6c65 2e0a 0a20   this module... 
+0000ea60: 2021 2020 2020 494e 5445 4e54 2849 4e29   !    INTENT(IN)
+0000ea70: 0a20 2021 3e20 2020 2020 2020 5c70 6172  .  !>       \par
+0000ea80: 616d 5b69 6e5d 2022 7265 616c 2864 7029  am[in] "real(dp)
+0000ea90: 2c20 6469 6d65 6e73 696f 6e28 3a29 203a  , dimension(:) :
+0000eaa0: 3a20 7061 7261 6d65 7465 7273 6574 220a  : parameterset".
+0000eab0: 2020 213e 2020 2020 2020 205c 7061 7261    !>       \para
+0000eac0: 6d5b 696e 5d20 2270 726f 6365 6475 7265  m[in] "procedure
+0000ead0: 2865 7661 6c5f 696e 7465 7266 6163 6529  (eval_interface)
+0000eae0: 203a 3a20 6576 616c 220a 0a20 2021 2020   :: eval"..  !  
+0000eaf0: 2020 5245 5455 524e 0a20 2021 3e20 2020    RETURN.  !>   
+0000eb00: 2020 2020 5c72 6574 7572 6e20 7265 616c      \return real
+0000eb10: 2864 7029 203a 3a20 6f62 6a65 6374 6976  (dp) :: objectiv
+0000eb20: 655f 6e65 7574 726f 6e73 5f6b 6765 5f63  e_neutrons_kge_c
+0000eb30: 6174 6368 6d65 6e74 5f61 7667 2026 6d64  atchment_avg &md
+0000eb40: 6173 683b 206f 626a 6563 7469 7665 2066  ash; objective f
+0000eb50: 756e 6374 696f 6e20 7661 6c75 650a 2020  unction value.  
+0000eb60: 213e 2020 2020 2020 2028 7768 6963 6820  !>       (which 
+0000eb70: 7769 6c6c 2062 6520 652e 672e 206d 696e  will be e.g. min
+0000eb80: 696d 697a 6564 2062 7920 616e 206f 7074  imized by an opt
+0000eb90: 696d 697a 6174 696f 6e20 726f 7574 696e  imization routin
+0000eba0: 6529 0a0a 2020 2120 2020 2048 4953 544f  e)..  !    HISTO
+0000ebb0: 5259 0a20 2021 3e20 2020 2020 2020 5c61  RY.  !>       \a
+0000ebc0: 7574 686f 7273 204d 6172 7469 6e20 5363  uthors Martin Sc
+0000ebd0: 6872 6f65 6e0a 0a20 2021 3e20 2020 2020  hroen..  !>     
+0000ebe0: 2020 5c64 6174 6520 4a75 6e20 3230 3135    \date Jun 2015
+0000ebf0: 0a0a 2020 2120 4d6f 6469 6669 6361 7469  ..  ! Modificati
+0000ec00: 6f6e 733a 0a20 2021 204d 6172 656e 204b  ons:.  ! Maren K
+0000ec10: 616c 757a 6120 4d61 7220 3230 3138 202d  aluza Mar 2018 -
+0000ec20: 2063 6861 6e67 6564 2066 6f72 6d61 7420   changed format 
+0000ec30: 7374 7269 6e67 2074 6f20 2728 4931 3029  string to '(I10)
+0000ec40: 270a 2020 2120 526f 6265 7274 2053 6368  '.  ! Robert Sch
+0000ec50: 7765 7070 6520 4a75 6e20 3230 3138 202d  weppe Jun 2018 -
+0000ec60: 2072 6566 6163 746f 7269 6e67 2061 6e64   refactoring and
+0000ec70: 2072 6566 6f72 6d61 7474 696e 670a 0a20   reformatting.. 
+0000ec80: 2046 554e 4354 494f 4e20 6f62 6a65 6374   FUNCTION object
+0000ec90: 6976 655f 6e65 7574 726f 6e73 5f6b 6765  ive_neutrons_kge
+0000eca0: 5f63 6174 6368 6d65 6e74 5f61 7667 2870  _catchment_avg(p
+0000ecb0: 6172 616d 6574 6572 7365 742c 2065 7661  arameterset, eva
+0000ecc0: 6c29 0a0a 2020 2020 7573 6520 6d6f 5f6f  l)..    use mo_o
+0000ecd0: 7074 696d 697a 6174 696f 6e5f 7479 7065  ptimization_type
+0000ece0: 732c 206f 6e6c 7920 3a20 6f70 7469 6461  s, only : optida
+0000ecf0: 7461 5f73 696d 0a20 2020 2075 7365 206d  ta_sim.    use m
+0000ed00: 6f5f 636f 6d6d 6f6e 5f63 6f6e 7374 616e  o_common_constan
+0000ed10: 7473 2c20 6f6e 6c79 203a 206e 6f64 6174  ts, only : nodat
+0000ed20: 615f 6470 0a20 2020 2075 7365 206d 6f5f  a_dp.    use mo_
+0000ed30: 636f 6d6d 6f6e 5f76 6172 6961 626c 6573  common_variables
+0000ed40: 2c20 6f6e 6c79 203a 2064 6f6d 6169 6e4d  , only : domainM
+0000ed50: 6574 610a 2020 2020 7573 6520 6d6f 5f65  eta.    use mo_e
+0000ed60: 7272 6f72 6d65 6173 7572 6573 2c20 6f6e  rrormeasures, on
+0000ed70: 6c79 203a 204b 4745 0a20 2020 2075 7365  ly : KGE.    use
+0000ed80: 206d 6f5f 676c 6f62 616c 5f76 6172 6961   mo_global_varia
+0000ed90: 626c 6573 2c20 6f6e 6c79 203a 204c 315f  bles, only : L1_
+0000eda0: 6e65 7574 726f 6e73 4f62 730a 2020 2020  neutronsObs.    
+0000edb0: 7573 6520 6d6f 5f6d 6f6d 656e 742c 206f  use mo_moment, o
+0000edc0: 6e6c 7920 3a20 6176 6572 6167 650a 2020  nly : average.  
+0000edd0: 2020 7573 6520 6d6f 5f73 7472 696e 675f    use mo_string_
+0000ede0: 7574 696c 732c 206f 6e6c 7920 3a20 6e75  utils, only : nu
+0000edf0: 6d32 7374 720a 0a20 2020 2069 6d70 6c69  m2str..    impli
+0000ee00: 6369 7420 6e6f 6e65 0a0a 2020 2020 7265  cit none..    re
+0000ee10: 616c 2864 7029 2c20 6469 6d65 6e73 696f  al(dp), dimensio
+0000ee20: 6e28 3a29 2c20 696e 7465 6e74 2869 6e29  n(:), intent(in)
+0000ee30: 203a 3a20 7061 7261 6d65 7465 7273 6574   :: parameterset
+0000ee40: 0a0a 2020 2020 7072 6f63 6564 7572 6528  ..    procedure(
+0000ee50: 6576 616c 5f69 6e74 6572 6661 6365 292c  eval_interface),
+0000ee60: 2049 4e54 454e 5428 494e 292c 2050 4f49   INTENT(IN), POI
+0000ee70: 4e54 4552 203a 3a20 6576 616c 0a0a 2020  NTER :: eval..  
+0000ee80: 2020 7265 616c 2864 7029 203a 3a20 6f62    real(dp) :: ob
+0000ee90: 6a65 6374 6976 655f 6e65 7574 726f 6e73  jective_neutrons
+0000eea0: 5f6b 6765 5f63 6174 6368 6d65 6e74 5f61  _kge_catchment_a
+0000eeb0: 7667 0a0a 2020 2020 2120 646f 6d61 696e  vg..    ! domain
+0000eec0: 206c 6f6f 7020 636f 756e 7465 720a 2020   loop counter.  
+0000eed0: 2020 696e 7465 6765 7228 6934 2920 3a3a    integer(i4) ::
+0000eee0: 2069 446f 6d61 696e 0a0a 2020 2020 2120   iDomain..    ! 
+0000eef0: 7469 6d65 206c 6f6f 7020 636f 756e 7465  time loop counte
+0000ef00: 720a 2020 2020 696e 7465 6765 7228 6934  r.    integer(i4
+0000ef10: 2920 3a3a 2069 5469 6d65 0a0a 2020 2020  ) :: iTime..    
+0000ef20: 2120 666f 7220 7369 7874 6820 726f 6f74  ! for sixth root
+0000ef30: 0a23 6966 6e64 6566 204d 5049 0a20 2020  .#ifndef MPI.   
+0000ef40: 2072 6561 6c28 6470 292c 2070 6172 616d   real(dp), param
+0000ef50: 6574 6572 203a 3a20 6f6e 6573 6978 7468  eter :: onesixth
+0000ef60: 203d 2031 2e30 5f64 7020 2f20 362e 305f   = 1.0_dp / 6.0_
+0000ef70: 6470 0a23 656e 6469 660a 0a20 2020 2021  dp.#endif..    !
+0000ef80: 2073 7061 7469 616c 2061 7665 7261 6765   spatial average
+0000ef90: 206f 6620 6f62 7365 7276 6564 206e 6575   of observed neu
+0000efa0: 7472 6f6e 730a 2020 2020 7265 616c 2864  trons.    real(d
+0000efb0: 7029 2c20 6469 6d65 6e73 696f 6e28 3a29  p), dimension(:)
+0000efc0: 2c20 616c 6c6f 6361 7461 626c 6520 3a3a  , allocatable ::
+0000efd0: 206e 6575 7472 6f6e 735f 6361 7463 685f   neutrons_catch_
+0000efe0: 6176 675f 646f 6d61 696e 0a0a 2020 2020  avg_domain..    
+0000eff0: 2120 7370 6174 6961 6c20 6176 6572 6761  ! spatial averga
+0000f000: 6520 6f66 206d 6f64 656c 6564 2020 6e65  e of modeled  ne
+0000f010: 7574 726f 6e73 0a20 2020 2072 6561 6c28  utrons.    real(
+0000f020: 6470 292c 2064 696d 656e 7369 6f6e 283a  dp), dimension(:
+0000f030: 292c 2061 6c6c 6f63 6174 6162 6c65 203a  ), allocatable :
+0000f040: 3a20 6e65 7574 726f 6e73 5f6f 7074 695f  : neutrons_opti_
+0000f050: 6361 7463 685f 6176 675f 646f 6d61 696e  catch_avg_domain
+0000f060: 0a0a 2020 2020 2120 7369 6d75 6c61 7465  ..    ! simulate
+0000f070: 6420 6e65 7574 726f 6e73 0a20 2020 2074  d neutrons.    t
+0000f080: 7970 6528 6f70 7469 6461 7461 5f73 696d  ype(optidata_sim
+0000f090: 292c 2064 696d 656e 7369 6f6e 283a 292c  ), dimension(:),
+0000f0a0: 2061 6c6c 6f63 6174 6162 6c65 203a 3a20   allocatable :: 
+0000f0b0: 6e65 7574 726f 6e73 4f70 7469 5369 6d0a  neutronsOptiSim.
+0000f0c0: 0a20 2020 2021 206d 6173 6b20 666f 7220  .    ! mask for 
+0000f0d0: 7661 6c69 6420 6e65 7574 726f 6e73 2063  valid neutrons c
+0000f0e0: 6174 6368 6d65 6e74 2061 7667 2074 696d  atchment avg tim
+0000f0f0: 6520 7374 6570 730a 2020 2020 6c6f 6769  e steps.    logi
+0000f100: 6361 6c2c 2064 696d 656e 7369 6f6e 283a  cal, dimension(:
+0000f110: 292c 2061 6c6c 6f63 6174 6162 6c65 203a  ), allocatable :
+0000f120: 3a20 6d61 736b 5f74 696d 6573 0a0a 0a20  : mask_times... 
+0000f130: 2020 2061 6c6c 6f63 6174 6528 6e65 7574     allocate(neut
+0000f140: 726f 6e73 4f70 7469 5369 6d28 646f 6d61  ronsOptiSim(doma
+0000f150: 696e 4d65 7461 256e 446f 6d61 696e 7329  inMeta%nDomains)
+0000f160: 290a 2020 2020 6361 6c6c 2065 7661 6c28  ).    call eval(
+0000f170: 7061 7261 6d65 7465 7273 6574 2c20 6e65  parameterset, ne
+0000f180: 7574 726f 6e73 4f70 7469 5369 6d20 3d20  utronsOptiSim = 
+0000f190: 6e65 7574 726f 6e73 4f70 7469 5369 6d29  neutronsOptiSim)
+0000f1a0: 0a0a 2020 2020 2120 696e 6974 6961 6c69  ..    ! initiali
+0000f1b0: 7a65 2073 6f6d 6520 7661 7269 6162 6c65  ze some variable
+0000f1c0: 730a 2020 2020 6f62 6a65 6374 6976 655f  s.    objective_
+0000f1d0: 6e65 7574 726f 6e73 5f6b 6765 5f63 6174  neutrons_kge_cat
+0000f1e0: 6368 6d65 6e74 5f61 7667 203d 2030 2e30  chment_avg = 0.0
+0000f1f0: 5f64 700a 0a20 2020 2021 206c 6f6f 7020  _dp..    ! loop 
+0000f200: 6f76 6572 2064 6f6d 6169 6e20 2d20 666f  over domain - fo
+0000f210: 7220 6170 706c 7969 6e67 2070 6f77 6572  r applying power
+0000f220: 206c 6177 206c 6174 6572 206f 6e0a 2020   law later on.  
+0000f230: 2020 646f 2069 446f 6d61 696e 203d 2031    do iDomain = 1
+0000f240: 2c20 646f 6d61 696e 4d65 7461 256e 446f  , domainMeta%nDo
+0000f250: 6d61 696e 730a 0a20 2020 2020 2021 2061  mains..      ! a
+0000f260: 6c6c 6f63 6174 650a 2020 2020 2020 616c  llocate.      al
+0000f270: 6c6f 6361 7465 286d 6173 6b5f 7469 6d65  locate(mask_time
+0000f280: 7320 2020 2020 2020 2020 2020 2020 2020  s               
+0000f290: 2020 2020 2028 7369 7a65 286e 6575 7472       (size(neutr
+0000f2a0: 6f6e 734f 7074 6953 696d 2869 446f 6d61  onsOptiSim(iDoma
+0000f2b0: 696e 2925 6461 7461 5369 6d2c 2064 696d  in)%dataSim, dim
+0000f2c0: 203d 2032 2929 290a 2020 2020 2020 616c   = 2))).      al
+0000f2d0: 6c6f 6361 7465 286e 6575 7472 6f6e 735f  locate(neutrons_
+0000f2e0: 6361 7463 685f 6176 675f 646f 6d61 696e  catch_avg_domain
+0000f2f0: 2020 2020 2028 7369 7a65 286e 6575 7472       (size(neutr
+0000f300: 6f6e 734f 7074 6953 696d 2869 446f 6d61  onsOptiSim(iDoma
+0000f310: 696e 2925 6461 7461 5369 6d2c 2064 696d  in)%dataSim, dim
+0000f320: 203d 2032 2929 290a 2020 2020 2020 616c   = 2))).      al
+0000f330: 6c6f 6361 7465 286e 6575 7472 6f6e 735f  locate(neutrons_
+0000f340: 6f70 7469 5f63 6174 6368 5f61 7667 5f64  opti_catch_avg_d
+0000f350: 6f6d 6169 6e28 7369 7a65 286e 6575 7472  omain(size(neutr
+0000f360: 6f6e 734f 7074 6953 696d 2869 446f 6d61  onsOptiSim(iDoma
+0000f370: 696e 2925 6461 7461 5369 6d2c 2064 696d  in)%dataSim, dim
+0000f380: 203d 2032 2929 290a 0a20 2020 2020 2021   = 2)))..      !
+0000f390: 2069 6e69 7461 6c69 7a65 0a20 2020 2020   initalize.     
+0000f3a0: 206d 6173 6b5f 7469 6d65 7320 3d20 2e54   mask_times = .T
+0000f3b0: 5255 452e 0a20 2020 2020 206e 6575 7472  RUE..      neutr
+0000f3c0: 6f6e 735f 6361 7463 685f 6176 675f 646f  ons_catch_avg_do
+0000f3d0: 6d61 696e 203d 206e 6f64 6174 615f 6470  main = nodata_dp
+0000f3e0: 0a20 2020 2020 206e 6575 7472 6f6e 735f  .      neutrons_
+0000f3f0: 6f70 7469 5f63 6174 6368 5f61 7667 5f64  opti_catch_avg_d
+0000f400: 6f6d 6169 6e20 3d20 6e6f 6461 7461 5f64  omain = nodata_d
+0000f410: 700a 0a20 2020 2020 2021 2063 616c 6375  p..      ! calcu
+0000f420: 6c61 7465 2063 6174 6368 6d65 6e74 2061  late catchment a
+0000f430: 7665 7261 6765 2073 6f69 6c20 6d6f 6973  verage soil mois
+0000f440: 7475 7265 0a20 2020 2020 2064 6f20 6954  ture.      do iT
+0000f450: 696d 6520 3d20 312c 2073 697a 6528 6e65  ime = 1, size(ne
+0000f460: 7574 726f 6e73 4f70 7469 5369 6d28 6944  utronsOptiSim(iD
+0000f470: 6f6d 6169 6e29 2564 6174 6153 696d 2c20  omain)%dataSim, 
+0000f480: 6469 6d20 3d20 3229 0a0a 2020 2020 2020  dim = 2)..      
+0000f490: 2020 2120 6368 6563 6b20 666f 7220 656e    ! check for en
+0000f4a0: 6f75 6768 2064 6174 6120 706f 696e 7473  ough data points
+0000f4b0: 2069 6e20 7469 6d65 2066 6f72 2063 6f72   in time for cor
+0000f4c0: 7265 6c61 7469 6f6e 0a20 2020 2020 2020  relation.       
+0000f4d0: 2069 6620 2861 6c6c 282e 4e4f 542e 204c   if (all(.NOT. L
+0000f4e0: 315f 6e65 7574 726f 6e73 4f62 7328 6944  1_neutronsObs(iD
+0000f4f0: 6f6d 6169 6e29 256d 6173 6b4f 6273 283a  omain)%maskObs(:
+0000f500: 2c20 6954 696d 6529 2929 2074 6865 6e0a  , iTime))) then.
+0000f510: 2020 2020 2020 2020 2020 6361 6c6c 206d            call m
+0000f520: 6573 7361 6765 2827 5741 524e 494e 473a  essage('WARNING:
+0000f530: 206e 6575 7472 6f6e 7320 6461 7461 2061   neutrons data a
+0000f540: 7420 7469 6d65 2027 2c20 6e75 6d32 7374  t time ', num2st
+0000f550: 7228 6954 696d 652c 2027 2849 3130 2927  r(iTime, '(I10)'
+0000f560: 292c 2027 2069 7320 656d 7074 792e 2729  ), ' is empty.')
+0000f570: 0a20 2020 2020 2020 2020 2021 6361 6c6c  .          !call
+0000f580: 206d 6573 7361 6765 2827 5741 524e 494e   message('WARNIN
+0000f590: 473a 206f 626a 6563 7469 7665 5f6e 6575  G: objective_neu
+0000f5a0: 7472 6f6e 735f 6b67 655f 6361 7463 686d  trons_kge_catchm
+0000f5b0: 656e 745f 6176 673a 2069 676e 6f72 6564  ent_avg: ignored
+0000f5c0: 2063 7572 7265 6e74 2074 696d 6520 7374   current time st
+0000f5d0: 6570 2073 696e 6365 206c 6573 7320 7468  ep since less th
+0000f5e0: 616e 2729 0a20 2020 2020 2020 2020 2021  an').          !
+0000f5f0: 6361 6c6c 206d 6573 7361 6765 2827 2020  call message('  
+0000f600: 2020 2020 2020 2031 3020 7661 6c69 6420         10 valid 
+0000f610: 6365 6c6c 7320 6176 6169 6c61 626c 6520  cells available 
+0000f620: 696e 2073 6f69 6c20 6d6f 6973 7475 7265  in soil moisture
+0000f630: 206f 6273 6572 7661 7469 6f6e 2729 0a20   observation'). 
+0000f640: 2020 2020 2020 2020 206d 6173 6b5f 7469           mask_ti
+0000f650: 6d65 7328 6954 696d 6529 203d 202e 4641  mes(iTime) = .FA
+0000f660: 4c53 452e 0a20 2020 2020 2020 2020 2063  LSE..          c
+0000f670: 7963 6c65 0a20 2020 2020 2020 2065 6e64  ycle.        end
+0000f680: 2069 660a 2020 2020 2020 2020 6e65 7574   if.        neut
+0000f690: 726f 6e73 5f63 6174 6368 5f61 7667 5f64  rons_catch_avg_d
+0000f6a0: 6f6d 6169 6e28 6954 696d 6529 203d 2061  omain(iTime) = a
+0000f6b0: 7665 7261 6765 284c 315f 6e65 7574 726f  verage(L1_neutro
+0000f6c0: 6e73 4f62 7328 6944 6f6d 6169 6e29 2564  nsObs(iDomain)%d
+0000f6d0: 6174 614f 6273 283a 2c20 6954 696d 6529  ataObs(:, iTime)
+0000f6e0: 2c20 260a 2020 2020 2020 2020 2020 2020  , &.            
 0000f6f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f700: 2020 2020 2020 2020 6d61 736b 203d 204c          mask = L
-0000f710: 315f 6e65 7574 726f 6e73 4f62 7328 6944  1_neutronsObs(iD
-0000f720: 6f6d 6169 6e29 256d 6173 6b4f 6273 283a  omain)%maskObs(:
-0000f730: 2c20 6954 696d 6529 290a 2020 2020 2020  , iTime)).      
-0000f740: 2020 6e65 7574 726f 6e73 5f6f 7074 695f    neutrons_opti_
-0000f750: 6361 7463 685f 6176 675f 646f 6d61 696e  catch_avg_domain
-0000f760: 2869 5469 6d65 2920 3d20 6176 6572 6167  (iTime) = averag
-0000f770: 6528 6e65 7574 726f 6e73 4f70 7469 5369  e(neutronsOptiSi
-0000f780: 6d28 6944 6f6d 6169 6e29 2564 6174 6153  m(iDomain)%dataS
-0000f790: 696d 283a 2c20 6954 696d 6529 2c20 260a  im(:, iTime), &.
-0000f7a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f700: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f710: 6d61 736b 203d 204c 315f 6e65 7574 726f  mask = L1_neutro
+0000f720: 6e73 4f62 7328 6944 6f6d 6169 6e29 256d  nsObs(iDomain)%m
+0000f730: 6173 6b4f 6273 283a 2c20 6954 696d 6529  askObs(:, iTime)
+0000f740: 290a 2020 2020 2020 2020 6e65 7574 726f  ).        neutro
+0000f750: 6e73 5f6f 7074 695f 6361 7463 685f 6176  ns_opti_catch_av
+0000f760: 675f 646f 6d61 696e 2869 5469 6d65 2920  g_domain(iTime) 
+0000f770: 3d20 6176 6572 6167 6528 6e65 7574 726f  = average(neutro
+0000f780: 6e73 4f70 7469 5369 6d28 6944 6f6d 6169  nsOptiSim(iDomai
+0000f790: 6e29 2564 6174 6153 696d 283a 2c20 6954  n)%dataSim(:, iT
+0000f7a0: 696d 6529 2c20 260a 2020 2020 2020 2020  ime), &.        
 0000f7b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f7c0: 2020 2020 2020 2020 206d 6173 6b20 3d20           mask = 
-0000f7d0: 4c31 5f6e 6575 7472 6f6e 734f 6273 2869  L1_neutronsObs(i
-0000f7e0: 446f 6d61 696e 2925 6d61 736b 4f62 7328  Domain)%maskObs(
-0000f7f0: 3a2c 2069 5469 6d65 2929 0a20 2020 2020  :, iTime)).     
-0000f800: 2065 6e64 2064 6f0a 0a20 2020 2020 2021   end do..      !
-0000f810: 2063 616c 6375 6c61 7465 2061 7665 7261   calculate avera
-0000f820: 6765 206e 6575 7472 6f6e 7320 4b47 4520  ge neutrons KGE 
-0000f830: 6f76 6572 2061 6c6c 2064 6f6d 6169 6e73  over all domains
-0000f840: 2077 6974 6820 706f 7765 7220 6c61 770a   with power law.
-0000f850: 2020 2020 2020 2120 646f 6d61 696e 7320        ! domains 
-0000f860: 6172 6520 7765 6967 6874 6564 2065 7175  are weighted equ
-0000f870: 616c 6c79 2028 2031 202f 2072 6561 6c28  ally ( 1 / real(
-0000f880: 646f 6d61 696e 4d65 7461 256f 7665 7261  domainMeta%overa
-0000f890: 6c6c 4e75 6d62 6572 4f66 446f 6d61 696e  llNumberOfDomain
-0000f8a0: 732c 6470 2929 2a2a 360a 2020 2020 2020  s,dp))**6.      
-0000f8b0: 6f62 6a65 6374 6976 655f 6e65 7574 726f  objective_neutro
-0000f8c0: 6e73 5f6b 6765 5f63 6174 6368 6d65 6e74  ns_kge_catchment
-0000f8d0: 5f61 7667 203d 206f 626a 6563 7469 7665  _avg = objective
-0000f8e0: 5f6e 6575 7472 6f6e 735f 6b67 655f 6361  _neutrons_kge_ca
-0000f8f0: 7463 686d 656e 745f 6176 6720 2b20 260a  tchment_avg + &.
-0000f900: 2020 2020 2020 2020 2828 312e 305f 6470          ((1.0_dp
-0000f910: 202d 204b 4745 286e 6575 7472 6f6e 735f   - KGE(neutrons_
-0000f920: 6361 7463 685f 6176 675f 646f 6d61 696e  catch_avg_domain
-0000f930: 2c20 6e65 7574 726f 6e73 5f6f 7074 695f  , neutrons_opti_
-0000f940: 6361 7463 685f 6176 675f 646f 6d61 696e  catch_avg_domain
-0000f950: 2c20 6d61 736b 203d 206d 6173 6b5f 7469  , mask = mask_ti
-0000f960: 6d65 7329 2920 2f20 260a 2020 2020 2020  mes)) / &.      
-0000f970: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f7c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f7d0: 206d 6173 6b20 3d20 4c31 5f6e 6575 7472   mask = L1_neutr
+0000f7e0: 6f6e 734f 6273 2869 446f 6d61 696e 2925  onsObs(iDomain)%
+0000f7f0: 6d61 736b 4f62 7328 3a2c 2069 5469 6d65  maskObs(:, iTime
+0000f800: 2929 0a20 2020 2020 2065 6e64 2064 6f0a  )).      end do.
+0000f810: 0a20 2020 2020 2021 2063 616c 6375 6c61  .      ! calcula
+0000f820: 7465 2061 7665 7261 6765 206e 6575 7472  te average neutr
+0000f830: 6f6e 7320 4b47 4520 6f76 6572 2061 6c6c  ons KGE over all
+0000f840: 2064 6f6d 6169 6e73 2077 6974 6820 706f   domains with po
+0000f850: 7765 7220 6c61 770a 2020 2020 2020 2120  wer law.      ! 
+0000f860: 646f 6d61 696e 7320 6172 6520 7765 6967  domains are weig
+0000f870: 6874 6564 2065 7175 616c 6c79 2028 2031  hted equally ( 1
+0000f880: 202f 2072 6561 6c28 646f 6d61 696e 4d65   / real(domainMe
+0000f890: 7461 256f 7665 7261 6c6c 4e75 6d62 6572  ta%overallNumber
+0000f8a0: 4f66 446f 6d61 696e 732c 6470 2929 2a2a  OfDomains,dp))**
+0000f8b0: 360a 2020 2020 2020 6f62 6a65 6374 6976  6.      objectiv
+0000f8c0: 655f 6e65 7574 726f 6e73 5f6b 6765 5f63  e_neutrons_kge_c
+0000f8d0: 6174 6368 6d65 6e74 5f61 7667 203d 206f  atchment_avg = o
+0000f8e0: 626a 6563 7469 7665 5f6e 6575 7472 6f6e  bjective_neutron
+0000f8f0: 735f 6b67 655f 6361 7463 686d 656e 745f  s_kge_catchment_
+0000f900: 6176 6720 2b20 260a 2020 2020 2020 2020  avg + &.        
+0000f910: 2828 312e 305f 6470 202d 204b 4745 286e  ((1.0_dp - KGE(n
+0000f920: 6575 7472 6f6e 735f 6361 7463 685f 6176  eutrons_catch_av
+0000f930: 675f 646f 6d61 696e 2c20 6e65 7574 726f  g_domain, neutro
+0000f940: 6e73 5f6f 7074 695f 6361 7463 685f 6176  ns_opti_catch_av
+0000f950: 675f 646f 6d61 696e 2c20 6d61 736b 203d  g_domain, mask =
+0000f960: 206d 6173 6b5f 7469 6d65 7329 2920 2f20   mask_times)) / 
+0000f970: 260a 2020 2020 2020 2020 2020 2020 2020  &.              
 0000f980: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000f990: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000f9a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f9b0: 7265 616c 2864 6f6d 6169 6e4d 6574 6125  real(domainMeta%
-0000f9c0: 6f76 6572 616c 6c4e 756d 6265 724f 6644  overallNumberOfD
-0000f9d0: 6f6d 6169 6e73 2c20 6470 2929 2a2a 360a  omains, dp))**6.
-0000f9e0: 0a20 2020 2020 2021 2064 6561 6c6c 6f63  .      ! dealloc
-0000f9f0: 6174 650a 2020 2020 2020 6465 616c 6c6f  ate.      deallo
-0000fa00: 6361 7465 286d 6173 6b5f 7469 6d65 7329  cate(mask_times)
-0000fa10: 0a20 2020 2020 2064 6561 6c6c 6f63 6174  .      deallocat
-0000fa20: 6528 6e65 7574 726f 6e73 5f63 6174 6368  e(neutrons_catch
-0000fa30: 5f61 7667 5f64 6f6d 6169 6e29 0a20 2020  _avg_domain).   
-0000fa40: 2020 2064 6561 6c6c 6f63 6174 6528 6e65     deallocate(ne
-0000fa50: 7574 726f 6e73 5f6f 7074 695f 6361 7463  utrons_opti_catc
-0000fa60: 685f 6176 675f 646f 6d61 696e 290a 0a20  h_avg_domain).. 
-0000fa70: 2020 2020 2063 616c 6c20 6e65 7574 726f       call neutro
-0000fa80: 6e73 4f70 7469 5369 6d28 6944 6f6d 6169  nsOptiSim(iDomai
-0000fa90: 6e29 2564 6573 7472 6f79 2829 0a20 2020  n)%destroy().   
-0000faa0: 2065 6e64 2064 6f0a 2020 2020 6465 616c   end do.    deal
-0000fab0: 6c6f 6361 7465 286e 6575 7472 6f6e 734f  locate(neutronsO
-0000fac0: 7074 6953 696d 290a 0a23 6966 6e64 6566  ptiSim)..#ifndef
-0000fad0: 204d 5049 0a20 2020 206f 626a 6563 7469   MPI.    objecti
-0000fae0: 7665 5f6e 6575 7472 6f6e 735f 6b67 655f  ve_neutrons_kge_
-0000faf0: 6361 7463 686d 656e 745f 6176 6720 3d20  catchment_avg = 
-0000fb00: 6f62 6a65 6374 6976 655f 6e65 7574 726f  objective_neutro
-0000fb10: 6e73 5f6b 6765 5f63 6174 6368 6d65 6e74  ns_kge_catchment
-0000fb20: 5f61 7667 2a2a 6f6e 6573 6978 7468 0a0a  _avg**onesixth..
-0000fb30: 2020 2020 6361 6c6c 206d 6573 7361 6765      call message
-0000fb40: 2827 2020 2020 6f62 6a65 6374 6976 655f  ('    objective_
-0000fb50: 6e65 7574 726f 6e73 5f6b 6765 5f63 6174  neutrons_kge_cat
-0000fb60: 6368 6d65 6e74 5f61 7667 203d 2027 2c20  chment_avg = ', 
-0000fb70: 6e75 6d32 7374 7228 6f62 6a65 6374 6976  num2str(objectiv
-0000fb80: 655f 6e65 7574 726f 6e73 5f6b 6765 5f63  e_neutrons_kge_c
-0000fb90: 6174 6368 6d65 6e74 5f61 7667 2c20 2728  atchment_avg, '(
-0000fba0: 4639 2e35 2927 2929 0a23 656e 6469 660a  F9.5)')).#endif.
-0000fbb0: 0a20 2045 4e44 2046 554e 4354 494f 4e20  .  END FUNCTION 
-0000fbc0: 6f62 6a65 6374 6976 655f 6e65 7574 726f  objective_neutro
-0000fbd0: 6e73 5f6b 6765 5f63 6174 6368 6d65 6e74  ns_kge_catchment
-0000fbe0: 5f61 7667 0a0a 2020 2120 2d2d 2d2d 2d2d  _avg..  ! ------
-0000fbf0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+0000f9b0: 2020 2020 2020 2020 7265 616c 2864 6f6d          real(dom
+0000f9c0: 6169 6e4d 6574 6125 6f76 6572 616c 6c4e  ainMeta%overallN
+0000f9d0: 756d 6265 724f 6644 6f6d 6169 6e73 2c20  umberOfDomains, 
+0000f9e0: 6470 2929 2a2a 360a 0a20 2020 2020 2021  dp))**6..      !
+0000f9f0: 2064 6561 6c6c 6f63 6174 650a 2020 2020   deallocate.    
+0000fa00: 2020 6465 616c 6c6f 6361 7465 286d 6173    deallocate(mas
+0000fa10: 6b5f 7469 6d65 7329 0a20 2020 2020 2064  k_times).      d
+0000fa20: 6561 6c6c 6f63 6174 6528 6e65 7574 726f  eallocate(neutro
+0000fa30: 6e73 5f63 6174 6368 5f61 7667 5f64 6f6d  ns_catch_avg_dom
+0000fa40: 6169 6e29 0a20 2020 2020 2064 6561 6c6c  ain).      deall
+0000fa50: 6f63 6174 6528 6e65 7574 726f 6e73 5f6f  ocate(neutrons_o
+0000fa60: 7074 695f 6361 7463 685f 6176 675f 646f  pti_catch_avg_do
+0000fa70: 6d61 696e 290a 0a20 2020 2020 2063 616c  main)..      cal
+0000fa80: 6c20 6e65 7574 726f 6e73 4f70 7469 5369  l neutronsOptiSi
+0000fa90: 6d28 6944 6f6d 6169 6e29 2564 6573 7472  m(iDomain)%destr
+0000faa0: 6f79 2829 0a20 2020 2065 6e64 2064 6f0a  oy().    end do.
+0000fab0: 2020 2020 6465 616c 6c6f 6361 7465 286e      deallocate(n
+0000fac0: 6575 7472 6f6e 734f 7074 6953 696d 290a  eutronsOptiSim).
+0000fad0: 0a23 6966 6e64 6566 204d 5049 0a20 2020  .#ifndef MPI.   
+0000fae0: 206f 626a 6563 7469 7665 5f6e 6575 7472   objective_neutr
+0000faf0: 6f6e 735f 6b67 655f 6361 7463 686d 656e  ons_kge_catchmen
+0000fb00: 745f 6176 6720 3d20 6f62 6a65 6374 6976  t_avg = objectiv
+0000fb10: 655f 6e65 7574 726f 6e73 5f6b 6765 5f63  e_neutrons_kge_c
+0000fb20: 6174 6368 6d65 6e74 5f61 7667 2a2a 6f6e  atchment_avg**on
+0000fb30: 6573 6978 7468 0a0a 2020 2020 6361 6c6c  esixth..    call
+0000fb40: 206d 6573 7361 6765 2827 2020 2020 6f62   message('    ob
+0000fb50: 6a65 6374 6976 655f 6e65 7574 726f 6e73  jective_neutrons
+0000fb60: 5f6b 6765 5f63 6174 6368 6d65 6e74 5f61  _kge_catchment_a
+0000fb70: 7667 203d 2027 2c20 6e75 6d32 7374 7228  vg = ', num2str(
+0000fb80: 6f62 6a65 6374 6976 655f 6e65 7574 726f  objective_neutro
+0000fb90: 6e73 5f6b 6765 5f63 6174 6368 6d65 6e74  ns_kge_catchment
+0000fba0: 5f61 7667 2c20 2728 4639 2e35 2927 2929  _avg, '(F9.5)'))
+0000fbb0: 0a23 656e 6469 660a 0a20 2045 4e44 2046  .#endif..  END F
+0000fbc0: 554e 4354 494f 4e20 6f62 6a65 6374 6976  UNCTION objectiv
+0000fbd0: 655f 6e65 7574 726f 6e73 5f6b 6765 5f63  e_neutrons_kge_c
+0000fbe0: 6174 6368 6d65 6e74 5f61 7667 0a0a 2020  atchment_avg..  
+0000fbf0: 2120 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ! --------------
 0000fc00: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
 0000fc10: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0000fc20: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a0a 2020  ------------..  
-0000fc30: 2120 2020 204e 414d 450a 2020 2120 2020  !    NAME.  !   
-0000fc40: 2020 2020 206f 626a 6563 7469 7665 5f65       objective_e
-0000fc50: 745f 6b67 655f 6361 7463 686d 656e 745f  t_kge_catchment_
-0000fc60: 6176 670a 0a20 2021 2020 2020 5055 5250  avg..  !    PURP
-0000fc70: 4f53 450a 2020 213e 2020 2020 2020 205c  OSE.  !>       \
-0000fc80: 6272 6965 6620 4f62 6a65 6374 6976 6520  brief Objective 
-0000fc90: 6675 6e63 7469 6f6e 2066 6f72 2065 7670  function for evp
-0000fca0: 6f74 7261 6e73 7069 7273 7469 6f6e 2028  otranspirstion (
-0000fcb0: 6574 292e 0a0a 2020 213e 2020 2020 2020  et)...  !>      
-0000fcc0: 205c 6465 7461 696c 7320 5468 6520 6f62   \details The ob
-0000fcd0: 6a65 6374 6976 6520 6675 6e63 7469 6f6e  jective function
-0000fce0: 206f 6e6c 7920 6465 7065 6e64 7320 6f6e   only depends on
-0000fcf0: 2061 2070 6172 616d 6574 6572 2076 6563   a parameter vec
-0000fd00: 746f 722e 0a20 2021 3e20 2020 2020 2020  tor..  !>       
-0000fd10: 5468 6520 6d6f 6465 6c20 7769 6c6c 2062  The model will b
-0000fd20: 6520 6361 6c6c 6564 2077 6974 6820 7468  e called with th
-0000fd30: 6174 2070 6172 616d 6574 6572 2076 6563  at parameter vec
-0000fd40: 746f 7220 616e 640a 2020 213e 2020 2020  tor and.  !>    
-0000fd50: 2020 2074 6865 206d 6f64 656c 206f 7574     the model out
-0000fd60: 7075 7420 6973 2073 7562 7365 7175 656e  put is subsequen
-0000fd70: 746c 7920 636f 6d70 6172 6564 2074 6f20  tly compared to 
-0000fd80: 6f62 7365 7276 6564 2064 6174 612e 0a0a  observed data...
-0000fd90: 2020 213e 2020 2020 2020 2054 6865 7265    !>       There
-0000fda0: 666f 7265 2c20 7468 6520 4b6c 696e 672d  fore, the Kling-
-0000fdb0: 4775 7074 6120 6d6f 6465 6c20 6566 6669  Gupta model effi
-0000fdc0: 6369 656e 6379 205c 6624 204b 4745 205c  ciency \f$ KGE \
-0000fdd0: 6624 206f 6620 7468 6520 6361 7463 686d  f$ of the catchm
-0000fde0: 656e 7420 6176 6572 6167 650a 2020 213e  ent average.  !>
-0000fdf0: 2020 2020 2020 2065 7661 706f 7472 616e         evapotran
-0000fe00: 7370 6972 6174 696f 6e20 2865 7429 2069  spiration (et) i
-0000fe10: 7320 6361 6c63 756c 6174 6564 0a20 2021  s calculated.  !
-0000fe20: 3e20 2020 2020 2020 5c66 5b20 4b47 4520  >       \f[ KGE 
-0000fe30: 3d20 312e 3020 2d20 5c73 7172 747b 2820  = 1.0 - \sqrt{( 
-0000fe40: 2831 2d72 295e 3220 2b20 2831 2d5c 616c  (1-r)^2 + (1-\al
-0000fe50: 7068 6129 5e32 202b 2028 312d 5c62 6574  pha)^2 + (1-\bet
-0000fe60: 6129 5e32 2029 7d20 5c66 5d0a 2020 213e  a)^2 )} \f].  !>
-0000fe70: 2020 2020 2020 2077 6865 7265 0a20 2021         where.  !
-0000fe80: 3e20 2020 2020 2020 5c66 2420 7220 5c66  >       \f$ r \f
-0000fe90: 2420 3d20 5065 6172 736f 6e20 7072 6f64  $ = Pearson prod
-0000fea0: 7563 742d 6d6f 6d65 6e74 2063 6f72 7265  uct-moment corre
-0000feb0: 6c61 7469 6f6e 2063 6f65 6666 6963 6965  lation coefficie
-0000fec0: 6e74 0a20 2021 3e20 2020 2020 2020 5c66  nt.  !>       \f
-0000fed0: 2420 5c61 6c70 6861 205c 6624 203d 2072  $ \alpha \f$ = r
-0000fee0: 6174 696f 206f 6620 7369 6d75 6c61 7465  atio of simulate
-0000fef0: 6420 6d65 616e 2074 6f20 6f62 7365 7276  d mean to observ
-0000ff00: 6564 206d 6561 6e20 534d 0a20 2021 3e20  ed mean SM.  !> 
-0000ff10: 2020 2020 2020 5c66 2420 5c62 6574 6120        \f$ \beta 
-0000ff20: 205c 6624 203d 2072 6174 696f 206f 6620   \f$ = ratio of 
-0000ff30: 7369 6d69 6c61 7465 6420 7374 616e 6461  similated standa
-0000ff40: 7264 2064 6576 6961 7469 6f6e 2074 6f20  rd deviation to 
-0000ff50: 6f62 7365 7276 6564 2073 7461 6e64 6172  observed standar
-0000ff60: 6420 6465 7669 6174 696f 6e0a 2020 213e  d deviation.  !>
-0000ff70: 2020 2020 2020 2069 7320 6361 6c63 756c         is calcul
-0000ff80: 6174 6564 2061 6e64 2074 6865 206f 626a  ated and the obj
-0000ff90: 6563 7469 7665 2066 756e 6374 696f 6e20  ective function 
-0000ffa0: 666f 7220 6120 6769 7665 6e20 646f 6d61  for a given doma
-0000ffb0: 696e 205c 6624 2069 205c 6624 2069 730a  in \f$ i \f$ is.
-0000ffc0: 2020 213e 2020 2020 2020 205c 665b 205c    !>       \f[ \
-0000ffd0: 7068 695f 7b69 7d20 3d20 312e 3020 2d20  phi_{i} = 1.0 - 
-0000ffe0: 4b47 455f 7b69 7d20 5c66 5d0a 2020 213e  KGE_{i} \f].  !>
-0000fff0: 2020 2020 2020 205c 6624 205c 7068 695f         \f$ \phi_
-00010000: 7b69 7d20 5c66 2420 6973 2074 6865 206f  {i} \f$ is the o
-00010010: 626a 6563 7469 7665 2073 696e 6365 2077  bjective since w
-00010020: 6520 616c 7761 7973 2061 7070 6c79 206d  e always apply m
-00010030: 696e 696d 697a 6174 696f 6e20 6d65 7468  inimization meth
-00010040: 6f64 732e 0a20 2021 3e20 2020 2020 2020  ods..  !>       
-00010050: 5468 6520 6d69 6e69 6d61 6c20 7661 6c75  The minimal valu
-00010060: 6520 6f66 205c 6624 205c 7068 695f 7b69  e of \f$ \phi_{i
-00010070: 7d20 5c66 2420 6973 2030 2066 6f72 2074  } \f$ is 0 for t
-00010080: 6865 206f 7074 696d 616c 204b 4745 206f  he optimal KGE o
-00010090: 6620 312e 302e 0a0a 2020 213e 2020 2020  f 1.0...  !>    
-000100a0: 2020 2046 696e 616c 6c79 2c20 7468 6520     Finally, the 
-000100b0: 6f76 6572 616c 6c20 6f62 6a65 6374 6976  overall objectiv
-000100c0: 6520 6675 6e63 7469 6f6e 2076 616c 7565  e function value
-000100d0: 205c 6624 204f 4620 5c66 2420 6973 2065   \f$ OF \f$ is e
-000100e0: 7374 696d 6174 6564 2062 6173 6564 206f  stimated based o
-000100f0: 6e20 7468 6520 706f 7765 722d 360a 2020  n the power-6.  
-00010100: 213e 2020 2020 2020 206e 6f72 6d20 746f  !>       norm to
-00010110: 2063 6f6d 6269 6e65 2074 6865 205c 6624   combine the \f$
-00010120: 205c 7068 695f 7b69 7d20 5c66 2420 6672   \phi_{i} \f$ fr
-00010130: 6f6d 2061 6c6c 2064 6f6d 6169 6e73 205c  om all domains \
-00010140: 6624 204e 205c 6624 2e0a 2020 213e 2020  f$ N \f$..  !>  
-00010150: 2020 2020 205c 665b 204f 4620 3d20 5c73       \f[ OF = \s
-00010160: 7172 745b 365d 7b5c 7375 6d28 2831 2e30  qrt[6]{\sum((1.0
-00010170: 202d 204b 4745 5f7b 697d 292f 4e29 5e36   - KGE_{i})/N)^6
-00010180: 207d 2e20 205c 665d 0a20 2021 3e20 2020   }.  \f].  !>   
-00010190: 2020 2020 5468 6520 6f62 7365 7276 6564      The observed
-000101a0: 2064 6174 6120 4c31 5f65 742c 204c 315f   data L1_et, L1_
-000101b0: 6574 5f6d 6173 6b20 6172 6520 676c 6f62  et_mask are glob
-000101c0: 616c 2069 6e20 7468 6973 206d 6f64 756c  al in this modul
-000101d0: 652e 0a0a 2020 2120 2020 2049 4e54 454e  e...  !    INTEN
-000101e0: 5428 494e 290a 2020 213e 2020 2020 2020  T(IN).  !>      
-000101f0: 205c 7061 7261 6d5b 696e 5d20 2272 6561   \param[in] "rea
-00010200: 6c28 6470 292c 2064 696d 656e 7369 6f6e  l(dp), dimension
-00010210: 283a 2920 3a3a 2070 6172 616d 6574 6572  (:) :: parameter
-00010220: 7365 7422 0a20 2021 3e20 2020 2020 2020  set".  !>       
-00010230: 5c70 6172 616d 5b69 6e5d 2022 7072 6f63  \param[in] "proc
-00010240: 6564 7572 6528 6576 616c 5f69 6e74 6572  edure(eval_inter
-00010250: 6661 6365 2920 3a3a 2065 7661 6c22 0a0a  face) :: eval"..
-00010260: 2020 2120 2020 2052 4554 5552 4e0a 2020    !    RETURN.  
-00010270: 213e 2020 2020 2020 205c 7265 7475 726e  !>       \return
-00010280: 2072 6561 6c28 6470 2920 3a3a 206f 626a   real(dp) :: obj
-00010290: 6563 7469 7665 5f65 745f 6b67 655f 6361  ective_et_kge_ca
-000102a0: 7463 686d 656e 745f 6176 6720 266d 6461  tchment_avg &mda
-000102b0: 7368 3b20 6f62 6a65 6374 6976 6520 6675  sh; objective fu
-000102c0: 6e63 7469 6f6e 2076 616c 7565 0a20 2021  nction value.  !
-000102d0: 3e20 2020 2020 2020 2877 6869 6368 2077  >       (which w
-000102e0: 696c 6c20 6265 2065 2e67 2e20 6d69 6e69  ill be e.g. mini
-000102f0: 6d69 7a65 6420 6279 2061 6e20 6f70 7469  mized by an opti
-00010300: 6d69 7a61 7469 6f6e 2072 6f75 7469 6e65  mization routine
-00010310: 290a 0a20 2021 2020 2020 4849 5354 4f52  )..  !    HISTOR
-00010320: 590a 2020 213e 2020 2020 2020 205c 6175  Y.  !>       \au
-00010330: 7468 6f72 7320 4a6f 6861 6e6e 6573 2042  thors Johannes B
-00010340: 7265 6e6e 6572 0a0a 2020 213e 2020 2020  renner..  !>    
-00010350: 2020 205c 6461 7465 2046 6562 2032 3031     \date Feb 201
-00010360: 370a 0a20 2021 204d 6f64 6966 6963 6174  7..  ! Modificat
-00010370: 696f 6e73 3a0a 2020 2120 526f 6265 7274  ions:.  ! Robert
-00010380: 2053 6368 7765 7070 6520 4a75 6e20 3230   Schweppe Jun 20
-00010390: 3138 202d 2072 6566 6163 746f 7269 6e67  18 - refactoring
-000103a0: 2061 6e64 2072 6566 6f72 6d61 7474 696e   and reformattin
-000103b0: 670a 0a20 2046 554e 4354 494f 4e20 6f62  g..  FUNCTION ob
-000103c0: 6a65 6374 6976 655f 6574 5f6b 6765 5f63  jective_et_kge_c
-000103d0: 6174 6368 6d65 6e74 5f61 7667 2870 6172  atchment_avg(par
-000103e0: 616d 6574 6572 7365 742c 2065 7661 6c29  ameterset, eval)
-000103f0: 0a0a 2020 2020 7573 6520 6d6f 5f6f 7074  ..    use mo_opt
-00010400: 696d 697a 6174 696f 6e5f 7479 7065 732c  imization_types,
-00010410: 206f 6e6c 7920 3a20 6f70 7469 6461 7461   only : optidata
-00010420: 5f73 696d 0a20 2020 2075 7365 206d 6f5f  _sim.    use mo_
-00010430: 636f 6d6d 6f6e 5f63 6f6e 7374 616e 7473  common_constants
-00010440: 2c20 6f6e 6c79 203a 206e 6f64 6174 615f  , only : nodata_
-00010450: 6470 0a20 2020 2075 7365 206d 6f5f 636f  dp.    use mo_co
-00010460: 6d6d 6f6e 5f76 6172 6961 626c 6573 2c20  mmon_variables, 
-00010470: 6f6e 6c79 203a 2064 6f6d 6169 6e4d 6574  only : domainMet
-00010480: 610a 2020 2020 7573 6520 6d6f 5f65 7272  a.    use mo_err
-00010490: 6f72 6d65 6173 7572 6573 2c20 6f6e 6c79  ormeasures, only
-000104a0: 203a 204b 4745 0a20 2020 2075 7365 206d   : KGE.    use m
-000104b0: 6f5f 6d65 7373 6167 652c 206f 6e6c 7920  o_message, only 
-000104c0: 3a20 6d65 7373 6167 650a 2020 2020 7573  : message.    us
-000104d0: 6520 6d6f 5f6d 6f6d 656e 742c 206f 6e6c  e mo_moment, onl
-000104e0: 7920 3a20 6176 6572 6167 650a 2020 2020  y : average.    
-000104f0: 7573 6520 6d6f 5f73 7472 696e 675f 7574  use mo_string_ut
-00010500: 696c 732c 206f 6e6c 7920 3a20 6e75 6d32  ils, only : num2
-00010510: 7374 720a 0a20 2020 2069 6d70 6c69 6369  str..    implici
-00010520: 7420 6e6f 6e65 0a0a 2020 2020 7265 616c  t none..    real
-00010530: 2864 7029 2c20 6469 6d65 6e73 696f 6e28  (dp), dimension(
-00010540: 3a29 2c20 696e 7465 6e74 2869 6e29 203a  :), intent(in) :
-00010550: 3a20 7061 7261 6d65 7465 7273 6574 0a0a  : parameterset..
-00010560: 2020 2020 7072 6f63 6564 7572 6528 6576      procedure(ev
-00010570: 616c 5f69 6e74 6572 6661 6365 292c 2049  al_interface), I
-00010580: 4e54 454e 5428 494e 292c 2050 4f49 4e54  NTENT(IN), POINT
-00010590: 4552 203a 3a20 6576 616c 0a0a 2020 2020  ER :: eval..    
-000105a0: 7265 616c 2864 7029 203a 3a20 6f62 6a65  real(dp) :: obje
-000105b0: 6374 6976 655f 6574 5f6b 6765 5f63 6174  ctive_et_kge_cat
-000105c0: 6368 6d65 6e74 5f61 7667 0a0a 2020 2020  chment_avg..    
-000105d0: 2120 646f 6d61 696e 206c 6f6f 7020 636f  ! domain loop co
-000105e0: 756e 7465 720a 2020 2020 696e 7465 6765  unter.    intege
-000105f0: 7228 6934 2920 3a3a 6944 6f6d 6169 6e0a  r(i4) ::iDomain.
-00010600: 0a20 2020 2021 2066 6f72 2073 6978 7468  .    ! for sixth
-00010610: 2072 6f6f 740a 2369 666e 6465 6620 4d50   root.#ifndef MP
-00010620: 490a 2020 2020 7265 616c 2864 7029 2c20  I.    real(dp), 
-00010630: 7061 7261 6d65 7465 7220 3a3a 206f 6e65  parameter :: one
-00010640: 7369 7874 6820 3d20 312e 305f 6470 202f  sixth = 1.0_dp /
-00010650: 2036 2e30 5f64 700a 2365 6e64 6966 0a0a   6.0_dp.#endif..
-00010660: 2020 2020 2120 7370 6174 6961 6c20 6176      ! spatial av
-00010670: 6572 6167 6520 6f66 206f 6273 6572 7665  erage of observe
-00010680: 6420 6574 0a20 2020 2072 6561 6c28 6470  d et.    real(dp
-00010690: 292c 2064 696d 656e 7369 6f6e 283a 292c  ), dimension(:),
-000106a0: 2061 6c6c 6f63 6174 6162 6c65 203a 3a20   allocatable :: 
-000106b0: 6574 5f63 6174 6368 5f61 7667 5f64 6f6d  et_catch_avg_dom
-000106c0: 6169 6e0a 0a20 2020 2021 2073 7061 7469  ain..    ! spati
-000106d0: 616c 2061 7665 7267 6165 206f 6620 6d6f  al avergae of mo
-000106e0: 6465 6c65 6420 2065 740a 2020 2020 7265  deled  et.    re
-000106f0: 616c 2864 7029 2c20 6469 6d65 6e73 696f  al(dp), dimensio
-00010700: 6e28 3a29 2c20 616c 6c6f 6361 7461 626c  n(:), allocatabl
-00010710: 6520 3a3a 2065 745f 6f70 7469 5f63 6174  e :: et_opti_cat
-00010720: 6368 5f61 7667 5f64 6f6d 6169 6e0a 0a20  ch_avg_domain.. 
-00010730: 2020 2021 3e20 7369 6d75 6c61 7465 6420     !> simulated 
-00010740: 6574 0a20 2020 2074 7970 6528 6f70 7469  et.    type(opti
-00010750: 6461 7461 5f73 696d 292c 2064 696d 656e  data_sim), dimen
-00010760: 7369 6f6e 283a 292c 2061 6c6c 6f63 6174  sion(:), allocat
-00010770: 6162 6c65 203a 3a20 6574 4f70 7469 5369  able :: etOptiSi
-00010780: 6d0a 0a20 2020 2021 206d 6173 6b20 666f  m..    ! mask fo
-00010790: 7220 7661 6c69 6420 6574 2063 6174 6368  r valid et catch
-000107a0: 6d65 6e74 2061 7667 2074 696d 6520 7374  ment avg time st
-000107b0: 6570 730a 2020 2020 6c6f 6769 6361 6c2c  eps.    logical,
-000107c0: 2064 696d 656e 7369 6f6e 283a 292c 2061   dimension(:), a
-000107d0: 6c6c 6f63 6174 6162 6c65 203a 3a20 6d61  llocatable :: ma
-000107e0: 736b 5f74 696d 6573 0a0a 0a20 2020 2063  sk_times...    c
-000107f0: 616c 6c20 6576 616c 2870 6172 616d 6574  all eval(paramet
-00010800: 6572 7365 742c 2065 744f 7074 6953 696d  erset, etOptiSim
-00010810: 203d 2065 744f 7074 6953 696d 290a 0a20   = etOptiSim).. 
-00010820: 2020 2021 2069 6e69 7469 616c 697a 6520     ! initialize 
-00010830: 736f 6d65 2076 6172 6961 626c 6573 0a20  some variables. 
-00010840: 2020 206f 626a 6563 7469 7665 5f65 745f     objective_et_
-00010850: 6b67 655f 6361 7463 686d 656e 745f 6176  kge_catchment_av
-00010860: 6720 3d20 302e 305f 6470 0a0a 2020 2020  g = 0.0_dp..    
-00010870: 2120 6c6f 6f70 206f 7665 7220 646f 6d61  ! loop over doma
-00010880: 696e 202d 2066 6f72 2061 7070 6c79 696e  in - for applyin
-00010890: 6720 706f 7765 7220 6c61 7720 6c61 7465  g power law late
-000108a0: 7220 6f6e 0a20 2020 2061 6c6c 6f63 6174  r on.    allocat
-000108b0: 6528 6574 4f70 7469 5369 6d28 646f 6d61  e(etOptiSim(doma
-000108c0: 696e 4d65 7461 256e 446f 6d61 696e 7329  inMeta%nDomains)
-000108d0: 290a 2020 2020 646f 2069 446f 6d61 696e  ).    do iDomain
-000108e0: 203d 2031 2c20 646f 6d61 696e 4d65 7461   = 1, domainMeta
-000108f0: 256e 446f 6d61 696e 730a 0a20 2020 2020  %nDomains..     
-00010900: 2021 2063 7265 6174 6520 6574 2061 7272   ! create et arr
-00010910: 6179 2069 6e70 7574 0a20 2020 2020 2063  ay input.      c
-00010920: 616c 6c20 6372 6561 7465 5f64 6f6d 6169  all create_domai
-00010930: 6e5f 6176 675f 6574 2869 446f 6d61 696e  n_avg_et(iDomain
-00010940: 2c20 6574 4f70 7469 5369 6d2c 2065 745f  , etOptiSim, et_
-00010950: 6361 7463 685f 6176 675f 646f 6d61 696e  catch_avg_domain
-00010960: 2c20 260a 2020 2020 2020 2020 2020 2020  , &.            
-00010970: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010980: 2020 2020 2020 2020 2020 2020 2020 2065                 e
-00010990: 745f 6f70 7469 5f63 6174 6368 5f61 7667  t_opti_catch_avg
-000109a0: 5f64 6f6d 6169 6e2c 206d 6173 6b5f 7469  _domain, mask_ti
-000109b0: 6d65 7329 0a20 2020 2020 2021 2063 616c  mes).      ! cal
-000109c0: 6375 6c61 7465 2061 7665 7261 6765 2045  culate average E
-000109d0: 5420 4b47 4520 6f76 6572 2061 6c6c 2064  T KGE over all d
-000109e0: 6f6d 6169 6e73 2077 6974 6820 706f 7765  omains with powe
-000109f0: 7220 6c61 770a 2020 2020 2020 2120 646f  r law.      ! do
-00010a00: 6d61 696e 7320 6172 6520 7765 6967 6874  mains are weight
-00010a10: 6564 2065 7175 616c 6c79 2028 2031 202f  ed equally ( 1 /
-00010a20: 2072 6561 6c28 646f 6d61 696e 4d65 7461   real(domainMeta
-00010a30: 256f 7665 7261 6c6c 4e75 6d62 6572 4f66  %overallNumberOf
-00010a40: 446f 6d61 696e 732c 6470 2929 2a2a 360a  Domains,dp))**6.
-00010a50: 0a20 2020 2020 206f 626a 6563 7469 7665  .      objective
-00010a60: 5f65 745f 6b67 655f 6361 7463 686d 656e  _et_kge_catchmen
-00010a70: 745f 6176 6720 3d20 6f62 6a65 6374 6976  t_avg = objectiv
-00010a80: 655f 6574 5f6b 6765 5f63 6174 6368 6d65  e_et_kge_catchme
-00010a90: 6e74 5f61 7667 202b 2026 0a20 2020 2020  nt_avg + &.     
-00010aa0: 2020 2020 2020 2020 2028 2831 2e30 5f64           ((1.0_d
-00010ab0: 7020 2d20 4b47 4528 6574 5f63 6174 6368  p - KGE(et_catch
-00010ac0: 5f61 7667 5f64 6f6d 6169 6e2c 2065 745f  _avg_domain, et_
-00010ad0: 6f70 7469 5f63 6174 6368 5f61 7667 5f64  opti_catch_avg_d
-00010ae0: 6f6d 6169 6e2c 206d 6173 6b20 3d20 6d61  omain, mask = ma
-00010af0: 736b 5f74 696d 6573 2929 202f 2026 0a20  sk_times)) / &. 
-00010b00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010b10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010b20: 2020 2020 2020 2072 6561 6c28 646f 6d61         real(doma
-00010b30: 696e 4d65 7461 256f 7665 7261 6c6c 4e75  inMeta%overallNu
-00010b40: 6d62 6572 4f66 446f 6d61 696e 732c 2064  mberOfDomains, d
-00010b50: 7029 292a 2a36 0a0a 2020 2020 2020 2120  p))**6..      ! 
-00010b60: 6465 616c 6c6f 6361 7465 0a20 2020 2020  deallocate.     
-00010b70: 2064 6561 6c6c 6f63 6174 6528 6d61 736b   deallocate(mask
-00010b80: 5f74 696d 6573 290a 2020 2020 2020 6465  _times).      de
-00010b90: 616c 6c6f 6361 7465 2865 745f 6361 7463  allocate(et_catc
-00010ba0: 685f 6176 675f 646f 6d61 696e 290a 2020  h_avg_domain).  
-00010bb0: 2020 2020 6465 616c 6c6f 6361 7465 2865      deallocate(e
-00010bc0: 745f 6f70 7469 5f63 6174 6368 5f61 7667  t_opti_catch_avg
-00010bd0: 5f64 6f6d 6169 6e29 0a20 2020 2020 2063  _domain).      c
-00010be0: 616c 6c20 6574 4f70 7469 5369 6d28 6944  all etOptiSim(iD
-00010bf0: 6f6d 6169 6e29 2564 6573 7472 6f79 2829  omain)%destroy()
-00010c00: 0a20 2020 2065 6e64 2064 6f0a 2020 2020  .    end do.    
-00010c10: 6465 616c 6c6f 6361 7465 2865 744f 7074  deallocate(etOpt
-00010c20: 6953 696d 290a 0a23 6966 6e64 6566 204d  iSim)..#ifndef M
-00010c30: 5049 0a20 2020 206f 626a 6563 7469 7665  PI.    objective
-00010c40: 5f65 745f 6b67 655f 6361 7463 686d 656e  _et_kge_catchmen
-00010c50: 745f 6176 6720 3d20 6f62 6a65 6374 6976  t_avg = objectiv
-00010c60: 655f 6574 5f6b 6765 5f63 6174 6368 6d65  e_et_kge_catchme
-00010c70: 6e74 5f61 7667 2a2a 6f6e 6573 6978 7468  nt_avg**onesixth
-00010c80: 0a0a 2020 2020 6361 6c6c 206d 6573 7361  ..    call messa
-00010c90: 6765 2827 2020 2020 6f62 6a65 6374 6976  ge('    objectiv
-00010ca0: 655f 6574 5f6b 6765 5f63 6174 6368 6d65  e_et_kge_catchme
-00010cb0: 6e74 5f61 7667 203d 2027 2c20 6e75 6d32  nt_avg = ', num2
-00010cc0: 7374 7228 6f62 6a65 6374 6976 655f 6574  str(objective_et
-00010cd0: 5f6b 6765 5f63 6174 6368 6d65 6e74 5f61  _kge_catchment_a
-00010ce0: 7667 2c20 2728 4639 2e35 2927 2929 0a23  vg, '(F9.5)')).#
-00010cf0: 656e 6469 660a 0a20 2045 4e44 2046 554e  endif..  END FUN
-00010d00: 4354 494f 4e20 6f62 6a65 6374 6976 655f  CTION objective_
-00010d10: 6574 5f6b 6765 5f63 6174 6368 6d65 6e74  et_kge_catchment
-00010d20: 5f61 7667 0a0a 2020 2120 2d2d 2d2d 2d2d  _avg..  ! ------
+0000fc20: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+0000fc30: 2d2d 2d2d 0a0a 2020 2120 2020 204e 414d  ----..  !    NAM
+0000fc40: 450a 2020 2120 2020 2020 2020 206f 626a  E.  !        obj
+0000fc50: 6563 7469 7665 5f65 745f 6b67 655f 6361  ective_et_kge_ca
+0000fc60: 7463 686d 656e 745f 6176 670a 0a20 2021  tchment_avg..  !
+0000fc70: 2020 2020 5055 5250 4f53 450a 2020 213e      PURPOSE.  !>
+0000fc80: 2020 2020 2020 205c 6272 6965 6620 4f62         \brief Ob
+0000fc90: 6a65 6374 6976 6520 6675 6e63 7469 6f6e  jective function
+0000fca0: 2066 6f72 2065 7670 6f74 7261 6e73 7069   for evpotranspi
+0000fcb0: 7273 7469 6f6e 2028 6574 292e 0a0a 2020  rstion (et)...  
+0000fcc0: 213e 2020 2020 2020 205c 6465 7461 696c  !>       \detail
+0000fcd0: 7320 5468 6520 6f62 6a65 6374 6976 6520  s The objective 
+0000fce0: 6675 6e63 7469 6f6e 206f 6e6c 7920 6465  function only de
+0000fcf0: 7065 6e64 7320 6f6e 2061 2070 6172 616d  pends on a param
+0000fd00: 6574 6572 2076 6563 746f 722e 0a20 2021  eter vector..  !
+0000fd10: 3e20 2020 2020 2020 5468 6520 6d6f 6465  >       The mode
+0000fd20: 6c20 7769 6c6c 2062 6520 6361 6c6c 6564  l will be called
+0000fd30: 2077 6974 6820 7468 6174 2070 6172 616d   with that param
+0000fd40: 6574 6572 2076 6563 746f 7220 616e 640a  eter vector and.
+0000fd50: 2020 213e 2020 2020 2020 2074 6865 206d    !>       the m
+0000fd60: 6f64 656c 206f 7574 7075 7420 6973 2073  odel output is s
+0000fd70: 7562 7365 7175 656e 746c 7920 636f 6d70  ubsequently comp
+0000fd80: 6172 6564 2074 6f20 6f62 7365 7276 6564  ared to observed
+0000fd90: 2064 6174 612e 0a0a 2020 213e 2020 2020   data...  !>    
+0000fda0: 2020 2054 6865 7265 666f 7265 2c20 7468     Therefore, th
+0000fdb0: 6520 4b6c 696e 672d 4775 7074 6120 6d6f  e Kling-Gupta mo
+0000fdc0: 6465 6c20 6566 6669 6369 656e 6379 205c  del efficiency \
+0000fdd0: 6624 204b 4745 205c 6624 206f 6620 7468  f$ KGE \f$ of th
+0000fde0: 6520 6361 7463 686d 656e 7420 6176 6572  e catchment aver
+0000fdf0: 6167 650a 2020 213e 2020 2020 2020 2065  age.  !>       e
+0000fe00: 7661 706f 7472 616e 7370 6972 6174 696f  vapotranspiratio
+0000fe10: 6e20 2865 7429 2069 7320 6361 6c63 756c  n (et) is calcul
+0000fe20: 6174 6564 0a20 2021 3e20 2020 2020 2020  ated.  !>       
+0000fe30: 5c66 5b20 4b47 4520 3d20 312e 3020 2d20  \f[ KGE = 1.0 - 
+0000fe40: 5c73 7172 747b 2820 2831 2d72 295e 3220  \sqrt{( (1-r)^2 
+0000fe50: 2b20 2831 2d5c 616c 7068 6129 5e32 202b  + (1-\alpha)^2 +
+0000fe60: 2028 312d 5c62 6574 6129 5e32 2029 7d20   (1-\beta)^2 )} 
+0000fe70: 5c66 5d0a 2020 213e 2020 2020 2020 2077  \f].  !>       w
+0000fe80: 6865 7265 0a20 2021 3e20 2020 2020 2020  here.  !>       
+0000fe90: 5c66 2420 7220 5c66 2420 3d20 5065 6172  \f$ r \f$ = Pear
+0000fea0: 736f 6e20 7072 6f64 7563 742d 6d6f 6d65  son product-mome
+0000feb0: 6e74 2063 6f72 7265 6c61 7469 6f6e 2063  nt correlation c
+0000fec0: 6f65 6666 6963 6965 6e74 0a20 2021 3e20  oefficient.  !> 
+0000fed0: 2020 2020 2020 5c66 2420 5c61 6c70 6861        \f$ \alpha
+0000fee0: 205c 6624 203d 2072 6174 696f 206f 6620   \f$ = ratio of 
+0000fef0: 7369 6d75 6c61 7465 6420 6d65 616e 2074  simulated mean t
+0000ff00: 6f20 6f62 7365 7276 6564 206d 6561 6e20  o observed mean 
+0000ff10: 534d 0a20 2021 3e20 2020 2020 2020 5c66  SM.  !>       \f
+0000ff20: 2420 5c62 6574 6120 205c 6624 203d 2072  $ \beta  \f$ = r
+0000ff30: 6174 696f 206f 6620 7369 6d69 6c61 7465  atio of similate
+0000ff40: 6420 7374 616e 6461 7264 2064 6576 6961  d standard devia
+0000ff50: 7469 6f6e 2074 6f20 6f62 7365 7276 6564  tion to observed
+0000ff60: 2073 7461 6e64 6172 6420 6465 7669 6174   standard deviat
+0000ff70: 696f 6e0a 2020 213e 2020 2020 2020 2069  ion.  !>       i
+0000ff80: 7320 6361 6c63 756c 6174 6564 2061 6e64  s calculated and
+0000ff90: 2074 6865 206f 626a 6563 7469 7665 2066   the objective f
+0000ffa0: 756e 6374 696f 6e20 666f 7220 6120 6769  unction for a gi
+0000ffb0: 7665 6e20 646f 6d61 696e 205c 6624 2069  ven domain \f$ i
+0000ffc0: 205c 6624 2069 730a 2020 213e 2020 2020   \f$ is.  !>    
+0000ffd0: 2020 205c 665b 205c 7068 695f 7b69 7d20     \f[ \phi_{i} 
+0000ffe0: 3d20 312e 3020 2d20 4b47 455f 7b69 7d20  = 1.0 - KGE_{i} 
+0000fff0: 5c66 5d0a 2020 213e 2020 2020 2020 205c  \f].  !>       \
+00010000: 6624 205c 7068 695f 7b69 7d20 5c66 2420  f$ \phi_{i} \f$ 
+00010010: 6973 2074 6865 206f 626a 6563 7469 7665  is the objective
+00010020: 2073 696e 6365 2077 6520 616c 7761 7973   since we always
+00010030: 2061 7070 6c79 206d 696e 696d 697a 6174   apply minimizat
+00010040: 696f 6e20 6d65 7468 6f64 732e 0a20 2021  ion methods..  !
+00010050: 3e20 2020 2020 2020 5468 6520 6d69 6e69  >       The mini
+00010060: 6d61 6c20 7661 6c75 6520 6f66 205c 6624  mal value of \f$
+00010070: 205c 7068 695f 7b69 7d20 5c66 2420 6973   \phi_{i} \f$ is
+00010080: 2030 2066 6f72 2074 6865 206f 7074 696d   0 for the optim
+00010090: 616c 204b 4745 206f 6620 312e 302e 0a0a  al KGE of 1.0...
+000100a0: 2020 213e 2020 2020 2020 2046 696e 616c    !>       Final
+000100b0: 6c79 2c20 7468 6520 6f76 6572 616c 6c20  ly, the overall 
+000100c0: 6f62 6a65 6374 6976 6520 6675 6e63 7469  objective functi
+000100d0: 6f6e 2076 616c 7565 205c 6624 204f 4620  on value \f$ OF 
+000100e0: 5c66 2420 6973 2065 7374 696d 6174 6564  \f$ is estimated
+000100f0: 2062 6173 6564 206f 6e20 7468 6520 706f   based on the po
+00010100: 7765 722d 360a 2020 213e 2020 2020 2020  wer-6.  !>      
+00010110: 206e 6f72 6d20 746f 2063 6f6d 6269 6e65   norm to combine
+00010120: 2074 6865 205c 6624 205c 7068 695f 7b69   the \f$ \phi_{i
+00010130: 7d20 5c66 2420 6672 6f6d 2061 6c6c 2064  } \f$ from all d
+00010140: 6f6d 6169 6e73 205c 6624 204e 205c 6624  omains \f$ N \f$
+00010150: 2e0a 2020 213e 2020 2020 2020 205c 665b  ..  !>       \f[
+00010160: 204f 4620 3d20 5c73 7172 745b 365d 7b5c   OF = \sqrt[6]{\
+00010170: 7375 6d28 2831 2e30 202d 204b 4745 5f7b  sum((1.0 - KGE_{
+00010180: 697d 292f 4e29 5e36 207d 2e20 205c 665d  i})/N)^6 }.  \f]
+00010190: 0a20 2021 3e20 2020 2020 2020 5468 6520  .  !>       The 
+000101a0: 6f62 7365 7276 6564 2064 6174 6120 4c31  observed data L1
+000101b0: 5f65 742c 204c 315f 6574 5f6d 6173 6b20  _et, L1_et_mask 
+000101c0: 6172 6520 676c 6f62 616c 2069 6e20 7468  are global in th
+000101d0: 6973 206d 6f64 756c 652e 0a0a 2020 2120  is module...  ! 
+000101e0: 2020 2049 4e54 454e 5428 494e 290a 2020     INTENT(IN).  
+000101f0: 213e 2020 2020 2020 205c 7061 7261 6d5b  !>       \param[
+00010200: 696e 5d20 2272 6561 6c28 6470 292c 2064  in] "real(dp), d
+00010210: 696d 656e 7369 6f6e 283a 2920 3a3a 2070  imension(:) :: p
+00010220: 6172 616d 6574 6572 7365 7422 0a20 2021  arameterset".  !
+00010230: 3e20 2020 2020 2020 5c70 6172 616d 5b69  >       \param[i
+00010240: 6e5d 2022 7072 6f63 6564 7572 6528 6576  n] "procedure(ev
+00010250: 616c 5f69 6e74 6572 6661 6365 2920 3a3a  al_interface) ::
+00010260: 2065 7661 6c22 0a0a 2020 2120 2020 2052   eval"..  !    R
+00010270: 4554 5552 4e0a 2020 213e 2020 2020 2020  ETURN.  !>      
+00010280: 205c 7265 7475 726e 2072 6561 6c28 6470   \return real(dp
+00010290: 2920 3a3a 206f 626a 6563 7469 7665 5f65  ) :: objective_e
+000102a0: 745f 6b67 655f 6361 7463 686d 656e 745f  t_kge_catchment_
+000102b0: 6176 6720 266d 6461 7368 3b20 6f62 6a65  avg &mdash; obje
+000102c0: 6374 6976 6520 6675 6e63 7469 6f6e 2076  ctive function v
+000102d0: 616c 7565 0a20 2021 3e20 2020 2020 2020  alue.  !>       
+000102e0: 2877 6869 6368 2077 696c 6c20 6265 2065  (which will be e
+000102f0: 2e67 2e20 6d69 6e69 6d69 7a65 6420 6279  .g. minimized by
+00010300: 2061 6e20 6f70 7469 6d69 7a61 7469 6f6e   an optimization
+00010310: 2072 6f75 7469 6e65 290a 0a20 2021 2020   routine)..  !  
+00010320: 2020 4849 5354 4f52 590a 2020 213e 2020    HISTORY.  !>  
+00010330: 2020 2020 205c 6175 7468 6f72 7320 4a6f       \authors Jo
+00010340: 6861 6e6e 6573 2042 7265 6e6e 6572 0a0a  hannes Brenner..
+00010350: 2020 213e 2020 2020 2020 205c 6461 7465    !>       \date
+00010360: 2046 6562 2032 3031 370a 0a20 2021 204d   Feb 2017..  ! M
+00010370: 6f64 6966 6963 6174 696f 6e73 3a0a 2020  odifications:.  
+00010380: 2120 526f 6265 7274 2053 6368 7765 7070  ! Robert Schwepp
+00010390: 6520 4a75 6e20 3230 3138 202d 2072 6566  e Jun 2018 - ref
+000103a0: 6163 746f 7269 6e67 2061 6e64 2072 6566  actoring and ref
+000103b0: 6f72 6d61 7474 696e 670a 0a20 2046 554e  ormatting..  FUN
+000103c0: 4354 494f 4e20 6f62 6a65 6374 6976 655f  CTION objective_
+000103d0: 6574 5f6b 6765 5f63 6174 6368 6d65 6e74  et_kge_catchment
+000103e0: 5f61 7667 2870 6172 616d 6574 6572 7365  _avg(parameterse
+000103f0: 742c 2065 7661 6c29 0a0a 2020 2020 7573  t, eval)..    us
+00010400: 6520 6d6f 5f6f 7074 696d 697a 6174 696f  e mo_optimizatio
+00010410: 6e5f 7479 7065 732c 206f 6e6c 7920 3a20  n_types, only : 
+00010420: 6f70 7469 6461 7461 5f73 696d 0a20 2020  optidata_sim.   
+00010430: 2075 7365 206d 6f5f 636f 6d6d 6f6e 5f63   use mo_common_c
+00010440: 6f6e 7374 616e 7473 2c20 6f6e 6c79 203a  onstants, only :
+00010450: 206e 6f64 6174 615f 6470 0a20 2020 2075   nodata_dp.    u
+00010460: 7365 206d 6f5f 636f 6d6d 6f6e 5f76 6172  se mo_common_var
+00010470: 6961 626c 6573 2c20 6f6e 6c79 203a 2064  iables, only : d
+00010480: 6f6d 6169 6e4d 6574 610a 2020 2020 7573  omainMeta.    us
+00010490: 6520 6d6f 5f65 7272 6f72 6d65 6173 7572  e mo_errormeasur
+000104a0: 6573 2c20 6f6e 6c79 203a 204b 4745 0a20  es, only : KGE. 
+000104b0: 2020 2075 7365 206d 6f5f 6d6f 6d65 6e74     use mo_moment
+000104c0: 2c20 6f6e 6c79 203a 2061 7665 7261 6765  , only : average
+000104d0: 0a20 2020 2075 7365 206d 6f5f 7374 7269  .    use mo_stri
+000104e0: 6e67 5f75 7469 6c73 2c20 6f6e 6c79 203a  ng_utils, only :
+000104f0: 206e 756d 3273 7472 0a0a 2020 2020 696d   num2str..    im
+00010500: 706c 6963 6974 206e 6f6e 650a 0a20 2020  plicit none..   
+00010510: 2072 6561 6c28 6470 292c 2064 696d 656e   real(dp), dimen
+00010520: 7369 6f6e 283a 292c 2069 6e74 656e 7428  sion(:), intent(
+00010530: 696e 2920 3a3a 2070 6172 616d 6574 6572  in) :: parameter
+00010540: 7365 740a 0a20 2020 2070 726f 6365 6475  set..    procedu
+00010550: 7265 2865 7661 6c5f 696e 7465 7266 6163  re(eval_interfac
+00010560: 6529 2c20 494e 5445 4e54 2849 4e29 2c20  e), INTENT(IN), 
+00010570: 504f 494e 5445 5220 3a3a 2065 7661 6c0a  POINTER :: eval.
+00010580: 0a20 2020 2072 6561 6c28 6470 2920 3a3a  .    real(dp) ::
+00010590: 206f 626a 6563 7469 7665 5f65 745f 6b67   objective_et_kg
+000105a0: 655f 6361 7463 686d 656e 745f 6176 670a  e_catchment_avg.
+000105b0: 0a20 2020 2021 2064 6f6d 6169 6e20 6c6f  .    ! domain lo
+000105c0: 6f70 2063 6f75 6e74 6572 0a20 2020 2069  op counter.    i
+000105d0: 6e74 6567 6572 2869 3429 203a 3a69 446f  nteger(i4) ::iDo
+000105e0: 6d61 696e 0a0a 2020 2020 2120 666f 7220  main..    ! for 
+000105f0: 7369 7874 6820 726f 6f74 0a23 6966 6e64  sixth root.#ifnd
+00010600: 6566 204d 5049 0a20 2020 2072 6561 6c28  ef MPI.    real(
+00010610: 6470 292c 2070 6172 616d 6574 6572 203a  dp), parameter :
+00010620: 3a20 6f6e 6573 6978 7468 203d 2031 2e30  : onesixth = 1.0
+00010630: 5f64 7020 2f20 362e 305f 6470 0a23 656e  _dp / 6.0_dp.#en
+00010640: 6469 660a 0a20 2020 2021 2073 7061 7469  dif..    ! spati
+00010650: 616c 2061 7665 7261 6765 206f 6620 6f62  al average of ob
+00010660: 7365 7276 6564 2065 740a 2020 2020 7265  served et.    re
+00010670: 616c 2864 7029 2c20 6469 6d65 6e73 696f  al(dp), dimensio
+00010680: 6e28 3a29 2c20 616c 6c6f 6361 7461 626c  n(:), allocatabl
+00010690: 6520 3a3a 2065 745f 6361 7463 685f 6176  e :: et_catch_av
+000106a0: 675f 646f 6d61 696e 0a0a 2020 2020 2120  g_domain..    ! 
+000106b0: 7370 6174 6961 6c20 6176 6572 6761 6520  spatial avergae 
+000106c0: 6f66 206d 6f64 656c 6564 2020 6574 0a20  of modeled  et. 
+000106d0: 2020 2072 6561 6c28 6470 292c 2064 696d     real(dp), dim
+000106e0: 656e 7369 6f6e 283a 292c 2061 6c6c 6f63  ension(:), alloc
+000106f0: 6174 6162 6c65 203a 3a20 6574 5f6f 7074  atable :: et_opt
+00010700: 695f 6361 7463 685f 6176 675f 646f 6d61  i_catch_avg_doma
+00010710: 696e 0a0a 2020 2020 213e 2073 696d 756c  in..    !> simul
+00010720: 6174 6564 2065 740a 2020 2020 7479 7065  ated et.    type
+00010730: 286f 7074 6964 6174 615f 7369 6d29 2c20  (optidata_sim), 
+00010740: 6469 6d65 6e73 696f 6e28 3a29 2c20 616c  dimension(:), al
+00010750: 6c6f 6361 7461 626c 6520 3a3a 2065 744f  locatable :: etO
+00010760: 7074 6953 696d 0a0a 2020 2020 2120 6d61  ptiSim..    ! ma
+00010770: 736b 2066 6f72 2076 616c 6964 2065 7420  sk for valid et 
+00010780: 6361 7463 686d 656e 7420 6176 6720 7469  catchment avg ti
+00010790: 6d65 2073 7465 7073 0a20 2020 206c 6f67  me steps.    log
+000107a0: 6963 616c 2c20 6469 6d65 6e73 696f 6e28  ical, dimension(
+000107b0: 3a29 2c20 616c 6c6f 6361 7461 626c 6520  :), allocatable 
+000107c0: 3a3a 206d 6173 6b5f 7469 6d65 730a 0a0a  :: mask_times...
+000107d0: 2020 2020 6361 6c6c 2065 7661 6c28 7061      call eval(pa
+000107e0: 7261 6d65 7465 7273 6574 2c20 6574 4f70  rameterset, etOp
+000107f0: 7469 5369 6d20 3d20 6574 4f70 7469 5369  tiSim = etOptiSi
+00010800: 6d29 0a0a 2020 2020 2120 696e 6974 6961  m)..    ! initia
+00010810: 6c69 7a65 2073 6f6d 6520 7661 7269 6162  lize some variab
+00010820: 6c65 730a 2020 2020 6f62 6a65 6374 6976  les.    objectiv
+00010830: 655f 6574 5f6b 6765 5f63 6174 6368 6d65  e_et_kge_catchme
+00010840: 6e74 5f61 7667 203d 2030 2e30 5f64 700a  nt_avg = 0.0_dp.
+00010850: 0a20 2020 2021 206c 6f6f 7020 6f76 6572  .    ! loop over
+00010860: 2064 6f6d 6169 6e20 2d20 666f 7220 6170   domain - for ap
+00010870: 706c 7969 6e67 2070 6f77 6572 206c 6177  plying power law
+00010880: 206c 6174 6572 206f 6e0a 2020 2020 616c   later on.    al
+00010890: 6c6f 6361 7465 2865 744f 7074 6953 696d  locate(etOptiSim
+000108a0: 2864 6f6d 6169 6e4d 6574 6125 6e44 6f6d  (domainMeta%nDom
+000108b0: 6169 6e73 2929 0a20 2020 2064 6f20 6944  ains)).    do iD
+000108c0: 6f6d 6169 6e20 3d20 312c 2064 6f6d 6169  omain = 1, domai
+000108d0: 6e4d 6574 6125 6e44 6f6d 6169 6e73 0a0a  nMeta%nDomains..
+000108e0: 2020 2020 2020 2120 6372 6561 7465 2065        ! create e
+000108f0: 7420 6172 7261 7920 696e 7075 740a 2020  t array input.  
+00010900: 2020 2020 6361 6c6c 2063 7265 6174 655f      call create_
+00010910: 646f 6d61 696e 5f61 7667 5f65 7428 6944  domain_avg_et(iD
+00010920: 6f6d 6169 6e2c 2065 744f 7074 6953 696d  omain, etOptiSim
+00010930: 2c20 6574 5f63 6174 6368 5f61 7667 5f64  , et_catch_avg_d
+00010940: 6f6d 6169 6e2c 2026 0a20 2020 2020 2020  omain, &.       
+00010950: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010960: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010970: 2020 2020 6574 5f6f 7074 695f 6361 7463      et_opti_catc
+00010980: 685f 6176 675f 646f 6d61 696e 2c20 6d61  h_avg_domain, ma
+00010990: 736b 5f74 696d 6573 290a 2020 2020 2020  sk_times).      
+000109a0: 2120 6361 6c63 756c 6174 6520 6176 6572  ! calculate aver
+000109b0: 6167 6520 4554 204b 4745 206f 7665 7220  age ET KGE over 
+000109c0: 616c 6c20 646f 6d61 696e 7320 7769 7468  all domains with
+000109d0: 2070 6f77 6572 206c 6177 0a20 2020 2020   power law.     
+000109e0: 2021 2064 6f6d 6169 6e73 2061 7265 2077   ! domains are w
+000109f0: 6569 6768 7465 6420 6571 7561 6c6c 7920  eighted equally 
+00010a00: 2820 3120 2f20 7265 616c 2864 6f6d 6169  ( 1 / real(domai
+00010a10: 6e4d 6574 6125 6f76 6572 616c 6c4e 756d  nMeta%overallNum
+00010a20: 6265 724f 6644 6f6d 6169 6e73 2c64 7029  berOfDomains,dp)
+00010a30: 292a 2a36 0a0a 2020 2020 2020 6f62 6a65  )**6..      obje
+00010a40: 6374 6976 655f 6574 5f6b 6765 5f63 6174  ctive_et_kge_cat
+00010a50: 6368 6d65 6e74 5f61 7667 203d 206f 626a  chment_avg = obj
+00010a60: 6563 7469 7665 5f65 745f 6b67 655f 6361  ective_et_kge_ca
+00010a70: 7463 686d 656e 745f 6176 6720 2b20 260a  tchment_avg + &.
+00010a80: 2020 2020 2020 2020 2020 2020 2020 2828                ((
+00010a90: 312e 305f 6470 202d 204b 4745 2865 745f  1.0_dp - KGE(et_
+00010aa0: 6361 7463 685f 6176 675f 646f 6d61 696e  catch_avg_domain
+00010ab0: 2c20 6574 5f6f 7074 695f 6361 7463 685f  , et_opti_catch_
+00010ac0: 6176 675f 646f 6d61 696e 2c20 6d61 736b  avg_domain, mask
+00010ad0: 203d 206d 6173 6b5f 7469 6d65 7329 2920   = mask_times)) 
+00010ae0: 2f20 260a 2020 2020 2020 2020 2020 2020  / &.            
+00010af0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010b00: 2020 2020 2020 2020 2020 2020 7265 616c              real
+00010b10: 2864 6f6d 6169 6e4d 6574 6125 6f76 6572  (domainMeta%over
+00010b20: 616c 6c4e 756d 6265 724f 6644 6f6d 6169  allNumberOfDomai
+00010b30: 6e73 2c20 6470 2929 2a2a 360a 0a20 2020  ns, dp))**6..   
+00010b40: 2020 2021 2064 6561 6c6c 6f63 6174 650a     ! deallocate.
+00010b50: 2020 2020 2020 6465 616c 6c6f 6361 7465        deallocate
+00010b60: 286d 6173 6b5f 7469 6d65 7329 0a20 2020  (mask_times).   
+00010b70: 2020 2064 6561 6c6c 6f63 6174 6528 6574     deallocate(et
+00010b80: 5f63 6174 6368 5f61 7667 5f64 6f6d 6169  _catch_avg_domai
+00010b90: 6e29 0a20 2020 2020 2064 6561 6c6c 6f63  n).      dealloc
+00010ba0: 6174 6528 6574 5f6f 7074 695f 6361 7463  ate(et_opti_catc
+00010bb0: 685f 6176 675f 646f 6d61 696e 290a 2020  h_avg_domain).  
+00010bc0: 2020 2020 6361 6c6c 2065 744f 7074 6953      call etOptiS
+00010bd0: 696d 2869 446f 6d61 696e 2925 6465 7374  im(iDomain)%dest
+00010be0: 726f 7928 290a 2020 2020 656e 6420 646f  roy().    end do
+00010bf0: 0a20 2020 2064 6561 6c6c 6f63 6174 6528  .    deallocate(
+00010c00: 6574 4f70 7469 5369 6d29 0a0a 2369 666e  etOptiSim)..#ifn
+00010c10: 6465 6620 4d50 490a 2020 2020 6f62 6a65  def MPI.    obje
+00010c20: 6374 6976 655f 6574 5f6b 6765 5f63 6174  ctive_et_kge_cat
+00010c30: 6368 6d65 6e74 5f61 7667 203d 206f 626a  chment_avg = obj
+00010c40: 6563 7469 7665 5f65 745f 6b67 655f 6361  ective_et_kge_ca
+00010c50: 7463 686d 656e 745f 6176 672a 2a6f 6e65  tchment_avg**one
+00010c60: 7369 7874 680a 0a20 2020 2063 616c 6c20  sixth..    call 
+00010c70: 6d65 7373 6167 6528 2720 2020 206f 626a  message('    obj
+00010c80: 6563 7469 7665 5f65 745f 6b67 655f 6361  ective_et_kge_ca
+00010c90: 7463 686d 656e 745f 6176 6720 3d20 272c  tchment_avg = ',
+00010ca0: 206e 756d 3273 7472 286f 626a 6563 7469   num2str(objecti
+00010cb0: 7665 5f65 745f 6b67 655f 6361 7463 686d  ve_et_kge_catchm
+00010cc0: 656e 745f 6176 672c 2027 2846 392e 3529  ent_avg, '(F9.5)
+00010cd0: 2729 290a 2365 6e64 6966 0a0a 2020 454e  ')).#endif..  EN
+00010ce0: 4420 4655 4e43 5449 4f4e 206f 626a 6563  D FUNCTION objec
+00010cf0: 7469 7665 5f65 745f 6b67 655f 6361 7463  tive_et_kge_catc
+00010d00: 686d 656e 745f 6176 670a 0a20 2021 202d  hment_avg..  ! -
+00010d10: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00010d20: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
 00010d30: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
 00010d40: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00010d50: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00010d60: 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 0a20 2021  -----------..  !
-00010d70: 2020 2020 4e41 4d45 0a20 2021 2020 2020      NAME.  !    
-00010d80: 2020 2020 6f62 6a65 6374 6976 655f 6b67      objective_kg
-00010d90: 655f 715f 736d 5f63 6f72 720a 0a20 2021  e_q_sm_corr..  !
-00010da0: 2020 2020 5055 5250 4f53 450a 2020 213e      PURPOSE.  !>
-00010db0: 2020 2020 2020 205c 6272 6965 6620 4f62         \brief Ob
-00010dc0: 6a65 6374 6976 6520 6675 6e63 7469 6f6e  jective function
-00010dd0: 206f 6620 4b47 4520 666f 7220 7275 6e6f   of KGE for runo
-00010de0: 6666 2061 6e64 2063 6f72 7265 6c61 7469  ff and correlati
-00010df0: 6f6e 2066 6f72 2053 4d0a 0a20 2021 3e20  on for SM..  !> 
-00010e00: 2020 2020 2020 5c64 6574 6169 6c73 204f        \details O
-00010e10: 626a 6563 7469 7665 2066 756e 6374 696f  bjective functio
-00010e20: 6e20 6f66 204b 4745 2066 6f72 2072 756e  n of KGE for run
-00010e30: 6f66 6620 616e 6420 5353 4520 666f 7220  off and SSE for 
-00010e40: 736f 696c 206d 6f69 7374 7572 6520 2873  soil moisture (s
-00010e50: 7461 6e64 6172 697a 6564 2073 636f 7265  tandarized score
-00010e60: 7329 2e0a 2020 213e 2020 2020 2020 2046  s)..  !>       F
-00010e70: 7572 7468 6572 2064 6574 6169 6c73 2063  urther details c
-00010e80: 616e 2062 6520 666f 756e 6420 696e 2074  an be found in t
-00010e90: 6865 2064 6f63 756d 656e 7461 7469 6f6e  he documentation
-00010ea0: 206f 6620 6f62 6a65 6374 6976 6520 6675   of objective fu
-00010eb0: 6e63 7469 6f6e 730a 2020 213e 2020 2020  nctions.  !>    
-00010ec0: 2020 2027 3134 202d 206f 626a 6563 7469     '14 - objecti
-00010ed0: 7665 5f6d 756c 7469 706c 655f 6761 7567  ve_multiple_gaug
-00010ee0: 6573 5f6b 6765 5f70 6f77 6572 3627 2061  es_kge_power6' a
-00010ef0: 6e64 2027 3133 202d 206f 626a 6563 7469  nd '13 - objecti
-00010f00: 7665 5f73 6d5f 636f 7272 272e 0a0a 2020  ve_sm_corr'...  
-00010f10: 2120 2020 2049 4e54 454e 5428 494e 290a  !    INTENT(IN).
-00010f20: 2020 213e 2020 2020 2020 205c 7061 7261    !>       \para
-00010f30: 6d5b 696e 5d20 2272 6561 6c28 6470 292c  m[in] "real(dp),
-00010f40: 2064 696d 656e 7369 6f6e 283a 2920 3a3a   dimension(:) ::
-00010f50: 2070 6172 616d 6574 6572 7365 7422 0a20   parameterset". 
-00010f60: 2021 3e20 2020 2020 2020 5c70 6172 616d   !>       \param
-00010f70: 5b69 6e5d 2022 7072 6f63 6564 7572 6528  [in] "procedure(
-00010f80: 6576 616c 5f69 6e74 6572 6661 6365 2920  eval_interface) 
-00010f90: 3a3a 2065 7661 6c22 0a0a 2020 2120 2020  :: eval"..  !   
-00010fa0: 2052 4554 5552 4e0a 2020 213e 2020 2020   RETURN.  !>    
-00010fb0: 2020 205c 7265 7475 726e 2072 6561 6c28     \return real(
-00010fc0: 6470 2920 3a3a 206f 626a 6563 7469 7665  dp) :: objective
-00010fd0: 5f6b 6765 5f71 5f73 7365 5f73 6d20 266d  _kge_q_sse_sm &m
-00010fe0: 6461 7368 3b20 6f62 6a65 6374 6976 6520  dash; objective 
-00010ff0: 6675 6e63 7469 6f6e 2076 616c 7565 0a20  function value. 
-00011000: 2021 3e20 2020 2020 2020 2877 6869 6368   !>       (which
-00011010: 2077 696c 6c20 6265 2065 2e67 2e20 6d69   will be e.g. mi
-00011020: 6e69 6d69 7a65 6420 6279 2061 6e20 6f70  nimized by an op
-00011030: 7469 6d69 7a61 7469 6f6e 2072 6f75 7469  timization routi
-00011040: 6e65 206c 696b 6520 4444 5329 0a0a 2020  ne like DDS)..  
-00011050: 2120 2020 2048 4953 544f 5259 0a20 2021  !    HISTORY.  !
-00011060: 3e20 2020 2020 2020 5c61 7574 686f 7273  >       \authors
-00011070: 204d 6174 7468 6961 7320 5a69 6e6b 0a0a   Matthias Zink..
-00011080: 2020 213e 2020 2020 2020 205c 6461 7465    !>       \date
-00011090: 204d 6172 2e20 3230 3137 0a0a 2020 2120   Mar. 2017..  ! 
-000110a0: 4d6f 6469 6669 6361 7469 6f6e 733a 0a20  Modifications:. 
-000110b0: 2021 2052 6f62 6572 7420 5363 6877 6570   ! Robert Schwep
-000110c0: 7065 204a 756e 2032 3031 3820 2d20 7265  pe Jun 2018 - re
-000110d0: 6661 6374 6f72 696e 6720 616e 6420 7265  factoring and re
-000110e0: 666f 726d 6174 7469 6e67 0a0a 2020 4655  formatting..  FU
-000110f0: 4e43 5449 4f4e 206f 626a 6563 7469 7665  NCTION objective
-00011100: 5f6b 6765 5f71 5f73 6d5f 636f 7272 2870  _kge_q_sm_corr(p
-00011110: 6172 616d 6574 6572 7365 742c 2065 7661  arameterset, eva
-00011120: 6c29 0a0a 2020 2020 7573 6520 6d6f 5f6f  l)..    use mo_o
-00011130: 7074 696d 697a 6174 696f 6e5f 7479 7065  ptimization_type
-00011140: 732c 206f 6e6c 7920 3a20 6f70 7469 6461  s, only : optida
-00011150: 7461 5f73 696d 0a20 2020 2075 7365 206d  ta_sim.    use m
-00011160: 6f5f 636f 6d6d 6f6e 5f76 6172 6961 626c  o_common_variabl
-00011170: 6573 2c20 6f6e 6c79 203a 206c 6576 656c  es, only : level
-00011180: 312c 2064 6f6d 6169 6e4d 6574 610a 2020  1, domainMeta.  
-00011190: 2020 7573 6520 6d6f 5f67 6c6f 6261 6c5f    use mo_global_
-000111a0: 7661 7269 6162 6c65 732c 206f 6e6c 7920  variables, only 
-000111b0: 3a20 4c31 5f73 6d4f 6273 0a20 2020 2075  : L1_smObs.    u
-000111c0: 7365 206d 6f5f 6d65 7373 6167 652c 206f  se mo_message, o
-000111d0: 6e6c 7920 3a20 6d65 7373 6167 650a 2020  nly : message.  
-000111e0: 2020 7573 6520 6d6f 5f6d 6f6d 656e 742c    use mo_moment,
-000111f0: 206f 6e6c 7920 3a20 636f 7272 656c 6174   only : correlat
-00011200: 696f 6e0a 2020 2020 7573 6520 6d6f 5f73  ion.    use mo_s
-00011210: 7472 696e 675f 7574 696c 732c 206f 6e6c  tring_utils, onl
-00011220: 7920 3a20 6e75 6d32 7374 720a 2020 2020  y : num2str.    
-00011230: 7573 6520 6d6f 5f65 7272 6f72 6d65 6173  use mo_errormeas
-00011240: 7572 6573 2c20 6f6e 6c79 203a 206b 6765  ures, only : kge
-00011250: 0a20 2020 2075 7365 206d 6f5f 6d72 6d5f  .    use mo_mrm_
-00011260: 6f62 6a65 6374 6976 655f 6675 6e63 7469  objective_functi
-00011270: 6f6e 5f72 756e 6f66 662c 206f 6e6c 7920  on_runoff, only 
-00011280: 3a20 6578 7472 6163 745f 7275 6e6f 6666  : extract_runoff
-00011290: 0a0a 2020 2020 696d 706c 6963 6974 206e  ..    implicit n
-000112a0: 6f6e 650a 0a20 2020 2072 6561 6c28 6470  one..    real(dp
-000112b0: 292c 2064 696d 656e 7369 6f6e 283a 292c  ), dimension(:),
-000112c0: 2069 6e74 656e 7428 696e 2920 3a3a 2070   intent(in) :: p
-000112d0: 6172 616d 6574 6572 7365 740a 0a20 2020  arameterset..   
-000112e0: 2070 726f 6365 6475 7265 2865 7661 6c5f   procedure(eval_
-000112f0: 696e 7465 7266 6163 6529 2c20 494e 5445  interface), INTE
-00011300: 4e54 2849 4e29 2c20 504f 494e 5445 5220  NT(IN), POINTER 
-00011310: 3a3a 2065 7661 6c0a 0a20 2020 2072 6561  :: eval..    rea
-00011320: 6c28 6470 2920 3a3a 206f 626a 6563 7469  l(dp) :: objecti
-00011330: 7665 5f6b 6765 5f71 5f73 6d5f 636f 7272  ve_kge_q_sm_corr
-00011340: 0a0a 2020 2020 7265 616c 2864 7029 203a  ..    real(dp) :
-00011350: 3a20 6f62 6a65 6374 6976 655f 736d 0a0a  : objective_sm..
-00011360: 2020 2020 7265 616c 2864 7029 203a 3a20      real(dp) :: 
-00011370: 6f62 6a65 6374 6976 655f 6b67 650a 0a20  objective_kge.. 
-00011380: 2020 2021 206e 756d 6265 7220 6f66 2069     ! number of i
-00011390: 6e76 616c 6964 2063 656c 6c73 2069 6e20  nvalid cells in 
-000113a0: 6361 7463 686d 656e 740a 2020 2020 7265  catchment.    re
-000113b0: 616c 2864 7029 203a 3a20 696e 7661 6c69  al(dp) :: invali
-000113c0: 645f 6365 6c6c 730a 0a20 2020 2021 206d  d_cells..    ! m
-000113d0: 6f64 656c 6c65 6420 7275 6e6f 6666 2066  odelled runoff f
-000113e0: 6f72 2061 2067 6976 656e 2070 6172 616d  or a given param
-000113f0: 6574 6572 2073 6574 0a20 2020 2021 2064  eter set.    ! d
-00011400: 696d 313d 6e54 696d 6553 7465 7073 2c20  im1=nTimeSteps, 
-00011410: 6469 6d32 3d6e 4761 7567 6573 0a20 2020  dim2=nGauges.   
-00011420: 2072 6561 6c28 6470 292c 2061 6c6c 6f63   real(dp), alloc
-00011430: 6174 6162 6c65 2c20 6469 6d65 6e73 696f  atable, dimensio
-00011440: 6e28 3a2c 203a 2920 3a3a 2072 756e 6f66  n(:, :) :: runof
-00011450: 660a 0a20 2020 2021 2064 6f6d 6169 6e20  f..    ! domain 
-00011460: 6c6f 6f70 2063 6f75 6e74 6572 0a20 2020  loop counter.   
-00011470: 2069 6e74 6567 6572 2869 3429 203a 3a20   integer(i4) :: 
-00011480: 6944 6f6d 6169 6e0a 0a20 2020 2021 2063  iDomain..    ! c
-00011490: 656c 6c20 6c6f 6f70 2063 6f75 6e74 6572  ell loop counter
-000114a0: 0a20 2020 2069 6e74 6567 6572 2869 3429  .    integer(i4)
-000114b0: 203a 3a20 6943 656c 6c0a 0a20 2020 2021   :: iCell..    !
-000114c0: 206e 6365 6c6c 7331 206f 6620 6c65 7665   ncells1 of leve
-000114d0: 6c20 310a 2020 2020 696e 7465 6765 7228  l 1.    integer(
-000114e0: 6934 2920 3a3a 206e 6365 6c6c 7331 0a0a  i4) :: ncells1..
-000114f0: 2020 2020 2120 646f 6d61 696e 7320 7769      ! domains wi
-00011500: 7365 206f 626a 6563 7469 7665 730a 2020  se objectives.  
-00011510: 2020 7265 616c 2864 7029 203a 3a20 6f62    real(dp) :: ob
-00011520: 6a65 6374 6976 655f 736d 5f64 6f6d 6169  jective_sm_domai
-00011530: 6e0a 0a20 2020 2021 2073 696d 756c 6174  n..    ! simulat
-00011540: 6564 2073 6f69 6c20 6d6f 6973 7475 7265  ed soil moisture
-00011550: 0a20 2020 2074 7970 6528 6f70 7469 6461  .    type(optida
-00011560: 7461 5f73 696d 292c 2064 696d 656e 7369  ta_sim), dimensi
-00011570: 6f6e 283a 292c 2061 6c6c 6f63 6174 6162  on(:), allocatab
-00011580: 6c65 203a 3a20 736d 4f70 7469 5369 6d0a  le :: smOptiSim.
-00011590: 0a20 2020 2072 6561 6c28 6470 292c 2070  .    real(dp), p
-000115a0: 6172 616d 6574 6572 203a 3a20 6f6e 6573  arameter :: ones
-000115b0: 6978 7468 203d 2031 2e30 5f64 7020 2f20  ixth = 1.0_dp / 
-000115c0: 362e 305f 6470 0a0a 2020 2020 2120 6761  6.0_dp..    ! ga
-000115d0: 7567 6573 2063 6f75 6e74 6572 0a20 2020  uges counter.   
-000115e0: 2069 6e74 6567 6572 2869 3429 203a 3a20   integer(i4) :: 
-000115f0: 6767 0a0a 2020 2020 696e 7465 6765 7228  gg..    integer(
-00011600: 6934 2920 3a3a 206e 4761 7567 6573 546f  i4) :: nGaugesTo
-00011610: 7461 6c0a 0a20 2020 2021 2061 6767 7265  tal..    ! aggre
-00011620: 6761 7465 6420 7369 6d75 6c61 7465 6420  gated simulated 
-00011630: 7275 6e6f 6666 0a20 2020 2072 6561 6c28  runoff.    real(
-00011640: 6470 292c 2064 696d 656e 7369 6f6e 283a  dp), dimension(:
-00011650: 292c 2061 6c6c 6f63 6174 6162 6c65 203a  ), allocatable :
-00011660: 3a20 7275 6e6f 6666 5f61 6767 0a0a 2020  : runoff_agg..  
-00011670: 2020 2120 6d65 6173 7572 6564 2072 756e    ! measured run
-00011680: 6f66 660a 2020 2020 7265 616c 2864 7029  off.    real(dp)
-00011690: 2c20 6469 6d65 6e73 696f 6e28 3a29 2c20  , dimension(:), 
-000116a0: 616c 6c6f 6361 7461 626c 6520 3a3a 2072  allocatable :: r
-000116b0: 756e 6f66 665f 6f62 730a 0a20 2020 2021  unoff_obs..    !
-000116c0: 206d 6173 6b20 666f 7220 6d65 6173 7572   mask for measur
-000116d0: 6564 2072 756e 6f66 660a 2020 2020 6c6f  ed runoff.    lo
-000116e0: 6769 6361 6c2c 2064 696d 656e 7369 6f6e  gical, dimension
-000116f0: 283a 292c 2061 6c6c 6f63 6174 6162 6c65  (:), allocatable
-00011700: 203a 3a20 7275 6e6f 6666 5f6f 6273 5f6d   :: runoff_obs_m
-00011710: 6173 6b0a 0a20 2020 2021 2072 756e 206d  ask..    ! run m
-00011720: 484d 0a20 2020 2061 6c6c 6f63 6174 6528  HM.    allocate(
-00011730: 736d 4f70 7469 5369 6d28 646f 6d61 696e  smOptiSim(domain
-00011740: 4d65 7461 256e 446f 6d61 696e 7329 290a  Meta%nDomains)).
-00011750: 2020 2020 6361 6c6c 2065 7661 6c28 7061      call eval(pa
-00011760: 7261 6d65 7465 7273 6574 2c20 7275 6e6f  rameterset, runo
-00011770: 6666 203d 2072 756e 6f66 662c 2073 6d4f  ff = runoff, smO
-00011780: 7074 6953 696d 203d 2073 6d4f 7074 6953  ptiSim = smOptiS
-00011790: 696d 290a 0a20 2020 2021 202d 2d2d 2d2d  im)..    ! -----
+00010d50: 0a0a 2020 2120 2020 204e 414d 450a 2020  ..  !    NAME.  
+00010d60: 2120 2020 2020 2020 206f 626a 6563 7469  !        objecti
+00010d70: 7665 5f6b 6765 5f71 5f73 6d5f 636f 7272  ve_kge_q_sm_corr
+00010d80: 0a0a 2020 2120 2020 2050 5552 504f 5345  ..  !    PURPOSE
+00010d90: 0a20 2021 3e20 2020 2020 2020 5c62 7269  .  !>       \bri
+00010da0: 6566 204f 626a 6563 7469 7665 2066 756e  ef Objective fun
+00010db0: 6374 696f 6e20 6f66 204b 4745 2066 6f72  ction of KGE for
+00010dc0: 2072 756e 6f66 6620 616e 6420 636f 7272   runoff and corr
+00010dd0: 656c 6174 696f 6e20 666f 7220 534d 0a0a  elation for SM..
+00010de0: 2020 213e 2020 2020 2020 205c 6465 7461    !>       \deta
+00010df0: 696c 7320 4f62 6a65 6374 6976 6520 6675  ils Objective fu
+00010e00: 6e63 7469 6f6e 206f 6620 4b47 4520 666f  nction of KGE fo
+00010e10: 7220 7275 6e6f 6666 2061 6e64 2053 5345  r runoff and SSE
+00010e20: 2066 6f72 2073 6f69 6c20 6d6f 6973 7475   for soil moistu
+00010e30: 7265 2028 7374 616e 6461 7269 7a65 6420  re (standarized 
+00010e40: 7363 6f72 6573 292e 0a20 2021 3e20 2020  scores)..  !>   
+00010e50: 2020 2020 4675 7274 6865 7220 6465 7461      Further deta
+00010e60: 696c 7320 6361 6e20 6265 2066 6f75 6e64  ils can be found
+00010e70: 2069 6e20 7468 6520 646f 6375 6d65 6e74   in the document
+00010e80: 6174 696f 6e20 6f66 206f 626a 6563 7469  ation of objecti
+00010e90: 7665 2066 756e 6374 696f 6e73 0a20 2021  ve functions.  !
+00010ea0: 3e20 2020 2020 2020 2731 3420 2d20 6f62  >       '14 - ob
+00010eb0: 6a65 6374 6976 655f 6d75 6c74 6970 6c65  jective_multiple
+00010ec0: 5f67 6175 6765 735f 6b67 655f 706f 7765  _gauges_kge_powe
+00010ed0: 7236 2720 616e 6420 2731 3320 2d20 6f62  r6' and '13 - ob
+00010ee0: 6a65 6374 6976 655f 736d 5f63 6f72 7227  jective_sm_corr'
+00010ef0: 2e0a 0a20 2021 2020 2020 494e 5445 4e54  ...  !    INTENT
+00010f00: 2849 4e29 0a20 2021 3e20 2020 2020 2020  (IN).  !>       
+00010f10: 5c70 6172 616d 5b69 6e5d 2022 7265 616c  \param[in] "real
+00010f20: 2864 7029 2c20 6469 6d65 6e73 696f 6e28  (dp), dimension(
+00010f30: 3a29 203a 3a20 7061 7261 6d65 7465 7273  :) :: parameters
+00010f40: 6574 220a 2020 213e 2020 2020 2020 205c  et".  !>       \
+00010f50: 7061 7261 6d5b 696e 5d20 2270 726f 6365  param[in] "proce
+00010f60: 6475 7265 2865 7661 6c5f 696e 7465 7266  dure(eval_interf
+00010f70: 6163 6529 203a 3a20 6576 616c 220a 0a20  ace) :: eval".. 
+00010f80: 2021 2020 2020 5245 5455 524e 0a20 2021   !    RETURN.  !
+00010f90: 3e20 2020 2020 2020 5c72 6574 7572 6e20  >       \return 
+00010fa0: 7265 616c 2864 7029 203a 3a20 6f62 6a65  real(dp) :: obje
+00010fb0: 6374 6976 655f 6b67 655f 715f 7373 655f  ctive_kge_q_sse_
+00010fc0: 736d 2026 6d64 6173 683b 206f 626a 6563  sm &mdash; objec
+00010fd0: 7469 7665 2066 756e 6374 696f 6e20 7661  tive function va
+00010fe0: 6c75 650a 2020 213e 2020 2020 2020 2028  lue.  !>       (
+00010ff0: 7768 6963 6820 7769 6c6c 2062 6520 652e  which will be e.
+00011000: 672e 206d 696e 696d 697a 6564 2062 7920  g. minimized by 
+00011010: 616e 206f 7074 696d 697a 6174 696f 6e20  an optimization 
+00011020: 726f 7574 696e 6520 6c69 6b65 2044 4453  routine like DDS
+00011030: 290a 0a20 2021 2020 2020 4849 5354 4f52  )..  !    HISTOR
+00011040: 590a 2020 213e 2020 2020 2020 205c 6175  Y.  !>       \au
+00011050: 7468 6f72 7320 4d61 7474 6869 6173 205a  thors Matthias Z
+00011060: 696e 6b0a 0a20 2021 3e20 2020 2020 2020  ink..  !>       
+00011070: 5c64 6174 6520 4d61 722e 2032 3031 370a  \date Mar. 2017.
+00011080: 0a20 2021 204d 6f64 6966 6963 6174 696f  .  ! Modificatio
+00011090: 6e73 3a0a 2020 2120 526f 6265 7274 2053  ns:.  ! Robert S
+000110a0: 6368 7765 7070 6520 4a75 6e20 3230 3138  chweppe Jun 2018
+000110b0: 202d 2072 6566 6163 746f 7269 6e67 2061   - refactoring a
+000110c0: 6e64 2072 6566 6f72 6d61 7474 696e 670a  nd reformatting.
+000110d0: 0a20 2046 554e 4354 494f 4e20 6f62 6a65  .  FUNCTION obje
+000110e0: 6374 6976 655f 6b67 655f 715f 736d 5f63  ctive_kge_q_sm_c
+000110f0: 6f72 7228 7061 7261 6d65 7465 7273 6574  orr(parameterset
+00011100: 2c20 6576 616c 290a 0a20 2020 2075 7365  , eval)..    use
+00011110: 206d 6f5f 6f70 7469 6d69 7a61 7469 6f6e   mo_optimization
+00011120: 5f74 7970 6573 2c20 6f6e 6c79 203a 206f  _types, only : o
+00011130: 7074 6964 6174 615f 7369 6d0a 2020 2020  ptidata_sim.    
+00011140: 7573 6520 6d6f 5f63 6f6d 6d6f 6e5f 7661  use mo_common_va
+00011150: 7269 6162 6c65 732c 206f 6e6c 7920 3a20  riables, only : 
+00011160: 6c65 7665 6c31 2c20 646f 6d61 696e 4d65  level1, domainMe
+00011170: 7461 0a20 2020 2075 7365 206d 6f5f 676c  ta.    use mo_gl
+00011180: 6f62 616c 5f76 6172 6961 626c 6573 2c20  obal_variables, 
+00011190: 6f6e 6c79 203a 204c 315f 736d 4f62 730a  only : L1_smObs.
+000111a0: 2020 2020 7573 6520 6d6f 5f6d 6f6d 656e      use mo_momen
+000111b0: 742c 206f 6e6c 7920 3a20 636f 7272 656c  t, only : correl
+000111c0: 6174 696f 6e0a 2020 2020 7573 6520 6d6f  ation.    use mo
+000111d0: 5f73 7472 696e 675f 7574 696c 732c 206f  _string_utils, o
+000111e0: 6e6c 7920 3a20 6e75 6d32 7374 720a 2020  nly : num2str.  
+000111f0: 2020 7573 6520 6d6f 5f65 7272 6f72 6d65    use mo_errorme
+00011200: 6173 7572 6573 2c20 6f6e 6c79 203a 206b  asures, only : k
+00011210: 6765 0a20 2020 2075 7365 206d 6f5f 6d72  ge.    use mo_mr
+00011220: 6d5f 6f62 6a65 6374 6976 655f 6675 6e63  m_objective_func
+00011230: 7469 6f6e 5f72 756e 6f66 662c 206f 6e6c  tion_runoff, onl
+00011240: 7920 3a20 6578 7472 6163 745f 7275 6e6f  y : extract_runo
+00011250: 6666 0a0a 2020 2020 696d 706c 6963 6974  ff..    implicit
+00011260: 206e 6f6e 650a 0a20 2020 2072 6561 6c28   none..    real(
+00011270: 6470 292c 2064 696d 656e 7369 6f6e 283a  dp), dimension(:
+00011280: 292c 2069 6e74 656e 7428 696e 2920 3a3a  ), intent(in) ::
+00011290: 2070 6172 616d 6574 6572 7365 740a 0a20   parameterset.. 
+000112a0: 2020 2070 726f 6365 6475 7265 2865 7661     procedure(eva
+000112b0: 6c5f 696e 7465 7266 6163 6529 2c20 494e  l_interface), IN
+000112c0: 5445 4e54 2849 4e29 2c20 504f 494e 5445  TENT(IN), POINTE
+000112d0: 5220 3a3a 2065 7661 6c0a 0a20 2020 2072  R :: eval..    r
+000112e0: 6561 6c28 6470 2920 3a3a 206f 626a 6563  eal(dp) :: objec
+000112f0: 7469 7665 5f6b 6765 5f71 5f73 6d5f 636f  tive_kge_q_sm_co
+00011300: 7272 0a0a 2020 2020 7265 616c 2864 7029  rr..    real(dp)
+00011310: 203a 3a20 6f62 6a65 6374 6976 655f 736d   :: objective_sm
+00011320: 0a0a 2020 2020 7265 616c 2864 7029 203a  ..    real(dp) :
+00011330: 3a20 6f62 6a65 6374 6976 655f 6b67 650a  : objective_kge.
+00011340: 0a20 2020 2021 206e 756d 6265 7220 6f66  .    ! number of
+00011350: 2069 6e76 616c 6964 2063 656c 6c73 2069   invalid cells i
+00011360: 6e20 6361 7463 686d 656e 740a 2020 2020  n catchment.    
+00011370: 7265 616c 2864 7029 203a 3a20 696e 7661  real(dp) :: inva
+00011380: 6c69 645f 6365 6c6c 730a 0a20 2020 2021  lid_cells..    !
+00011390: 206d 6f64 656c 6c65 6420 7275 6e6f 6666   modelled runoff
+000113a0: 2066 6f72 2061 2067 6976 656e 2070 6172   for a given par
+000113b0: 616d 6574 6572 2073 6574 0a20 2020 2021  ameter set.    !
+000113c0: 2064 696d 313d 6e54 696d 6553 7465 7073   dim1=nTimeSteps
+000113d0: 2c20 6469 6d32 3d6e 4761 7567 6573 0a20  , dim2=nGauges. 
+000113e0: 2020 2072 6561 6c28 6470 292c 2061 6c6c     real(dp), all
+000113f0: 6f63 6174 6162 6c65 2c20 6469 6d65 6e73  ocatable, dimens
+00011400: 696f 6e28 3a2c 203a 2920 3a3a 2072 756e  ion(:, :) :: run
+00011410: 6f66 660a 0a20 2020 2021 2064 6f6d 6169  off..    ! domai
+00011420: 6e20 6c6f 6f70 2063 6f75 6e74 6572 0a20  n loop counter. 
+00011430: 2020 2069 6e74 6567 6572 2869 3429 203a     integer(i4) :
+00011440: 3a20 6944 6f6d 6169 6e0a 0a20 2020 2021  : iDomain..    !
+00011450: 2063 656c 6c20 6c6f 6f70 2063 6f75 6e74   cell loop count
+00011460: 6572 0a20 2020 2069 6e74 6567 6572 2869  er.    integer(i
+00011470: 3429 203a 3a20 6943 656c 6c0a 0a20 2020  4) :: iCell..   
+00011480: 2021 206e 6365 6c6c 7331 206f 6620 6c65   ! ncells1 of le
+00011490: 7665 6c20 310a 2020 2020 696e 7465 6765  vel 1.    intege
+000114a0: 7228 6934 2920 3a3a 206e 6365 6c6c 7331  r(i4) :: ncells1
+000114b0: 0a0a 2020 2020 2120 646f 6d61 696e 7320  ..    ! domains 
+000114c0: 7769 7365 206f 626a 6563 7469 7665 730a  wise objectives.
+000114d0: 2020 2020 7265 616c 2864 7029 203a 3a20      real(dp) :: 
+000114e0: 6f62 6a65 6374 6976 655f 736d 5f64 6f6d  objective_sm_dom
+000114f0: 6169 6e0a 0a20 2020 2021 2073 696d 756c  ain..    ! simul
+00011500: 6174 6564 2073 6f69 6c20 6d6f 6973 7475  ated soil moistu
+00011510: 7265 0a20 2020 2074 7970 6528 6f70 7469  re.    type(opti
+00011520: 6461 7461 5f73 696d 292c 2064 696d 656e  data_sim), dimen
+00011530: 7369 6f6e 283a 292c 2061 6c6c 6f63 6174  sion(:), allocat
+00011540: 6162 6c65 203a 3a20 736d 4f70 7469 5369  able :: smOptiSi
+00011550: 6d0a 0a20 2020 2072 6561 6c28 6470 292c  m..    real(dp),
+00011560: 2070 6172 616d 6574 6572 203a 3a20 6f6e   parameter :: on
+00011570: 6573 6978 7468 203d 2031 2e30 5f64 7020  esixth = 1.0_dp 
+00011580: 2f20 362e 305f 6470 0a0a 2020 2020 2120  / 6.0_dp..    ! 
+00011590: 6761 7567 6573 2063 6f75 6e74 6572 0a20  gauges counter. 
+000115a0: 2020 2069 6e74 6567 6572 2869 3429 203a     integer(i4) :
+000115b0: 3a20 6767 0a0a 2020 2020 696e 7465 6765  : gg..    intege
+000115c0: 7228 6934 2920 3a3a 206e 4761 7567 6573  r(i4) :: nGauges
+000115d0: 546f 7461 6c0a 0a20 2020 2021 2061 6767  Total..    ! agg
+000115e0: 7265 6761 7465 6420 7369 6d75 6c61 7465  regated simulate
+000115f0: 6420 7275 6e6f 6666 0a20 2020 2072 6561  d runoff.    rea
+00011600: 6c28 6470 292c 2064 696d 656e 7369 6f6e  l(dp), dimension
+00011610: 283a 292c 2061 6c6c 6f63 6174 6162 6c65  (:), allocatable
+00011620: 203a 3a20 7275 6e6f 6666 5f61 6767 0a0a   :: runoff_agg..
+00011630: 2020 2020 2120 6d65 6173 7572 6564 2072      ! measured r
+00011640: 756e 6f66 660a 2020 2020 7265 616c 2864  unoff.    real(d
+00011650: 7029 2c20 6469 6d65 6e73 696f 6e28 3a29  p), dimension(:)
+00011660: 2c20 616c 6c6f 6361 7461 626c 6520 3a3a  , allocatable ::
+00011670: 2072 756e 6f66 665f 6f62 730a 0a20 2020   runoff_obs..   
+00011680: 2021 206d 6173 6b20 666f 7220 6d65 6173   ! mask for meas
+00011690: 7572 6564 2072 756e 6f66 660a 2020 2020  ured runoff.    
+000116a0: 6c6f 6769 6361 6c2c 2064 696d 656e 7369  logical, dimensi
+000116b0: 6f6e 283a 292c 2061 6c6c 6f63 6174 6162  on(:), allocatab
+000116c0: 6c65 203a 3a20 7275 6e6f 6666 5f6f 6273  le :: runoff_obs
+000116d0: 5f6d 6173 6b0a 0a20 2020 2021 2072 756e  _mask..    ! run
+000116e0: 206d 484d 0a20 2020 2061 6c6c 6f63 6174   mHM.    allocat
+000116f0: 6528 736d 4f70 7469 5369 6d28 646f 6d61  e(smOptiSim(doma
+00011700: 696e 4d65 7461 256e 446f 6d61 696e 7329  inMeta%nDomains)
+00011710: 290a 2020 2020 6361 6c6c 2065 7661 6c28  ).    call eval(
+00011720: 7061 7261 6d65 7465 7273 6574 2c20 7275  parameterset, ru
+00011730: 6e6f 6666 203d 2072 756e 6f66 662c 2073  noff = runoff, s
+00011740: 6d4f 7074 6953 696d 203d 2073 6d4f 7074  mOptiSim = smOpt
+00011750: 6953 696d 290a 0a20 2020 2021 202d 2d2d  iSim)..    ! ---
+00011760: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00011770: 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2020 2021  ----------.    !
+00011780: 2053 4f49 4c20 4d4f 4953 5455 5245 0a20   SOIL MOISTURE. 
+00011790: 2020 2021 202d 2d2d 2d2d 2d2d 2d2d 2d2d     ! -----------
 000117a0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000117b0: 2d2d 2d2d 2d2d 2d2d 0a20 2020 2021 2053  --------.    ! S
-000117c0: 4f49 4c20 4d4f 4953 5455 5245 0a20 2020  OIL MOISTURE.   
-000117d0: 2021 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d   ! -------------
-000117e0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000117f0: 0a0a 2020 2020 2120 696e 6974 6961 6c69  ..    ! initiali
-00011800: 7a65 2073 6f6d 6520 7661 7269 6162 6c65  ze some variable
-00011810: 730a 2020 2020 6f62 6a65 6374 6976 655f  s.    objective_
-00011820: 736d 203d 2030 2e30 5f64 700a 0a20 2020  sm = 0.0_dp..   
-00011830: 2021 206c 6f6f 7020 6f76 6572 2064 6f6d   ! loop over dom
-00011840: 6169 6e20 2d20 666f 7220 6170 706c 7969  ain - for applyi
-00011850: 6e67 2070 6f77 6572 206c 6177 206c 6174  ng power law lat
-00011860: 6572 206f 6e0a 2020 2020 646f 2069 446f  er on.    do iDo
-00011870: 6d61 696e 203d 2031 2c20 646f 6d61 696e  main = 1, domain
-00011880: 4d65 7461 256e 446f 6d61 696e 730a 0a20  Meta%nDomains.. 
-00011890: 2020 2020 2021 2069 6e69 740a 2020 2020       ! init.    
-000118a0: 2020 6f62 6a65 6374 6976 655f 736d 5f64    objective_sm_d
-000118b0: 6f6d 6169 6e20 3d20 302e 305f 6470 0a20  omain = 0.0_dp. 
-000118c0: 2020 2020 2021 2067 6574 2064 6f6d 6169       ! get domai
-000118d0: 6e20 696e 666f 726d 6174 696f 6e0a 2020  n information.  
-000118e0: 2020 2020 6e43 656c 6c73 3120 3d20 6c65      nCells1 = le
-000118f0: 7665 6c31 2869 446f 6d61 696e 2925 6e43  vel1(iDomain)%nC
-00011900: 656c 6c73 0a0a 2020 2020 2020 2120 636f  ells..      ! co
-00011910: 7272 656c 6174 696f 6e20 7369 676e 616c  rrelation signal
-00011920: 2069 7320 6361 6c63 756c 6174 6564 206f   is calculated o
-00011930: 6e20 696e 6469 7669 6475 616c 2067 7269  n individual gri
-00011940: 6420 6365 6c6c 730a 2020 2020 2020 696e  d cells.      in
-00011950: 7661 6c69 645f 6365 6c6c 7320 3d20 302e  valid_cells = 0.
-00011960: 305f 6470 0a20 2020 2020 2064 6f20 6943  0_dp.      do iC
-00011970: 656c 6c20 3d20 312c 2073 697a 6528 4c31  ell = 1, size(L1
-00011980: 5f73 6d4f 6273 2869 446f 6d61 696e 2925  _smObs(iDomain)%
-00011990: 6d61 736b 4f62 7328 3a2c 203a 292c 2064  maskObs(:, :), d
-000119a0: 696d 203d 2031 290a 0a20 2020 2020 2020  im = 1)..       
-000119b0: 2021 2063 6865 636b 2066 6f72 2065 6e6f   ! check for eno
-000119c0: 7567 6820 6461 7461 2070 6f69 6e74 7320  ugh data points 
-000119d0: 696e 2074 696d 6520 666f 7220 7374 6174  in time for stat
-000119e0: 6973 7469 6361 6c20 6361 6c63 756c 6174  istical calculat
-000119f0: 696f 6e73 2028 652e 672e 206d 6561 6e2c  ions (e.g. mean,
-00011a00: 2073 7464 6465 7629 0a20 2020 2020 2020   stddev).       
-00011a10: 2069 6620 2863 6f75 6e74 284c 315f 736d   if (count(L1_sm
-00011a20: 4f62 7328 6944 6f6d 6169 6e29 256d 6173  Obs(iDomain)%mas
-00011a30: 6b4f 6273 2869 4365 6c6c 2c20 3a29 2920  kObs(iCell, :)) 
-00011a40: 2e4c 452e 2028 302e 3130 5f64 7020 2a20  .LE. (0.10_dp * 
-00011a50: 7265 616c 2873 697a 6528 4c31 5f73 6d4f  real(size(L1_smO
-00011a60: 6273 2869 446f 6d61 696e 2925 6461 7461  bs(iDomain)%data
-00011a70: 4f62 732c 2064 696d 203d 2032 292c 2064  Obs, dim = 2), d
-00011a80: 7029 2929 2074 6865 6e0a 2020 2020 2020  p))) then.      
-00011a90: 2020 2020 696e 7661 6c69 645f 6365 6c6c      invalid_cell
-00011aa0: 7320 3d20 696e 7661 6c69 645f 6365 6c6c  s = invalid_cell
-00011ab0: 7320 2b20 312e 305f 6470 0a20 2020 2020  s + 1.0_dp.     
-00011ac0: 2020 2020 2063 7963 6c65 0a20 2020 2020       cycle.     
-00011ad0: 2020 2065 6e64 2069 660a 0a20 2020 2020     end if..     
-00011ae0: 2020 2021 2063 616c 6375 6c61 7465 206f     ! calculate o
-00011af0: 6a65 6374 6976 6520 6675 6e63 7469 6f6e  jective function
-00011b00: 0a20 2020 2020 2020 206f 626a 6563 7469  .        objecti
-00011b10: 7665 5f73 6d5f 646f 6d61 696e 203d 206f  ve_sm_domain = o
-00011b20: 626a 6563 7469 7665 5f73 6d5f 646f 6d61  bjective_sm_doma
-00011b30: 696e 202b 2026 0a20 2020 2020 2020 2020  in + &.         
-00011b40: 2020 2020 2020 2063 6f72 7265 6c61 7469         correlati
-00011b50: 6f6e 284c 315f 736d 4f62 7328 6944 6f6d  on(L1_smObs(iDom
-00011b60: 6169 6e29 2564 6174 614f 6273 2869 4365  ain)%dataObs(iCe
-00011b70: 6c6c 2c20 3a29 2c20 736d 4f70 7469 5369  ll, :), smOptiSi
-00011b80: 6d28 6944 6f6d 6169 6e29 2564 6174 6153  m(iDomain)%dataS
-00011b90: 696d 2869 4365 6c6c 2c20 3a29 2c20 260a  im(iCell, :), &.
-00011ba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011bb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011bc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011bd0: 2020 2020 2020 2020 2020 206d 6173 6b20             mask 
-00011be0: 3d20 4c31 5f73 6d4f 6273 2869 446f 6d61  = L1_smObs(iDoma
-00011bf0: 696e 2925 6d61 736b 4f62 7328 6943 656c  in)%maskObs(iCel
-00011c00: 6c2c 203a 2929 0a20 2020 2020 2065 6e64  l, :)).      end
-00011c10: 2064 6f0a 0a20 2020 2020 2021 2075 7365   do..      ! use
-00011c20: 7220 696e 666f 726d 6174 696f 6e20 6162  r information ab
-00011c30: 6f75 7420 696e 7661 6c69 6420 6365 6c6c  out invalid cell
-00011c40: 730a 2020 2020 2020 6966 2028 696e 7661  s.      if (inva
-00011c50: 6c69 645f 6365 6c6c 7320 2e47 542e 2030  lid_cells .GT. 0
-00011c60: 2e35 5f64 7029 2074 6865 6e0a 2020 2020  .5_dp) then.    
-00011c70: 2020 2020 6361 6c6c 206d 6573 7361 6765      call message
-00011c80: 2827 2020 2057 4152 4e49 4e47 3a20 6f62  ('   WARNING: ob
-00011c90: 6a65 6374 6976 655f 736d 3a20 4465 7465  jective_sm: Dete
-00011ca0: 6374 6564 2069 6e76 616c 6964 2063 656c  cted invalid cel
-00011cb0: 6c73 2069 6e20 7374 7564 7920 6172 6561  ls in study area
-00011cc0: 2028 2e4c 542e 2031 3020 7661 6c69 6420   (.LT. 10 valid 
-00011cd0: 6461 7461 2070 6f69 6e74 7329 2e27 290a  data points).').
-00011ce0: 2020 2020 2020 2020 6361 6c6c 206d 6573          call mes
-00011cf0: 7361 6765 2827 2020 2020 2020 2020 2020  sage('          
-00011d00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011d10: 4672 6163 7469 6f6e 206f 6620 696e 7661  Fraction of inva
-00011d20: 6c69 6420 6365 6c6c 733a 2027 2c20 260a  lid cells: ', &.
-00011d30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011d40: 6e75 6d32 7374 7228 696e 7661 6c69 645f  num2str(invalid_
-00011d50: 6365 6c6c 7320 2f20 7265 616c 286e 4365  cells / real(nCe
-00011d60: 6c6c 7331 2c20 6470 292c 2027 2846 342e  lls1, dp), '(F4.
-00011d70: 3229 2729 290a 2020 2020 2020 656e 6420  2)')).      end 
-00011d80: 6966 0a0a 2020 2020 2020 2120 6361 6c63  if..      ! calc
-00011d90: 756c 6174 6520 6176 6572 6167 6520 736f  ulate average so
-00011da0: 696c 206d 6f69 7374 7572 6520 6f62 6a65  il moisture obje
-00011db0: 6374 6976 6520 6f76 6572 2061 6c6c 2064  ctive over all d
-00011dc0: 6f6d 6169 6e73 2077 6974 6820 706f 7765  omains with powe
-00011dd0: 7220 6c61 770a 2020 2020 2020 2120 646f  r law.      ! do
-00011de0: 6d61 696e 7320 6172 6520 7765 6967 6874  mains are weight
-00011df0: 6564 2065 7175 616c 6c79 2028 2031 202f  ed equally ( 1 /
-00011e00: 2072 6561 6c28 646f 6d61 696e 4d65 7461   real(domainMeta
-00011e10: 256f 7665 7261 6c6c 4e75 6d62 6572 4f66  %overallNumberOf
-00011e20: 446f 6d61 696e 732c 6470 2929 2a2a 360a  Domains,dp))**6.
-00011e30: 2020 2020 2020 6f62 6a65 6374 6976 655f        objective_
-00011e40: 736d 203d 206f 626a 6563 7469 7665 5f73  sm = objective_s
-00011e50: 6d20 2b20 260a 2020 2020 2020 2020 2020  m + &.          
-00011e60: 2020 2020 2828 312e 305f 6470 202d 206f      ((1.0_dp - o
-00011e70: 626a 6563 7469 7665 5f73 6d5f 646f 6d61  bjective_sm_doma
-00011e80: 696e 202f 2072 6561 6c28 6e43 656c 6c73  in / real(nCells
-00011e90: 312c 2064 7029 2920 2f20 7265 616c 2864  1, dp)) / real(d
-00011ea0: 6f6d 6169 6e4d 6574 6125 6f76 6572 616c  omainMeta%overal
-00011eb0: 6c4e 756d 6265 724f 6644 6f6d 6169 6e73  lNumberOfDomains
-00011ec0: 2c20 6470 2929 2a2a 360a 2020 2020 2020  , dp))**6.      
-00011ed0: 6361 6c6c 2073 6d4f 7074 6953 696d 2869  call smOptiSim(i
-00011ee0: 446f 6d61 696e 2925 6465 7374 726f 7928  Domain)%destroy(
-00011ef0: 290a 2020 2020 656e 6420 646f 0a20 2020  ).    end do.   
-00011f00: 2064 6561 6c6c 6f63 6174 6528 736d 4f70   deallocate(smOp
-00011f10: 7469 5369 6d29 0a0a 2020 2020 2120 636f  tiSim)..    ! co
-00011f20: 6d70 726f 6d69 7365 2073 6f6c 7574 696f  mpromise solutio
-00011f30: 6e20 2d20 7369 7874 6820 726f 6f74 0a20  n - sixth root. 
-00011f40: 2020 206f 626a 6563 7469 7665 5f73 6d20     objective_sm 
-00011f50: 3d20 6f62 6a65 6374 6976 655f 736d 2a2a  = objective_sm**
-00011f60: 6f6e 6573 6978 7468 0a0a 2020 2020 2120  onesixth..    ! 
+000117b0: 2d2d 0a0a 2020 2020 2120 696e 6974 6961  --..    ! initia
+000117c0: 6c69 7a65 2073 6f6d 6520 7661 7269 6162  lize some variab
+000117d0: 6c65 730a 2020 2020 6f62 6a65 6374 6976  les.    objectiv
+000117e0: 655f 736d 203d 2030 2e30 5f64 700a 0a20  e_sm = 0.0_dp.. 
+000117f0: 2020 2021 206c 6f6f 7020 6f76 6572 2064     ! loop over d
+00011800: 6f6d 6169 6e20 2d20 666f 7220 6170 706c  omain - for appl
+00011810: 7969 6e67 2070 6f77 6572 206c 6177 206c  ying power law l
+00011820: 6174 6572 206f 6e0a 2020 2020 646f 2069  ater on.    do i
+00011830: 446f 6d61 696e 203d 2031 2c20 646f 6d61  Domain = 1, doma
+00011840: 696e 4d65 7461 256e 446f 6d61 696e 730a  inMeta%nDomains.
+00011850: 0a20 2020 2020 2021 2069 6e69 740a 2020  .      ! init.  
+00011860: 2020 2020 6f62 6a65 6374 6976 655f 736d      objective_sm
+00011870: 5f64 6f6d 6169 6e20 3d20 302e 305f 6470  _domain = 0.0_dp
+00011880: 0a20 2020 2020 2021 2067 6574 2064 6f6d  .      ! get dom
+00011890: 6169 6e20 696e 666f 726d 6174 696f 6e0a  ain information.
+000118a0: 2020 2020 2020 6e43 656c 6c73 3120 3d20        nCells1 = 
+000118b0: 6c65 7665 6c31 2869 446f 6d61 696e 2925  level1(iDomain)%
+000118c0: 6e43 656c 6c73 0a0a 2020 2020 2020 2120  nCells..      ! 
+000118d0: 636f 7272 656c 6174 696f 6e20 7369 676e  correlation sign
+000118e0: 616c 2069 7320 6361 6c63 756c 6174 6564  al is calculated
+000118f0: 206f 6e20 696e 6469 7669 6475 616c 2067   on individual g
+00011900: 7269 6420 6365 6c6c 730a 2020 2020 2020  rid cells.      
+00011910: 696e 7661 6c69 645f 6365 6c6c 7320 3d20  invalid_cells = 
+00011920: 302e 305f 6470 0a20 2020 2020 2064 6f20  0.0_dp.      do 
+00011930: 6943 656c 6c20 3d20 312c 2073 697a 6528  iCell = 1, size(
+00011940: 4c31 5f73 6d4f 6273 2869 446f 6d61 696e  L1_smObs(iDomain
+00011950: 2925 6d61 736b 4f62 7328 3a2c 203a 292c  )%maskObs(:, :),
+00011960: 2064 696d 203d 2031 290a 0a20 2020 2020   dim = 1)..     
+00011970: 2020 2021 2063 6865 636b 2066 6f72 2065     ! check for e
+00011980: 6e6f 7567 6820 6461 7461 2070 6f69 6e74  nough data point
+00011990: 7320 696e 2074 696d 6520 666f 7220 7374  s in time for st
+000119a0: 6174 6973 7469 6361 6c20 6361 6c63 756c  atistical calcul
+000119b0: 6174 696f 6e73 2028 652e 672e 206d 6561  ations (e.g. mea
+000119c0: 6e2c 2073 7464 6465 7629 0a20 2020 2020  n, stddev).     
+000119d0: 2020 2069 6620 2863 6f75 6e74 284c 315f     if (count(L1_
+000119e0: 736d 4f62 7328 6944 6f6d 6169 6e29 256d  smObs(iDomain)%m
+000119f0: 6173 6b4f 6273 2869 4365 6c6c 2c20 3a29  askObs(iCell, :)
+00011a00: 2920 2e4c 452e 2028 302e 3130 5f64 7020  ) .LE. (0.10_dp 
+00011a10: 2a20 7265 616c 2873 697a 6528 4c31 5f73  * real(size(L1_s
+00011a20: 6d4f 6273 2869 446f 6d61 696e 2925 6461  mObs(iDomain)%da
+00011a30: 7461 4f62 732c 2064 696d 203d 2032 292c  taObs, dim = 2),
+00011a40: 2064 7029 2929 2074 6865 6e0a 2020 2020   dp))) then.    
+00011a50: 2020 2020 2020 696e 7661 6c69 645f 6365        invalid_ce
+00011a60: 6c6c 7320 3d20 696e 7661 6c69 645f 6365  lls = invalid_ce
+00011a70: 6c6c 7320 2b20 312e 305f 6470 0a20 2020  lls + 1.0_dp.   
+00011a80: 2020 2020 2020 2063 7963 6c65 0a20 2020         cycle.   
+00011a90: 2020 2020 2065 6e64 2069 660a 0a20 2020       end if..   
+00011aa0: 2020 2020 2021 2063 616c 6375 6c61 7465       ! calculate
+00011ab0: 206f 6a65 6374 6976 6520 6675 6e63 7469   ojective functi
+00011ac0: 6f6e 0a20 2020 2020 2020 206f 626a 6563  on.        objec
+00011ad0: 7469 7665 5f73 6d5f 646f 6d61 696e 203d  tive_sm_domain =
+00011ae0: 206f 626a 6563 7469 7665 5f73 6d5f 646f   objective_sm_do
+00011af0: 6d61 696e 202b 2026 0a20 2020 2020 2020  main + &.       
+00011b00: 2020 2020 2020 2020 2063 6f72 7265 6c61           correla
+00011b10: 7469 6f6e 284c 315f 736d 4f62 7328 6944  tion(L1_smObs(iD
+00011b20: 6f6d 6169 6e29 2564 6174 614f 6273 2869  omain)%dataObs(i
+00011b30: 4365 6c6c 2c20 3a29 2c20 736d 4f70 7469  Cell, :), smOpti
+00011b40: 5369 6d28 6944 6f6d 6169 6e29 2564 6174  Sim(iDomain)%dat
+00011b50: 6153 696d 2869 4365 6c6c 2c20 3a29 2c20  aSim(iCell, :), 
+00011b60: 260a 2020 2020 2020 2020 2020 2020 2020  &.              
+00011b70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011b80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011b90: 2020 2020 2020 2020 2020 2020 206d 6173               mas
+00011ba0: 6b20 3d20 4c31 5f73 6d4f 6273 2869 446f  k = L1_smObs(iDo
+00011bb0: 6d61 696e 2925 6d61 736b 4f62 7328 6943  main)%maskObs(iC
+00011bc0: 656c 6c2c 203a 2929 0a20 2020 2020 2065  ell, :)).      e
+00011bd0: 6e64 2064 6f0a 0a20 2020 2020 2021 2075  nd do..      ! u
+00011be0: 7365 7220 696e 666f 726d 6174 696f 6e20  ser information 
+00011bf0: 6162 6f75 7420 696e 7661 6c69 6420 6365  about invalid ce
+00011c00: 6c6c 730a 2020 2020 2020 6966 2028 696e  lls.      if (in
+00011c10: 7661 6c69 645f 6365 6c6c 7320 2e47 542e  valid_cells .GT.
+00011c20: 2030 2e35 5f64 7029 2074 6865 6e0a 2020   0.5_dp) then.  
+00011c30: 2020 2020 2020 6361 6c6c 206d 6573 7361        call messa
+00011c40: 6765 2827 2020 2057 4152 4e49 4e47 3a20  ge('   WARNING: 
+00011c50: 6f62 6a65 6374 6976 655f 736d 3a20 4465  objective_sm: De
+00011c60: 7465 6374 6564 2069 6e76 616c 6964 2063  tected invalid c
+00011c70: 656c 6c73 2069 6e20 7374 7564 7920 6172  ells in study ar
+00011c80: 6561 2028 2e4c 542e 2031 3020 7661 6c69  ea (.LT. 10 vali
+00011c90: 6420 6461 7461 2070 6f69 6e74 7329 2e27  d data points).'
+00011ca0: 290a 2020 2020 2020 2020 6361 6c6c 206d  ).        call m
+00011cb0: 6573 7361 6765 2827 2020 2020 2020 2020  essage('        
+00011cc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011cd0: 2020 4672 6163 7469 6f6e 206f 6620 696e    Fraction of in
+00011ce0: 7661 6c69 6420 6365 6c6c 733a 2027 2c20  valid cells: ', 
+00011cf0: 260a 2020 2020 2020 2020 2020 2020 2020  &.              
+00011d00: 2020 6e75 6d32 7374 7228 696e 7661 6c69    num2str(invali
+00011d10: 645f 6365 6c6c 7320 2f20 7265 616c 286e  d_cells / real(n
+00011d20: 4365 6c6c 7331 2c20 6470 292c 2027 2846  Cells1, dp), '(F
+00011d30: 342e 3229 2729 290a 2020 2020 2020 656e  4.2)')).      en
+00011d40: 6420 6966 0a0a 2020 2020 2020 2120 6361  d if..      ! ca
+00011d50: 6c63 756c 6174 6520 6176 6572 6167 6520  lculate average 
+00011d60: 736f 696c 206d 6f69 7374 7572 6520 6f62  soil moisture ob
+00011d70: 6a65 6374 6976 6520 6f76 6572 2061 6c6c  jective over all
+00011d80: 2064 6f6d 6169 6e73 2077 6974 6820 706f   domains with po
+00011d90: 7765 7220 6c61 770a 2020 2020 2020 2120  wer law.      ! 
+00011da0: 646f 6d61 696e 7320 6172 6520 7765 6967  domains are weig
+00011db0: 6874 6564 2065 7175 616c 6c79 2028 2031  hted equally ( 1
+00011dc0: 202f 2072 6561 6c28 646f 6d61 696e 4d65   / real(domainMe
+00011dd0: 7461 256f 7665 7261 6c6c 4e75 6d62 6572  ta%overallNumber
+00011de0: 4f66 446f 6d61 696e 732c 6470 2929 2a2a  OfDomains,dp))**
+00011df0: 360a 2020 2020 2020 6f62 6a65 6374 6976  6.      objectiv
+00011e00: 655f 736d 203d 206f 626a 6563 7469 7665  e_sm = objective
+00011e10: 5f73 6d20 2b20 260a 2020 2020 2020 2020  _sm + &.        
+00011e20: 2020 2020 2020 2828 312e 305f 6470 202d        ((1.0_dp -
+00011e30: 206f 626a 6563 7469 7665 5f73 6d5f 646f   objective_sm_do
+00011e40: 6d61 696e 202f 2072 6561 6c28 6e43 656c  main / real(nCel
+00011e50: 6c73 312c 2064 7029 2920 2f20 7265 616c  ls1, dp)) / real
+00011e60: 2864 6f6d 6169 6e4d 6574 6125 6f76 6572  (domainMeta%over
+00011e70: 616c 6c4e 756d 6265 724f 6644 6f6d 6169  allNumberOfDomai
+00011e80: 6e73 2c20 6470 2929 2a2a 360a 2020 2020  ns, dp))**6.    
+00011e90: 2020 6361 6c6c 2073 6d4f 7074 6953 696d    call smOptiSim
+00011ea0: 2869 446f 6d61 696e 2925 6465 7374 726f  (iDomain)%destro
+00011eb0: 7928 290a 2020 2020 656e 6420 646f 0a20  y().    end do. 
+00011ec0: 2020 2064 6561 6c6c 6f63 6174 6528 736d     deallocate(sm
+00011ed0: 4f70 7469 5369 6d29 0a0a 2020 2020 2120  OptiSim)..    ! 
+00011ee0: 636f 6d70 726f 6d69 7365 2073 6f6c 7574  compromise solut
+00011ef0: 696f 6e20 2d20 7369 7874 6820 726f 6f74  ion - sixth root
+00011f00: 0a20 2020 206f 626a 6563 7469 7665 5f73  .    objective_s
+00011f10: 6d20 3d20 6f62 6a65 6374 6976 655f 736d  m = objective_sm
+00011f20: 2a2a 6f6e 6573 6978 7468 0a0a 2020 2020  **onesixth..    
+00011f30: 2120 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ! --------------
+00011f40: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a  ---------------.
+00011f50: 2020 2020 2120 5255 4e4f 4646 0a20 2020      ! RUNOFF.   
+00011f60: 2021 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d   ! -------------
 00011f70: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00011f80: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 2020  -------------.  
-00011f90: 2020 2120 5255 4e4f 4646 0a20 2020 2021    ! RUNOFF.    !
-00011fa0: 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d   ---------------
-00011fb0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a20  --------------. 
-00011fc0: 2020 206f 626a 6563 7469 7665 5f6b 6765     objective_kge
-00011fd0: 203d 2030 2e30 5f64 700a 2020 2020 6e47   = 0.0_dp.    nG
-00011fe0: 6175 6765 7354 6f74 616c 203d 2073 697a  augesTotal = siz
-00011ff0: 6528 7275 6e6f 6666 2c20 6469 6d20 3d20  e(runoff, dim = 
-00012000: 3229 0a0a 2020 2020 646f 2067 6720 3d20  2)..    do gg = 
-00012010: 312c 206e 4761 7567 6573 546f 7461 6c0a  1, nGaugesTotal.
-00012020: 0a20 2020 2020 2021 2065 7874 7261 6374  .      ! extract
-00012030: 2072 756e 6f66 660a 2020 2020 2020 6361   runoff.      ca
-00012040: 6c6c 2065 7874 7261 6374 5f72 756e 6f66  ll extract_runof
-00012050: 6628 6767 2c20 7275 6e6f 6666 2c20 7275  f(gg, runoff, ru
-00012060: 6e6f 6666 5f61 6767 2c20 7275 6e6f 6666  noff_agg, runoff
-00012070: 5f6f 6273 2c20 7275 6e6f 6666 5f6f 6273  _obs, runoff_obs
-00012080: 5f6d 6173 6b29 0a0a 2020 2020 2020 2120  _mask)..      ! 
-00012090: 4b47 450a 2020 2020 2020 6f62 6a65 6374  KGE.      object
-000120a0: 6976 655f 6b67 6520 3d20 6f62 6a65 6374  ive_kge = object
-000120b0: 6976 655f 6b67 6520 2b20 260a 2020 2020  ive_kge + &.    
-000120c0: 2020 2020 2020 2020 2020 2828 312e 305f            ((1.0_
-000120d0: 6470 202d 206b 6765 2872 756e 6f66 665f  dp - kge(runoff_
-000120e0: 6f62 732c 2072 756e 6f66 665f 6167 672c  obs, runoff_agg,
-000120f0: 206d 6173 6b20 3d20 7275 6e6f 6666 5f6f   mask = runoff_o
-00012100: 6273 5f6d 6173 6b29 2920 2f20 7265 616c  bs_mask)) / real
-00012110: 286e 4761 7567 6573 546f 7461 6c2c 2064  (nGaugesTotal, d
-00012120: 7029 292a 2a36 0a0a 2020 2020 656e 6420  p))**6..    end 
-00012130: 646f 0a0a 2020 2020 6465 616c 6c6f 6361  do..    dealloca
-00012140: 7465 2872 756e 6f66 665f 6167 672c 2072  te(runoff_agg, r
-00012150: 756e 6f66 665f 6f62 732c 2072 756e 6f66  unoff_obs, runof
-00012160: 665f 6f62 735f 6d61 736b 290a 0a20 2020  f_obs_mask)..   
-00012170: 2021 2063 6f6d 7072 6f6d 6973 6520 736f   ! compromise so
-00012180: 6c75 7469 6f6e 202d 2073 6978 7468 2072  lution - sixth r
-00012190: 6f6f 740a 2020 2020 6f62 6a65 6374 6976  oot.    objectiv
-000121a0: 655f 6b67 6520 3d20 6f62 6a65 6374 6976  e_kge = objectiv
-000121b0: 655f 6b67 652a 2a6f 6e65 7369 7874 680a  e_kge**onesixth.
-000121c0: 0a20 2020 2021 2065 7175 616c 2077 6569  .    ! equal wei
-000121d0: 6768 7465 6420 636f 6d70 726f 6d69 7365  ghted compromise
-000121e0: 206f 626a 6563 7469 7665 2066 756e 6374   objective funct
-000121f0: 696f 6e73 2066 6f72 2064 6973 6368 6172  ions for dischar
-00012200: 6765 2061 6e64 2073 6f69 6c6d 6f69 7374  ge and soilmoist
-00012210: 7572 650a 2020 2020 2120 546f 446f 3a20  ure.    ! ToDo: 
-00012220: 7768 7920 646f 2077 6520 7573 6520 7468  why do we use th
-00012230: 6520 7369 7874 6820 726f 6f74 206f 6620  e sixth root of 
-00012240: 6f66 206f 626a 6563 7469 7665 5f73 6d20  of objective_sm 
-00012250: 616e 6420 6f62 6a65 6374 6976 655f 6b67  and objective_kg
-00012260: 650a 2020 2020 2120 6f6e 6c79 2074 6f20  e.    ! only to 
-00012270: 7461 6b65 2074 6865 2070 6f77 6572 2074  take the power t
-00012280: 6f20 3620 6865 7265 2061 6761 696e 2c20  o 6 here again, 
-00012290: 7768 656e 2077 6520 6e65 7665 7220 6e65  when we never ne
-000122a0: 6564 2074 6865 0a20 2020 2021 2069 6e74  ed the.    ! int
-000122b0: 6572 6d65 6469 6174 6520 7265 7375 6c74  ermediate result
-000122c0: 733f 0a23 6966 6465 6620 4d50 490a 2020  s?.#ifdef MPI.  
-000122d0: 2020 6f62 6a65 6374 6976 655f 6b67 655f    objective_kge_
-000122e0: 715f 736d 5f63 6f72 7220 3d20 286f 626a  q_sm_corr = (obj
-000122f0: 6563 7469 7665 5f73 6d2a 2a36 202b 206f  ective_sm**6 + o
-00012300: 626a 6563 7469 7665 5f6b 6765 2a2a 3629  bjective_kge**6)
-00012310: 0a23 656c 7365 0a20 2020 206f 626a 6563  .#else.    objec
-00012320: 7469 7665 5f6b 6765 5f71 5f73 6d5f 636f  tive_kge_q_sm_co
-00012330: 7272 203d 2028 6f62 6a65 6374 6976 655f  rr = (objective_
-00012340: 736d 2a2a 3620 2b20 6f62 6a65 6374 6976  sm**6 + objectiv
-00012350: 655f 6b67 652a 2a36 292a 2a6f 6e65 7369  e_kge**6)**onesi
-00012360: 7874 680a 0a20 2020 2063 616c 6c20 6d65  xth..    call me
-00012370: 7373 6167 6528 2720 2020 206f 626a 6563  ssage('    objec
-00012380: 7469 7665 5f6b 6765 5f71 5f73 6d5f 636f  tive_kge_q_sm_co
-00012390: 7272 203d 2027 2c20 6e75 6d32 7374 7228  rr = ', num2str(
-000123a0: 6f62 6a65 6374 6976 655f 6b67 655f 715f  objective_kge_q_
-000123b0: 736d 5f63 6f72 722c 2027 2846 392e 3529  sm_corr, '(F9.5)
-000123c0: 2729 290a 2365 6e64 6966 0a20 2020 2021  ')).#endif.    !
-000123d0: 2020 2020 7072 696e 742a 2c20 2231 2d53      print*, "1-S
-000123e0: 4d20 322d 5120 3a20 222c 2031 2e30 5f64  M 2-Q : ", 1.0_d
-000123f0: 702d 6f62 6a65 6374 6976 655f 736d 2c20  p-objective_sm, 
-00012400: 312e 305f 6470 2d6f 626a 6563 7469 7665  1.0_dp-objective
-00012410: 5f6b 6765 2021 204d 5a4d 5a4d 5a4d 5a0a  _kge ! MZMZMZMZ.
-00012420: 0a20 2045 4e44 2046 554e 4354 494f 4e20  .  END FUNCTION 
-00012430: 6f62 6a65 6374 6976 655f 6b67 655f 715f  objective_kge_q_
-00012440: 736d 5f63 6f72 720a 0a0a 2020 2120 2d2d  sm_corr...  ! --
-00012450: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00012460: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00012470: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00012480: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a  ---------------.
-00012490: 0a20 2021 2020 2020 4e41 4d45 0a20 2021  .  !    NAME.  !
-000124a0: 2020 2020 2020 2020 6f62 6a65 6374 6976          objectiv
-000124b0: 655f 6b67 655f 715f 6574 0a0a 2020 2120  e_kge_q_et..  ! 
-000124c0: 2020 2050 5552 504f 5345 0a20 2021 3e20     PURPOSE.  !> 
-000124d0: 2020 2020 2020 5c62 7269 6566 204f 626a        \brief Obj
-000124e0: 6563 7469 7665 2066 756e 6374 696f 6e20  ective function 
-000124f0: 6f66 204b 4745 2066 6f72 2072 756e 6f66  of KGE for runof
-00012500: 6620 616e 6420 4b47 4520 666f 7220 4554  f and KGE for ET
-00012510: 0a0a 2020 213e 2020 2020 2020 205c 6465  ..  !>       \de
-00012520: 7461 696c 7320 4f62 6a65 6374 6976 6520  tails Objective 
-00012530: 6675 6e63 7469 6f6e 206f 6620 4b47 4520  function of KGE 
-00012540: 666f 7220 7275 6e6f 6666 2061 6e64 204b  for runoff and K
-00012550: 4745 2066 6f72 2045 542e 0a20 2021 3e20  GE for ET..  !> 
-00012560: 2020 2020 2020 4675 7274 6865 7220 6465        Further de
-00012570: 7461 696c 7320 6361 6e20 6265 2066 6f75  tails can be fou
-00012580: 6e64 2069 6e20 7468 6520 646f 6375 6d65  nd in the docume
-00012590: 6e74 6174 696f 6e20 6f66 206f 626a 6563  ntation of objec
-000125a0: 7469 7665 2066 756e 6374 696f 6e73 0a20  tive functions. 
-000125b0: 2021 3e20 2020 2020 2020 2731 3420 2d20   !>       '14 - 
-000125c0: 6f62 6a65 6374 6976 655f 6d75 6c74 6970  objective_multip
-000125d0: 6c65 5f67 6175 6765 735f 6b67 655f 706f  le_gauges_kge_po
-000125e0: 7765 7236 272e 0a0a 2020 2120 2020 2049  wer6'...  !    I
-000125f0: 4e54 454e 5428 494e 290a 2020 213e 2020  NTENT(IN).  !>  
-00012600: 2020 2020 205c 7061 7261 6d5b 696e 5d20       \param[in] 
-00012610: 2272 6561 6c28 6470 292c 2064 696d 656e  "real(dp), dimen
-00012620: 7369 6f6e 283a 2920 3a3a 2070 6172 616d  sion(:) :: param
-00012630: 6574 6572 7365 7422 0a20 2021 3e20 2020  eterset".  !>   
-00012640: 2020 2020 5c70 6172 616d 5b69 6e5d 2022      \param[in] "
-00012650: 7072 6f63 6564 7572 6528 6576 616c 5f69  procedure(eval_i
-00012660: 6e74 6572 6661 6365 2920 3a3a 2065 7661  nterface) :: eva
-00012670: 6c22 0a0a 2020 2120 2020 2052 4554 5552  l"..  !    RETUR
-00012680: 4e0a 2020 213e 2020 2020 2020 205c 7265  N.  !>       \re
-00012690: 7475 726e 2072 6561 6c28 6470 2920 3a3a  turn real(dp) ::
-000126a0: 206f 626a 6563 7469 7665 5f6b 6765 5f71   objective_kge_q
-000126b0: 5f65 7420 266d 6461 7368 3b20 6f62 6a65  _et &mdash; obje
-000126c0: 6374 6976 6520 6675 6e63 7469 6f6e 2076  ctive function v
-000126d0: 616c 7565 0a20 2021 3e20 2020 2020 2020  alue.  !>       
-000126e0: 2877 6869 6368 2077 696c 6c20 6265 2065  (which will be e
-000126f0: 2e67 2e20 6d69 6e69 6d69 7a65 6420 6279  .g. minimized by
-00012700: 2061 6e20 6f70 7469 6d69 7a61 7469 6f6e   an optimization
-00012710: 2072 6f75 7469 6e65 206c 696b 6520 4444   routine like DD
-00012720: 5329 0a0a 2020 2120 2020 2048 4953 544f  S)..  !    HISTO
-00012730: 5259 0a20 2021 3e20 2020 2020 2020 5c61  RY.  !>       \a
-00012740: 7574 686f 7273 204a 6f68 616e 6e65 7320  uthors Johannes 
-00012750: 4272 656e 6e65 720a 0a20 2021 3e20 2020  Brenner..  !>   
-00012760: 2020 2020 5c64 6174 6520 4a75 6c79 2032      \date July 2
-00012770: 3031 370a 0a20 2021 204d 6f64 6966 6963  017..  ! Modific
-00012780: 6174 696f 6e73 3a0a 2020 2120 526f 6265  ations:.  ! Robe
-00012790: 7274 2053 6368 7765 7070 6520 4a75 6e20  rt Schweppe Jun 
-000127a0: 3230 3138 202d 2072 6566 6163 746f 7269  2018 - refactori
-000127b0: 6e67 2061 6e64 2072 6566 6f72 6d61 7474  ng and reformatt
-000127c0: 696e 670a 0a20 2046 554e 4354 494f 4e20  ing..  FUNCTION 
-000127d0: 6f62 6a65 6374 6976 655f 6b67 655f 715f  objective_kge_q_
-000127e0: 6574 2870 6172 616d 6574 6572 7365 742c  et(parameterset,
-000127f0: 2065 7661 6c29 0a0a 2020 2020 7573 6520   eval)..    use 
-00012800: 6d6f 5f6f 7074 696d 697a 6174 696f 6e5f  mo_optimization_
-00012810: 7479 7065 732c 206f 6e6c 7920 3a20 6f70  types, only : op
-00012820: 7469 6461 7461 5f73 696d 0a20 2020 2075  tidata_sim.    u
-00012830: 7365 206d 6f5f 636f 6d6d 6f6e 5f76 6172  se mo_common_var
-00012840: 6961 626c 6573 2c20 6f6e 6c79 203a 206c  iables, only : l
-00012850: 6576 656c 312c 2064 6f6d 6169 6e4d 6574  evel1, domainMet
-00012860: 610a 2020 2020 7573 6520 6d6f 5f65 7272  a.    use mo_err
-00012870: 6f72 6d65 6173 7572 6573 2c20 6f6e 6c79  ormeasures, only
-00012880: 203a 206b 6765 0a20 2020 2075 7365 206d   : kge.    use m
-00012890: 6f5f 676c 6f62 616c 5f76 6172 6961 626c  o_global_variabl
-000128a0: 6573 2c20 6f6e 6c79 203a 204c 315f 6574  es, only : L1_et
-000128b0: 4f62 730a 2020 2020 7573 6520 6d6f 5f6d  Obs.    use mo_m
-000128c0: 6573 7361 6765 2c20 6f6e 6c79 203a 206d  essage, only : m
-000128d0: 6573 7361 6765 0a20 2020 2075 7365 206d  essage.    use m
-000128e0: 6f5f 7374 7269 6e67 5f75 7469 6c73 2c20  o_string_utils, 
-000128f0: 6f6e 6c79 203a 206e 756d 3273 7472 0a20  only : num2str. 
-00012900: 2020 2075 7365 206d 6f5f 6d72 6d5f 6f62     use mo_mrm_ob
-00012910: 6a65 6374 6976 655f 6675 6e63 7469 6f6e  jective_function
-00012920: 5f72 756e 6f66 662c 206f 6e6c 7920 3a20  _runoff, only : 
-00012930: 6578 7472 6163 745f 7275 6e6f 6666 0a0a  extract_runoff..
-00012940: 2020 2020 696d 706c 6963 6974 206e 6f6e      implicit non
-00012950: 650a 0a20 2020 2072 6561 6c28 6470 292c  e..    real(dp),
-00012960: 2064 696d 656e 7369 6f6e 283a 292c 2069   dimension(:), i
-00012970: 6e74 656e 7428 696e 2920 3a3a 2070 6172  ntent(in) :: par
-00012980: 616d 6574 6572 7365 740a 0a20 2020 2070  ameterset..    p
-00012990: 726f 6365 6475 7265 2865 7661 6c5f 696e  rocedure(eval_in
-000129a0: 7465 7266 6163 6529 2c20 494e 5445 4e54  terface), INTENT
-000129b0: 2849 4e29 2c20 504f 494e 5445 5220 3a3a  (IN), POINTER ::
-000129c0: 2065 7661 6c0a 0a20 2020 2072 6561 6c28   eval..    real(
-000129d0: 6470 2920 3a3a 206f 626a 6563 7469 7665  dp) :: objective
-000129e0: 5f6b 6765 5f71 5f65 740a 0a20 2020 2072  _kge_q_et..    r
-000129f0: 6561 6c28 6470 2920 3a3a 206f 626a 6563  eal(dp) :: objec
-00012a00: 7469 7665 5f65 740a 0a20 2020 2072 6561  tive_et..    rea
-00012a10: 6c28 6470 2920 3a3a 206f 626a 6563 7469  l(dp) :: objecti
-00012a20: 7665 5f71 0a0a 2020 2020 2120 6e75 6d62  ve_q..    ! numb
-00012a30: 6572 206f 6620 696e 7661 6c69 6420 6365  er of invalid ce
-00012a40: 6c6c 7320 696e 2063 6174 6368 6d65 6e74  lls in catchment
-00012a50: 0a20 2020 2072 6561 6c28 6470 2920 3a3a  .    real(dp) ::
-00012a60: 2069 6e76 616c 6964 5f63 656c 6c73 0a0a   invalid_cells..
-00012a70: 2020 2020 2120 6d6f 6465 6c6c 6564 2072      ! modelled r
-00012a80: 756e 6f66 6620 666f 7220 6120 6769 7665  unoff for a give
-00012a90: 6e20 7061 7261 6d65 7465 7220 7365 740a  n parameter set.
-00012aa0: 2020 2020 2120 6469 6d31 3d6e 5469 6d65      ! dim1=nTime
-00012ab0: 5374 6570 732c 2064 696d 323d 6e47 6175  Steps, dim2=nGau
-00012ac0: 6765 730a 2020 2020 7265 616c 2864 7029  ges.    real(dp)
-00012ad0: 2c20 616c 6c6f 6361 7461 626c 652c 2064  , allocatable, d
-00012ae0: 696d 656e 7369 6f6e 283a 2c20 3a29 203a  imension(:, :) :
-00012af0: 3a20 7275 6e6f 6666 0a0a 2020 2020 2120  : runoff..    ! 
-00012b00: 646f 6d61 696e 206c 6f6f 7020 636f 756e  domain loop coun
-00012b10: 7465 720a 2020 2020 696e 7465 6765 7228  ter.    integer(
-00012b20: 6934 2920 3a3a 2069 446f 6d61 696e 0a0a  i4) :: iDomain..
-00012b30: 2020 2020 2120 6365 6c6c 206c 6f6f 7020      ! cell loop 
-00012b40: 636f 756e 7465 720a 2020 2020 696e 7465  counter.    inte
-00012b50: 6765 7228 6934 2920 3a3a 2069 4365 6c6c  ger(i4) :: iCell
-00012b60: 0a0a 2020 2020 2120 6e63 656c 6c73 3120  ..    ! ncells1 
-00012b70: 6f66 206c 6576 656c 2031 0a20 2020 2069  of level 1.    i
-00012b80: 6e74 6567 6572 2869 3429 203a 3a20 6e43  nteger(i4) :: nC
-00012b90: 656c 6c73 310a 0a20 2020 2021 2064 6f6d  ells1..    ! dom
-00012ba0: 6169 6e73 2077 6973 6520 6f62 6a65 6374  ains wise object
-00012bb0: 6976 6573 0a20 2020 2072 6561 6c28 6470  ives.    real(dp
-00012bc0: 2920 3a3a 206f 626a 6563 7469 7665 5f65  ) :: objective_e
-00012bd0: 745f 646f 6d61 696e 0a0a 2020 2020 213e  t_domain..    !>
-00012be0: 2073 696d 756c 6174 6564 2065 740a 2020   simulated et.  
-00012bf0: 2020 7479 7065 286f 7074 6964 6174 615f    type(optidata_
-00012c00: 7369 6d29 2c20 6469 6d65 6e73 696f 6e28  sim), dimension(
-00012c10: 3a29 2c20 616c 6c6f 6361 7461 626c 6520  :), allocatable 
-00012c20: 3a3a 2065 744f 7074 6953 696d 0a0a 2020  :: etOptiSim..  
-00012c30: 2020 7265 616c 2864 7029 2c20 7061 7261    real(dp), para
-00012c40: 6d65 7465 7220 3a3a 206f 6e65 7369 7874  meter :: onesixt
-00012c50: 6820 3d20 312e 305f 6470 202f 2036 2e30  h = 1.0_dp / 6.0
-00012c60: 5f64 700a 0a20 2020 2021 2067 6175 6765  _dp..    ! gauge
-00012c70: 7320 636f 756e 7465 720a 2020 2020 696e  s counter.    in
-00012c80: 7465 6765 7228 6934 2920 3a3a 2067 670a  teger(i4) :: gg.
-00012c90: 0a20 2020 2069 6e74 6567 6572 2869 3429  .    integer(i4)
-00012ca0: 203a 3a20 6e47 6175 6765 7354 6f74 616c   :: nGaugesTotal
-00012cb0: 0a0a 2020 2020 2120 6167 6772 6567 6174  ..    ! aggregat
-00012cc0: 6564 2073 696d 756c 6174 6564 2072 756e  ed simulated run
-00012cd0: 6f66 660a 2020 2020 7265 616c 2864 7029  off.    real(dp)
-00012ce0: 2c20 6469 6d65 6e73 696f 6e28 3a29 2c20  , dimension(:), 
-00012cf0: 616c 6c6f 6361 7461 626c 6520 3a3a 2072  allocatable :: r
-00012d00: 756e 6f66 665f 6167 670a 0a20 2020 2021  unoff_agg..    !
-00012d10: 206d 6561 7375 7265 6420 7275 6e6f 6666   measured runoff
-00012d20: 0a20 2020 2072 6561 6c28 6470 292c 2064  .    real(dp), d
-00012d30: 696d 656e 7369 6f6e 283a 292c 2061 6c6c  imension(:), all
-00012d40: 6f63 6174 6162 6c65 203a 3a20 7275 6e6f  ocatable :: runo
-00012d50: 6666 5f6f 6273 0a0a 2020 2020 2120 6d61  ff_obs..    ! ma
-00012d60: 736b 2066 6f72 206d 6561 7375 7265 6420  sk for measured 
-00012d70: 7275 6e6f 6666 0a20 2020 206c 6f67 6963  runoff.    logic
-00012d80: 616c 2c20 6469 6d65 6e73 696f 6e28 3a29  al, dimension(:)
-00012d90: 2c20 616c 6c6f 6361 7461 626c 6520 3a3a  , allocatable ::
-00012da0: 2072 756e 6f66 665f 6f62 735f 6d61 736b   runoff_obs_mask
-00012db0: 0a0a 2020 2020 2120 7275 6e20 6d48 4d0a  ..    ! run mHM.
-00012dc0: 2020 2020 616c 6c6f 6361 7465 2865 744f      allocate(etO
-00012dd0: 7074 6953 696d 2864 6f6d 6169 6e4d 6574  ptiSim(domainMet
-00012de0: 6125 6e44 6f6d 6169 6e73 2929 0a20 2020  a%nDomains)).   
-00012df0: 2063 616c 6c20 6576 616c 2870 6172 616d   call eval(param
-00012e00: 6574 6572 7365 742c 2072 756e 6f66 6620  eterset, runoff 
-00012e10: 3d20 7275 6e6f 6666 2c20 6574 4f70 7469  = runoff, etOpti
-00012e20: 5369 6d20 3d20 6574 4f70 7469 5369 6d29  Sim = etOptiSim)
-00012e30: 0a0a 2020 2020 2120 2d2d 2d2d 2d2d 2d2d  ..    ! --------
-00012e40: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00012e50: 2d2d 2d2d 2d0a 2020 2020 2120 4556 4150  -----.    ! EVAP
-00012e60: 4f54 5241 4e53 5049 5241 5449 4f4e 0a20  OTRANSPIRATION. 
-00012e70: 2020 2021 202d 2d2d 2d2d 2d2d 2d2d 2d2d     ! -----------
-00012e80: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00012e90: 2d2d 0a0a 2020 2020 2120 696e 6974 6961  --..    ! initia
-00012ea0: 6c69 7a65 2073 6f6d 6520 7661 7269 6162  lize some variab
-00012eb0: 6c65 730a 2020 2020 6f62 6a65 6374 6976  les.    objectiv
-00012ec0: 655f 6574 203d 2030 2e30 5f64 700a 0a20  e_et = 0.0_dp.. 
-00012ed0: 2020 2021 206c 6f6f 7020 6f76 6572 2064     ! loop over d
-00012ee0: 6f6d 6169 6e20 2d20 666f 7220 6170 706c  omain - for appl
-00012ef0: 7969 6e67 2070 6f77 6572 206c 6177 206c  ying power law l
-00012f00: 6174 6572 206f 6e0a 2020 2020 646f 2069  ater on.    do i
-00012f10: 446f 6d61 696e 203d 2031 2c20 646f 6d61  Domain = 1, doma
-00012f20: 696e 4d65 7461 256e 446f 6d61 696e 730a  inMeta%nDomains.
-00012f30: 0a20 2020 2020 2021 2069 6e69 740a 2020  .      ! init.  
-00012f40: 2020 2020 6f62 6a65 6374 6976 655f 6574      objective_et
-00012f50: 5f64 6f6d 6169 6e20 3d20 302e 305f 6470  _domain = 0.0_dp
-00012f60: 0a20 2020 2020 2021 2067 6574 2064 6f6d  .      ! get dom
-00012f70: 6169 6e20 696e 666f 726d 6174 696f 6e0a  ain information.
-00012f80: 2020 2020 2020 6e43 656c 6c73 3120 3d20        nCells1 = 
-00012f90: 6c65 7665 6c31 2869 446f 6d61 696e 2925  level1(iDomain)%
-00012fa0: 6e43 656c 6c73 0a0a 2020 2020 2020 2120  nCells..      ! 
-00012fb0: 636f 7272 656c 6174 696f 6e20 7369 676e  correlation sign
-00012fc0: 616c 2069 7320 6361 6c63 756c 6174 6564  al is calculated
-00012fd0: 206f 6e20 696e 6469 7669 6475 616c 2067   on individual g
-00012fe0: 7269 6420 6365 6c6c 730a 2020 2020 2020  rid cells.      
-00012ff0: 696e 7661 6c69 645f 6365 6c6c 7320 3d20  invalid_cells = 
-00013000: 302e 305f 6470 0a20 2020 2020 2064 6f20  0.0_dp.      do 
-00013010: 6943 656c 6c20 3d20 312c 2073 697a 6528  iCell = 1, size(
-00013020: 4c31 5f65 744f 6273 2869 446f 6d61 696e  L1_etObs(iDomain
-00013030: 2925 6d61 736b 4f62 732c 2064 696d 203d  )%maskObs, dim =
-00013040: 2031 290a 0a20 2020 2020 2020 2021 2063   1)..        ! c
-00013050: 6865 636b 2066 6f72 2065 6e6f 7567 6820  heck for enough 
-00013060: 6461 7461 2070 6f69 6e74 7320 696e 2074  data points in t
-00013070: 696d 6520 666f 7220 7374 6174 6973 7469  ime for statisti
-00013080: 6361 6c20 6361 6c63 756c 6174 696f 6e73  cal calculations
-00013090: 2028 652e 672e 206d 6561 6e2c 2073 7464   (e.g. mean, std
-000130a0: 6465 7629 0a20 2020 2020 2020 2069 6620  dev).        if 
-000130b0: 2863 6f75 6e74 284c 315f 6574 4f62 7328  (count(L1_etObs(
-000130c0: 6944 6f6d 6169 6e29 256d 6173 6b4f 6273  iDomain)%maskObs
-000130d0: 2869 4365 6c6c 2c20 3a29 2920 2e4c 452e  (iCell, :)) .LE.
-000130e0: 2026 0a20 2020 2020 2020 2020 2020 2020   &.             
-000130f0: 2020 2020 2020 2020 2020 2020 2020 2028                 (
-00013100: 302e 3130 5f64 7020 2a20 7265 616c 2873  0.10_dp * real(s
-00013110: 697a 6528 4c31 5f65 744f 6273 2869 446f  ize(L1_etObs(iDo
-00013120: 6d61 696e 2925 6461 7461 4f62 7328 3a2c  main)%dataObs(:,
-00013130: 203a 292c 2064 696d 203d 2032 292c 2064   :), dim = 2), d
-00013140: 7029 2929 2074 6865 6e0a 2020 2020 2020  p))) then.      
-00013150: 2020 2020 696e 7661 6c69 645f 6365 6c6c      invalid_cell
-00013160: 7320 3d20 696e 7661 6c69 645f 6365 6c6c  s = invalid_cell
-00013170: 7320 2b20 312e 305f 6470 0a20 2020 2020  s + 1.0_dp.     
-00013180: 2020 2020 2063 7963 6c65 0a20 2020 2020       cycle.     
-00013190: 2020 2065 6e64 2069 660a 0a20 2020 2020     end if..     
-000131a0: 2020 2021 2063 616c 6375 6c61 7465 206f     ! calculate o
-000131b0: 6a65 6374 6976 6520 6675 6e63 7469 6f6e  jective function
-000131c0: 0a20 2020 2020 2020 206f 626a 6563 7469  .        objecti
-000131d0: 7665 5f65 745f 646f 6d61 696e 203d 206f  ve_et_domain = o
-000131e0: 626a 6563 7469 7665 5f65 745f 646f 6d61  bjective_et_doma
-000131f0: 696e 202b 2026 0a20 2020 2020 2020 2020  in + &.         
-00013200: 2020 2020 2020 206b 6765 284c 315f 6574         kge(L1_et
-00013210: 4f62 7328 6944 6f6d 6169 6e29 2564 6174  Obs(iDomain)%dat
-00013220: 614f 6273 2869 4365 6c6c 2c20 3a29 2c20  aObs(iCell, :), 
-00013230: 6574 4f70 7469 5369 6d28 6944 6f6d 6169  etOptiSim(iDomai
-00013240: 6e29 2564 6174 6153 696d 2869 4365 6c6c  n)%dataSim(iCell
-00013250: 2c20 3a29 2c20 260a 2020 2020 2020 2020  , :), &.        
-00013260: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013270: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013280: 2020 2020 2020 2020 2020 206d 6173 6b20             mask 
-00013290: 3d20 4c31 5f65 744f 6273 2869 446f 6d61  = L1_etObs(iDoma
-000132a0: 696e 2925 6d61 736b 4f62 7328 6943 656c  in)%maskObs(iCel
-000132b0: 6c2c 203a 2929 0a20 2020 2020 2065 6e64  l, :)).      end
-000132c0: 2064 6f0a 0a20 2020 2020 2021 2075 7365   do..      ! use
-000132d0: 7220 696e 666f 726d 6174 696f 6e20 6162  r information ab
-000132e0: 6f75 7420 696e 7661 6c69 6420 6365 6c6c  out invalid cell
-000132f0: 730a 2020 2020 2020 6966 2028 696e 7661  s.      if (inva
-00013300: 6c69 645f 6365 6c6c 7320 2e47 542e 2030  lid_cells .GT. 0
-00013310: 2e35 5f64 7029 2074 6865 6e0a 2020 2020  .5_dp) then.    
-00013320: 2020 2020 6361 6c6c 206d 6573 7361 6765      call message
-00013330: 2827 2020 2057 4152 4e49 4e47 3a20 6f62  ('   WARNING: ob
-00013340: 6a65 6374 6976 655f 6574 3a20 4465 7465  jective_et: Dete
-00013350: 6374 6564 2069 6e76 616c 6964 2063 656c  cted invalid cel
-00013360: 6c73 2069 6e20 7374 7564 7920 6172 6561  ls in study area
-00013370: 2028 2e4c 542e 2031 3020 7661 6c69 6420   (.LT. 10 valid 
-00013380: 6461 7461 2070 6f69 6e74 7329 2e27 290a  data points).').
-00013390: 2020 2020 2020 2020 6361 6c6c 206d 6573          call mes
-000133a0: 7361 6765 2827 2020 2020 2020 2020 2020  sage('          
-000133b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000133c0: 4672 6163 7469 6f6e 206f 6620 696e 7661  Fraction of inva
-000133d0: 6c69 6420 6365 6c6c 733a 2027 2c20 260a  lid cells: ', &.
-000133e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000133f0: 6e75 6d32 7374 7228 696e 7661 6c69 645f  num2str(invalid_
-00013400: 6365 6c6c 7320 2f20 7265 616c 286e 4365  cells / real(nCe
-00013410: 6c6c 7331 2c20 6470 292c 2027 2846 342e  lls1, dp), '(F4.
-00013420: 3229 2729 290a 2020 2020 2020 656e 6420  2)')).      end 
-00013430: 6966 0a0a 2020 2020 2020 2120 6361 6c63  if..      ! calc
-00013440: 756c 6174 6520 6176 6572 6167 6520 736f  ulate average so
-00013450: 696c 206d 6f69 7374 7572 6520 6f62 6a65  il moisture obje
-00013460: 6374 6976 6520 6f76 6572 2061 6c6c 2064  ctive over all d
-00013470: 6f6d 6169 6e73 2077 6974 6820 706f 7765  omains with powe
-00013480: 7220 6c61 770a 2020 2020 2020 2120 646f  r law.      ! do
-00013490: 6d61 696e 7320 6172 6520 7765 6967 6874  mains are weight
-000134a0: 6564 2065 7175 616c 6c79 2028 2031 202f  ed equally ( 1 /
-000134b0: 2072 6561 6c28 646f 6d61 696e 4d65 7461   real(domainMeta
-000134c0: 256f 7665 7261 6c6c 4e75 6d62 6572 4f66  %overallNumberOf
-000134d0: 446f 6d61 696e 732c 6470 2929 2a2a 360a  Domains,dp))**6.
-000134e0: 2020 2020 2020 6f62 6a65 6374 6976 655f        objective_
-000134f0: 6574 203d 206f 626a 6563 7469 7665 5f65  et = objective_e
-00013500: 7420 2b20 260a 2020 2020 2020 2020 2020  t + &.          
-00013510: 2020 2020 2828 312e 305f 6470 202d 206f      ((1.0_dp - o
-00013520: 626a 6563 7469 7665 5f65 745f 646f 6d61  bjective_et_doma
-00013530: 696e 202f 2072 6561 6c28 6e43 656c 6c73  in / real(nCells
-00013540: 312c 2064 7029 2920 2f20 7265 616c 2864  1, dp)) / real(d
-00013550: 6f6d 6169 6e4d 6574 6125 6f76 6572 616c  omainMeta%overal
-00013560: 6c4e 756d 6265 724f 6644 6f6d 6169 6e73  lNumberOfDomains
-00013570: 2c20 6470 2929 2a2a 360a 2020 2020 2020  , dp))**6.      
-00013580: 6361 6c6c 2065 744f 7074 6953 696d 2869  call etOptiSim(i
-00013590: 446f 6d61 696e 2925 6465 7374 726f 7928  Domain)%destroy(
-000135a0: 290a 2020 2020 656e 6420 646f 0a20 2020  ).    end do.   
-000135b0: 2064 6561 6c6c 6f63 6174 6528 6574 4f70   deallocate(etOp
-000135c0: 7469 5369 6d29 0a0a 2020 2020 2120 636f  tiSim)..    ! co
-000135d0: 6d70 726f 6d69 7365 2073 6f6c 7574 696f  mpromise solutio
-000135e0: 6e20 2d20 7369 7874 6820 726f 6f74 0a20  n - sixth root. 
-000135f0: 2020 206f 626a 6563 7469 7665 5f65 7420     objective_et 
-00013600: 3d20 6f62 6a65 6374 6976 655f 6574 2a2a  = objective_et**
-00013610: 6f6e 6573 6978 7468 0a0a 2020 2020 2120  onesixth..    ! 
-00013620: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00013630: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 2020  -------------.  
-00013640: 2020 2120 5255 4e4f 4646 0a20 2020 2021    ! RUNOFF.    !
-00013650: 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d   ---------------
-00013660: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a20  --------------. 
-00013670: 2020 206f 626a 6563 7469 7665 5f71 203d     objective_q =
-00013680: 2030 2e30 5f64 700a 2020 2020 6e47 6175   0.0_dp.    nGau
-00013690: 6765 7354 6f74 616c 203d 2073 697a 6528  gesTotal = size(
-000136a0: 7275 6e6f 6666 2c20 6469 6d20 3d20 3229  runoff, dim = 2)
-000136b0: 0a0a 2020 2020 646f 2067 6720 3d20 312c  ..    do gg = 1,
-000136c0: 206e 4761 7567 6573 546f 7461 6c0a 0a20   nGaugesTotal.. 
-000136d0: 2020 2020 2021 2065 7874 7261 6374 2072       ! extract r
-000136e0: 756e 6f66 660a 2020 2020 2020 6361 6c6c  unoff.      call
-000136f0: 2065 7874 7261 6374 5f72 756e 6f66 6628   extract_runoff(
-00013700: 6767 2c20 7275 6e6f 6666 2c20 7275 6e6f  gg, runoff, runo
-00013710: 6666 5f61 6767 2c20 7275 6e6f 6666 5f6f  ff_agg, runoff_o
-00013720: 6273 2c20 7275 6e6f 6666 5f6f 6273 5f6d  bs, runoff_obs_m
-00013730: 6173 6b29 0a0a 2020 2020 2020 2120 4b47  ask)..      ! KG
-00013740: 450a 2020 2020 2020 6f62 6a65 6374 6976  E.      objectiv
-00013750: 655f 7120 3d20 6f62 6a65 6374 6976 655f  e_q = objective_
-00013760: 7120 2b20 260a 2020 2020 2020 2020 2020  q + &.          
-00013770: 2020 2020 2828 312e 305f 6470 202d 206b      ((1.0_dp - k
-00013780: 6765 2872 756e 6f66 665f 6f62 732c 2072  ge(runoff_obs, r
-00013790: 756e 6f66 665f 6167 672c 206d 6173 6b20  unoff_agg, mask 
-000137a0: 3d20 7275 6e6f 6666 5f6f 6273 5f6d 6173  = runoff_obs_mas
-000137b0: 6b29 2920 2f20 7265 616c 286e 4761 7567  k)) / real(nGaug
-000137c0: 6573 546f 7461 6c2c 2064 7029 292a 2a36  esTotal, dp))**6
-000137d0: 0a0a 2020 2020 656e 6420 646f 0a0a 2020  ..    end do..  
-000137e0: 2020 6465 616c 6c6f 6361 7465 2872 756e    deallocate(run
-000137f0: 6f66 665f 6167 672c 2072 756e 6f66 665f  off_agg, runoff_
-00013800: 6f62 732c 2072 756e 6f66 665f 6f62 735f  obs, runoff_obs_
-00013810: 6d61 736b 290a 0a20 2020 2021 2063 6f6d  mask)..    ! com
-00013820: 7072 6f6d 6973 6520 736f 6c75 7469 6f6e  promise solution
-00013830: 202d 2073 6978 7468 2072 6f6f 740a 2020   - sixth root.  
-00013840: 2020 6f62 6a65 6374 6976 655f 7120 3d20    objective_q = 
-00013850: 6f62 6a65 6374 6976 655f 712a 2a6f 6e65  objective_q**one
-00013860: 7369 7874 680a 0a20 2020 2021 2065 7175  sixth..    ! equ
-00013870: 616c 2077 6569 6768 7465 6420 636f 6d70  al weighted comp
-00013880: 726f 6d69 7365 206f 626a 6563 7469 7665  romise objective
-00013890: 2066 756e 6374 696f 6e73 2066 6f72 2064   functions for d
-000138a0: 6973 6368 6172 6765 2061 6e64 2073 6f69  ischarge and soi
-000138b0: 6c6d 6f69 7374 7572 650a 2020 2020 2120  lmoisture.    ! 
-000138c0: 546f 446f 3a20 7768 7920 646f 2077 6520  ToDo: why do we 
-000138d0: 7573 6520 7468 6520 7369 7874 6820 726f  use the sixth ro
-000138e0: 6f74 206f 6620 6f66 206f 626a 6563 7469  ot of of objecti
-000138f0: 7665 5f73 6d20 616e 6420 6f62 6a65 6374  ve_sm and object
-00013900: 6976 655f 6b67 650a 2020 2020 2120 6f6e  ive_kge.    ! on
-00013910: 6c79 2074 6f20 7461 6b65 2074 6865 2070  ly to take the p
-00013920: 6f77 6572 2074 6f20 3620 6865 7265 2061  ower to 6 here a
-00013930: 6761 696e 2c20 7768 656e 2077 6520 6e65  gain, when we ne
-00013940: 7665 7220 6e65 6564 2074 6865 0a20 2020  ver need the.   
-00013950: 2021 2069 6e74 6572 6d65 6469 6174 6520   ! intermediate 
-00013960: 7265 7375 6c74 733f 0a23 6966 6465 6620  results?.#ifdef 
-00013970: 4d50 490a 2020 2020 6f62 6a65 6374 6976  MPI.    objectiv
-00013980: 655f 6b67 655f 715f 6574 203d 2028 6f62  e_kge_q_et = (ob
-00013990: 6a65 6374 6976 655f 6574 2a2a 3620 2b20  jective_et**6 + 
-000139a0: 6f62 6a65 6374 6976 655f 712a 2a36 290a  objective_q**6).
-000139b0: 2365 6c73 650a 2020 2020 6f62 6a65 6374  #else.    object
-000139c0: 6976 655f 6b67 655f 715f 6574 203d 2028  ive_kge_q_et = (
-000139d0: 6f62 6a65 6374 6976 655f 6574 2a2a 3620  objective_et**6 
-000139e0: 2b20 6f62 6a65 6374 6976 655f 712a 2a36  + objective_q**6
-000139f0: 292a 2a6f 6e65 7369 7874 680a 0a20 2020  )**onesixth..   
-00013a00: 2063 616c 6c20 6d65 7373 6167 6528 2720   call message(' 
-00013a10: 2020 206f 626a 6563 7469 7665 5f6b 6765     objective_kge
-00013a20: 5f71 5f65 7420 3d20 272c 206e 756d 3273  _q_et = ', num2s
-00013a30: 7472 286f 626a 6563 7469 7665 5f6b 6765  tr(objective_kge
-00013a40: 5f71 5f65 742c 2027 2846 392e 3529 2729  _q_et, '(F9.5)')
-00013a50: 290a 2365 6e64 6966 0a20 2020 2021 2020  ).#endif.    !  
-00013a60: 2020 7072 696e 742a 2c20 2231 2d53 4d20    print*, "1-SM 
-00013a70: 322d 5120 3a20 222c 2031 2e30 5f64 702d  2-Q : ", 1.0_dp-
-00013a80: 6f62 6a65 6374 6976 655f 736d 2c20 312e  objective_sm, 1.
-00013a90: 305f 6470 2d6f 626a 6563 7469 7665 5f6b  0_dp-objective_k
-00013aa0: 6765 2021 204d 5a4d 5a4d 5a4d 5a0a 0a20  ge ! MZMZMZMZ.. 
-00013ab0: 2045 4e44 2046 554e 4354 494f 4e20 6f62   END FUNCTION ob
-00013ac0: 6a65 6374 6976 655f 6b67 655f 715f 6574  jective_kge_q_et
-00013ad0: 0a0a 0a20 2021 202d 2d2d 2d2d 2d2d 2d2d  ...  ! ---------
-00013ae0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00013af0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00013b00: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00013b10: 2d2d 2d2d 2d2d 2d2d 0a0a 2020 2120 2020  --------..  !   
-00013b20: 204e 414d 450a 2020 2120 2020 2020 2020   NAME.  !       
-00013b30: 206f 626a 6563 7469 7665 5f6b 6765 5f71   objective_kge_q
-00013b40: 5f42 4649 0a0a 2020 2120 2020 2050 5552  _BFI..  !    PUR
-00013b50: 504f 5345 0a20 2021 3e20 2020 2020 2020  POSE.  !>       
-00013b60: 5c62 7269 6566 204f 626a 6563 7469 7665  \brief Objective
-00013b70: 2066 756e 6374 696f 6e20 6f66 204b 4745   function of KGE
-00013b80: 2066 6f72 2072 756e 6f66 6620 616e 6420   for runoff and 
-00013b90: 4246 4920 6162 7375 6c75 7465 2064 6966  BFI absulute dif
-00013ba0: 6665 7265 6e63 650a 0a20 2021 3e20 2020  ference..  !>   
-00013bb0: 2020 2020 5c64 6574 6169 6c73 204f 626a      \details Obj
-00013bc0: 6563 7469 7665 2066 756e 6374 696f 6e20  ective function 
-00013bd0: 6f66 204b 4745 2066 6f72 2072 756e 6f66  of KGE for runof
-00013be0: 6620 616e 6420 4b47 4520 666f 7220 4554  f and KGE for ET
-00013bf0: 2e0a 2020 213e 2020 2020 2020 2046 7572  ..  !>       Fur
-00013c00: 7468 6572 2064 6574 6169 6c73 2063 616e  ther details can
-00013c10: 2062 6520 666f 756e 6420 696e 2074 6865   be found in the
-00013c20: 2064 6f63 756d 656e 7461 7469 6f6e 206f   documentation o
-00013c30: 6620 6f62 6a65 6374 6976 6520 6675 6e63  f objective func
-00013c40: 7469 6f6e 730a 2020 213e 2020 2020 2020  tions.  !>      
-00013c50: 2027 3134 202d 206f 626a 6563 7469 7665   '14 - objective
-00013c60: 5f6d 756c 7469 706c 655f 6761 7567 6573  _multiple_gauges
-00013c70: 5f6b 6765 5f70 6f77 6572 3627 2e0a 0a20  _kge_power6'... 
-00013c80: 2021 2020 2020 494e 5445 4e54 2849 4e29   !    INTENT(IN)
-00013c90: 0a20 2021 3e20 2020 2020 2020 5c70 6172  .  !>       \par
-00013ca0: 616d 5b69 6e5d 2022 7265 616c 2864 7029  am[in] "real(dp)
-00013cb0: 2c20 6469 6d65 6e73 696f 6e28 3a29 203a  , dimension(:) :
-00013cc0: 3a20 7061 7261 6d65 7465 7273 6574 220a  : parameterset".
-00013cd0: 2020 213e 2020 2020 2020 205c 7061 7261    !>       \para
-00013ce0: 6d5b 696e 5d20 2270 726f 6365 6475 7265  m[in] "procedure
-00013cf0: 2865 7661 6c5f 696e 7465 7266 6163 6529  (eval_interface)
-00013d00: 203a 3a20 6576 616c 220a 0a20 2021 2020   :: eval"..  !  
-00013d10: 2020 5245 5455 524e 0a20 2021 3e20 2020    RETURN.  !>   
-00013d20: 2020 2020 5c72 6574 7572 6e20 7265 616c      \return real
-00013d30: 2864 7029 203a 3a20 6f62 6a65 6374 6976  (dp) :: objectiv
-00013d40: 655f 6b67 655f 715f 4246 4920 266d 6461  e_kge_q_BFI &mda
-00013d50: 7368 3b20 6f62 6a65 6374 6976 6520 6675  sh; objective fu
-00013d60: 6e63 7469 6f6e 2076 616c 7565 0a20 2021  nction value.  !
-00013d70: 3e20 2020 2020 2020 2877 6869 6368 2077  >       (which w
-00013d80: 696c 6c20 6265 2065 2e67 2e20 6d69 6e69  ill be e.g. mini
-00013d90: 6d69 7a65 6420 6279 2061 6e20 6f70 7469  mized by an opti
-00013da0: 6d69 7a61 7469 6f6e 2072 6f75 7469 6e65  mization routine
-00013db0: 206c 696b 6520 4444 5329 0a0a 2020 2120   like DDS)..  ! 
-00013dc0: 2020 2048 4953 544f 5259 0a20 2021 3e20     HISTORY.  !> 
-00013dd0: 2020 2020 2020 5c61 7574 686f 7273 2053        \authors S
-00013de0: 6562 6173 7469 616e 204d c3bc 6c6c 6572  ebastian M..ller
-00013df0: 0a0a 2020 213e 2020 2020 2020 205c 6461  ..  !>       \da
-00013e00: 7465 2041 7072 2032 3032 320a 0a20 2046  te Apr 2022..  F
-00013e10: 554e 4354 494f 4e20 6f62 6a65 6374 6976  UNCTION objectiv
-00013e20: 655f 6b67 655f 715f 4246 4928 7061 7261  e_kge_q_BFI(para
-00013e30: 6d65 7465 7273 6574 2c20 6576 616c 290a  meterset, eval).
-00013e40: 0a20 2020 2075 7365 206d 6f5f 6f70 7469  .    use mo_opti
-00013e50: 6d69 7a61 7469 6f6e 5f74 7970 6573 2c20  mization_types, 
-00013e60: 6f6e 6c79 203a 206f 7074 6964 6174 615f  only : optidata_
-00013e70: 7369 6d0a 2020 2020 7573 6520 6d6f 5f63  sim.    use mo_c
-00013e80: 6f6d 6d6f 6e5f 7661 7269 6162 6c65 732c  ommon_variables,
-00013e90: 206f 6e6c 7920 3a20 6c65 7665 6c31 2c20   only : level1, 
-00013ea0: 646f 6d61 696e 4d65 7461 0a20 2020 2075  domainMeta.    u
-00013eb0: 7365 206d 6f5f 6572 726f 726d 6561 7375  se mo_errormeasu
-00013ec0: 7265 732c 206f 6e6c 7920 3a20 6b67 650a  res, only : kge.
-00013ed0: 2020 2020 7573 6520 6d6f 5f67 6c6f 6261      use mo_globa
-00013ee0: 6c5f 7661 7269 6162 6c65 732c 206f 6e6c  l_variables, onl
-00013ef0: 7920 3a20 4246 495f 6f62 730a 2020 2020  y : BFI_obs.    
-00013f00: 7573 6520 6d6f 5f6d 6573 7361 6765 2c20  use mo_message, 
-00013f10: 6f6e 6c79 203a 206d 6573 7361 6765 2c20  only : message, 
-00013f20: 6572 726f 725f 6d65 7373 6167 650a 2020  error_message.  
-00013f30: 2020 7573 6520 6d6f 5f73 7472 696e 675f    use mo_string_
-00013f40: 7574 696c 732c 206f 6e6c 7920 3a20 6e75  utils, only : nu
-00013f50: 6d32 7374 720a 2020 2020 7573 6520 6d6f  m2str.    use mo
-00013f60: 5f6d 726d 5f6f 626a 6563 7469 7665 5f66  _mrm_objective_f
-00013f70: 756e 6374 696f 6e5f 7275 6e6f 6666 2c20  unction_runoff, 
-00013f80: 6f6e 6c79 203a 2065 7874 7261 6374 5f72  only : extract_r
-00013f90: 756e 6f66 660a 0a20 2020 2069 6d70 6c69  unoff..    impli
-00013fa0: 6369 7420 6e6f 6e65 0a0a 2020 2020 7265  cit none..    re
-00013fb0: 616c 2864 7029 2c20 6469 6d65 6e73 696f  al(dp), dimensio
-00013fc0: 6e28 3a29 2c20 696e 7465 6e74 2869 6e29  n(:), intent(in)
-00013fd0: 203a 3a20 7061 7261 6d65 7465 7273 6574   :: parameterset
-00013fe0: 0a0a 2020 2020 7072 6f63 6564 7572 6528  ..    procedure(
-00013ff0: 6576 616c 5f69 6e74 6572 6661 6365 292c  eval_interface),
-00014000: 2049 4e54 454e 5428 494e 292c 2050 4f49   INTENT(IN), POI
-00014010: 4e54 4552 203a 3a20 6576 616c 0a0a 2020  NTER :: eval..  
-00014020: 2020 7265 616c 2864 7029 203a 3a20 6f62    real(dp) :: ob
-00014030: 6a65 6374 6976 655f 6b67 655f 715f 4246  jective_kge_q_BF
-00014040: 490a 2020 2020 7265 616c 2864 7029 203a  I.    real(dp) :
-00014050: 3a20 6f62 6a65 6374 6976 655f 4246 490a  : objective_BFI.
-00014060: 2020 2020 7265 616c 2864 7029 203a 3a20      real(dp) :: 
-00014070: 6f62 6a65 6374 6976 655f 710a 0a20 2020  objective_q..   
-00014080: 2072 6561 6c28 6470 292c 2070 6172 616d   real(dp), param
-00014090: 6574 6572 203a 3a20 6f6e 6573 6978 7468  eter :: onesixth
-000140a0: 203d 2031 2e30 5f64 7020 2f20 362e 305f   = 1.0_dp / 6.0_
-000140b0: 6470 0a0a 2020 2020 2120 6e75 6d62 6572  dp..    ! number
-000140c0: 206f 6620 696e 7661 6c69 6420 6365 6c6c   of invalid cell
-000140d0: 7320 696e 2063 6174 6368 6d65 6e74 0a20  s in catchment. 
-000140e0: 2020 2072 6561 6c28 6470 2920 3a3a 2069     real(dp) :: i
-000140f0: 6e76 616c 6964 5f63 656c 6c73 0a0a 2020  nvalid_cells..  
-00014100: 2020 2120 6d6f 6465 6c6c 6564 2072 756e    ! modelled run
-00014110: 6f66 6620 666f 7220 6120 6769 7665 6e20  off for a given 
-00014120: 7061 7261 6d65 7465 7220 7365 740a 2020  parameter set.  
-00014130: 2020 2120 6469 6d31 3d6e 5469 6d65 5374    ! dim1=nTimeSt
-00014140: 6570 732c 2064 696d 323d 6e47 6175 6765  eps, dim2=nGauge
-00014150: 730a 2020 2020 7265 616c 2864 7029 2c20  s.    real(dp), 
-00014160: 616c 6c6f 6361 7461 626c 652c 2064 696d  allocatable, dim
-00014170: 656e 7369 6f6e 283a 2c20 3a29 203a 3a20  ension(:, :) :: 
-00014180: 7275 6e6f 6666 0a0a 2020 2020 2120 646f  runoff..    ! do
-00014190: 6d61 696e 206c 6f6f 7020 636f 756e 7465  main loop counte
-000141a0: 720a 2020 2020 696e 7465 6765 7228 6934  r.    integer(i4
-000141b0: 2920 3a3a 2069 446f 6d61 696e 0a0a 2020  ) :: iDomain..  
-000141c0: 2020 213e 2062 6173 6566 6c6f 7720 696e    !> baseflow in
-000141d0: 6465 7820 666f 7220 6561 6368 2064 6f6d  dex for each dom
-000141e0: 6169 6e0a 2020 2020 7265 616c 2864 7029  ain.    real(dp)
-000141f0: 2c20 6469 6d65 6e73 696f 6e28 3a29 2c20  , dimension(:), 
-00014200: 616c 6c6f 6361 7461 626c 6520 3a3a 2042  allocatable :: B
-00014210: 4649 0a0a 2020 2020 2120 636f 756e 7465  FI..    ! counte
-00014220: 720a 2020 2020 696e 7465 6765 7228 6934  r.    integer(i4
-00014230: 2920 3a3a 2067 672c 2069 0a0a 2020 2020  ) :: gg, i..    
-00014240: 696e 7465 6765 7228 6934 2920 3a3a 206e  integer(i4) :: n
-00014250: 4761 7567 6573 546f 7461 6c0a 0a20 2020  GaugesTotal..   
-00014260: 2021 2061 6767 7265 6761 7465 6420 7369   ! aggregated si
-00014270: 6d75 6c61 7465 6420 7275 6e6f 6666 0a20  mulated runoff. 
-00014280: 2020 2069 6e74 6567 6572 2869 3429 2c20     integer(i4), 
-00014290: 6469 6d65 6e73 696f 6e28 3a29 2c20 616c  dimension(:), al
-000142a0: 6c6f 6361 7461 626c 6520 3a3a 2064 6f6d  locatable :: dom
-000142b0: 6169 6e5f 6964 732c 2064 6f6d 6169 6e5f  ain_ids, domain_
-000142c0: 6964 735f 7061 636b 0a0a 2020 2020 2120  ids_pack..    ! 
-000142d0: 6167 6772 6567 6174 6564 2073 696d 756c  aggregated simul
-000142e0: 6174 6564 2072 756e 6f66 660a 2020 2020  ated runoff.    
-000142f0: 7265 616c 2864 7029 2c20 6469 6d65 6e73  real(dp), dimens
-00014300: 696f 6e28 3a29 2c20 616c 6c6f 6361 7461  ion(:), allocata
-00014310: 626c 6520 3a3a 2072 756e 6f66 665f 6167  ble :: runoff_ag
-00014320: 670a 0a20 2020 2021 206d 6561 7375 7265  g..    ! measure
-00014330: 6420 7275 6e6f 6666 0a20 2020 2072 6561  d runoff.    rea
-00014340: 6c28 6470 292c 2064 696d 656e 7369 6f6e  l(dp), dimension
-00014350: 283a 292c 2061 6c6c 6f63 6174 6162 6c65  (:), allocatable
-00014360: 203a 3a20 7275 6e6f 6666 5f6f 6273 0a0a   :: runoff_obs..
-00014370: 2020 2020 2120 6d61 736b 2066 6f72 206d      ! mask for m
-00014380: 6561 7375 7265 6420 7275 6e6f 6666 0a20  easured runoff. 
-00014390: 2020 206c 6f67 6963 616c 2c20 6469 6d65     logical, dime
-000143a0: 6e73 696f 6e28 3a29 2c20 616c 6c6f 6361  nsion(:), alloca
-000143b0: 7461 626c 6520 3a3a 2072 756e 6f66 665f  table :: runoff_
-000143c0: 6f62 735f 6d61 736b 0a0a 2020 2020 2120  obs_mask..    ! 
-000143d0: 7275 6e20 6d48 4d0a 2020 2020 616c 6c6f  run mHM.    allo
-000143e0: 6361 7465 2842 4649 2864 6f6d 6169 6e4d  cate(BFI(domainM
-000143f0: 6574 6125 6e44 6f6d 6169 6e73 2929 0a20  eta%nDomains)). 
-00014400: 2020 2063 616c 6c20 6576 616c 2870 6172     call eval(par
-00014410: 616d 6574 6572 7365 742c 2072 756e 6f66  ameterset, runof
-00014420: 6620 3d20 7275 6e6f 6666 2c20 4246 4920  f = runoff, BFI 
-00014430: 3d20 4246 4929 0a0a 2020 2020 2120 2d2d  = BFI)..    ! --
-00014440: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00014450: 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020  -----------.    
-00014460: 2120 4246 490a 2020 2020 2120 2d2d 2d2d  ! BFI.    ! ----
-00014470: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00014480: 2d2d 2d2d 2d2d 2d2d 2d0a 0a20 2020 2021  ---------..    !
-00014490: 2069 6e69 7469 616c 697a 6520 736f 6d65   initialize some
-000144a0: 2076 6172 6961 626c 6573 0a20 2020 206f   variables.    o
-000144b0: 626a 6563 7469 7665 5f42 4649 203d 2030  bjective_BFI = 0
-000144c0: 2e30 5f64 700a 0a20 2020 2069 6620 2820  .0_dp..    if ( 
-000144d0: 616e 7928 4246 495f 6f62 7320 3c20 302e  any(BFI_obs < 0.
-000144e0: 305f 6470 2920 2920 7468 656e 0a20 2020  0_dp) ) then.   
-000144f0: 2020 2061 6c6c 6f63 6174 6528 646f 6d61     allocate(doma
-00014500: 696e 5f69 6473 2864 6f6d 6169 6e4d 6574  in_ids(domainMet
-00014510: 6125 6e44 6f6d 6169 6e73 2929 0a20 2020  a%nDomains)).   
-00014520: 2020 2061 6c6c 6f63 6174 6528 646f 6d61     allocate(doma
-00014530: 696e 5f69 6473 5f70 6163 6b28 636f 756e  in_ids_pack(coun
-00014540: 7428 4246 495f 6f62 7320 3c20 302e 305f  t(BFI_obs < 0.0_
-00014550: 6470 2929 290a 2020 2020 2020 646f 6d61  dp))).      doma
-00014560: 696e 5f69 6473 203d 205b 2869 2c20 693d  in_ids = [(i, i=
-00014570: 312c 7369 7a65 2864 6f6d 6169 6e5f 6964  1,size(domain_id
-00014580: 7329 295d 0a20 2020 2020 2064 6f6d 6169  s))].      domai
-00014590: 6e5f 6964 735f 7061 636b 203d 2070 6163  n_ids_pack = pac
-000145a0: 6b28 646f 6d61 696e 5f69 6473 2c20 6d61  k(domain_ids, ma
-000145b0: 736b 3d28 4246 495f 6f62 7320 3c20 302e  sk=(BFI_obs < 0.
-000145c0: 305f 6470 2929 0a20 2020 2020 2063 616c  0_dp)).      cal
-000145d0: 6c20 6572 726f 725f 6d65 7373 6167 6528  l error_message(
-000145e0: 2026 0a20 2020 2020 2020 2022 6f62 6a65   &.        "obje
-000145f0: 6374 6976 655f 6b67 655f 715f 4246 493a  ctive_kge_q_BFI:
-00014600: 206d 6973 7369 6e67 2042 4649 2076 616c   missing BFI val
-00014610: 7565 7320 666f 7220 646f 6d61 696e 2022  ues for domain "
-00014620: 2c20 260a 2020 2020 2020 2020 7472 696d  , &.        trim
-00014630: 2861 646a 7573 746c 286e 756d 3273 7472  (adjustl(num2str
-00014640: 2864 6f6d 6169 6e5f 6964 735f 7061 636b  (domain_ids_pack
-00014650: 2831 2929 2929 2026 0a20 2020 2020 2029  (1)))) &.      )
-00014660: 0a20 2020 2065 6e64 2069 660a 0a20 2020  .    end if..   
-00014670: 2021 206c 6f6f 7020 6f76 6572 2064 6f6d   ! loop over dom
-00014680: 6169 6e20 2d20 666f 7220 6170 706c 7969  ain - for applyi
-00014690: 6e67 2070 6f77 6572 206c 6177 206c 6174  ng power law lat
-000146a0: 6572 206f 6e0a 2020 2020 646f 2069 446f  er on.    do iDo
-000146b0: 6d61 696e 203d 2031 2c20 646f 6d61 696e  main = 1, domain
-000146c0: 4d65 7461 256e 446f 6d61 696e 730a 2020  Meta%nDomains.  
-000146d0: 2020 2020 6f62 6a65 6374 6976 655f 4246      objective_BF
-000146e0: 4920 3d20 6f62 6a65 6374 6976 655f 4246  I = objective_BF
-000146f0: 4920 2b20 6162 7328 4246 4928 6944 6f6d  I + abs(BFI(iDom
-00014700: 6169 6e29 202d 2042 4649 5f6f 6273 2869  ain) - BFI_obs(i
-00014710: 446f 6d61 696e 2929 202f 2064 6f6d 6169  Domain)) / domai
-00014720: 6e4d 6574 6125 6e44 6f6d 6169 6e73 0a20  nMeta%nDomains. 
-00014730: 2020 2065 6e64 2064 6f0a 0a20 2020 2021     end do..    !
-00014740: 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d   ---------------
-00014750: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a20  --------------. 
-00014760: 2020 2021 2052 554e 4f46 460a 2020 2020     ! RUNOFF.    
-00014770: 2120 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ! --------------
-00014780: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a  ---------------.
-00014790: 2020 2020 6f62 6a65 6374 6976 655f 7120      objective_q 
-000147a0: 3d20 302e 305f 6470 0a20 2020 206e 4761  = 0.0_dp.    nGa
-000147b0: 7567 6573 546f 7461 6c20 3d20 7369 7a65  ugesTotal = size
-000147c0: 2872 756e 6f66 662c 2064 696d 203d 2032  (runoff, dim = 2
-000147d0: 290a 0a20 2020 2064 6f20 6767 203d 2031  )..    do gg = 1
-000147e0: 2c20 6e47 6175 6765 7354 6f74 616c 0a0a  , nGaugesTotal..
-000147f0: 2020 2020 2020 2120 6578 7472 6163 7420        ! extract 
-00014800: 7275 6e6f 6666 0a20 2020 2020 2063 616c  runoff.      cal
-00014810: 6c20 6578 7472 6163 745f 7275 6e6f 6666  l extract_runoff
-00014820: 2867 672c 2072 756e 6f66 662c 2072 756e  (gg, runoff, run
-00014830: 6f66 665f 6167 672c 2072 756e 6f66 665f  off_agg, runoff_
-00014840: 6f62 732c 2072 756e 6f66 665f 6f62 735f  obs, runoff_obs_
-00014850: 6d61 736b 290a 0a20 2020 2020 2021 204b  mask)..      ! K
-00014860: 4745 0a20 2020 2020 206f 626a 6563 7469  GE.      objecti
-00014870: 7665 5f71 203d 206f 626a 6563 7469 7665  ve_q = objective
-00014880: 5f71 202b 2026 0a20 2020 2020 2020 2020  _q + &.         
-00014890: 2020 2020 2028 2831 2e30 5f64 7020 2d20       ((1.0_dp - 
-000148a0: 6b67 6528 7275 6e6f 6666 5f6f 6273 2c20  kge(runoff_obs, 
-000148b0: 7275 6e6f 6666 5f61 6767 2c20 6d61 736b  runoff_agg, mask
-000148c0: 203d 2072 756e 6f66 665f 6f62 735f 6d61   = runoff_obs_ma
-000148d0: 736b 2929 202f 2072 6561 6c28 6e47 6175  sk)) / real(nGau
-000148e0: 6765 7354 6f74 616c 2c20 6470 2929 2a2a  gesTotal, dp))**
-000148f0: 360a 0a20 2020 2065 6e64 2064 6f0a 0a20  6..    end do.. 
-00014900: 2020 2064 6561 6c6c 6f63 6174 6528 7275     deallocate(ru
-00014910: 6e6f 6666 5f61 6767 2c20 7275 6e6f 6666  noff_agg, runoff
-00014920: 5f6f 6273 2c20 7275 6e6f 6666 5f6f 6273  _obs, runoff_obs
-00014930: 5f6d 6173 6b29 0a0a 2020 2020 2120 636f  _mask)..    ! co
-00014940: 6d70 726f 6d69 7365 2073 6f6c 7574 696f  mpromise solutio
-00014950: 6e20 2d20 7369 7874 6820 726f 6f74 0a20  n - sixth root. 
-00014960: 2020 206f 626a 6563 7469 7665 5f71 203d     objective_q =
-00014970: 206f 626a 6563 7469 7665 5f71 2a2a 6f6e   objective_q**on
-00014980: 6573 6978 7468 0a0a 2020 2020 6f62 6a65  esixth..    obje
-00014990: 6374 6976 655f 6b67 655f 715f 4246 4920  ctive_kge_q_BFI 
-000149a0: 3d20 286f 626a 6563 7469 7665 5f42 4649  = (objective_BFI
-000149b0: 202b 2031 2e5f 6470 292a 6f62 6a65 6374   + 1._dp)*object
-000149c0: 6976 655f 710a 2020 2020 6361 6c6c 206d  ive_q.    call m
-000149d0: 6573 7361 6765 2827 2020 2020 6f62 6a65  essage('    obje
-000149e0: 6374 6976 655f 6b67 655f 715f 4246 4920  ctive_kge_q_BFI 
-000149f0: 3d20 272c 206e 756d 3273 7472 286f 626a  = ', num2str(obj
-00014a00: 6563 7469 7665 5f6b 6765 5f71 5f42 4649  ective_kge_q_BFI
-00014a10: 2c20 2728 4639 2e35 2927 2929 0a0a 2020  , '(F9.5)'))..  
-00014a20: 454e 4420 4655 4e43 5449 4f4e 206f 626a  END FUNCTION obj
-00014a30: 6563 7469 7665 5f6b 6765 5f71 5f42 4649  ective_kge_q_BFI
-00014a40: 0a0a 0a20 2021 202d 2d2d 2d2d 2d2d 2d2d  ...  ! ---------
-00014a50: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00014a60: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00014a70: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00014a80: 2d2d 2d2d 2d2d 2d2d 0a0a 2020 2120 2020  --------..  !   
-00014a90: 204e 414d 450a 2020 2120 2020 2020 2020   NAME.  !       
-00014aa0: 206f 626a 6563 7469 7665 5f6b 6765 5f71   objective_kge_q
-00014ab0: 5f72 6d73 655f 6574 0a0a 2020 2120 2020  _rmse_et..  !   
-00014ac0: 2050 5552 504f 5345 0a20 2021 3e20 2020   PURPOSE.  !>   
-00014ad0: 2020 2020 5c62 7269 6566 204f 626a 6563      \brief Objec
-00014ae0: 7469 7665 2066 756e 6374 696f 6e20 6f66  tive function of
-00014af0: 204b 4745 2066 6f72 2072 756e 6f66 6620   KGE for runoff 
-00014b00: 616e 6420 524d 5345 2066 6f72 2064 6f6d  and RMSE for dom
-00014b10: 6169 6e5f 6176 6720 4554 2028 7374 616e  ain_avg ET (stan
-00014b20: 6461 7269 7a65 6420 7363 6f72 6573 290a  darized scores).
-00014b30: 0a20 2021 3e20 2020 2020 2020 5c64 6574  .  !>       \det
-00014b40: 6169 6c73 204f 626a 6563 7469 7665 2066  ails Objective f
-00014b50: 756e 6374 696f 6e20 6f66 204b 4745 2066  unction of KGE f
-00014b60: 6f72 2072 756e 6f66 6620 616e 6420 524d  or runoff and RM
-00014b70: 5345 2066 6f72 2064 6f6d 6169 6e5f 6176  SE for domain_av
-00014b80: 6720 4554 2028 7374 616e 6461 7269 7a65  g ET (standarize
-00014b90: 6420 7363 6f72 6573 290a 0a20 2021 2020  d scores)..  !  
-00014ba0: 2020 494e 5445 4e54 2849 4e29 0a20 2021    INTENT(IN).  !
-00014bb0: 3e20 2020 2020 2020 5c70 6172 616d 5b69  >       \param[i
-00014bc0: 6e5d 2022 7265 616c 2864 7029 2c20 6469  n] "real(dp), di
-00014bd0: 6d65 6e73 696f 6e28 3a29 203a 3a20 7061  mension(:) :: pa
-00014be0: 7261 6d65 7465 7273 6574 220a 2020 213e  rameterset".  !>
-00014bf0: 2020 2020 2020 205c 7061 7261 6d5b 696e         \param[in
-00014c00: 5d20 2270 726f 6365 6475 7265 2865 7661  ] "procedure(eva
-00014c10: 6c5f 696e 7465 7266 6163 6529 203a 3a20  l_interface) :: 
-00014c20: 6576 616c 220a 0a20 2021 2020 2020 5245  eval"..  !    RE
-00014c30: 5455 524e 0a20 2021 3e20 2020 2020 2020  TURN.  !>       
-00014c40: 5c72 6574 7572 6e20 7265 616c 2864 7029  \return real(dp)
-00014c50: 203a 3a20 6f62 6a65 6374 6976 655f 6b67   :: objective_kg
-00014c60: 655f 715f 726d 7365 5f65 7420 266d 6461  e_q_rmse_et &mda
-00014c70: 7368 3b20 6f62 6a65 6374 6976 6520 6675  sh; objective fu
-00014c80: 6e63 7469 6f6e 2076 616c 7565 0a20 2021  nction value.  !
-00014c90: 3e20 2020 2020 2020 2877 6869 6368 2077  >       (which w
-00014ca0: 696c 6c20 6265 2065 2e67 2e20 6d69 6e69  ill be e.g. mini
-00014cb0: 6d69 7a65 6420 6279 2061 6e20 6f70 7469  mized by an opti
-00014cc0: 6d69 7a61 7469 6f6e 2072 6f75 7469 6e65  mization routine
-00014cd0: 206c 696b 6520 4444 5329 0a0a 2020 2120   like DDS)..  ! 
-00014ce0: 2020 2048 4953 544f 5259 0a20 2021 3e20     HISTORY.  !> 
-00014cf0: 2020 2020 2020 5c61 7574 686f 7273 204a        \authors J
-00014d00: 6f68 616e 6e65 7320 4272 656e 6e65 720a  ohannes Brenner.
-00014d10: 0a20 2021 3e20 2020 2020 2020 5c64 6174  .  !>       \dat
-00014d20: 6520 4a75 6c79 2032 3031 370a 0a20 2021  e July 2017..  !
-00014d30: 204d 6f64 6966 6963 6174 696f 6e73 3a0a   Modifications:.
-00014d40: 2020 2120 526f 6265 7274 2053 6368 7765    ! Robert Schwe
-00014d50: 7070 6520 4a75 6e20 3230 3138 202d 2072  ppe Jun 2018 - r
-00014d60: 6566 6163 746f 7269 6e67 2061 6e64 2072  efactoring and r
-00014d70: 6566 6f72 6d61 7474 696e 670a 0a20 2046  eformatting..  F
-00014d80: 554e 4354 494f 4e20 6f62 6a65 6374 6976  UNCTION objectiv
-00014d90: 655f 6b67 655f 715f 726d 7365 5f65 7428  e_kge_q_rmse_et(
-00014da0: 7061 7261 6d65 7465 7273 6574 2c20 6576  parameterset, ev
-00014db0: 616c 290a 0a20 2020 2075 7365 206d 6f5f  al)..    use mo_
-00014dc0: 6f70 7469 6d69 7a61 7469 6f6e 5f74 7970  optimization_typ
-00014dd0: 6573 2c20 6f6e 6c79 203a 206f 7074 6964  es, only : optid
-00014de0: 6174 615f 7369 6d0a 2020 2020 7573 6520  ata_sim.    use 
-00014df0: 6d6f 5f63 6f6d 6d6f 6e5f 636f 6e73 7461  mo_common_consta
-00014e00: 6e74 732c 206f 6e6c 7920 3a20 6570 735f  nts, only : eps_
-00014e10: 6470 2c20 6e6f 6461 7461 5f64 700a 2020  dp, nodata_dp.  
-00014e20: 2020 7573 6520 6d6f 5f63 6f6d 6d6f 6e5f    use mo_common_
-00014e30: 6d68 6d5f 6d72 6d5f 7661 7269 6162 6c65  mhm_mrm_variable
-00014e40: 732c 206f 6e6c 7920 3a20 6576 616c 5065  s, only : evalPe
-00014e50: 720a 2020 2020 7573 6520 6d6f 5f63 6f6d  r.    use mo_com
-00014e60: 6d6f 6e5f 7661 7269 6162 6c65 732c 206f  mon_variables, o
-00014e70: 6e6c 7920 3a20 646f 6d61 696e 4d65 7461  nly : domainMeta
-00014e80: 0a20 2020 2075 7365 206d 6f5f 6572 726f  .    use mo_erro
-00014e90: 726d 6561 7375 7265 732c 206f 6e6c 7920  rmeasures, only 
-00014ea0: 3a20 726d 7365 0a20 2020 2075 7365 206d  : rmse.    use m
-00014eb0: 6f5f 676c 6f62 616c 5f76 6172 6961 626c  o_global_variabl
-00014ec0: 6573 2c20 6f6e 6c79 203a 204c 315f 6574  es, only : L1_et
-00014ed0: 4f62 730a 2020 2020 7573 6520 6d6f 5f6a  Obs.    use mo_j
-00014ee0: 756c 6961 6e2c 206f 6e6c 7920 3a20 6361  ulian, only : ca
-00014ef0: 6c64 6174 0a20 2020 2075 7365 206d 6f5f  ldat.    use mo_
-00014f00: 6d65 7373 6167 652c 206f 6e6c 7920 3a20  message, only : 
-00014f10: 6d65 7373 6167 650a 2020 2020 7573 6520  message.    use 
-00014f20: 6d6f 5f6d 6f6d 656e 742c 206f 6e6c 7920  mo_moment, only 
-00014f30: 3a20 6176 6572 6167 652c 206d 6561 6e0a  : average, mean.
-00014f40: 2020 2020 7573 6520 6d6f 5f73 7461 6e64      use mo_stand
-00014f50: 6172 645f 7363 6f72 652c 206f 6e6c 7920  ard_score, only 
-00014f60: 3a20 636c 6173 7369 6669 6564 5f73 7461  : classified_sta
-00014f70: 6e64 6172 645f 7363 6f72 650a 2020 2020  ndard_score.    
-00014f80: 7573 6520 6d6f 5f73 7472 696e 675f 7574  use mo_string_ut
-00014f90: 696c 732c 206f 6e6c 7920 3a20 6e75 6d32  ils, only : num2
-00014fa0: 7374 720a 2020 2020 7573 6520 6d6f 5f74  str.    use mo_t
-00014fb0: 656d 706f 7261 6c5f 6167 6772 6567 6174  emporal_aggregat
-00014fc0: 696f 6e2c 206f 6e6c 7920 3a20 6461 7932  ion, only : day2
-00014fd0: 6d6f 6e5f 6176 6572 6167 650a 2020 2020  mon_average.    
-00014fe0: 7573 6520 6d6f 5f65 7272 6f72 6d65 6173  use mo_errormeas
-00014ff0: 7572 6573 2c20 6f6e 6c79 203a 206b 6765  ures, only : kge
-00015000: 0a20 2020 2075 7365 206d 6f5f 6d72 6d5f  .    use mo_mrm_
-00015010: 6f62 6a65 6374 6976 655f 6675 6e63 7469  objective_functi
-00015020: 6f6e 5f72 756e 6f66 662c 206f 6e6c 7920  on_runoff, only 
-00015030: 3a20 6578 7472 6163 745f 7275 6e6f 6666  : extract_runoff
-00015040: 0a0a 2020 2020 696d 706c 6963 6974 206e  ..    implicit n
-00015050: 6f6e 650a 0a20 2020 2072 6561 6c28 6470  one..    real(dp
-00015060: 292c 2064 696d 656e 7369 6f6e 283a 292c  ), dimension(:),
-00015070: 2069 6e74 656e 7428 696e 2920 3a3a 2070   intent(in) :: p
-00015080: 6172 616d 6574 6572 7365 740a 0a20 2020  arameterset..   
-00015090: 2070 726f 6365 6475 7265 2865 7661 6c5f   procedure(eval_
-000150a0: 696e 7465 7266 6163 6529 2c20 494e 5445  interface), INTE
-000150b0: 4e54 2849 4e29 2c20 504f 494e 5445 5220  NT(IN), POINTER 
-000150c0: 3a3a 2065 7661 6c0a 0a20 2020 2072 6561  :: eval..    rea
-000150d0: 6c28 6470 2920 3a3a 206f 626a 6563 7469  l(dp) :: objecti
-000150e0: 7665 5f6b 6765 5f71 5f72 6d73 655f 6574  ve_kge_q_rmse_et
-000150f0: 0a0a 2020 2020 2120 6d6f 6465 6c6c 6564  ..    ! modelled
-00015100: 2072 756e 6f66 6620 666f 7220 6120 6769   runoff for a gi
-00015110: 7665 6e20 7061 7261 6d65 7465 7220 7365  ven parameter se
-00015120: 740a 2020 2020 2120 6469 6d31 3d6e 5469  t.    ! dim1=nTi
-00015130: 6d65 5374 6570 732c 2064 696d 323d 6e47  meSteps, dim2=nG
-00015140: 6175 6765 730a 2020 2020 7265 616c 2864  auges.    real(d
-00015150: 7029 2c20 616c 6c6f 6361 7461 626c 652c  p), allocatable,
-00015160: 2064 696d 656e 7369 6f6e 283a 2c20 3a29   dimension(:, :)
-00015170: 203a 3a20 7275 6e6f 6666 0a0a 2020 2020   :: runoff..    
-00015180: 213e 2073 696d 756c 6174 6564 2065 740a  !> simulated et.
-00015190: 2020 2020 7479 7065 286f 7074 6964 6174      type(optidat
-000151a0: 615f 7369 6d29 2c20 6469 6d65 6e73 696f  a_sim), dimensio
-000151b0: 6e28 3a29 2c20 616c 6c6f 6361 7461 626c  n(:), allocatabl
-000151c0: 6520 3a3a 2065 744f 7074 6953 696d 0a0a  e :: etOptiSim..
-000151d0: 2020 2020 2120 7469 6d65 206c 6f6f 7020      ! time loop 
-000151e0: 636f 756e 7465 720a 2020 2020 696e 7465  counter.    inte
-000151f0: 6765 7228 6934 2920 3a3a 2069 5469 6d65  ger(i4) :: iTime
-00015200: 0a0a 2020 2020 2120 646f 6d61 696e 2063  ..    ! domain c
-00015210: 6f75 6e74 6572 2c20 6d6f 6e74 6820 636f  ounter, month co
-00015220: 756e 7465 7273 0a20 2020 2069 6e74 6567  unters.    integ
-00015230: 6572 2869 3429 203a 3a20 6944 6f6d 6169  er(i4) :: iDomai
-00015240: 6e2c 2070 702c 206d 6d6d 0a0a 2020 2020  n, pp, mmm..    
-00015250: 696e 7465 6765 7228 6934 2920 3a3a 2079  integer(i4) :: y
-00015260: 6561 722c 206d 6f6e 7468 2c20 6461 790a  ear, month, day.
-00015270: 0a20 2020 2072 6561 6c28 6470 292c 2064  .    real(dp), d
-00015280: 696d 656e 7369 6f6e 2864 6f6d 6169 6e4d  imension(domainM
-00015290: 6574 6125 6e44 6f6d 6169 6e73 2920 3a3a  eta%nDomains) ::
-000152a0: 2069 6e69 7454 696d 650a 0a20 2020 2021   initTime..    !
-000152b0: 2074 6f74 616c 206e 756d 6265 7220 6f66   total number of
-000152c0: 206d 6f6e 7468 730a 2020 2020 696e 7465   months.    inte
-000152d0: 6765 7228 6934 2920 3a3a 206e 4d6f 6e74  ger(i4) :: nMont
-000152e0: 6873 0a0a 2020 2020 2120 7665 6374 6f72  hs..    ! vector
-000152f0: 2077 6974 6820 6d6f 6e74 6873 2720 636c   with months' cl
-00015300: 6173 7365 730a 2020 2020 696e 7465 6765  asses.    intege
-00015310: 7228 6934 292c 2064 696d 656e 7369 6f6e  r(i4), dimension
-00015320: 283a 292c 2061 6c6c 6f63 6174 6162 6c65  (:), allocatable
-00015330: 203a 3a20 6d6f 6e74 685f 636c 6173 7365   :: month_classe
-00015340: 730a 0a20 2020 2021 206d 6f6e 7468 6c79  s..    ! monthly
-00015350: 2076 616c 7565 7320 6f72 6967 696e 616c   values original
-00015360: 2074 696d 6520 7365 7269 6573 0a20 2020   time series.   
-00015370: 2072 6561 6c28 6470 292c 2064 696d 656e   real(dp), dimen
-00015380: 7369 6f6e 283a 292c 2061 6c6c 6f63 6174  sion(:), allocat
-00015390: 6162 6c65 203a 3a20 6574 5f73 696d 5f6d  able :: et_sim_m
-000153a0: 2c20 6574 5f6f 6273 5f6d 0a0a 2020 2020  , et_obs_m..    
-000153b0: 2120 6d6f 6e74 686c 7920 7661 6c75 6573  ! monthly values
-000153c0: 2061 6e6f 6d61 6c79 2074 696d 6520 7365   anomaly time se
-000153d0: 7269 6573 0a20 2020 2072 6561 6c28 6470  ries.    real(dp
-000153e0: 292c 2064 696d 656e 7369 6f6e 283a 292c  ), dimension(:),
-000153f0: 2061 6c6c 6f63 6174 6162 6c65 203a 3a20   allocatable :: 
-00015400: 6574 5f73 696d 5f6d 5f61 6e6f 6d2c 2065  et_sim_m_anom, e
-00015410: 745f 6f62 735f 6d5f 616e 6f6d 0a0a 2020  t_obs_m_anom..  
-00015420: 2020 6c6f 6769 6361 6c2c 2064 696d 656e    logical, dimen
-00015430: 7369 6f6e 283a 292c 2061 6c6c 6f63 6174  sion(:), allocat
-00015440: 6162 6c65 203a 3a20 6574 5f6f 6273 5f6d  able :: et_obs_m
-00015450: 5f6d 6173 6b0a 0a20 2020 2021 206b 6765  _mask..    ! kge
-00015460: 5f71 286e 4761 7567 6573 546f 7461 6c29  _q(nGaugesTotal)
-00015470: 0a20 2020 2072 6561 6c28 6470 292c 2064  .    real(dp), d
-00015480: 696d 656e 7369 6f6e 283a 292c 2061 6c6c  imension(:), all
-00015490: 6f63 6174 6162 6c65 203a 3a20 726d 7365  ocatable :: rmse
-000154a0: 5f65 740a 0a20 2020 2021 206f 626a 2e20  _et..    ! obj. 
-000154b0: 6675 6e63 7469 6f6e 730a 2020 2020 7265  functions.    re
-000154c0: 616c 2864 7029 203a 3a20 726d 7365 5f65  al(dp) :: rmse_e
-000154d0: 745f 6176 672c 206b 6765 5f71 5f61 7667  t_avg, kge_q_avg
-000154e0: 0a0a 2020 2020 2120 7370 6174 6961 6c20  ..    ! spatial 
-000154f0: 6176 6572 6167 6520 6f66 206f 6273 6572  average of obser
-00015500: 7665 6420 6574 0a20 2020 2072 6561 6c28  ved et.    real(
-00015510: 6470 292c 2064 696d 656e 7369 6f6e 283a  dp), dimension(:
-00015520: 292c 2061 6c6c 6f63 6174 6162 6c65 203a  ), allocatable :
-00015530: 3a20 6574 5f63 6174 6368 5f61 7667 5f64  : et_catch_avg_d
-00015540: 6f6d 6169 6e0a 0a20 2020 2021 2073 7061  omain..    ! spa
-00015550: 7469 616c 2061 7665 7267 6165 206f 6620  tial avergae of 
-00015560: 6d6f 6465 6c65 6420 2065 740a 2020 2020  modeled  et.    
-00015570: 7265 616c 2864 7029 2c20 6469 6d65 6e73  real(dp), dimens
-00015580: 696f 6e28 3a29 2c20 616c 6c6f 6361 7461  ion(:), allocata
-00015590: 626c 6520 3a3a 2065 745f 6f70 7469 5f63  ble :: et_opti_c
-000155a0: 6174 6368 5f61 7667 5f64 6f6d 6169 6e0a  atch_avg_domain.
-000155b0: 0a20 2020 2021 206d 6173 6b20 666f 7220  .    ! mask for 
-000155c0: 7661 6c69 6420 6574 2063 6174 6368 6d65  valid et catchme
-000155d0: 6e74 2061 7667 2074 696d 6520 7374 6570  nt avg time step
-000155e0: 730a 2020 2020 6c6f 6769 6361 6c2c 2064  s.    logical, d
-000155f0: 696d 656e 7369 6f6e 283a 292c 2061 6c6c  imension(:), all
-00015600: 6f63 6174 6162 6c65 203a 3a20 6d61 736b  ocatable :: mask
-00015610: 5f74 696d 6573 0a0a 2020 2020 2120 726d  _times..    ! rm
-00015620: 7365 5f65 7428 646f 6d61 696e 4d65 7461  se_et(domainMeta
-00015630: 256e 446f 6d61 696e 7329 0a20 2020 2072  %nDomains).    r
-00015640: 6561 6c28 6470 292c 2064 696d 656e 7369  eal(dp), dimensi
-00015650: 6f6e 283a 292c 2061 6c6c 6f63 6174 6162  on(:), allocatab
-00015660: 6c65 203a 3a20 6b67 655f 710a 0a20 2020  le :: kge_q..   
-00015670: 2021 2067 6175 6765 7320 636f 756e 7465   ! gauges counte
-00015680: 720a 2020 2020 696e 7465 6765 7228 6934  r.    integer(i4
-00015690: 2920 3a3a 2067 670a 0a20 2020 2069 6e74  ) :: gg..    int
-000156a0: 6567 6572 2869 3429 203a 3a20 6e47 6175  eger(i4) :: nGau
-000156b0: 6765 7354 6f74 616c 0a0a 2020 2020 2120  gesTotal..    ! 
-000156c0: 6167 6772 6567 6174 6564 2073 696d 756c  aggregated simul
-000156d0: 6174 6564 2072 756e 6f66 660a 2020 2020  ated runoff.    
-000156e0: 7265 616c 2864 7029 2c20 6469 6d65 6e73  real(dp), dimens
-000156f0: 696f 6e28 3a29 2c20 616c 6c6f 6361 7461  ion(:), allocata
-00015700: 626c 6520 3a3a 2072 756e 6f66 665f 6167  ble :: runoff_ag
-00015710: 670a 0a20 2020 2021 206d 6561 7375 7265  g..    ! measure
-00015720: 6420 7275 6e6f 6666 0a20 2020 2072 6561  d runoff.    rea
-00015730: 6c28 6470 292c 2064 696d 656e 7369 6f6e  l(dp), dimension
-00015740: 283a 292c 2061 6c6c 6f63 6174 6162 6c65  (:), allocatable
-00015750: 203a 3a20 7275 6e6f 6666 5f6f 6273 0a0a   :: runoff_obs..
-00015760: 2020 2020 2120 6d61 736b 2066 6f72 206d      ! mask for m
-00015770: 6561 7375 7265 6420 7275 6e6f 6666 0a20  easured runoff. 
-00015780: 2020 206c 6f67 6963 616c 2c20 6469 6d65     logical, dime
-00015790: 6e73 696f 6e28 3a29 2c20 616c 6c6f 6361  nsion(:), alloca
-000157a0: 7461 626c 6520 3a3a 2072 756e 6f66 665f  table :: runoff_
-000157b0: 6f62 735f 6d61 736b 0a0a 2020 2020 2120  obs_mask..    ! 
-000157c0: 6f62 7461 696e 2073 696d 756c 6174 696f  obtain simulatio
-000157d0: 6e20 7661 6c75 6573 206f 6620 7275 6e6f  n values of runo
-000157e0: 6666 2028 686f 7572 6c79 2920 616e 6420  ff (hourly) and 
-000157f0: 4554 0a20 2020 2021 2066 6f72 2045 5420  ET.    ! for ET 
-00015800: 6f6e 6c79 2076 616c 6964 2063 656c 6c73  only valid cells
-00015810: 2028 646f 6d61 696e 7320 636f 6e63 6174   (domains concat
-00015820: 656e 6174 6564 290a 2020 2020 2120 6574  enated).    ! et
-00015830: 5f6f 7074 693a 2061 6767 7265 6761 7465  _opti: aggregate
-00015840: 2045 5420 746f 206e 6565 6465 6420 7469   ET to needed ti
-00015850: 6d65 2073 7465 7020 666f 7220 6f70 7469  me step for opti
-00015860: 6d69 7a61 7469 6f6e 2028 7365 6520 7469  mization (see ti
-00015870: 6d65 5374 6570 5f65 745f 696e 7075 7429  meStep_et_input)
-00015880: 0a20 2020 2061 6c6c 6f63 6174 6528 6574  .    allocate(et
-00015890: 4f70 7469 5369 6d28 646f 6d61 696e 4d65  OptiSim(domainMe
-000158a0: 7461 256e 446f 6d61 696e 7329 290a 2020  ta%nDomains)).  
-000158b0: 2020 6361 6c6c 2065 7661 6c28 7061 7261    call eval(para
-000158c0: 6d65 7465 7273 6574 2c20 7275 6e6f 6666  meterset, runoff
-000158d0: 203d 2072 756e 6f66 662c 2065 744f 7074   = runoff, etOpt
-000158e0: 6953 696d 203d 2065 744f 7074 6953 696d  iSim = etOptiSim
-000158f0: 290a 0a20 2020 2021 2d2d 2d2d 2d2d 2d2d  )..    !--------
-00015900: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00015910: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00015920: 2d2d 2d2d 0a20 2020 2021 2120 4556 4150  ----.    !! EVAP
-00015930: 4f54 5241 4e53 5049 5241 5449 4f4e 0a20  OTRANSPIRATION. 
-00015940: 2020 2021 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d     !------------
-00015950: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00015960: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00015970: 0a0a 2020 2020 2120 616c 6c6f 6361 7465  ..    ! allocate
-00015980: 0a20 2020 2061 6c6c 6f63 6174 6528 726d  .    allocate(rm
-00015990: 7365 5f65 7428 646f 6d61 696e 4d65 7461  se_et(domainMeta
-000159a0: 256e 446f 6d61 696e 7329 290a 2020 2020  %nDomains)).    
-000159b0: 726d 7365 5f65 7428 3a29 203d 206e 6f64  rmse_et(:) = nod
-000159c0: 6174 615f 6470 0a0a 2020 2020 646f 2069  ata_dp..    do i
-000159d0: 446f 6d61 696e 203d 2031 2c20 646f 6d61  Domain = 1, doma
-000159e0: 696e 4d65 7461 256e 446f 6d61 696e 730a  inMeta%nDomains.
-000159f0: 0a20 2020 2020 2021 2061 6c6c 6f63 6174  .      ! allocat
-00015a00: 650a 2020 2020 2020 616c 6c6f 6361 7465  e.      allocate
-00015a10: 286d 6173 6b5f 7469 6d65 7320 2020 2020  (mask_times     
-00015a20: 2020 2020 2020 2020 2028 7369 7a65 2865           (size(e
-00015a30: 744f 7074 6953 696d 2869 446f 6d61 696e  tOptiSim(iDomain
-00015a40: 2925 6461 7461 5369 6d2c 2064 696d 203d  )%dataSim, dim =
-00015a50: 2032 2929 290a 2020 2020 2020 616c 6c6f   2))).      allo
-00015a60: 6361 7465 2865 745f 6361 7463 685f 6176  cate(et_catch_av
-00015a70: 675f 646f 6d61 696e 2020 2020 2028 7369  g_domain     (si
-00015a80: 7a65 2865 744f 7074 6953 696d 2869 446f  ze(etOptiSim(iDo
-00015a90: 6d61 696e 2925 6461 7461 5369 6d2c 2064  main)%dataSim, d
-00015aa0: 696d 203d 2032 2929 290a 2020 2020 2020  im = 2))).      
-00015ab0: 616c 6c6f 6361 7465 2865 745f 6f70 7469  allocate(et_opti
-00015ac0: 5f63 6174 6368 5f61 7667 5f64 6f6d 6169  _catch_avg_domai
-00015ad0: 6e28 7369 7a65 2865 744f 7074 6953 696d  n(size(etOptiSim
-00015ae0: 2869 446f 6d61 696e 2925 6461 7461 5369  (iDomain)%dataSi
-00015af0: 6d2c 2064 696d 203d 2032 2929 290a 0a20  m, dim = 2))).. 
-00015b00: 2020 2020 2021 2069 6e69 7461 6c69 7a65       ! initalize
-00015b10: 0a20 2020 2020 206d 6173 6b5f 7469 6d65  .      mask_time
-00015b20: 7320 3d20 2e54 5255 452e 0a20 2020 2020  s = .TRUE..     
-00015b30: 2065 745f 6361 7463 685f 6176 675f 646f   et_catch_avg_do
-00015b40: 6d61 696e 203d 206e 6f64 6174 615f 6470  main = nodata_dp
-00015b50: 0a20 2020 2020 2065 745f 6f70 7469 5f63  .      et_opti_c
-00015b60: 6174 6368 5f61 7667 5f64 6f6d 6169 6e20  atch_avg_domain 
-00015b70: 3d20 6e6f 6461 7461 5f64 700a 0a20 2020  = nodata_dp..   
-00015b80: 2020 2021 2063 616c 6375 6c61 7465 2063     ! calculate c
-00015b90: 6174 6368 6d65 6e74 2061 7665 7261 6765  atchment average
-00015ba0: 2065 7661 706f 7472 616e 7370 6972 6174   evapotranspirat
-00015bb0: 696f 6e0a 2020 2020 2020 646f 2069 5469  ion.      do iTi
-00015bc0: 6d65 203d 2031 2c20 7369 7a65 2865 744f  me = 1, size(etO
-00015bd0: 7074 6953 696d 2869 446f 6d61 696e 2925  ptiSim(iDomain)%
-00015be0: 6461 7461 5369 6d2c 2064 696d 203d 2032  dataSim, dim = 2
-00015bf0: 290a 2020 2020 2020 2020 2120 6368 6563  ).        ! chec
-00015c00: 6b20 666f 7220 656e 6f75 6768 2064 6174  k for enough dat
-00015c10: 6120 706f 696e 7473 2069 6e20 7469 6d65  a points in time
-00015c20: 2066 6f72 2063 6f72 7265 6c61 7469 6f6e   for correlation
-00015c30: 0a20 2020 2020 2020 2069 6620 2861 6c6c  .        if (all
-00015c40: 282e 4e4f 542e 204c 315f 6574 4f62 7328  (.NOT. L1_etObs(
-00015c50: 6944 6f6d 6169 6e29 256d 6173 6b4f 6273  iDomain)%maskObs
-00015c60: 283a 2c20 6954 696d 6529 2929 2074 6865  (:, iTime))) the
-00015c70: 6e0a 2020 2020 2020 2020 2020 2177 7269  n.          !wri
-00015c80: 7465 2028 2a2c 2a29 2027 5741 524e 494e  te (*,*) 'WARNIN
-00015c90: 473a 2065 7420 6461 7461 2061 7420 7469  G: et data at ti
-00015ca0: 6d65 2027 2c20 6954 696d 652c 2027 2069  me ', iTime, ' i
-00015cb0: 7320 656d 7074 792e 270a 2020 2020 2020  s empty.'.      
-00015cc0: 2020 2020 2163 616c 6c20 6d65 7373 6167      !call messag
-00015cd0: 6528 2757 4152 4e49 4e47 3a20 6f62 6a65  e('WARNING: obje
-00015ce0: 6374 6976 655f 6574 5f6b 6765 5f63 6174  ctive_et_kge_cat
-00015cf0: 6368 6d65 6e74 5f61 7667 3a20 6967 6e6f  chment_avg: igno
-00015d00: 7265 6420 6375 7272 656e 7420 7469 6d65  red current time
-00015d10: 2073 7465 7020 7369 6e63 6520 6c65 7373   step since less
-00015d20: 2074 6861 6e27 290a 2020 2020 2020 2020   than').        
-00015d30: 2020 2163 616c 6c20 6d65 7373 6167 6528    !call message(
-00015d40: 2720 2020 2020 2020 2020 3130 2076 616c  '         10 val
-00015d50: 6964 2063 656c 6c73 2061 7661 696c 6162  id cells availab
-00015d60: 6c65 2069 6e20 6576 6170 6f74 7261 6e73  le in evapotrans
-00015d70: 7069 7261 7469 6f6e 206f 6273 6572 7661  piration observa
-00015d80: 7469 6f6e 2729 0a20 2020 2020 2020 2020  tion').         
-00015d90: 206d 6173 6b5f 7469 6d65 7328 6954 696d   mask_times(iTim
-00015da0: 6529 203d 202e 4641 4c53 452e 0a20 2020  e) = .FALSE..   
-00015db0: 2020 2020 2020 2063 7963 6c65 0a20 2020         cycle.   
-00015dc0: 2020 2020 2065 6e64 2069 660a 2020 2020       end if.    
-00015dd0: 2020 2020 2120 7370 6174 6961 6c20 6176      ! spatial av
-00015de0: 6572 6167 6520 6f66 206f 6273 6572 7665  erage of observe
-00015df0: 6420 4554 0a20 2020 2020 2020 2065 745f  d ET.        et_
-00015e00: 6361 7463 685f 6176 675f 646f 6d61 696e  catch_avg_domain
-00015e10: 2869 5469 6d65 2920 3d20 6176 6572 6167  (iTime) = averag
-00015e20: 6528 4c31 5f65 744f 6273 2869 446f 6d61  e(L1_etObs(iDoma
-00015e30: 696e 2925 6461 7461 4f62 7328 3a2c 2069  in)%dataObs(:, i
-00015e40: 5469 6d65 292c 2026 0a20 2020 2020 2020  Time), &.       
-00015e50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015e60: 2020 2020 2020 2020 2020 2020 2020 206d                 m
-00015e70: 6173 6b20 3d20 4c31 5f65 744f 6273 2869  ask = L1_etObs(i
-00015e80: 446f 6d61 696e 2925 6d61 736b 4f62 7328  Domain)%maskObs(
-00015e90: 3a2c 2069 5469 6d65 2929 0a20 2020 2020  :, iTime)).     
-00015ea0: 2020 2021 2073 7061 7469 616c 2061 7665     ! spatial ave
-00015eb0: 7267 6165 206f 6620 6d6f 6465 6c65 6420  rgae of modeled 
-00015ec0: 4554 0a20 2020 2020 2020 2065 745f 6f70  ET.        et_op
-00015ed0: 7469 5f63 6174 6368 5f61 7667 5f64 6f6d  ti_catch_avg_dom
-00015ee0: 6169 6e28 6954 696d 6529 203d 2061 7665  ain(iTime) = ave
-00015ef0: 7261 6765 2865 744f 7074 6953 696d 2869  rage(etOptiSim(i
-00015f00: 446f 6d61 696e 2925 6461 7461 5369 6d28  Domain)%dataSim(
-00015f10: 3a2c 2069 5469 6d65 292c 2026 0a20 2020  :, iTime), &.   
-00015f20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015f30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015f40: 2020 2020 2020 2020 206d 6173 6b20 3d20           mask = 
-00015f50: 4c31 5f65 744f 6273 2869 446f 6d61 696e  L1_etObs(iDomain
-00015f60: 2925 6d61 736b 4f62 7328 3a2c 2069 5469  )%maskObs(:, iTi
-00015f70: 6d65 2929 0a20 2020 2020 2065 6e64 2064  me)).      end d
-00015f80: 6f0a 0a20 2020 2020 2021 2067 6574 2069  o..      ! get i
-00015f90: 6e69 7469 616c 2074 696d 6520 6f66 2074  nitial time of t
-00015fa0: 6865 2065 7661 6c75 6174 696f 6e20 7065  he evaluation pe
-00015fb0: 7269 6f64 0a20 2020 2020 2069 6e69 7454  riod.      initT
-00015fc0: 696d 6528 6944 6f6d 6169 6e29 203d 2072  ime(iDomain) = r
-00015fd0: 6561 6c28 6576 616c 5065 7228 6944 6f6d  eal(evalPer(iDom
-00015fe0: 6169 6e29 256a 756c 5374 6172 742c 2064  ain)%julStart, d
-00015ff0: 7029 0a0a 2020 2020 2020 2120 6765 7420  p)..      ! get 
-00016000: 6361 6c65 6e64 6172 2064 6179 732c 206d  calendar days, m
-00016010: 6f6e 7468 732c 2079 6561 720a 2020 2020  onths, year.    
-00016020: 2020 6361 6c6c 2063 616c 6461 7428 696e    call caldat(in
-00016030: 7428 696e 6974 5469 6d65 2869 446f 6d61  t(initTime(iDoma
-00016040: 696e 2929 2c20 7979 203d 2079 6561 722c  in)), yy = year,
-00016050: 206d 6d20 3d20 6d6f 6e74 682c 2064 6420   mm = month, dd 
-00016060: 3d20 6461 7929 0a0a 2020 2020 2020 2120  = day)..      ! 
-00016070: 6966 2065 7661 706f 7472 616e 7370 6972  if evapotranspir
-00016080: 6174 696f 6e20 696e 7075 7420 6461 696c  ation input dail
-00016090: 790a 2020 2020 2020 7365 6c65 6374 2063  y.      select c
-000160a0: 6173 6528 4c31 5f65 744f 6273 2869 446f  ase(L1_etObs(iDo
-000160b0: 6d61 696e 2925 7469 6d65 5374 6570 496e  main)%timeStepIn
-000160c0: 7075 7429 0a20 2020 2020 2020 2021 204a  put).        ! J
-000160d0: 424a 424a 420a 2020 2020 2020 2020 2120  BJBJB.        ! 
-000160e0: 6461 696c 793a 2061 6767 7265 6761 7465  daily: aggregate
-000160f0: 2074 6f20 6d6f 6e74 686c 7920 6d65 616e   to monthly mean
-00016100: 0a20 2020 2020 2063 6173 6528 2d31 290a  .      case(-1).
-00016110: 2020 2020 2020 2020 2120 6361 6c63 756c          ! calcul
-00016120: 6174 6520 6d6f 6e74 686c 7920 6176 6572  ate monthly aver
-00016130: 6167 6573 2066 726f 6d20 6461 696c 7920  ages from daily 
-00016140: 7661 6c75 6573 206f 6620 7468 6520 6d6f  values of the mo
-00016150: 6465 6c0a 2020 2020 2020 2020 6361 6c6c  del.        call
-00016160: 2064 6179 326d 6f6e 5f61 7665 7261 6765   day2mon_average
-00016170: 2865 745f 6f70 7469 5f63 6174 6368 5f61  (et_opti_catch_a
-00016180: 7667 5f64 6f6d 6169 6e2c 2079 6561 722c  vg_domain, year,
-00016190: 206d 6f6e 7468 2c20 6461 792c 2065 745f   month, day, et_
-000161a0: 7369 6d5f 6d2c 206d 6973 7661 6c20 3d20  sim_m, misval = 
-000161b0: 6e6f 6461 7461 5f64 7029 0a20 2020 2020  nodata_dp).     
-000161c0: 2020 2021 2063 616c 6375 6c61 7465 206d     ! calculate m
-000161d0: 6f6e 7468 6c79 2061 7665 7261 6765 7320  onthly averages 
-000161e0: 6672 6f6d 2064 6169 6c79 2076 616c 7565  from daily value
-000161f0: 7320 6f66 2074 6865 206f 6273 6572 7661  s of the observa
-00016200: 7469 6f6e 730a 2020 2020 2020 2020 6361  tions.        ca
-00016210: 6c6c 2064 6179 326d 6f6e 5f61 7665 7261  ll day2mon_avera
-00016220: 6765 2865 745f 6361 7463 685f 6176 675f  ge(et_catch_avg_
-00016230: 646f 6d61 696e 2c20 7965 6172 2c20 6d6f  domain, year, mo
-00016240: 6e74 682c 2064 6179 2c20 6574 5f6f 6273  nth, day, et_obs
-00016250: 5f6d 2c20 6d69 7376 616c 203d 206e 6f64  _m, misval = nod
-00016260: 6174 615f 6470 290a 2020 2020 2020 2020  ata_dp).        
-00016270: 210a 2020 2020 2020 2020 2120 6d6f 6e74  !.        ! mont
-00016280: 686c 793a 2070 726f 6365 6564 2077 6974  hly: proceed wit
-00016290: 686f 7574 2061 6374 696f 6e0a 2020 2020  hout action.    
-000162a0: 2020 6361 7365 282d 3229 0a20 2020 2020    case(-2).     
-000162b0: 2020 2021 2073 696d 756c 6174 696f 6e0a     ! simulation.
-000162c0: 2020 2020 2020 2020 616c 6c6f 6361 7465          allocate
-000162d0: 2865 745f 7369 6d5f 6d28 7369 7a65 2865  (et_sim_m(size(e
-000162e0: 744f 7074 6953 696d 2869 446f 6d61 696e  tOptiSim(iDomain
-000162f0: 2925 6461 7461 5369 6d2c 2064 696d 203d  )%dataSim, dim =
-00016300: 2032 2929 290a 2020 2020 2020 2020 6574   2))).        et
-00016310: 5f73 696d 5f6d 203d 2065 745f 6f70 7469  _sim_m = et_opti
-00016320: 5f63 6174 6368 5f61 7667 5f64 6f6d 6169  _catch_avg_domai
-00016330: 6e0a 2020 2020 2020 2020 2120 6f62 7365  n.        ! obse
-00016340: 7276 6174 696f 6e0a 2020 2020 2020 2020  rvation.        
-00016350: 616c 6c6f 6361 7465 2865 745f 6f62 735f  allocate(et_obs_
-00016360: 6d28 7369 7a65 2865 744f 7074 6953 696d  m(size(etOptiSim
-00016370: 2869 446f 6d61 696e 2925 6461 7461 5369  (iDomain)%dataSi
-00016380: 6d2c 2064 696d 203d 2032 2929 290a 2020  m, dim = 2))).  
-00016390: 2020 2020 2020 6574 5f6f 6273 5f6d 203d        et_obs_m =
-000163a0: 2065 745f 6361 7463 685f 6176 675f 646f   et_catch_avg_do
-000163b0: 6d61 696e 0a0a 2020 2020 2020 2020 2120  main..        ! 
-000163c0: 7965 6172 6c79 3a20 4552 524f 5220 7374  yearly: ERROR st
-000163d0: 6f70 2070 726f 6772 616d 0a20 2020 2020  op program.     
-000163e0: 2063 6173 6528 2d33 290a 2020 2020 2020   case(-3).      
-000163f0: 2020 6361 6c6c 206d 6573 7361 6765 2827    call message('
-00016400: 2a2a 2a45 5252 4f52 3a20 6f62 6a65 6374  ***ERROR: object
-00016410: 6976 655f 6b67 655f 715f 726d 7365 5f65  ive_kge_q_rmse_e
-00016420: 743a 2074 696d 6520 7374 6570 206f 6620  t: time step of 
-00016430: 6576 6170 6f74 7261 6e73 7069 7261 7469  evapotranspirati
-00016440: 6f6e 2079 6561 726c 792e 2729 0a20 2020  on yearly.').   
-00016450: 2020 2020 2073 746f 700a 2020 2020 2020       stop.      
-00016460: 656e 6420 7365 6c65 6374 0a20 2020 2020  end select.     
-00016470: 2021 2072 656d 6f76 6520 6d65 616e 2066   ! remove mean f
-00016480: 726f 6d20 6d6f 6465 6c6c 6564 2074 696d  rom modelled tim
-00016490: 6520 7365 7269 6573 0a20 2020 2020 2065  e series.      e
-000164a0: 745f 7369 6d5f 6d28 3a29 203d 2065 745f  t_sim_m(:) = et_
-000164b0: 7369 6d5f 6d28 3a29 202d 206d 6561 6e28  sim_m(:) - mean(
-000164c0: 6574 5f73 696d 5f6d 283a 2929 0a20 2020  et_sim_m(:)).   
-000164d0: 2020 2021 2072 656d 6f76 6520 6d65 616e     ! remove mean
-000164e0: 2066 726f 6d20 6f62 7365 7276 6564 2074   from observed t
-000164f0: 696d 6520 7365 7269 6573 0a20 2020 2020  ime series.     
-00016500: 2065 745f 6f62 735f 6d28 3a29 203d 2065   et_obs_m(:) = e
-00016510: 745f 6f62 735f 6d28 3a29 202d 206d 6561  t_obs_m(:) - mea
-00016520: 6e28 6574 5f6f 6273 5f6d 283a 2929 0a20  n(et_obs_m(:)). 
-00016530: 2020 2020 2021 2067 6574 206e 756d 6265       ! get numbe
-00016540: 7220 6f66 206d 6f6e 7468 7320 666f 7220  r of months for 
-00016550: 6769 7665 6e20 646f 6d61 696e 0a20 2020  given domain.   
-00016560: 2020 206e 4d6f 6e74 6873 203d 2073 697a     nMonths = siz
-00016570: 6528 6574 5f6f 6273 5f6d 290a 2020 2020  e(et_obs_m).    
-00016580: 2020 616c 6c6f 6361 7465 2028 6d6f 6e74    allocate (mont
-00016590: 685f 636c 6173 7365 7328 6e4d 6f6e 7468  h_classes(nMonth
-000165a0: 7329 290a 2020 2020 2020 616c 6c6f 6361  s)).      alloca
-000165b0: 7465 2028 6574 5f6f 6273 5f6d 5f6d 6173  te (et_obs_m_mas
-000165c0: 6b28 6e4d 6f6e 7468 7329 290a 2020 2020  k(nMonths)).    
-000165d0: 2020 616c 6c6f 6361 7465 2028 6574 5f6f    allocate (et_o
-000165e0: 6273 5f6d 5f61 6e6f 6d28 6e4d 6f6e 7468  bs_m_anom(nMonth
-000165f0: 7329 290a 2020 2020 2020 616c 6c6f 6361  s)).      alloca
-00016600: 7465 2028 6574 5f73 696d 5f6d 5f61 6e6f  te (et_sim_m_ano
-00016610: 6d28 6e4d 6f6e 7468 7329 290a 0a20 2020  m(nMonths))..   
-00016620: 2020 206d 6f6e 7468 5f63 6c61 7373 6573     month_classes
-00016630: 283a 2920 3d20 300a 2020 2020 2020 6574  (:) = 0.      et
-00016640: 5f6f 6273 5f6d 5f6d 6173 6b28 3a29 203d  _obs_m_mask(:) =
-00016650: 202e 5452 5545 2e0a 2020 2020 2020 6574   .TRUE..      et
-00016660: 5f6f 6273 5f6d 5f61 6e6f 6d28 3a29 203d  _obs_m_anom(:) =
-00016670: 206e 6f64 6174 615f 6470 0a20 2020 2020   nodata_dp.     
-00016680: 2065 745f 7369 6d5f 6d5f 616e 6f6d 283a   et_sim_m_anom(:
-00016690: 2920 3d20 6e6f 6461 7461 5f64 700a 0a20  ) = nodata_dp.. 
-000166a0: 2020 2020 2021 2064 6566 696e 6520 6d6f       ! define mo
-000166b0: 6e74 6873 2720 636c 6173 7365 730a 2020  nths' classes.  
-000166c0: 2020 2020 6d6d 6d20 3d20 6d6f 6e74 680a      mmm = month.
-000166d0: 2020 2020 2020 646f 2070 7020 3d20 312c        do pp = 1,
-000166e0: 206e 4d6f 6e74 6873 0a20 2020 2020 2020   nMonths.       
-000166f0: 206d 6f6e 7468 5f63 6c61 7373 6573 2870   month_classes(p
-00016700: 7029 203d 206d 6d6d 0a20 2020 2020 2020  p) = mmm.       
-00016710: 2069 6620 286d 6d6d 202e 4c54 2e20 3132   if (mmm .LT. 12
-00016720: 2920 7468 656e 0a20 2020 2020 2020 2020  ) then.         
-00016730: 206d 6d6d 203d 206d 6d6d 202b 2031 0a20   mmm = mmm + 1. 
-00016740: 2020 2020 2020 2065 6c73 650a 2020 2020         else.    
-00016750: 2020 2020 2020 6d6d 6d20 3d20 310a 2020        mmm = 1.  
-00016760: 2020 2020 2020 656e 6420 6966 0a20 2020        end if.   
-00016770: 2020 2065 6e64 2064 6f0a 2020 2020 2020     end do.      
-00016780: 2120 646f 7562 6c65 2063 6865 636b 206d  ! double check m
-00016790: 6973 7369 6e67 2064 6174 610a 2020 2020  issing data.    
-000167a0: 2020 2120 6465 6669 6e65 206d 6173 6b20    ! define mask 
-000167b0: 666f 7220 6d69 7373 696e 6720 6461 7461  for missing data
-000167c0: 2069 6e20 6f62 7365 7276 6174 696f 6e73   in observations
-000167d0: 2028 7468 6572 6520 6172 6520 616c 7761   (there are alwa
-000167e0: 7973 2064 6174 6120 666f 7220 7369 6d75  ys data for simu
-000167f0: 6c61 7469 6f6e 7329 0a20 2020 2020 2077  lations).      w
-00016800: 6865 7265 2861 6273 2865 745f 6f62 735f  here(abs(et_obs_
-00016810: 6d20 2d20 6e6f 6461 7461 5f64 7029 202e  m - nodata_dp) .
-00016820: 6c74 2e20 6570 735f 6470 2920 6574 5f6f  lt. eps_dp) et_o
-00016830: 6273 5f6d 5f6d 6173 6b20 3d20 2e46 414c  bs_m_mask = .FAL
-00016840: 5345 2e0a 0a20 2020 2020 2021 2063 616c  SE...      ! cal
-00016850: 6375 6c61 7465 2073 7461 6e64 6172 6420  culate standard 
-00016860: 7363 6f72 650a 2020 2020 2020 6574 5f6f  score.      et_o
-00016870: 6273 5f6d 5f61 6e6f 6d20 3d20 636c 6173  bs_m_anom = clas
-00016880: 7369 6669 6564 5f73 7461 6e64 6172 645f  sified_standard_
-00016890: 7363 6f72 6528 6574 5f6f 6273 5f6d 2c20  score(et_obs_m, 
-000168a0: 6d6f 6e74 685f 636c 6173 7365 732c 206d  month_classes, m
-000168b0: 6173 6b20 3d20 6574 5f6f 6273 5f6d 5f6d  ask = et_obs_m_m
-000168c0: 6173 6b29 0a20 2020 2020 2065 745f 7369  ask).      et_si
-000168d0: 6d5f 6d5f 616e 6f6d 203d 2063 6c61 7373  m_m_anom = class
-000168e0: 6966 6965 645f 7374 616e 6461 7264 5f73  ified_standard_s
-000168f0: 636f 7265 2865 745f 7369 6d5f 6d2c 206d  core(et_sim_m, m
-00016900: 6f6e 7468 5f63 6c61 7373 6573 2c20 6d61  onth_classes, ma
-00016910: 736b 203d 2065 745f 6f62 735f 6d5f 6d61  sk = et_obs_m_ma
-00016920: 736b 290a 2020 2020 2020 726d 7365 5f65  sk).      rmse_e
-00016930: 7428 6944 6f6d 6169 6e29 203d 2072 6d73  t(iDomain) = rms
-00016940: 6528 6574 5f73 696d 5f6d 5f61 6e6f 6d2c  e(et_sim_m_anom,
-00016950: 2065 745f 6f62 735f 6d5f 616e 6f6d 2c20   et_obs_m_anom, 
-00016960: 6d61 736b 203d 2065 745f 6f62 735f 6d5f  mask = et_obs_m_
-00016970: 6d61 736b 290a 0a20 2020 2020 2064 6561  mask)..      dea
-00016980: 6c6c 6f63 6174 6520 286d 6f6e 7468 5f63  llocate (month_c
-00016990: 6c61 7373 6573 290a 2020 2020 2020 6465  lasses).      de
-000169a0: 616c 6c6f 6361 7465 2028 6574 5f6f 6273  allocate (et_obs
-000169b0: 5f6d 290a 2020 2020 2020 6465 616c 6c6f  _m).      deallo
-000169c0: 6361 7465 2028 6574 5f73 696d 5f6d 290a  cate (et_sim_m).
-000169d0: 2020 2020 2020 6465 616c 6c6f 6361 7465        deallocate
-000169e0: 2028 6574 5f6f 6273 5f6d 5f6d 6173 6b29   (et_obs_m_mask)
-000169f0: 0a20 2020 2020 2064 6561 6c6c 6f63 6174  .      deallocat
-00016a00: 6520 2865 745f 7369 6d5f 6d5f 616e 6f6d  e (et_sim_m_anom
-00016a10: 290a 2020 2020 2020 6465 616c 6c6f 6361  ).      dealloca
-00016a20: 7465 2028 6574 5f6f 6273 5f6d 5f61 6e6f  te (et_obs_m_ano
-00016a30: 6d29 0a20 2020 2020 2021 656e 6420 6966  m).      !end if
-00016a40: 0a0a 2020 2020 2020 6361 6c6c 2065 744f  ..      call etO
-00016a50: 7074 6953 696d 2869 446f 6d61 696e 2925  ptiSim(iDomain)%
-00016a60: 6465 7374 726f 7928 290a 2020 2020 656e  destroy().    en
-00016a70: 6420 646f 0a0a 2020 2020 726d 7365 5f65  d do..    rmse_e
-00016a80: 745f 6176 6720 3d20 7375 6d28 726d 7365  t_avg = sum(rmse
-00016a90: 5f65 7428 3a29 2c20 6162 7328 726d 7365  _et(:), abs(rmse
-00016aa0: 5f65 7420 2d20 6e6f 6461 7461 5f64 7029  _et - nodata_dp)
-00016ab0: 202e 6774 2e20 6570 735f 6470 2920 2f20   .gt. eps_dp) / 
-00016ac0: 260a 2020 2020 2020 2020 2020 2020 7265  &.            re
-00016ad0: 616c 2863 6f75 6e74 2861 6273 2872 6d73  al(count(abs(rms
-00016ae0: 655f 6574 202d 206e 6f64 6174 615f 6470  e_et - nodata_dp
-00016af0: 2920 2e67 742e 2065 7073 5f64 7029 2c20  ) .gt. eps_dp), 
-00016b00: 6470 290a 2020 2020 6465 616c 6c6f 6361  dp).    dealloca
-00016b10: 7465 2872 6d73 655f 6574 290a 2020 2020  te(rmse_et).    
-00016b20: 6465 616c 6c6f 6361 7465 2865 744f 7074  deallocate(etOpt
-00016b30: 6953 696d 290a 0a20 2020 2021 2d2d 2d2d  iSim)..    !----
-00016b40: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00016b50: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00016b60: 2d2d 2d2d 2d2d 2d2d 0a20 2020 2021 2120  --------.    !! 
-00016b70: 5255 4e4f 4646 0a20 2020 2021 2d2d 2d2d  RUNOFF.    !----
-00016b80: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00016b90: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00016ba0: 2d2d 2d2d 2d2d 2d2d 0a20 2020 206b 6765  --------.    kge
-00016bb0: 5f71 5f61 7667 203d 2030 5f64 700a 2020  _q_avg = 0_dp.  
-00016bc0: 2020 6e47 6175 6765 7354 6f74 616c 203d    nGaugesTotal =
-00016bd0: 2073 697a 6528 7275 6e6f 6666 2c20 6469   size(runoff, di
-00016be0: 6d20 3d20 3229 0a20 2020 2061 6c6c 6f63  m = 2).    alloc
-00016bf0: 6174 6528 6b67 655f 7128 6e47 6175 6765  ate(kge_q(nGauge
-00016c00: 7354 6f74 616c 2929 0a20 2020 206b 6765  sTotal)).    kge
-00016c10: 5f71 283a 2920 3d20 6e6f 6461 7461 5f64  _q(:) = nodata_d
-00016c20: 700a 0a20 2020 2064 6f20 6767 203d 2031  p..    do gg = 1
-00016c30: 2c20 6e47 6175 6765 7354 6f74 616c 0a0a  , nGaugesTotal..
-00016c40: 2020 2020 2020 2120 6578 7472 6163 7420        ! extract 
-00016c50: 7275 6e6f 6666 0a20 2020 2020 2063 616c  runoff.      cal
-00016c60: 6c20 6578 7472 6163 745f 7275 6e6f 6666  l extract_runoff
-00016c70: 2867 672c 2072 756e 6f66 662c 2072 756e  (gg, runoff, run
-00016c80: 6f66 665f 6167 672c 2072 756e 6f66 665f  off_agg, runoff_
-00016c90: 6f62 732c 2072 756e 6f66 665f 6f62 735f  obs, runoff_obs_
-00016ca0: 6d61 736b 290a 0a20 2020 2020 2021 2063  mask)..      ! c
-00016cb0: 6865 636b 2066 6f72 2077 6865 7468 6572  heck for whether
-00016cc0: 2074 6f20 7072 6f63 6565 6420 7769 7468   to proceed with
-00016cd0: 2074 6869 7320 646f 6d61 696e 206f 7220   this domain or 
-00016ce0: 6e6f 740a 2020 2020 2020 2120 706f 7465  not.      ! pote
-00016cf0: 6e74 6961 6c6c 7920 3320 7965 6172 7320  ntially 3 years 
-00016d00: 6f66 2064 6174 610a 2020 2020 2020 2170  of data.      !p
-00016d10: 7020 3d20 636f 756e 7428 7275 6e6f 6666  p = count(runoff
-00016d20: 5f61 6767 202e 6765 2e20 302e 305f 6470  _agg .ge. 0.0_dp
-00016d30: 2029 0a20 2020 2020 2021 6966 2028 7070   ).      !if (pp
-00016d40: 202e 6c74 2e20 2033 3635 2a33 2029 2074   .lt.  365*3 ) t
-00016d50: 6865 6e0a 2020 2020 2020 2120 2020 2064  hen.      !    d
-00016d60: 6561 6c6c 6f63 6174 6520 2872 756e 6f66  eallocate (runof
-00016d70: 665f 6167 672c 2072 756e 6f66 665f 6f62  f_agg, runoff_ob
-00016d80: 732c 2072 756e 6f66 665f 6f62 735f 6d61  s, runoff_obs_ma
-00016d90: 736b 290a 2020 2020 2020 2120 2020 2063  sk).      !    c
-00016da0: 7963 6c65 0a20 2020 2020 2021 2065 6c73  ycle.      ! els
-00016db0: 650a 2020 2020 2020 2120 6361 6c63 756c  e.      ! calcul
-00016dc0: 6174 6520 4b47 4520 666f 7220 6561 6368  ate KGE for each
-00016dd0: 2064 6f6d 6169 6e3a 0a20 2020 2020 206b   domain:.      k
-00016de0: 6765 5f71 2867 6729 203d 206b 6765 2872  ge_q(gg) = kge(r
-00016df0: 756e 6f66 665f 6f62 732c 2072 756e 6f66  unoff_obs, runof
-00016e00: 665f 6167 672c 206d 6173 6b20 3d20 7275  f_agg, mask = ru
-00016e10: 6e6f 6666 5f6f 6273 5f6d 6173 6b29 0a20  noff_obs_mask). 
-00016e20: 2020 2020 2064 6561 6c6c 6f63 6174 6520       deallocate 
-00016e30: 2872 756e 6f66 665f 6167 672c 2072 756e  (runoff_agg, run
-00016e40: 6f66 665f 6f62 732c 2072 756e 6f66 665f  off_obs, runoff_
-00016e50: 6f62 735f 6d61 736b 290a 2020 2020 2020  obs_mask).      
-00016e60: 2120 656e 6420 6966 0a0a 2020 2020 656e  ! end if..    en
-00016e70: 6420 646f 0a0a 2020 2020 2120 6361 6c63  d do..    ! calc
-00016e80: 756c 6174 6520 6176 6572 6167 6520 4b47  ulate average KG
-00016e90: 4520 7661 6c75 6520 666f 7220 7275 6e6f  E value for runo
-00016ea0: 6666 0a20 2020 206b 6765 5f71 5f61 7667  ff.    kge_q_avg
-00016eb0: 203d 2073 756d 286b 6765 5f71 283a 292c   = sum(kge_q(:),
-00016ec0: 2061 6273 286b 6765 5f71 202d 206e 6f64   abs(kge_q - nod
-00016ed0: 6174 615f 6470 2920 2e67 742e 2065 7073  ata_dp) .gt. eps
-00016ee0: 5f64 7029 202f 2026 0a20 2020 2020 2020  _dp) / &.       
-00016ef0: 2020 2020 2072 6561 6c28 636f 756e 7428       real(count(
-00016f00: 6162 7328 6b67 655f 7120 2d20 6e6f 6461  abs(kge_q - noda
-00016f10: 7461 5f64 7029 202e 6774 2e20 6570 735f  ta_dp) .gt. eps_
-00016f20: 6470 292c 2064 7029 0a20 2020 2064 6561  dp), dp).    dea
-00016f30: 6c6c 6f63 6174 6528 6b67 655f 7129 0a0a  llocate(kge_q)..
-00016f40: 2020 2020 210a 2020 2020 6f62 6a65 6374      !.    object
-00016f50: 6976 655f 6b67 655f 715f 726d 7365 5f65  ive_kge_q_rmse_e
-00016f60: 7420 3d20 726d 7365 5f65 745f 6176 6720  t = rmse_et_avg 
-00016f70: 2a20 2831 2e5f 6470 202d 206b 6765 5f71  * (1._dp - kge_q
-00016f80: 5f61 7667 290a 0a20 2020 2063 616c 6c20  _avg)..    call 
-00016f90: 6d65 7373 6167 6528 2720 2020 206f 626a  message('    obj
-00016fa0: 6563 7469 7665 5f6b 6765 5f71 5f72 6d73  ective_kge_q_rms
-00016fb0: 655f 6574 203d 2027 2c20 6e75 6d32 7374  e_et = ', num2st
-00016fc0: 7228 6f62 6a65 6374 6976 655f 6b67 655f  r(objective_kge_
-00016fd0: 715f 726d 7365 5f65 742c 2027 2846 392e  q_rmse_et, '(F9.
-00016fe0: 3529 2729 290a 0a20 2045 4e44 2046 554e  5)'))..  END FUN
-00016ff0: 4354 494f 4e20 6f62 6a65 6374 6976 655f  CTION objective_
-00017000: 6b67 655f 715f 726d 7365 5f65 740a 0a20  kge_q_rmse_et.. 
-00017010: 2073 7562 726f 7574 696e 6520 6372 6561   subroutine crea
-00017020: 7465 5f64 6f6d 6169 6e5f 6176 675f 7477  te_domain_avg_tw
-00017030: 7328 6944 6f6d 6169 6e2c 2074 7773 4f70  s(iDomain, twsOp
-00017040: 7469 5369 6d2c 2074 7773 5f63 6174 6368  tiSim, tws_catch
-00017050: 5f61 7667 5f64 6f6d 6169 6e2c 2026 0a20  _avg_domain, &. 
-00017060: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017070: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017080: 2020 2020 2020 2020 2020 7477 735f 6f70            tws_op
-00017090: 7469 5f63 6174 6368 5f61 7667 5f64 6f6d  ti_catch_avg_dom
-000170a0: 6169 6e2c 206d 6173 6b5f 7469 6d65 7329  ain, mask_times)
-000170b0: 0a20 2020 2075 7365 206d 6f5f 6f70 7469  .    use mo_opti
-000170c0: 6d69 7a61 7469 6f6e 5f74 7970 6573 2c20  mization_types, 
-000170d0: 6f6e 6c79 203a 206f 7074 6964 6174 615f  only : optidata_
-000170e0: 7369 6d0a 2020 2020 7573 6520 6d6f 5f63  sim.    use mo_c
-000170f0: 6f6d 6d6f 6e5f 636f 6e73 7461 6e74 732c  ommon_constants,
-00017100: 206f 6e6c 7920 3a20 6e6f 6461 7461 5f64   only : nodata_d
-00017110: 700a 2020 2020 7573 6520 6d6f 5f67 6c6f  p.    use mo_glo
-00017120: 6261 6c5f 7661 7269 6162 6c65 732c 206f  bal_variables, o
-00017130: 6e6c 7920 3a20 4c31 5f74 7773 614f 6273  nly : L1_twsaObs
-00017140: 0a20 2020 2075 7365 206d 6f5f 6d6f 6d65  .    use mo_mome
-00017150: 6e74 2c20 6f6e 6c79 203a 2061 7665 7261  nt, only : avera
-00017160: 6765 0a20 2020 2021 2063 7572 7265 6e74  ge.    ! current
-00017170: 2064 6f6d 6169 6e20 4964 0a20 2020 2069   domain Id.    i
-00017180: 6e74 6567 6572 2869 3429 2c20 696e 7465  nteger(i4), inte
-00017190: 6e74 2869 6e29 203a 3a20 6944 6f6d 6169  nt(in) :: iDomai
-000171a0: 6e0a 0a20 2020 2021 2073 696d 756c 6174  n..    ! simulat
-000171b0: 6564 2074 7773 0a20 2020 2074 7970 6528  ed tws.    type(
-000171c0: 6f70 7469 6461 7461 5f73 696d 292c 2064  optidata_sim), d
-000171d0: 696d 656e 7369 6f6e 283a 292c 2069 6e74  imension(:), int
-000171e0: 656e 7428 696e 2920 3a3a 2074 7773 4f70  ent(in) :: twsOp
-000171f0: 7469 5369 6d0a 0a20 2020 2021 2061 6767  tiSim..    ! agg
-00017200: 7265 6761 7465 6420 7369 6d75 6c61 7465  regated simulate
-00017210: 640a 2020 2020 7265 616c 2864 7029 2c20  d.    real(dp), 
-00017220: 6469 6d65 6e73 696f 6e28 3a29 2c20 616c  dimension(:), al
-00017230: 6c6f 6361 7461 626c 652c 2069 6e74 656e  locatable, inten
-00017240: 7428 6f75 7429 203a 3a20 7477 735f 6361  t(out) :: tws_ca
-00017250: 7463 685f 6176 675f 646f 6d61 696e 0a0a  tch_avg_domain..
-00017260: 2020 2020 2120 6578 7472 6163 7465 6420      ! extracted 
-00017270: 6d65 6173 7572 6564 0a20 2020 2072 6561  measured.    rea
-00017280: 6c28 6470 292c 2064 696d 656e 7369 6f6e  l(dp), dimension
-00017290: 283a 292c 2061 6c6c 6f63 6174 6162 6c65  (:), allocatable
-000172a0: 2c20 696e 7465 6e74 286f 7574 2920 3a3a  , intent(out) ::
-000172b0: 2074 7773 5f6f 7074 695f 6361 7463 685f   tws_opti_catch_
-000172c0: 6176 675f 646f 6d61 696e 0a0a 2020 2020  avg_domain..    
-000172d0: 2120 6d61 736b 206f 6620 6e6f 2064 6174  ! mask of no dat
-000172e0: 6120 7661 6c75 6573 0a20 2020 206c 6f67  a values.    log
-000172f0: 6963 616c 2c20 6469 6d65 6e73 696f 6e28  ical, dimension(
-00017300: 3a29 2c20 616c 6c6f 6361 7461 626c 652c  :), allocatable,
-00017310: 2069 6e74 656e 7428 6f75 7429 203a 3a20   intent(out) :: 
-00017320: 6d61 736b 5f74 696d 6573 0a0a 2020 2020  mask_times..    
-00017330: 2120 6c6f 6361 6c0a 2020 2020 2120 7469  ! local.    ! ti
-00017340: 6d65 206c 6f6f 7020 636f 756e 7465 720a  me loop counter.
-00017350: 2020 2020 696e 7465 6765 7228 6934 2920      integer(i4) 
-00017360: 3a3a 2069 5469 6d65 0a0a 2020 2020 2120  :: iTime..    ! 
-00017370: 616c 6c6f 6361 7465 0a20 2020 2061 6c6c  allocate.    all
-00017380: 6f63 6174 6528 6d61 736b 5f74 696d 6573  ocate(mask_times
-00017390: 2020 2020 2020 2020 2020 2020 2020 2028                 (
-000173a0: 7369 7a65 2874 7773 4f70 7469 5369 6d28  size(twsOptiSim(
-000173b0: 6944 6f6d 6169 6e29 2564 6174 6153 696d  iDomain)%dataSim
-000173c0: 2c20 6469 6d20 3d20 3229 2929 0a20 2020  , dim = 2))).   
-000173d0: 2061 6c6c 6f63 6174 6528 7477 735f 6361   allocate(tws_ca
-000173e0: 7463 685f 6176 675f 646f 6d61 696e 2020  tch_avg_domain  
-000173f0: 2020 2028 7369 7a65 2874 7773 4f70 7469     (size(twsOpti
-00017400: 5369 6d28 6944 6f6d 6169 6e29 2564 6174  Sim(iDomain)%dat
-00017410: 6153 696d 2c20 6469 6d20 3d20 3229 2929  aSim, dim = 2)))
-00017420: 0a20 2020 2061 6c6c 6f63 6174 6528 7477  .    allocate(tw
-00017430: 735f 6f70 7469 5f63 6174 6368 5f61 7667  s_opti_catch_avg
-00017440: 5f64 6f6d 6169 6e28 7369 7a65 2874 7773  _domain(size(tws
-00017450: 4f70 7469 5369 6d28 6944 6f6d 6169 6e29  OptiSim(iDomain)
-00017460: 2564 6174 6153 696d 2c20 6469 6d20 3d20  %dataSim, dim = 
-00017470: 3229 2929 0a0a 2020 2020 2120 696e 6974  2)))..    ! init
-00017480: 616c 697a 650a 2020 2020 6d61 736b 5f74  alize.    mask_t
-00017490: 696d 6573 203d 202e 5452 5545 2e0a 2020  imes = .TRUE..  
-000174a0: 2020 7477 735f 6361 7463 685f 6176 675f    tws_catch_avg_
-000174b0: 646f 6d61 696e 203d 206e 6f64 6174 615f  domain = nodata_
-000174c0: 6470 0a20 2020 2074 7773 5f6f 7074 695f  dp.    tws_opti_
-000174d0: 6361 7463 685f 6176 675f 646f 6d61 696e  catch_avg_domain
-000174e0: 203d 206e 6f64 6174 615f 6470 0a0a 2020   = nodata_dp..  
-000174f0: 2020 2120 6361 6c63 756c 6174 6520 6361    ! calculate ca
-00017500: 7463 686d 656e 7420 6176 6572 6167 6520  tchment average 
-00017510: 6576 6170 6f74 7261 6e73 7069 7261 7469  evapotranspirati
-00017520: 6f6e 0a20 2020 2064 6f20 6954 696d 6520  on.    do iTime 
-00017530: 3d20 312c 2073 697a 6528 7477 734f 7074  = 1, size(twsOpt
-00017540: 6953 696d 2869 446f 6d61 696e 2925 6461  iSim(iDomain)%da
-00017550: 7461 5369 6d2c 2064 696d 203d 2032 290a  taSim, dim = 2).
-00017560: 0a20 2020 2020 2021 2063 6865 636b 2066  .      ! check f
-00017570: 6f72 2065 6e6f 7567 6820 6461 7461 2070  or enough data p
-00017580: 6f69 6e74 7320 696e 2074 696d 6520 666f  oints in time fo
-00017590: 7220 636f 7272 656c 6174 696f 6e0a 2020  r correlation.  
-000175a0: 2020 2020 6966 2028 616c 6c28 2e4e 4f54      if (all(.NOT
-000175b0: 2e20 4c31 5f74 7773 614f 6273 2869 446f  . L1_twsaObs(iDo
-000175c0: 6d61 696e 2925 6d61 736b 4f62 7328 3a2c  main)%maskObs(:,
-000175d0: 2069 5469 6d65 2929 2920 7468 656e 0a20   iTime))) then. 
-000175e0: 2020 2020 2020 2021 7772 6974 6520 282a         !write (*
-000175f0: 2c2a 2920 2757 4152 4e49 4e47 3a20 6574  ,*) 'WARNING: et
-00017600: 2064 6174 6120 6174 2074 696d 6520 272c   data at time ',
-00017610: 2069 5469 6d65 2c20 2720 6973 2065 6d70   iTime, ' is emp
-00017620: 7479 2e27 0a20 2020 2020 2020 2021 6361  ty.'.        !ca
-00017630: 6c6c 206d 6573 7361 6765 2827 5741 524e  ll message('WARN
-00017640: 494e 473a 206f 626a 6563 7469 7665 5f65  ING: objective_e
-00017650: 745f 6b67 655f 6361 7463 686d 656e 745f  t_kge_catchment_
-00017660: 6176 673a 2069 676e 6f72 6564 2063 7572  avg: ignored cur
-00017670: 7265 6e74 2074 696d 6520 7374 6570 2073  rent time step s
-00017680: 696e 6365 206c 6573 7320 7468 616e 2729  ince less than')
-00017690: 0a20 2020 2020 2020 2021 6361 6c6c 206d  .        !call m
-000176a0: 6573 7361 6765 2827 2020 2020 2020 2020  essage('        
-000176b0: 2031 3020 7661 6c69 6420 6365 6c6c 7320   10 valid cells 
-000176c0: 6176 6169 6c61 626c 6520 696e 2065 7661  available in eva
-000176d0: 706f 7472 616e 7370 6972 6174 696f 6e20  potranspiration 
-000176e0: 6f62 7365 7276 6174 696f 6e27 290a 2020  observation').  
-000176f0: 2020 2020 2020 6d61 736b 5f74 696d 6573        mask_times
-00017700: 2869 5469 6d65 2920 3d20 2e46 414c 5345  (iTime) = .FALSE
-00017710: 2e0a 2020 2020 2020 2020 6379 636c 650a  ..        cycle.
-00017720: 2020 2020 2020 656e 6420 6966 0a0a 2020        end if..  
-00017730: 2020 2020 7477 735f 6361 7463 685f 6176      tws_catch_av
-00017740: 675f 646f 6d61 696e 2869 5469 6d65 2920  g_domain(iTime) 
-00017750: 3d20 6176 6572 6167 6528 4c31 5f74 7773  = average(L1_tws
-00017760: 614f 6273 2869 446f 6d61 696e 2925 6461  aObs(iDomain)%da
-00017770: 7461 4f62 7328 3a2c 2069 5469 6d65 292c  taObs(:, iTime),
-00017780: 2026 0a20 2020 2020 2020 2020 2020 2020   &.             
-00017790: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000177a0: 2020 2020 2020 2020 6d61 736b 203d 204c          mask = L
-000177b0: 315f 7477 7361 4f62 7328 6944 6f6d 6169  1_twsaObs(iDomai
-000177c0: 6e29 256d 6173 6b4f 6273 283a 2c20 6954  n)%maskObs(:, iT
-000177d0: 696d 6529 290a 2020 2020 2020 7477 735f  ime)).      tws_
-000177e0: 6f70 7469 5f63 6174 6368 5f61 7667 5f64  opti_catch_avg_d
-000177f0: 6f6d 6169 6e28 6954 696d 6529 203d 2061  omain(iTime) = a
-00017800: 7665 7261 6765 2874 7773 4f70 7469 5369  verage(twsOptiSi
-00017810: 6d28 6944 6f6d 6169 6e29 2564 6174 6153  m(iDomain)%dataS
-00017820: 696d 283a 2c20 6954 696d 6529 2c20 260a  im(:, iTime), &.
-00017830: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017840: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017850: 2020 2020 206d 6173 6b20 3d20 4c31 5f74       mask = L1_t
-00017860: 7773 614f 6273 2869 446f 6d61 696e 2925  wsaObs(iDomain)%
-00017870: 6d61 736b 4f62 7328 3a2c 2069 5469 6d65  maskObs(:, iTime
-00017880: 2929 0a20 2020 2065 6e64 2064 6f0a 0a20  )).    end do.. 
-00017890: 2065 6e64 2073 7562 726f 7574 696e 6520   end subroutine 
-000178a0: 6372 6561 7465 5f64 6f6d 6169 6e5f 6176  create_domain_av
-000178b0: 675f 7477 730a 0a20 2073 7562 726f 7574  g_tws..  subrout
-000178c0: 696e 6520 6372 6561 7465 5f64 6f6d 6169  ine create_domai
-000178d0: 6e5f 6176 675f 6574 2869 446f 6d61 696e  n_avg_et(iDomain
-000178e0: 2c20 6574 4f70 7469 5369 6d2c 2065 745f  , etOptiSim, et_
-000178f0: 6361 7463 685f 6176 675f 646f 6d61 696e  catch_avg_domain
-00017900: 2c20 260a 2020 2020 2020 2020 2020 2020  , &.            
-00017910: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017920: 2020 2020 2020 2020 2020 2020 2020 2065                 e
-00017930: 745f 6f70 7469 5f63 6174 6368 5f61 7667  t_opti_catch_avg
-00017940: 5f64 6f6d 6169 6e2c 206d 6173 6b5f 7469  _domain, mask_ti
-00017950: 6d65 7329 0a20 2020 2075 7365 206d 6f5f  mes).    use mo_
-00017960: 6f70 7469 6d69 7a61 7469 6f6e 5f74 7970  optimization_typ
-00017970: 6573 2c20 6f6e 6c79 203a 206f 7074 6964  es, only : optid
-00017980: 6174 615f 7369 6d0a 2020 2020 7573 6520  ata_sim.    use 
-00017990: 6d6f 5f63 6f6d 6d6f 6e5f 636f 6e73 7461  mo_common_consta
-000179a0: 6e74 732c 206f 6e6c 7920 3a20 6e6f 6461  nts, only : noda
-000179b0: 7461 5f64 700a 2020 2020 7573 6520 6d6f  ta_dp.    use mo
-000179c0: 5f67 6c6f 6261 6c5f 7661 7269 6162 6c65  _global_variable
-000179d0: 732c 206f 6e6c 7920 3a20 4c31 5f65 744f  s, only : L1_etO
-000179e0: 6273 0a20 2020 2075 7365 206d 6f5f 6d6f  bs.    use mo_mo
-000179f0: 6d65 6e74 2c20 6f6e 6c79 203a 2061 7665  ment, only : ave
-00017a00: 7261 6765 0a20 2020 2021 2063 7572 7265  rage.    ! curre
-00017a10: 6e74 2064 6f6d 6169 6e20 4964 0a20 2020  nt domain Id.   
-00017a20: 2069 6e74 6567 6572 2869 3429 2c20 696e   integer(i4), in
-00017a30: 7465 6e74 2869 6e29 203a 3a20 6944 6f6d  tent(in) :: iDom
-00017a40: 6169 6e0a 0a20 2020 2021 2073 696d 756c  ain..    ! simul
-00017a50: 6174 6564 2065 740a 2020 2020 7479 7065  ated et.    type
-00017a60: 286f 7074 6964 6174 615f 7369 6d29 2c20  (optidata_sim), 
-00017a70: 6469 6d65 6e73 696f 6e28 3a29 2c20 696e  dimension(:), in
-00017a80: 7465 6e74 2869 6e29 203a 3a20 6574 4f70  tent(in) :: etOp
-00017a90: 7469 5369 6d0a 0a20 2020 2021 2061 6767  tiSim..    ! agg
-00017aa0: 7265 6761 7465 6420 7369 6d75 6c61 7465  regated simulate
-00017ab0: 640a 2020 2020 7265 616c 2864 7029 2c20  d.    real(dp), 
-00017ac0: 6469 6d65 6e73 696f 6e28 3a29 2c20 616c  dimension(:), al
-00017ad0: 6c6f 6361 7461 626c 652c 2069 6e74 656e  locatable, inten
-00017ae0: 7428 6f75 7429 203a 3a20 6574 5f63 6174  t(out) :: et_cat
-00017af0: 6368 5f61 7667 5f64 6f6d 6169 6e0a 0a20  ch_avg_domain.. 
-00017b00: 2020 2021 2065 7874 7261 6374 6564 206d     ! extracted m
-00017b10: 6561 7375 7265 640a 2020 2020 7265 616c  easured.    real
-00017b20: 2864 7029 2c20 6469 6d65 6e73 696f 6e28  (dp), dimension(
-00017b30: 3a29 2c20 616c 6c6f 6361 7461 626c 652c  :), allocatable,
-00017b40: 2069 6e74 656e 7428 6f75 7429 203a 3a20   intent(out) :: 
-00017b50: 6574 5f6f 7074 695f 6361 7463 685f 6176  et_opti_catch_av
-00017b60: 675f 646f 6d61 696e 0a0a 2020 2020 2120  g_domain..    ! 
-00017b70: 6d61 736b 206f 6620 6e6f 2064 6174 6120  mask of no data 
-00017b80: 7661 6c75 6573 0a20 2020 206c 6f67 6963  values.    logic
-00017b90: 616c 2c20 6469 6d65 6e73 696f 6e28 3a29  al, dimension(:)
-00017ba0: 2c20 616c 6c6f 6361 7461 626c 652c 2069  , allocatable, i
-00017bb0: 6e74 656e 7428 6f75 7429 203a 3a20 6d61  ntent(out) :: ma
-00017bc0: 736b 5f74 696d 6573 0a0a 2020 2020 2120  sk_times..    ! 
-00017bd0: 6c6f 6361 6c0a 2020 2020 2120 7469 6d65  local.    ! time
-00017be0: 206c 6f6f 7020 636f 756e 7465 720a 2020   loop counter.  
-00017bf0: 2020 696e 7465 6765 7228 6934 2920 3a3a    integer(i4) ::
-00017c00: 2069 5469 6d65 0a0a 2020 2020 2120 616c   iTime..    ! al
-00017c10: 6c6f 6361 7465 0a20 2020 2061 6c6c 6f63  locate.    alloc
-00017c20: 6174 6528 6d61 736b 5f74 696d 6573 2020  ate(mask_times  
-00017c30: 2020 2020 2020 2020 2020 2020 2873 697a              (siz
-00017c40: 6528 6574 4f70 7469 5369 6d28 6944 6f6d  e(etOptiSim(iDom
-00017c50: 6169 6e29 2564 6174 6153 696d 2c20 6469  ain)%dataSim, di
-00017c60: 6d20 3d20 3229 2929 0a20 2020 2061 6c6c  m = 2))).    all
-00017c70: 6f63 6174 6528 6574 5f63 6174 6368 5f61  ocate(et_catch_a
-00017c80: 7667 5f64 6f6d 6169 6e20 2020 2020 2873  vg_domain     (s
-00017c90: 697a 6528 6574 4f70 7469 5369 6d28 6944  ize(etOptiSim(iD
-00017ca0: 6f6d 6169 6e29 2564 6174 6153 696d 2c20  omain)%dataSim, 
-00017cb0: 6469 6d20 3d20 3229 2929 0a20 2020 2061  dim = 2))).    a
-00017cc0: 6c6c 6f63 6174 6528 6574 5f6f 7074 695f  llocate(et_opti_
-00017cd0: 6361 7463 685f 6176 675f 646f 6d61 696e  catch_avg_domain
-00017ce0: 2873 697a 6528 6574 4f70 7469 5369 6d28  (size(etOptiSim(
-00017cf0: 6944 6f6d 6169 6e29 2564 6174 6153 696d  iDomain)%dataSim
-00017d00: 2c20 6469 6d20 3d20 3229 2929 0a0a 2020  , dim = 2)))..  
-00017d10: 2020 2120 696e 6974 616c 697a 650a 2020    ! initalize.  
-00017d20: 2020 6d61 736b 5f74 696d 6573 203d 202e    mask_times = .
-00017d30: 5452 5545 2e0a 2020 2020 6574 5f63 6174  TRUE..    et_cat
-00017d40: 6368 5f61 7667 5f64 6f6d 6169 6e20 3d20  ch_avg_domain = 
-00017d50: 6e6f 6461 7461 5f64 700a 2020 2020 6574  nodata_dp.    et
-00017d60: 5f6f 7074 695f 6361 7463 685f 6176 675f  _opti_catch_avg_
-00017d70: 646f 6d61 696e 203d 206e 6f64 6174 615f  domain = nodata_
-00017d80: 6470 0a0a 2020 2020 2120 6361 6c63 756c  dp..    ! calcul
-00017d90: 6174 6520 6361 7463 686d 656e 7420 6176  ate catchment av
-00017da0: 6572 6167 6520 6576 6170 6f74 7261 6e73  erage evapotrans
-00017db0: 7069 7261 7469 6f6e 0a20 2020 2064 6f20  piration.    do 
-00017dc0: 6954 696d 6520 3d20 312c 2073 697a 6528  iTime = 1, size(
-00017dd0: 6574 4f70 7469 5369 6d28 6944 6f6d 6169  etOptiSim(iDomai
-00017de0: 6e29 2564 6174 6153 696d 2c20 6469 6d20  n)%dataSim, dim 
-00017df0: 3d20 3229 0a0a 2020 2020 2020 2120 6368  = 2)..      ! ch
-00017e00: 6563 6b20 666f 7220 656e 6f75 6768 2064  eck for enough d
-00017e10: 6174 6120 706f 696e 7473 2069 6e20 7469  ata points in ti
-00017e20: 6d65 2066 6f72 2063 6f72 7265 6c61 7469  me for correlati
-00017e30: 6f6e 0a20 2020 2020 2069 6620 2861 6c6c  on.      if (all
-00017e40: 282e 4e4f 542e 204c 315f 6574 4f62 7328  (.NOT. L1_etObs(
-00017e50: 6944 6f6d 6169 6e29 256d 6173 6b4f 6273  iDomain)%maskObs
-00017e60: 283a 2c20 6954 696d 6529 2929 2074 6865  (:, iTime))) the
-00017e70: 6e0a 2020 2020 2020 2020 2177 7269 7465  n.        !write
-00017e80: 2028 2a2c 2a29 2027 5741 524e 494e 473a   (*,*) 'WARNING:
-00017e90: 2065 7420 6461 7461 2061 7420 7469 6d65   et data at time
-00017ea0: 2027 2c20 6954 696d 652c 2027 2069 7320   ', iTime, ' is 
-00017eb0: 656d 7074 792e 270a 2020 2020 2020 2020  empty.'.        
-00017ec0: 2163 616c 6c20 6d65 7373 6167 6528 2757  !call message('W
-00017ed0: 4152 4e49 4e47 3a20 6f62 6a65 6374 6976  ARNING: objectiv
-00017ee0: 655f 6574 5f6b 6765 5f63 6174 6368 6d65  e_et_kge_catchme
-00017ef0: 6e74 5f61 7667 3a20 6967 6e6f 7265 6420  nt_avg: ignored 
-00017f00: 6375 7272 656e 7420 7469 6d65 2073 7465  current time ste
-00017f10: 7020 7369 6e63 6520 6c65 7373 2074 6861  p since less tha
-00017f20: 6e27 290a 2020 2020 2020 2020 2163 616c  n').        !cal
-00017f30: 6c20 6d65 7373 6167 6528 2720 2020 2020  l message('     
-00017f40: 2020 2020 3130 2076 616c 6964 2063 656c      10 valid cel
-00017f50: 6c73 2061 7661 696c 6162 6c65 2069 6e20  ls available in 
-00017f60: 6576 6170 6f74 7261 6e73 7069 7261 7469  evapotranspirati
-00017f70: 6f6e 206f 6273 6572 7661 7469 6f6e 2729  on observation')
-00017f80: 0a20 2020 2020 2020 206d 6173 6b5f 7469  .        mask_ti
-00017f90: 6d65 7328 6954 696d 6529 203d 202e 4641  mes(iTime) = .FA
-00017fa0: 4c53 452e 0a20 2020 2020 2020 2063 7963  LSE..        cyc
-00017fb0: 6c65 0a20 2020 2020 2065 6e64 2069 660a  le.      end if.
-00017fc0: 0a20 2020 2020 2065 745f 6361 7463 685f  .      et_catch_
-00017fd0: 6176 675f 646f 6d61 696e 2869 5469 6d65  avg_domain(iTime
-00017fe0: 2920 3d20 6176 6572 6167 6528 4c31 5f65  ) = average(L1_e
-00017ff0: 744f 6273 2869 446f 6d61 696e 2925 6461  tObs(iDomain)%da
-00018000: 7461 4f62 7328 3a2c 2069 5469 6d65 292c  taObs(:, iTime),
-00018010: 2026 0a20 2020 2020 2020 2020 2020 2020   &.             
-00018020: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018030: 2020 2020 2020 206d 6173 6b20 3d20 4c31         mask = L1
-00018040: 5f65 744f 6273 2869 446f 6d61 696e 2925  _etObs(iDomain)%
-00018050: 6d61 736b 4f62 7328 3a2c 2069 5469 6d65  maskObs(:, iTime
-00018060: 2929 0a20 2020 2020 2065 745f 6f70 7469  )).      et_opti
-00018070: 5f63 6174 6368 5f61 7667 5f64 6f6d 6169  _catch_avg_domai
-00018080: 6e28 6954 696d 6529 203d 2061 7665 7261  n(iTime) = avera
-00018090: 6765 2865 744f 7074 6953 696d 2869 446f  ge(etOptiSim(iDo
-000180a0: 6d61 696e 2925 6461 7461 5369 6d28 3a2c  main)%dataSim(:,
-000180b0: 2069 5469 6d65 292c 2026 0a20 2020 2020   iTime), &.     
-000180c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000180d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000180e0: 2020 2020 206d 6173 6b20 3d20 4c31 5f65       mask = L1_e
-000180f0: 744f 6273 2869 446f 6d61 696e 2925 6d61  tObs(iDomain)%ma
-00018100: 736b 4f62 7328 3a2c 2069 5469 6d65 2929  skObs(:, iTime))
-00018110: 0a20 2020 2065 6e64 2064 6f0a 0a20 2065  .    end do..  e
-00018120: 6e64 2073 7562 726f 7574 696e 6520 6372  nd subroutine cr
-00018130: 6561 7465 5f64 6f6d 6169 6e5f 6176 675f  eate_domain_avg_
-00018140: 6574 0a0a 2020 7375 6272 6f75 7469 6e65  et..  subroutine
-00018150: 2063 6f6e 7665 7274 5f74 7773 5f74 6f5f   convert_tws_to_
-00018160: 7477 7361 2874 7773 4f70 7469 5369 6d2c  twsa(twsOptiSim,
-00018170: 204c 315f 7477 7361 4f62 732c 2074 7773   L1_twsaObs, tws
-00018180: 614f 7074 6953 696d 290a 2020 2020 7573  aOptiSim).    us
-00018190: 6520 6d6f 5f6f 7074 696d 697a 6174 696f  e mo_optimizatio
-000181a0: 6e5f 7479 7065 732c 206f 6e6c 7920 3a20  n_types, only : 
-000181b0: 6f70 7469 6461 7461 5f73 696d 2c20 6f70  optidata_sim, op
-000181c0: 7469 6461 7461 0a20 2020 2075 7365 206d  tidata.    use m
-000181d0: 6f5f 6d6f 6d65 6e74 2c20 6f6e 6c79 203a  o_moment, only :
-000181e0: 2061 7665 7261 6765 0a20 2020 2021 2073   average.    ! s
-000181f0: 696d 756c 6174 6564 2074 7773 0a20 2020  imulated tws.   
-00018200: 2074 7970 6528 6f70 7469 6461 7461 5f73   type(optidata_s
-00018210: 696d 292c 2069 6e74 656e 7428 696e 2920  im), intent(in) 
-00018220: 2020 203a 3a20 7477 734f 7074 6953 696d     :: twsOptiSim
-00018230: 0a20 2020 2021 206f 6273 6572 7665 6420  .    ! observed 
-00018240: 7477 7361 0a20 2020 2074 7970 6528 6f70  twsa.    type(op
-00018250: 7469 6461 7461 292c 2020 2020 2069 6e74  tidata),     int
-00018260: 656e 7428 696e 2920 2020 203a 3a20 4c31  ent(in)    :: L1
-00018270: 5f74 7773 614f 6273 0a20 2020 2021 2073  _twsaObs.    ! s
-00018280: 696d 756c 6174 6564 2074 7773 610a 2020  imulated twsa.  
-00018290: 2020 7479 7065 286f 7074 6964 6174 615f    type(optidata_
-000182a0: 7369 6d29 2c20 696e 7465 6e74 2869 6e6f  sim), intent(ino
-000182b0: 7574 2920 3a3a 2074 7773 614f 7074 6953  ut) :: twsaOptiS
-000182c0: 696d 0a0a 2020 2020 2120 6c6f 6361 6c0a  im..    ! local.
-000182d0: 2020 2020 696e 7465 6765 7228 6934 2920      integer(i4) 
-000182e0: 3a3a 2069 4365 6c6c 0a20 2020 2072 6561  :: iCell.    rea
-000182f0: 6c28 6470 2920 2020 203a 3a20 7477 7361  l(dp)    :: twsa
-00018300: 5f61 765f 6365 6c6c 0a0a 2020 2020 616c  _av_cell..    al
-00018310: 6c6f 6361 7465 2874 7773 614f 7074 6953  locate(twsaOptiS
-00018320: 696d 2564 6174 6153 696d 2873 697a 6528  im%dataSim(size(
-00018330: 7477 734f 7074 6953 696d 2564 6174 6153  twsOptiSim%dataS
-00018340: 696d 283a 2c20 3a29 2c20 6469 6d20 3d20  im(:, :), dim = 
-00018350: 3129 2c20 7369 7a65 2874 7773 4f70 7469  1), size(twsOpti
-00018360: 5369 6d25 6461 7461 5369 6d28 3a2c 203a  Sim%dataSim(:, :
-00018370: 292c 2064 696d 203d 2032 2929 290a 0a20  ), dim = 2))).. 
-00018380: 2020 2064 6f20 6943 656c 6c20 3d20 312c     do iCell = 1,
-00018390: 2073 697a 6528 7477 734f 7074 6953 696d   size(twsOptiSim
-000183a0: 2564 6174 6153 696d 283a 2c20 3a29 2c20  %dataSim(:, :), 
-000183b0: 6469 6d20 3d20 3129 0a20 2020 2020 2074  dim = 1).      t
-000183c0: 7773 615f 6176 5f63 656c 6c20 3d20 6176  wsa_av_cell = av
-000183d0: 6572 6167 6528 7477 734f 7074 6953 696d  erage(twsOptiSim
-000183e0: 2564 6174 6153 696d 2869 4365 6c6c 2c20  %dataSim(iCell, 
-000183f0: 3a29 2c20 6d61 736b 203d 204c 315f 7477  :), mask = L1_tw
-00018400: 7361 4f62 7325 6d61 736b 4f62 7328 6943  saObs%maskObs(iC
-00018410: 656c 6c2c 203a 2929 0a20 2020 2020 2074  ell, :)).      t
-00018420: 7773 614f 7074 6953 696d 2564 6174 6153  wsaOptiSim%dataS
-00018430: 696d 2869 4365 6c6c 2c20 3a29 203d 2074  im(iCell, :) = t
-00018440: 7773 4f70 7469 5369 6d25 6461 7461 5369  wsOptiSim%dataSi
-00018450: 6d28 6943 656c 6c2c 203a 2920 2d20 7477  m(iCell, :) - tw
-00018460: 7361 5f61 765f 6365 6c6c 0a20 2020 2065  sa_av_cell.    e
-00018470: 6e64 2064 6f0a 0a20 2065 6e64 2073 7562  nd do..  end sub
-00018480: 726f 7574 696e 6520 636f 6e76 6572 745f  routine convert_
-00018490: 7477 735f 746f 5f74 7773 610a 0a45 4e44  tws_to_twsa..END
-000184a0: 204d 4f44 554c 4520 6d6f 5f6f 626a 6563   MODULE mo_objec
-000184b0: 7469 7665 5f66 756e 6374 696f 6e0a       tive_function.
+00011f80: 0a20 2020 206f 626a 6563 7469 7665 5f6b  .    objective_k
+00011f90: 6765 203d 2030 2e30 5f64 700a 2020 2020  ge = 0.0_dp.    
+00011fa0: 6e47 6175 6765 7354 6f74 616c 203d 2073  nGaugesTotal = s
+00011fb0: 697a 6528 7275 6e6f 6666 2c20 6469 6d20  ize(runoff, dim 
+00011fc0: 3d20 3229 0a0a 2020 2020 646f 2067 6720  = 2)..    do gg 
+00011fd0: 3d20 312c 206e 4761 7567 6573 546f 7461  = 1, nGaugesTota
+00011fe0: 6c0a 0a20 2020 2020 2021 2065 7874 7261  l..      ! extra
+00011ff0: 6374 2072 756e 6f66 660a 2020 2020 2020  ct runoff.      
+00012000: 6361 6c6c 2065 7874 7261 6374 5f72 756e  call extract_run
+00012010: 6f66 6628 6767 2c20 7275 6e6f 6666 2c20  off(gg, runoff, 
+00012020: 7275 6e6f 6666 5f61 6767 2c20 7275 6e6f  runoff_agg, runo
+00012030: 6666 5f6f 6273 2c20 7275 6e6f 6666 5f6f  ff_obs, runoff_o
+00012040: 6273 5f6d 6173 6b29 0a0a 2020 2020 2020  bs_mask)..      
+00012050: 2120 4b47 450a 2020 2020 2020 6f62 6a65  ! KGE.      obje
+00012060: 6374 6976 655f 6b67 6520 3d20 6f62 6a65  ctive_kge = obje
+00012070: 6374 6976 655f 6b67 6520 2b20 260a 2020  ctive_kge + &.  
+00012080: 2020 2020 2020 2020 2020 2020 2828 312e              ((1.
+00012090: 305f 6470 202d 206b 6765 2872 756e 6f66  0_dp - kge(runof
+000120a0: 665f 6f62 732c 2072 756e 6f66 665f 6167  f_obs, runoff_ag
+000120b0: 672c 206d 6173 6b20 3d20 7275 6e6f 6666  g, mask = runoff
+000120c0: 5f6f 6273 5f6d 6173 6b29 2920 2f20 7265  _obs_mask)) / re
+000120d0: 616c 286e 4761 7567 6573 546f 7461 6c2c  al(nGaugesTotal,
+000120e0: 2064 7029 292a 2a36 0a0a 2020 2020 656e   dp))**6..    en
+000120f0: 6420 646f 0a0a 2020 2020 6465 616c 6c6f  d do..    deallo
+00012100: 6361 7465 2872 756e 6f66 665f 6167 672c  cate(runoff_agg,
+00012110: 2072 756e 6f66 665f 6f62 732c 2072 756e   runoff_obs, run
+00012120: 6f66 665f 6f62 735f 6d61 736b 290a 0a20  off_obs_mask).. 
+00012130: 2020 2021 2063 6f6d 7072 6f6d 6973 6520     ! compromise 
+00012140: 736f 6c75 7469 6f6e 202d 2073 6978 7468  solution - sixth
+00012150: 2072 6f6f 740a 2020 2020 6f62 6a65 6374   root.    object
+00012160: 6976 655f 6b67 6520 3d20 6f62 6a65 6374  ive_kge = object
+00012170: 6976 655f 6b67 652a 2a6f 6e65 7369 7874  ive_kge**onesixt
+00012180: 680a 0a20 2020 2021 2065 7175 616c 2077  h..    ! equal w
+00012190: 6569 6768 7465 6420 636f 6d70 726f 6d69  eighted compromi
+000121a0: 7365 206f 626a 6563 7469 7665 2066 756e  se objective fun
+000121b0: 6374 696f 6e73 2066 6f72 2064 6973 6368  ctions for disch
+000121c0: 6172 6765 2061 6e64 2073 6f69 6c6d 6f69  arge and soilmoi
+000121d0: 7374 7572 650a 2020 2020 2120 546f 446f  sture.    ! ToDo
+000121e0: 3a20 7768 7920 646f 2077 6520 7573 6520  : why do we use 
+000121f0: 7468 6520 7369 7874 6820 726f 6f74 206f  the sixth root o
+00012200: 6620 6f66 206f 626a 6563 7469 7665 5f73  f of objective_s
+00012210: 6d20 616e 6420 6f62 6a65 6374 6976 655f  m and objective_
+00012220: 6b67 650a 2020 2020 2120 6f6e 6c79 2074  kge.    ! only t
+00012230: 6f20 7461 6b65 2074 6865 2070 6f77 6572  o take the power
+00012240: 2074 6f20 3620 6865 7265 2061 6761 696e   to 6 here again
+00012250: 2c20 7768 656e 2077 6520 6e65 7665 7220  , when we never 
+00012260: 6e65 6564 2074 6865 0a20 2020 2021 2069  need the.    ! i
+00012270: 6e74 6572 6d65 6469 6174 6520 7265 7375  ntermediate resu
+00012280: 6c74 733f 0a23 6966 6465 6620 4d50 490a  lts?.#ifdef MPI.
+00012290: 2020 2020 6f62 6a65 6374 6976 655f 6b67      objective_kg
+000122a0: 655f 715f 736d 5f63 6f72 7220 3d20 286f  e_q_sm_corr = (o
+000122b0: 626a 6563 7469 7665 5f73 6d2a 2a36 202b  bjective_sm**6 +
+000122c0: 206f 626a 6563 7469 7665 5f6b 6765 2a2a   objective_kge**
+000122d0: 3629 0a23 656c 7365 0a20 2020 206f 626a  6).#else.    obj
+000122e0: 6563 7469 7665 5f6b 6765 5f71 5f73 6d5f  ective_kge_q_sm_
+000122f0: 636f 7272 203d 2028 6f62 6a65 6374 6976  corr = (objectiv
+00012300: 655f 736d 2a2a 3620 2b20 6f62 6a65 6374  e_sm**6 + object
+00012310: 6976 655f 6b67 652a 2a36 292a 2a6f 6e65  ive_kge**6)**one
+00012320: 7369 7874 680a 0a20 2020 2063 616c 6c20  sixth..    call 
+00012330: 6d65 7373 6167 6528 2720 2020 206f 626a  message('    obj
+00012340: 6563 7469 7665 5f6b 6765 5f71 5f73 6d5f  ective_kge_q_sm_
+00012350: 636f 7272 203d 2027 2c20 6e75 6d32 7374  corr = ', num2st
+00012360: 7228 6f62 6a65 6374 6976 655f 6b67 655f  r(objective_kge_
+00012370: 715f 736d 5f63 6f72 722c 2027 2846 392e  q_sm_corr, '(F9.
+00012380: 3529 2729 290a 2365 6e64 6966 0a20 2020  5)')).#endif.   
+00012390: 2021 2020 2020 7072 696e 742a 2c20 2231   !    print*, "1
+000123a0: 2d53 4d20 322d 5120 3a20 222c 2031 2e30  -SM 2-Q : ", 1.0
+000123b0: 5f64 702d 6f62 6a65 6374 6976 655f 736d  _dp-objective_sm
+000123c0: 2c20 312e 305f 6470 2d6f 626a 6563 7469  , 1.0_dp-objecti
+000123d0: 7665 5f6b 6765 2021 204d 5a4d 5a4d 5a4d  ve_kge ! MZMZMZM
+000123e0: 5a0a 0a20 2045 4e44 2046 554e 4354 494f  Z..  END FUNCTIO
+000123f0: 4e20 6f62 6a65 6374 6976 655f 6b67 655f  N objective_kge_
+00012400: 715f 736d 5f63 6f72 720a 0a0a 2020 2120  q_sm_corr...  ! 
+00012410: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00012420: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00012430: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00012440: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00012450: 2d0a 0a20 2021 2020 2020 4e41 4d45 0a20  -..  !    NAME. 
+00012460: 2021 2020 2020 2020 2020 6f62 6a65 6374   !        object
+00012470: 6976 655f 6b67 655f 715f 6574 0a0a 2020  ive_kge_q_et..  
+00012480: 2120 2020 2050 5552 504f 5345 0a20 2021  !    PURPOSE.  !
+00012490: 3e20 2020 2020 2020 5c62 7269 6566 204f  >       \brief O
+000124a0: 626a 6563 7469 7665 2066 756e 6374 696f  bjective functio
+000124b0: 6e20 6f66 204b 4745 2066 6f72 2072 756e  n of KGE for run
+000124c0: 6f66 6620 616e 6420 4b47 4520 666f 7220  off and KGE for 
+000124d0: 4554 0a0a 2020 213e 2020 2020 2020 205c  ET..  !>       \
+000124e0: 6465 7461 696c 7320 4f62 6a65 6374 6976  details Objectiv
+000124f0: 6520 6675 6e63 7469 6f6e 206f 6620 4b47  e function of KG
+00012500: 4520 666f 7220 7275 6e6f 6666 2061 6e64  E for runoff and
+00012510: 204b 4745 2066 6f72 2045 542e 0a20 2021   KGE for ET..  !
+00012520: 3e20 2020 2020 2020 4675 7274 6865 7220  >       Further 
+00012530: 6465 7461 696c 7320 6361 6e20 6265 2066  details can be f
+00012540: 6f75 6e64 2069 6e20 7468 6520 646f 6375  ound in the docu
+00012550: 6d65 6e74 6174 696f 6e20 6f66 206f 626a  mentation of obj
+00012560: 6563 7469 7665 2066 756e 6374 696f 6e73  ective functions
+00012570: 0a20 2021 3e20 2020 2020 2020 2731 3420  .  !>       '14 
+00012580: 2d20 6f62 6a65 6374 6976 655f 6d75 6c74  - objective_mult
+00012590: 6970 6c65 5f67 6175 6765 735f 6b67 655f  iple_gauges_kge_
+000125a0: 706f 7765 7236 272e 0a0a 2020 2120 2020  power6'...  !   
+000125b0: 2049 4e54 454e 5428 494e 290a 2020 213e   INTENT(IN).  !>
+000125c0: 2020 2020 2020 205c 7061 7261 6d5b 696e         \param[in
+000125d0: 5d20 2272 6561 6c28 6470 292c 2064 696d  ] "real(dp), dim
+000125e0: 656e 7369 6f6e 283a 2920 3a3a 2070 6172  ension(:) :: par
+000125f0: 616d 6574 6572 7365 7422 0a20 2021 3e20  ameterset".  !> 
+00012600: 2020 2020 2020 5c70 6172 616d 5b69 6e5d        \param[in]
+00012610: 2022 7072 6f63 6564 7572 6528 6576 616c   "procedure(eval
+00012620: 5f69 6e74 6572 6661 6365 2920 3a3a 2065  _interface) :: e
+00012630: 7661 6c22 0a0a 2020 2120 2020 2052 4554  val"..  !    RET
+00012640: 5552 4e0a 2020 213e 2020 2020 2020 205c  URN.  !>       \
+00012650: 7265 7475 726e 2072 6561 6c28 6470 2920  return real(dp) 
+00012660: 3a3a 206f 626a 6563 7469 7665 5f6b 6765  :: objective_kge
+00012670: 5f71 5f65 7420 266d 6461 7368 3b20 6f62  _q_et &mdash; ob
+00012680: 6a65 6374 6976 6520 6675 6e63 7469 6f6e  jective function
+00012690: 2076 616c 7565 0a20 2021 3e20 2020 2020   value.  !>     
+000126a0: 2020 2877 6869 6368 2077 696c 6c20 6265    (which will be
+000126b0: 2065 2e67 2e20 6d69 6e69 6d69 7a65 6420   e.g. minimized 
+000126c0: 6279 2061 6e20 6f70 7469 6d69 7a61 7469  by an optimizati
+000126d0: 6f6e 2072 6f75 7469 6e65 206c 696b 6520  on routine like 
+000126e0: 4444 5329 0a0a 2020 2120 2020 2048 4953  DDS)..  !    HIS
+000126f0: 544f 5259 0a20 2021 3e20 2020 2020 2020  TORY.  !>       
+00012700: 5c61 7574 686f 7273 204a 6f68 616e 6e65  \authors Johanne
+00012710: 7320 4272 656e 6e65 720a 0a20 2021 3e20  s Brenner..  !> 
+00012720: 2020 2020 2020 5c64 6174 6520 4a75 6c79        \date July
+00012730: 2032 3031 370a 0a20 2021 204d 6f64 6966   2017..  ! Modif
+00012740: 6963 6174 696f 6e73 3a0a 2020 2120 526f  ications:.  ! Ro
+00012750: 6265 7274 2053 6368 7765 7070 6520 4a75  bert Schweppe Ju
+00012760: 6e20 3230 3138 202d 2072 6566 6163 746f  n 2018 - refacto
+00012770: 7269 6e67 2061 6e64 2072 6566 6f72 6d61  ring and reforma
+00012780: 7474 696e 670a 0a20 2046 554e 4354 494f  tting..  FUNCTIO
+00012790: 4e20 6f62 6a65 6374 6976 655f 6b67 655f  N objective_kge_
+000127a0: 715f 6574 2870 6172 616d 6574 6572 7365  q_et(parameterse
+000127b0: 742c 2065 7661 6c29 0a0a 2020 2020 7573  t, eval)..    us
+000127c0: 6520 6d6f 5f6f 7074 696d 697a 6174 696f  e mo_optimizatio
+000127d0: 6e5f 7479 7065 732c 206f 6e6c 7920 3a20  n_types, only : 
+000127e0: 6f70 7469 6461 7461 5f73 696d 0a20 2020  optidata_sim.   
+000127f0: 2075 7365 206d 6f5f 636f 6d6d 6f6e 5f76   use mo_common_v
+00012800: 6172 6961 626c 6573 2c20 6f6e 6c79 203a  ariables, only :
+00012810: 206c 6576 656c 312c 2064 6f6d 6169 6e4d   level1, domainM
+00012820: 6574 610a 2020 2020 7573 6520 6d6f 5f65  eta.    use mo_e
+00012830: 7272 6f72 6d65 6173 7572 6573 2c20 6f6e  rrormeasures, on
+00012840: 6c79 203a 206b 6765 0a20 2020 2075 7365  ly : kge.    use
+00012850: 206d 6f5f 676c 6f62 616c 5f76 6172 6961   mo_global_varia
+00012860: 626c 6573 2c20 6f6e 6c79 203a 204c 315f  bles, only : L1_
+00012870: 6574 4f62 730a 2020 2020 7573 6520 6d6f  etObs.    use mo
+00012880: 5f73 7472 696e 675f 7574 696c 732c 206f  _string_utils, o
+00012890: 6e6c 7920 3a20 6e75 6d32 7374 720a 2020  nly : num2str.  
+000128a0: 2020 7573 6520 6d6f 5f6d 726d 5f6f 626a    use mo_mrm_obj
+000128b0: 6563 7469 7665 5f66 756e 6374 696f 6e5f  ective_function_
+000128c0: 7275 6e6f 6666 2c20 6f6e 6c79 203a 2065  runoff, only : e
+000128d0: 7874 7261 6374 5f72 756e 6f66 660a 0a20  xtract_runoff.. 
+000128e0: 2020 2069 6d70 6c69 6369 7420 6e6f 6e65     implicit none
+000128f0: 0a0a 2020 2020 7265 616c 2864 7029 2c20  ..    real(dp), 
+00012900: 6469 6d65 6e73 696f 6e28 3a29 2c20 696e  dimension(:), in
+00012910: 7465 6e74 2869 6e29 203a 3a20 7061 7261  tent(in) :: para
+00012920: 6d65 7465 7273 6574 0a0a 2020 2020 7072  meterset..    pr
+00012930: 6f63 6564 7572 6528 6576 616c 5f69 6e74  ocedure(eval_int
+00012940: 6572 6661 6365 292c 2049 4e54 454e 5428  erface), INTENT(
+00012950: 494e 292c 2050 4f49 4e54 4552 203a 3a20  IN), POINTER :: 
+00012960: 6576 616c 0a0a 2020 2020 7265 616c 2864  eval..    real(d
+00012970: 7029 203a 3a20 6f62 6a65 6374 6976 655f  p) :: objective_
+00012980: 6b67 655f 715f 6574 0a0a 2020 2020 7265  kge_q_et..    re
+00012990: 616c 2864 7029 203a 3a20 6f62 6a65 6374  al(dp) :: object
+000129a0: 6976 655f 6574 0a0a 2020 2020 7265 616c  ive_et..    real
+000129b0: 2864 7029 203a 3a20 6f62 6a65 6374 6976  (dp) :: objectiv
+000129c0: 655f 710a 0a20 2020 2021 206e 756d 6265  e_q..    ! numbe
+000129d0: 7220 6f66 2069 6e76 616c 6964 2063 656c  r of invalid cel
+000129e0: 6c73 2069 6e20 6361 7463 686d 656e 740a  ls in catchment.
+000129f0: 2020 2020 7265 616c 2864 7029 203a 3a20      real(dp) :: 
+00012a00: 696e 7661 6c69 645f 6365 6c6c 730a 0a20  invalid_cells.. 
+00012a10: 2020 2021 206d 6f64 656c 6c65 6420 7275     ! modelled ru
+00012a20: 6e6f 6666 2066 6f72 2061 2067 6976 656e  noff for a given
+00012a30: 2070 6172 616d 6574 6572 2073 6574 0a20   parameter set. 
+00012a40: 2020 2021 2064 696d 313d 6e54 696d 6553     ! dim1=nTimeS
+00012a50: 7465 7073 2c20 6469 6d32 3d6e 4761 7567  teps, dim2=nGaug
+00012a60: 6573 0a20 2020 2072 6561 6c28 6470 292c  es.    real(dp),
+00012a70: 2061 6c6c 6f63 6174 6162 6c65 2c20 6469   allocatable, di
+00012a80: 6d65 6e73 696f 6e28 3a2c 203a 2920 3a3a  mension(:, :) ::
+00012a90: 2072 756e 6f66 660a 0a20 2020 2021 2064   runoff..    ! d
+00012aa0: 6f6d 6169 6e20 6c6f 6f70 2063 6f75 6e74  omain loop count
+00012ab0: 6572 0a20 2020 2069 6e74 6567 6572 2869  er.    integer(i
+00012ac0: 3429 203a 3a20 6944 6f6d 6169 6e0a 0a20  4) :: iDomain.. 
+00012ad0: 2020 2021 2063 656c 6c20 6c6f 6f70 2063     ! cell loop c
+00012ae0: 6f75 6e74 6572 0a20 2020 2069 6e74 6567  ounter.    integ
+00012af0: 6572 2869 3429 203a 3a20 6943 656c 6c0a  er(i4) :: iCell.
+00012b00: 0a20 2020 2021 206e 6365 6c6c 7331 206f  .    ! ncells1 o
+00012b10: 6620 6c65 7665 6c20 310a 2020 2020 696e  f level 1.    in
+00012b20: 7465 6765 7228 6934 2920 3a3a 206e 4365  teger(i4) :: nCe
+00012b30: 6c6c 7331 0a0a 2020 2020 2120 646f 6d61  lls1..    ! doma
+00012b40: 696e 7320 7769 7365 206f 626a 6563 7469  ins wise objecti
+00012b50: 7665 730a 2020 2020 7265 616c 2864 7029  ves.    real(dp)
+00012b60: 203a 3a20 6f62 6a65 6374 6976 655f 6574   :: objective_et
+00012b70: 5f64 6f6d 6169 6e0a 0a20 2020 2021 3e20  _domain..    !> 
+00012b80: 7369 6d75 6c61 7465 6420 6574 0a20 2020  simulated et.   
+00012b90: 2074 7970 6528 6f70 7469 6461 7461 5f73   type(optidata_s
+00012ba0: 696d 292c 2064 696d 656e 7369 6f6e 283a  im), dimension(:
+00012bb0: 292c 2061 6c6c 6f63 6174 6162 6c65 203a  ), allocatable :
+00012bc0: 3a20 6574 4f70 7469 5369 6d0a 0a20 2020  : etOptiSim..   
+00012bd0: 2072 6561 6c28 6470 292c 2070 6172 616d   real(dp), param
+00012be0: 6574 6572 203a 3a20 6f6e 6573 6978 7468  eter :: onesixth
+00012bf0: 203d 2031 2e30 5f64 7020 2f20 362e 305f   = 1.0_dp / 6.0_
+00012c00: 6470 0a0a 2020 2020 2120 6761 7567 6573  dp..    ! gauges
+00012c10: 2063 6f75 6e74 6572 0a20 2020 2069 6e74   counter.    int
+00012c20: 6567 6572 2869 3429 203a 3a20 6767 0a0a  eger(i4) :: gg..
+00012c30: 2020 2020 696e 7465 6765 7228 6934 2920      integer(i4) 
+00012c40: 3a3a 206e 4761 7567 6573 546f 7461 6c0a  :: nGaugesTotal.
+00012c50: 0a20 2020 2021 2061 6767 7265 6761 7465  .    ! aggregate
+00012c60: 6420 7369 6d75 6c61 7465 6420 7275 6e6f  d simulated runo
+00012c70: 6666 0a20 2020 2072 6561 6c28 6470 292c  ff.    real(dp),
+00012c80: 2064 696d 656e 7369 6f6e 283a 292c 2061   dimension(:), a
+00012c90: 6c6c 6f63 6174 6162 6c65 203a 3a20 7275  llocatable :: ru
+00012ca0: 6e6f 6666 5f61 6767 0a0a 2020 2020 2120  noff_agg..    ! 
+00012cb0: 6d65 6173 7572 6564 2072 756e 6f66 660a  measured runoff.
+00012cc0: 2020 2020 7265 616c 2864 7029 2c20 6469      real(dp), di
+00012cd0: 6d65 6e73 696f 6e28 3a29 2c20 616c 6c6f  mension(:), allo
+00012ce0: 6361 7461 626c 6520 3a3a 2072 756e 6f66  catable :: runof
+00012cf0: 665f 6f62 730a 0a20 2020 2021 206d 6173  f_obs..    ! mas
+00012d00: 6b20 666f 7220 6d65 6173 7572 6564 2072  k for measured r
+00012d10: 756e 6f66 660a 2020 2020 6c6f 6769 6361  unoff.    logica
+00012d20: 6c2c 2064 696d 656e 7369 6f6e 283a 292c  l, dimension(:),
+00012d30: 2061 6c6c 6f63 6174 6162 6c65 203a 3a20   allocatable :: 
+00012d40: 7275 6e6f 6666 5f6f 6273 5f6d 6173 6b0a  runoff_obs_mask.
+00012d50: 0a20 2020 2021 2072 756e 206d 484d 0a20  .    ! run mHM. 
+00012d60: 2020 2061 6c6c 6f63 6174 6528 6574 4f70     allocate(etOp
+00012d70: 7469 5369 6d28 646f 6d61 696e 4d65 7461  tiSim(domainMeta
+00012d80: 256e 446f 6d61 696e 7329 290a 2020 2020  %nDomains)).    
+00012d90: 6361 6c6c 2065 7661 6c28 7061 7261 6d65  call eval(parame
+00012da0: 7465 7273 6574 2c20 7275 6e6f 6666 203d  terset, runoff =
+00012db0: 2072 756e 6f66 662c 2065 744f 7074 6953   runoff, etOptiS
+00012dc0: 696d 203d 2065 744f 7074 6953 696d 290a  im = etOptiSim).
+00012dd0: 0a20 2020 2021 202d 2d2d 2d2d 2d2d 2d2d  .    ! ---------
+00012de0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00012df0: 2d2d 2d2d 0a20 2020 2021 2045 5641 504f  ----.    ! EVAPO
+00012e00: 5452 414e 5350 4952 4154 494f 4e0a 2020  TRANSPIRATION.  
+00012e10: 2020 2120 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d    ! ------------
+00012e20: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00012e30: 2d0a 0a20 2020 2021 2069 6e69 7469 616c  -..    ! initial
+00012e40: 697a 6520 736f 6d65 2076 6172 6961 626c  ize some variabl
+00012e50: 6573 0a20 2020 206f 626a 6563 7469 7665  es.    objective
+00012e60: 5f65 7420 3d20 302e 305f 6470 0a0a 2020  _et = 0.0_dp..  
+00012e70: 2020 2120 6c6f 6f70 206f 7665 7220 646f    ! loop over do
+00012e80: 6d61 696e 202d 2066 6f72 2061 7070 6c79  main - for apply
+00012e90: 696e 6720 706f 7765 7220 6c61 7720 6c61  ing power law la
+00012ea0: 7465 7220 6f6e 0a20 2020 2064 6f20 6944  ter on.    do iD
+00012eb0: 6f6d 6169 6e20 3d20 312c 2064 6f6d 6169  omain = 1, domai
+00012ec0: 6e4d 6574 6125 6e44 6f6d 6169 6e73 0a0a  nMeta%nDomains..
+00012ed0: 2020 2020 2020 2120 696e 6974 0a20 2020        ! init.   
+00012ee0: 2020 206f 626a 6563 7469 7665 5f65 745f     objective_et_
+00012ef0: 646f 6d61 696e 203d 2030 2e30 5f64 700a  domain = 0.0_dp.
+00012f00: 2020 2020 2020 2120 6765 7420 646f 6d61        ! get doma
+00012f10: 696e 2069 6e66 6f72 6d61 7469 6f6e 0a20  in information. 
+00012f20: 2020 2020 206e 4365 6c6c 7331 203d 206c       nCells1 = l
+00012f30: 6576 656c 3128 6944 6f6d 6169 6e29 256e  evel1(iDomain)%n
+00012f40: 4365 6c6c 730a 0a20 2020 2020 2021 2063  Cells..      ! c
+00012f50: 6f72 7265 6c61 7469 6f6e 2073 6967 6e61  orrelation signa
+00012f60: 6c20 6973 2063 616c 6375 6c61 7465 6420  l is calculated 
+00012f70: 6f6e 2069 6e64 6976 6964 7561 6c20 6772  on individual gr
+00012f80: 6964 2063 656c 6c73 0a20 2020 2020 2069  id cells.      i
+00012f90: 6e76 616c 6964 5f63 656c 6c73 203d 2030  nvalid_cells = 0
+00012fa0: 2e30 5f64 700a 2020 2020 2020 646f 2069  .0_dp.      do i
+00012fb0: 4365 6c6c 203d 2031 2c20 7369 7a65 284c  Cell = 1, size(L
+00012fc0: 315f 6574 4f62 7328 6944 6f6d 6169 6e29  1_etObs(iDomain)
+00012fd0: 256d 6173 6b4f 6273 2c20 6469 6d20 3d20  %maskObs, dim = 
+00012fe0: 3129 0a0a 2020 2020 2020 2020 2120 6368  1)..        ! ch
+00012ff0: 6563 6b20 666f 7220 656e 6f75 6768 2064  eck for enough d
+00013000: 6174 6120 706f 696e 7473 2069 6e20 7469  ata points in ti
+00013010: 6d65 2066 6f72 2073 7461 7469 7374 6963  me for statistic
+00013020: 616c 2063 616c 6375 6c61 7469 6f6e 7320  al calculations 
+00013030: 2865 2e67 2e20 6d65 616e 2c20 7374 6464  (e.g. mean, stdd
+00013040: 6576 290a 2020 2020 2020 2020 6966 2028  ev).        if (
+00013050: 636f 756e 7428 4c31 5f65 744f 6273 2869  count(L1_etObs(i
+00013060: 446f 6d61 696e 2925 6d61 736b 4f62 7328  Domain)%maskObs(
+00013070: 6943 656c 6c2c 203a 2929 202e 4c45 2e20  iCell, :)) .LE. 
+00013080: 260a 2020 2020 2020 2020 2020 2020 2020  &.              
+00013090: 2020 2020 2020 2020 2020 2020 2020 2830                (0
+000130a0: 2e31 305f 6470 202a 2072 6561 6c28 7369  .10_dp * real(si
+000130b0: 7a65 284c 315f 6574 4f62 7328 6944 6f6d  ze(L1_etObs(iDom
+000130c0: 6169 6e29 2564 6174 614f 6273 283a 2c20  ain)%dataObs(:, 
+000130d0: 3a29 2c20 6469 6d20 3d20 3229 2c20 6470  :), dim = 2), dp
+000130e0: 2929 2920 7468 656e 0a20 2020 2020 2020  ))) then.       
+000130f0: 2020 2069 6e76 616c 6964 5f63 656c 6c73     invalid_cells
+00013100: 203d 2069 6e76 616c 6964 5f63 656c 6c73   = invalid_cells
+00013110: 202b 2031 2e30 5f64 700a 2020 2020 2020   + 1.0_dp.      
+00013120: 2020 2020 6379 636c 650a 2020 2020 2020      cycle.      
+00013130: 2020 656e 6420 6966 0a0a 2020 2020 2020    end if..      
+00013140: 2020 2120 6361 6c63 756c 6174 6520 6f6a    ! calculate oj
+00013150: 6563 7469 7665 2066 756e 6374 696f 6e0a  ective function.
+00013160: 2020 2020 2020 2020 6f62 6a65 6374 6976          objectiv
+00013170: 655f 6574 5f64 6f6d 6169 6e20 3d20 6f62  e_et_domain = ob
+00013180: 6a65 6374 6976 655f 6574 5f64 6f6d 6169  jective_et_domai
+00013190: 6e20 2b20 260a 2020 2020 2020 2020 2020  n + &.          
+000131a0: 2020 2020 2020 6b67 6528 4c31 5f65 744f        kge(L1_etO
+000131b0: 6273 2869 446f 6d61 696e 2925 6461 7461  bs(iDomain)%data
+000131c0: 4f62 7328 6943 656c 6c2c 203a 292c 2065  Obs(iCell, :), e
+000131d0: 744f 7074 6953 696d 2869 446f 6d61 696e  tOptiSim(iDomain
+000131e0: 2925 6461 7461 5369 6d28 6943 656c 6c2c  )%dataSim(iCell,
+000131f0: 203a 292c 2026 0a20 2020 2020 2020 2020   :), &.         
+00013200: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013210: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013220: 2020 2020 2020 2020 2020 6d61 736b 203d            mask =
+00013230: 204c 315f 6574 4f62 7328 6944 6f6d 6169   L1_etObs(iDomai
+00013240: 6e29 256d 6173 6b4f 6273 2869 4365 6c6c  n)%maskObs(iCell
+00013250: 2c20 3a29 290a 2020 2020 2020 656e 6420  , :)).      end 
+00013260: 646f 0a0a 2020 2020 2020 2120 7573 6572  do..      ! user
+00013270: 2069 6e66 6f72 6d61 7469 6f6e 2061 626f   information abo
+00013280: 7574 2069 6e76 616c 6964 2063 656c 6c73  ut invalid cells
+00013290: 0a20 2020 2020 2069 6620 2869 6e76 616c  .      if (inval
+000132a0: 6964 5f63 656c 6c73 202e 4754 2e20 302e  id_cells .GT. 0.
+000132b0: 355f 6470 2920 7468 656e 0a20 2020 2020  5_dp) then.     
+000132c0: 2020 2063 616c 6c20 6d65 7373 6167 6528     call message(
+000132d0: 2720 2020 5741 524e 494e 473a 206f 626a  '   WARNING: obj
+000132e0: 6563 7469 7665 5f65 743a 2044 6574 6563  ective_et: Detec
+000132f0: 7465 6420 696e 7661 6c69 6420 6365 6c6c  ted invalid cell
+00013300: 7320 696e 2073 7475 6479 2061 7265 6120  s in study area 
+00013310: 282e 4c54 2e20 3130 2076 616c 6964 2064  (.LT. 10 valid d
+00013320: 6174 6120 706f 696e 7473 292e 2729 0a20  ata points).'). 
+00013330: 2020 2020 2020 2063 616c 6c20 6d65 7373         call mess
+00013340: 6167 6528 2720 2020 2020 2020 2020 2020  age('           
+00013350: 2020 2020 2020 2020 2020 2020 2020 2046                 F
+00013360: 7261 6374 696f 6e20 6f66 2069 6e76 616c  raction of inval
+00013370: 6964 2063 656c 6c73 3a20 272c 2026 0a20  id cells: ', &. 
+00013380: 2020 2020 2020 2020 2020 2020 2020 206e                 n
+00013390: 756d 3273 7472 2869 6e76 616c 6964 5f63  um2str(invalid_c
+000133a0: 656c 6c73 202f 2072 6561 6c28 6e43 656c  ells / real(nCel
+000133b0: 6c73 312c 2064 7029 2c20 2728 4634 2e32  ls1, dp), '(F4.2
+000133c0: 2927 2929 0a20 2020 2020 2065 6e64 2069  )')).      end i
+000133d0: 660a 0a20 2020 2020 2021 2063 616c 6375  f..      ! calcu
+000133e0: 6c61 7465 2061 7665 7261 6765 2073 6f69  late average soi
+000133f0: 6c20 6d6f 6973 7475 7265 206f 626a 6563  l moisture objec
+00013400: 7469 7665 206f 7665 7220 616c 6c20 646f  tive over all do
+00013410: 6d61 696e 7320 7769 7468 2070 6f77 6572  mains with power
+00013420: 206c 6177 0a20 2020 2020 2021 2064 6f6d   law.      ! dom
+00013430: 6169 6e73 2061 7265 2077 6569 6768 7465  ains are weighte
+00013440: 6420 6571 7561 6c6c 7920 2820 3120 2f20  d equally ( 1 / 
+00013450: 7265 616c 2864 6f6d 6169 6e4d 6574 6125  real(domainMeta%
+00013460: 6f76 6572 616c 6c4e 756d 6265 724f 6644  overallNumberOfD
+00013470: 6f6d 6169 6e73 2c64 7029 292a 2a36 0a20  omains,dp))**6. 
+00013480: 2020 2020 206f 626a 6563 7469 7665 5f65       objective_e
+00013490: 7420 3d20 6f62 6a65 6374 6976 655f 6574  t = objective_et
+000134a0: 202b 2026 0a20 2020 2020 2020 2020 2020   + &.           
+000134b0: 2020 2028 2831 2e30 5f64 7020 2d20 6f62     ((1.0_dp - ob
+000134c0: 6a65 6374 6976 655f 6574 5f64 6f6d 6169  jective_et_domai
+000134d0: 6e20 2f20 7265 616c 286e 4365 6c6c 7331  n / real(nCells1
+000134e0: 2c20 6470 2929 202f 2072 6561 6c28 646f  , dp)) / real(do
+000134f0: 6d61 696e 4d65 7461 256f 7665 7261 6c6c  mainMeta%overall
+00013500: 4e75 6d62 6572 4f66 446f 6d61 696e 732c  NumberOfDomains,
+00013510: 2064 7029 292a 2a36 0a20 2020 2020 2063   dp))**6.      c
+00013520: 616c 6c20 6574 4f70 7469 5369 6d28 6944  all etOptiSim(iD
+00013530: 6f6d 6169 6e29 2564 6573 7472 6f79 2829  omain)%destroy()
+00013540: 0a20 2020 2065 6e64 2064 6f0a 2020 2020  .    end do.    
+00013550: 6465 616c 6c6f 6361 7465 2865 744f 7074  deallocate(etOpt
+00013560: 6953 696d 290a 0a20 2020 2021 2063 6f6d  iSim)..    ! com
+00013570: 7072 6f6d 6973 6520 736f 6c75 7469 6f6e  promise solution
+00013580: 202d 2073 6978 7468 2072 6f6f 740a 2020   - sixth root.  
+00013590: 2020 6f62 6a65 6374 6976 655f 6574 203d    objective_et =
+000135a0: 206f 626a 6563 7469 7665 5f65 742a 2a6f   objective_et**o
+000135b0: 6e65 7369 7874 680a 0a20 2020 2021 202d  nesixth..    ! -
+000135c0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000135d0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2020  ------------.   
+000135e0: 2021 2052 554e 4f46 460a 2020 2020 2120   ! RUNOFF.    ! 
+000135f0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00013600: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 2020  -------------.  
+00013610: 2020 6f62 6a65 6374 6976 655f 7120 3d20    objective_q = 
+00013620: 302e 305f 6470 0a20 2020 206e 4761 7567  0.0_dp.    nGaug
+00013630: 6573 546f 7461 6c20 3d20 7369 7a65 2872  esTotal = size(r
+00013640: 756e 6f66 662c 2064 696d 203d 2032 290a  unoff, dim = 2).
+00013650: 0a20 2020 2064 6f20 6767 203d 2031 2c20  .    do gg = 1, 
+00013660: 6e47 6175 6765 7354 6f74 616c 0a0a 2020  nGaugesTotal..  
+00013670: 2020 2020 2120 6578 7472 6163 7420 7275      ! extract ru
+00013680: 6e6f 6666 0a20 2020 2020 2063 616c 6c20  noff.      call 
+00013690: 6578 7472 6163 745f 7275 6e6f 6666 2867  extract_runoff(g
+000136a0: 672c 2072 756e 6f66 662c 2072 756e 6f66  g, runoff, runof
+000136b0: 665f 6167 672c 2072 756e 6f66 665f 6f62  f_agg, runoff_ob
+000136c0: 732c 2072 756e 6f66 665f 6f62 735f 6d61  s, runoff_obs_ma
+000136d0: 736b 290a 0a20 2020 2020 2021 204b 4745  sk)..      ! KGE
+000136e0: 0a20 2020 2020 206f 626a 6563 7469 7665  .      objective
+000136f0: 5f71 203d 206f 626a 6563 7469 7665 5f71  _q = objective_q
+00013700: 202b 2026 0a20 2020 2020 2020 2020 2020   + &.           
+00013710: 2020 2028 2831 2e30 5f64 7020 2d20 6b67     ((1.0_dp - kg
+00013720: 6528 7275 6e6f 6666 5f6f 6273 2c20 7275  e(runoff_obs, ru
+00013730: 6e6f 6666 5f61 6767 2c20 6d61 736b 203d  noff_agg, mask =
+00013740: 2072 756e 6f66 665f 6f62 735f 6d61 736b   runoff_obs_mask
+00013750: 2929 202f 2072 6561 6c28 6e47 6175 6765  )) / real(nGauge
+00013760: 7354 6f74 616c 2c20 6470 2929 2a2a 360a  sTotal, dp))**6.
+00013770: 0a20 2020 2065 6e64 2064 6f0a 0a20 2020  .    end do..   
+00013780: 2064 6561 6c6c 6f63 6174 6528 7275 6e6f   deallocate(runo
+00013790: 6666 5f61 6767 2c20 7275 6e6f 6666 5f6f  ff_agg, runoff_o
+000137a0: 6273 2c20 7275 6e6f 6666 5f6f 6273 5f6d  bs, runoff_obs_m
+000137b0: 6173 6b29 0a0a 2020 2020 2120 636f 6d70  ask)..    ! comp
+000137c0: 726f 6d69 7365 2073 6f6c 7574 696f 6e20  romise solution 
+000137d0: 2d20 7369 7874 6820 726f 6f74 0a20 2020  - sixth root.   
+000137e0: 206f 626a 6563 7469 7665 5f71 203d 206f   objective_q = o
+000137f0: 626a 6563 7469 7665 5f71 2a2a 6f6e 6573  bjective_q**ones
+00013800: 6978 7468 0a0a 2020 2020 2120 6571 7561  ixth..    ! equa
+00013810: 6c20 7765 6967 6874 6564 2063 6f6d 7072  l weighted compr
+00013820: 6f6d 6973 6520 6f62 6a65 6374 6976 6520  omise objective 
+00013830: 6675 6e63 7469 6f6e 7320 666f 7220 6469  functions for di
+00013840: 7363 6861 7267 6520 616e 6420 736f 696c  scharge and soil
+00013850: 6d6f 6973 7475 7265 0a20 2020 2021 2054  moisture.    ! T
+00013860: 6f44 6f3a 2077 6879 2064 6f20 7765 2075  oDo: why do we u
+00013870: 7365 2074 6865 2073 6978 7468 2072 6f6f  se the sixth roo
+00013880: 7420 6f66 206f 6620 6f62 6a65 6374 6976  t of of objectiv
+00013890: 655f 736d 2061 6e64 206f 626a 6563 7469  e_sm and objecti
+000138a0: 7665 5f6b 6765 0a20 2020 2021 206f 6e6c  ve_kge.    ! onl
+000138b0: 7920 746f 2074 616b 6520 7468 6520 706f  y to take the po
+000138c0: 7765 7220 746f 2036 2068 6572 6520 6167  wer to 6 here ag
+000138d0: 6169 6e2c 2077 6865 6e20 7765 206e 6576  ain, when we nev
+000138e0: 6572 206e 6565 6420 7468 650a 2020 2020  er need the.    
+000138f0: 2120 696e 7465 726d 6564 6961 7465 2072  ! intermediate r
+00013900: 6573 756c 7473 3f0a 2369 6664 6566 204d  esults?.#ifdef M
+00013910: 5049 0a20 2020 206f 626a 6563 7469 7665  PI.    objective
+00013920: 5f6b 6765 5f71 5f65 7420 3d20 286f 626a  _kge_q_et = (obj
+00013930: 6563 7469 7665 5f65 742a 2a36 202b 206f  ective_et**6 + o
+00013940: 626a 6563 7469 7665 5f71 2a2a 3629 0a23  bjective_q**6).#
+00013950: 656c 7365 0a20 2020 206f 626a 6563 7469  else.    objecti
+00013960: 7665 5f6b 6765 5f71 5f65 7420 3d20 286f  ve_kge_q_et = (o
+00013970: 626a 6563 7469 7665 5f65 742a 2a36 202b  bjective_et**6 +
+00013980: 206f 626a 6563 7469 7665 5f71 2a2a 3629   objective_q**6)
+00013990: 2a2a 6f6e 6573 6978 7468 0a0a 2020 2020  **onesixth..    
+000139a0: 6361 6c6c 206d 6573 7361 6765 2827 2020  call message('  
+000139b0: 2020 6f62 6a65 6374 6976 655f 6b67 655f    objective_kge_
+000139c0: 715f 6574 203d 2027 2c20 6e75 6d32 7374  q_et = ', num2st
+000139d0: 7228 6f62 6a65 6374 6976 655f 6b67 655f  r(objective_kge_
+000139e0: 715f 6574 2c20 2728 4639 2e35 2927 2929  q_et, '(F9.5)'))
+000139f0: 0a23 656e 6469 660a 2020 2020 2120 2020  .#endif.    !   
+00013a00: 2070 7269 6e74 2a2c 2022 312d 534d 2032   print*, "1-SM 2
+00013a10: 2d51 203a 2022 2c20 312e 305f 6470 2d6f  -Q : ", 1.0_dp-o
+00013a20: 626a 6563 7469 7665 5f73 6d2c 2031 2e30  bjective_sm, 1.0
+00013a30: 5f64 702d 6f62 6a65 6374 6976 655f 6b67  _dp-objective_kg
+00013a40: 6520 2120 4d5a 4d5a 4d5a 4d5a 0a0a 2020  e ! MZMZMZMZ..  
+00013a50: 454e 4420 4655 4e43 5449 4f4e 206f 626a  END FUNCTION obj
+00013a60: 6563 7469 7665 5f6b 6765 5f71 5f65 740a  ective_kge_q_et.
+00013a70: 0a0a 2020 2120 2d2d 2d2d 2d2d 2d2d 2d2d  ..  ! ----------
+00013a80: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00013a90: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00013aa0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00013ab0: 2d2d 2d2d 2d2d 2d0a 0a20 2021 2020 2020  -------..  !    
+00013ac0: 4e41 4d45 0a20 2021 2020 2020 2020 2020  NAME.  !        
+00013ad0: 6f62 6a65 6374 6976 655f 6b67 655f 715f  objective_kge_q_
+00013ae0: 4246 490a 0a20 2021 2020 2020 5055 5250  BFI..  !    PURP
+00013af0: 4f53 450a 2020 213e 2020 2020 2020 205c  OSE.  !>       \
+00013b00: 6272 6965 6620 4f62 6a65 6374 6976 6520  brief Objective 
+00013b10: 6675 6e63 7469 6f6e 206f 6620 4b47 4520  function of KGE 
+00013b20: 666f 7220 7275 6e6f 6666 2061 6e64 2042  for runoff and B
+00013b30: 4649 2061 6273 756c 7574 6520 6469 6666  FI absulute diff
+00013b40: 6572 656e 6365 0a0a 2020 213e 2020 2020  erence..  !>    
+00013b50: 2020 205c 6465 7461 696c 7320 4f62 6a65     \details Obje
+00013b60: 6374 6976 6520 6675 6e63 7469 6f6e 206f  ctive function o
+00013b70: 6620 4b47 4520 666f 7220 7275 6e6f 6666  f KGE for runoff
+00013b80: 2061 6e64 204b 4745 2066 6f72 2045 542e   and KGE for ET.
+00013b90: 0a20 2021 3e20 2020 2020 2020 4675 7274  .  !>       Furt
+00013ba0: 6865 7220 6465 7461 696c 7320 6361 6e20  her details can 
+00013bb0: 6265 2066 6f75 6e64 2069 6e20 7468 6520  be found in the 
+00013bc0: 646f 6375 6d65 6e74 6174 696f 6e20 6f66  documentation of
+00013bd0: 206f 626a 6563 7469 7665 2066 756e 6374   objective funct
+00013be0: 696f 6e73 0a20 2021 3e20 2020 2020 2020  ions.  !>       
+00013bf0: 2731 3420 2d20 6f62 6a65 6374 6976 655f  '14 - objective_
+00013c00: 6d75 6c74 6970 6c65 5f67 6175 6765 735f  multiple_gauges_
+00013c10: 6b67 655f 706f 7765 7236 272e 0a0a 2020  kge_power6'...  
+00013c20: 2120 2020 2049 4e54 454e 5428 494e 290a  !    INTENT(IN).
+00013c30: 2020 213e 2020 2020 2020 205c 7061 7261    !>       \para
+00013c40: 6d5b 696e 5d20 2272 6561 6c28 6470 292c  m[in] "real(dp),
+00013c50: 2064 696d 656e 7369 6f6e 283a 2920 3a3a   dimension(:) ::
+00013c60: 2070 6172 616d 6574 6572 7365 7422 0a20   parameterset". 
+00013c70: 2021 3e20 2020 2020 2020 5c70 6172 616d   !>       \param
+00013c80: 5b69 6e5d 2022 7072 6f63 6564 7572 6528  [in] "procedure(
+00013c90: 6576 616c 5f69 6e74 6572 6661 6365 2920  eval_interface) 
+00013ca0: 3a3a 2065 7661 6c22 0a0a 2020 2120 2020  :: eval"..  !   
+00013cb0: 2052 4554 5552 4e0a 2020 213e 2020 2020   RETURN.  !>    
+00013cc0: 2020 205c 7265 7475 726e 2072 6561 6c28     \return real(
+00013cd0: 6470 2920 3a3a 206f 626a 6563 7469 7665  dp) :: objective
+00013ce0: 5f6b 6765 5f71 5f42 4649 2026 6d64 6173  _kge_q_BFI &mdas
+00013cf0: 683b 206f 626a 6563 7469 7665 2066 756e  h; objective fun
+00013d00: 6374 696f 6e20 7661 6c75 650a 2020 213e  ction value.  !>
+00013d10: 2020 2020 2020 2028 7768 6963 6820 7769         (which wi
+00013d20: 6c6c 2062 6520 652e 672e 206d 696e 696d  ll be e.g. minim
+00013d30: 697a 6564 2062 7920 616e 206f 7074 696d  ized by an optim
+00013d40: 697a 6174 696f 6e20 726f 7574 696e 6520  ization routine 
+00013d50: 6c69 6b65 2044 4453 290a 0a20 2021 2020  like DDS)..  !  
+00013d60: 2020 4849 5354 4f52 590a 2020 213e 2020    HISTORY.  !>  
+00013d70: 2020 2020 205c 6175 7468 6f72 7320 5365       \authors Se
+00013d80: 6261 7374 6961 6e20 4dc3 bc6c 6c65 720a  bastian M..ller.
+00013d90: 0a20 2021 3e20 2020 2020 2020 5c64 6174  .  !>       \dat
+00013da0: 6520 4170 7220 3230 3232 0a0a 2020 4655  e Apr 2022..  FU
+00013db0: 4e43 5449 4f4e 206f 626a 6563 7469 7665  NCTION objective
+00013dc0: 5f6b 6765 5f71 5f42 4649 2870 6172 616d  _kge_q_BFI(param
+00013dd0: 6574 6572 7365 742c 2065 7661 6c29 0a0a  eterset, eval)..
+00013de0: 2020 2020 7573 6520 6d6f 5f6f 7074 696d      use mo_optim
+00013df0: 697a 6174 696f 6e5f 7479 7065 732c 206f  ization_types, o
+00013e00: 6e6c 7920 3a20 6f70 7469 6461 7461 5f73  nly : optidata_s
+00013e10: 696d 0a20 2020 2075 7365 206d 6f5f 636f  im.    use mo_co
+00013e20: 6d6d 6f6e 5f76 6172 6961 626c 6573 2c20  mmon_variables, 
+00013e30: 6f6e 6c79 203a 206c 6576 656c 312c 2064  only : level1, d
+00013e40: 6f6d 6169 6e4d 6574 610a 2020 2020 7573  omainMeta.    us
+00013e50: 6520 6d6f 5f65 7272 6f72 6d65 6173 7572  e mo_errormeasur
+00013e60: 6573 2c20 6f6e 6c79 203a 206b 6765 0a20  es, only : kge. 
+00013e70: 2020 2075 7365 206d 6f5f 676c 6f62 616c     use mo_global
+00013e80: 5f76 6172 6961 626c 6573 2c20 6f6e 6c79  _variables, only
+00013e90: 203a 2042 4649 5f6f 6273 0a20 2020 2075   : BFI_obs.    u
+00013ea0: 7365 206d 6f5f 7374 7269 6e67 5f75 7469  se mo_string_uti
+00013eb0: 6c73 2c20 6f6e 6c79 203a 206e 756d 3273  ls, only : num2s
+00013ec0: 7472 0a20 2020 2075 7365 206d 6f5f 6d72  tr.    use mo_mr
+00013ed0: 6d5f 6f62 6a65 6374 6976 655f 6675 6e63  m_objective_func
+00013ee0: 7469 6f6e 5f72 756e 6f66 662c 206f 6e6c  tion_runoff, onl
+00013ef0: 7920 3a20 6578 7472 6163 745f 7275 6e6f  y : extract_runo
+00013f00: 6666 0a0a 2020 2020 696d 706c 6963 6974  ff..    implicit
+00013f10: 206e 6f6e 650a 0a20 2020 2072 6561 6c28   none..    real(
+00013f20: 6470 292c 2064 696d 656e 7369 6f6e 283a  dp), dimension(:
+00013f30: 292c 2069 6e74 656e 7428 696e 2920 3a3a  ), intent(in) ::
+00013f40: 2070 6172 616d 6574 6572 7365 740a 0a20   parameterset.. 
+00013f50: 2020 2070 726f 6365 6475 7265 2865 7661     procedure(eva
+00013f60: 6c5f 696e 7465 7266 6163 6529 2c20 494e  l_interface), IN
+00013f70: 5445 4e54 2849 4e29 2c20 504f 494e 5445  TENT(IN), POINTE
+00013f80: 5220 3a3a 2065 7661 6c0a 0a20 2020 2072  R :: eval..    r
+00013f90: 6561 6c28 6470 2920 3a3a 206f 626a 6563  eal(dp) :: objec
+00013fa0: 7469 7665 5f6b 6765 5f71 5f42 4649 0a20  tive_kge_q_BFI. 
+00013fb0: 2020 2072 6561 6c28 6470 2920 3a3a 206f     real(dp) :: o
+00013fc0: 626a 6563 7469 7665 5f42 4649 0a20 2020  bjective_BFI.   
+00013fd0: 2072 6561 6c28 6470 2920 3a3a 206f 626a   real(dp) :: obj
+00013fe0: 6563 7469 7665 5f71 0a0a 2020 2020 7265  ective_q..    re
+00013ff0: 616c 2864 7029 2c20 7061 7261 6d65 7465  al(dp), paramete
+00014000: 7220 3a3a 206f 6e65 7369 7874 6820 3d20  r :: onesixth = 
+00014010: 312e 305f 6470 202f 2036 2e30 5f64 700a  1.0_dp / 6.0_dp.
+00014020: 0a20 2020 2021 206e 756d 6265 7220 6f66  .    ! number of
+00014030: 2069 6e76 616c 6964 2063 656c 6c73 2069   invalid cells i
+00014040: 6e20 6361 7463 686d 656e 740a 2020 2020  n catchment.    
+00014050: 7265 616c 2864 7029 203a 3a20 696e 7661  real(dp) :: inva
+00014060: 6c69 645f 6365 6c6c 730a 0a20 2020 2021  lid_cells..    !
+00014070: 206d 6f64 656c 6c65 6420 7275 6e6f 6666   modelled runoff
+00014080: 2066 6f72 2061 2067 6976 656e 2070 6172   for a given par
+00014090: 616d 6574 6572 2073 6574 0a20 2020 2021  ameter set.    !
+000140a0: 2064 696d 313d 6e54 696d 6553 7465 7073   dim1=nTimeSteps
+000140b0: 2c20 6469 6d32 3d6e 4761 7567 6573 0a20  , dim2=nGauges. 
+000140c0: 2020 2072 6561 6c28 6470 292c 2061 6c6c     real(dp), all
+000140d0: 6f63 6174 6162 6c65 2c20 6469 6d65 6e73  ocatable, dimens
+000140e0: 696f 6e28 3a2c 203a 2920 3a3a 2072 756e  ion(:, :) :: run
+000140f0: 6f66 660a 0a20 2020 2021 2064 6f6d 6169  off..    ! domai
+00014100: 6e20 6c6f 6f70 2063 6f75 6e74 6572 0a20  n loop counter. 
+00014110: 2020 2069 6e74 6567 6572 2869 3429 203a     integer(i4) :
+00014120: 3a20 6944 6f6d 6169 6e0a 0a20 2020 2021  : iDomain..    !
+00014130: 3e20 6261 7365 666c 6f77 2069 6e64 6578  > baseflow index
+00014140: 2066 6f72 2065 6163 6820 646f 6d61 696e   for each domain
+00014150: 0a20 2020 2072 6561 6c28 6470 292c 2064  .    real(dp), d
+00014160: 696d 656e 7369 6f6e 283a 292c 2061 6c6c  imension(:), all
+00014170: 6f63 6174 6162 6c65 203a 3a20 4246 490a  ocatable :: BFI.
+00014180: 0a20 2020 2021 2063 6f75 6e74 6572 0a20  .    ! counter. 
+00014190: 2020 2069 6e74 6567 6572 2869 3429 203a     integer(i4) :
+000141a0: 3a20 6767 2c20 690a 0a20 2020 2069 6e74  : gg, i..    int
+000141b0: 6567 6572 2869 3429 203a 3a20 6e47 6175  eger(i4) :: nGau
+000141c0: 6765 7354 6f74 616c 0a0a 2020 2020 2120  gesTotal..    ! 
+000141d0: 6167 6772 6567 6174 6564 2073 696d 756c  aggregated simul
+000141e0: 6174 6564 2072 756e 6f66 660a 2020 2020  ated runoff.    
+000141f0: 696e 7465 6765 7228 6934 292c 2064 696d  integer(i4), dim
+00014200: 656e 7369 6f6e 283a 292c 2061 6c6c 6f63  ension(:), alloc
+00014210: 6174 6162 6c65 203a 3a20 646f 6d61 696e  atable :: domain
+00014220: 5f69 6473 2c20 646f 6d61 696e 5f69 6473  _ids, domain_ids
+00014230: 5f70 6163 6b0a 0a20 2020 2021 2061 6767  _pack..    ! agg
+00014240: 7265 6761 7465 6420 7369 6d75 6c61 7465  regated simulate
+00014250: 6420 7275 6e6f 6666 0a20 2020 2072 6561  d runoff.    rea
+00014260: 6c28 6470 292c 2064 696d 656e 7369 6f6e  l(dp), dimension
+00014270: 283a 292c 2061 6c6c 6f63 6174 6162 6c65  (:), allocatable
+00014280: 203a 3a20 7275 6e6f 6666 5f61 6767 0a0a   :: runoff_agg..
+00014290: 2020 2020 2120 6d65 6173 7572 6564 2072      ! measured r
+000142a0: 756e 6f66 660a 2020 2020 7265 616c 2864  unoff.    real(d
+000142b0: 7029 2c20 6469 6d65 6e73 696f 6e28 3a29  p), dimension(:)
+000142c0: 2c20 616c 6c6f 6361 7461 626c 6520 3a3a  , allocatable ::
+000142d0: 2072 756e 6f66 665f 6f62 730a 0a20 2020   runoff_obs..   
+000142e0: 2021 206d 6173 6b20 666f 7220 6d65 6173   ! mask for meas
+000142f0: 7572 6564 2072 756e 6f66 660a 2020 2020  ured runoff.    
+00014300: 6c6f 6769 6361 6c2c 2064 696d 656e 7369  logical, dimensi
+00014310: 6f6e 283a 292c 2061 6c6c 6f63 6174 6162  on(:), allocatab
+00014320: 6c65 203a 3a20 7275 6e6f 6666 5f6f 6273  le :: runoff_obs
+00014330: 5f6d 6173 6b0a 0a20 2020 2021 2072 756e  _mask..    ! run
+00014340: 206d 484d 0a20 2020 2061 6c6c 6f63 6174   mHM.    allocat
+00014350: 6528 4246 4928 646f 6d61 696e 4d65 7461  e(BFI(domainMeta
+00014360: 256e 446f 6d61 696e 7329 290a 2020 2020  %nDomains)).    
+00014370: 6361 6c6c 2065 7661 6c28 7061 7261 6d65  call eval(parame
+00014380: 7465 7273 6574 2c20 7275 6e6f 6666 203d  terset, runoff =
+00014390: 2072 756e 6f66 662c 2042 4649 203d 2042   runoff, BFI = B
+000143a0: 4649 290a 0a20 2020 2021 202d 2d2d 2d2d  FI)..    ! -----
+000143b0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000143c0: 2d2d 2d2d 2d2d 2d2d 0a20 2020 2021 2042  --------.    ! B
+000143d0: 4649 0a20 2020 2021 202d 2d2d 2d2d 2d2d  FI.    ! -------
+000143e0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000143f0: 2d2d 2d2d 2d2d 0a0a 2020 2020 2120 696e  ------..    ! in
+00014400: 6974 6961 6c69 7a65 2073 6f6d 6520 7661  itialize some va
+00014410: 7269 6162 6c65 730a 2020 2020 6f62 6a65  riables.    obje
+00014420: 6374 6976 655f 4246 4920 3d20 302e 305f  ctive_BFI = 0.0_
+00014430: 6470 0a0a 2020 2020 6966 2028 2061 6e79  dp..    if ( any
+00014440: 2842 4649 5f6f 6273 203c 2030 2e30 5f64  (BFI_obs < 0.0_d
+00014450: 7029 2029 2074 6865 6e0a 2020 2020 2020  p) ) then.      
+00014460: 616c 6c6f 6361 7465 2864 6f6d 6169 6e5f  allocate(domain_
+00014470: 6964 7328 646f 6d61 696e 4d65 7461 256e  ids(domainMeta%n
+00014480: 446f 6d61 696e 7329 290a 2020 2020 2020  Domains)).      
+00014490: 616c 6c6f 6361 7465 2864 6f6d 6169 6e5f  allocate(domain_
+000144a0: 6964 735f 7061 636b 2863 6f75 6e74 2842  ids_pack(count(B
+000144b0: 4649 5f6f 6273 203c 2030 2e30 5f64 7029  FI_obs < 0.0_dp)
+000144c0: 2929 0a20 2020 2020 2064 6f6d 6169 6e5f  )).      domain_
+000144d0: 6964 7320 3d20 5b28 692c 2069 3d31 2c73  ids = [(i, i=1,s
+000144e0: 697a 6528 646f 6d61 696e 5f69 6473 2929  ize(domain_ids))
+000144f0: 5d0a 2020 2020 2020 646f 6d61 696e 5f69  ].      domain_i
+00014500: 6473 5f70 6163 6b20 3d20 7061 636b 2864  ds_pack = pack(d
+00014510: 6f6d 6169 6e5f 6964 732c 206d 6173 6b3d  omain_ids, mask=
+00014520: 2842 4649 5f6f 6273 203c 2030 2e30 5f64  (BFI_obs < 0.0_d
+00014530: 7029 290a 2020 2020 2020 6361 6c6c 2065  p)).      call e
+00014540: 7272 6f72 5f6d 6573 7361 6765 2820 260a  rror_message( &.
+00014550: 2020 2020 2020 2020 226f 626a 6563 7469          "objecti
+00014560: 7665 5f6b 6765 5f71 5f42 4649 3a20 6d69  ve_kge_q_BFI: mi
+00014570: 7373 696e 6720 4246 4920 7661 6c75 6573  ssing BFI values
+00014580: 2066 6f72 2064 6f6d 6169 6e20 222c 2026   for domain ", &
+00014590: 0a20 2020 2020 2020 2074 7269 6d28 6164  .        trim(ad
+000145a0: 6a75 7374 6c28 6e75 6d32 7374 7228 646f  justl(num2str(do
+000145b0: 6d61 696e 5f69 6473 5f70 6163 6b28 3129  main_ids_pack(1)
+000145c0: 2929 2920 260a 2020 2020 2020 290a 2020  ))) &.      ).  
+000145d0: 2020 656e 6420 6966 0a0a 2020 2020 2120    end if..    ! 
+000145e0: 6c6f 6f70 206f 7665 7220 646f 6d61 696e  loop over domain
+000145f0: 202d 2066 6f72 2061 7070 6c79 696e 6720   - for applying 
+00014600: 706f 7765 7220 6c61 7720 6c61 7465 7220  power law later 
+00014610: 6f6e 0a20 2020 2064 6f20 6944 6f6d 6169  on.    do iDomai
+00014620: 6e20 3d20 312c 2064 6f6d 6169 6e4d 6574  n = 1, domainMet
+00014630: 6125 6e44 6f6d 6169 6e73 0a20 2020 2020  a%nDomains.     
+00014640: 206f 626a 6563 7469 7665 5f42 4649 203d   objective_BFI =
+00014650: 206f 626a 6563 7469 7665 5f42 4649 202b   objective_BFI +
+00014660: 2061 6273 2842 4649 2869 446f 6d61 696e   abs(BFI(iDomain
+00014670: 2920 2d20 4246 495f 6f62 7328 6944 6f6d  ) - BFI_obs(iDom
+00014680: 6169 6e29 2920 2f20 646f 6d61 696e 4d65  ain)) / domainMe
+00014690: 7461 256e 446f 6d61 696e 730a 2020 2020  ta%nDomains.    
+000146a0: 656e 6420 646f 0a0a 2020 2020 2120 2d2d  end do..    ! --
+000146b0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000146c0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020  -----------.    
+000146d0: 2120 5255 4e4f 4646 0a20 2020 2021 202d  ! RUNOFF.    ! -
+000146e0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000146f0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2020  ------------.   
+00014700: 206f 626a 6563 7469 7665 5f71 203d 2030   objective_q = 0
+00014710: 2e30 5f64 700a 2020 2020 6e47 6175 6765  .0_dp.    nGauge
+00014720: 7354 6f74 616c 203d 2073 697a 6528 7275  sTotal = size(ru
+00014730: 6e6f 6666 2c20 6469 6d20 3d20 3229 0a0a  noff, dim = 2)..
+00014740: 2020 2020 646f 2067 6720 3d20 312c 206e      do gg = 1, n
+00014750: 4761 7567 6573 546f 7461 6c0a 0a20 2020  GaugesTotal..   
+00014760: 2020 2021 2065 7874 7261 6374 2072 756e     ! extract run
+00014770: 6f66 660a 2020 2020 2020 6361 6c6c 2065  off.      call e
+00014780: 7874 7261 6374 5f72 756e 6f66 6628 6767  xtract_runoff(gg
+00014790: 2c20 7275 6e6f 6666 2c20 7275 6e6f 6666  , runoff, runoff
+000147a0: 5f61 6767 2c20 7275 6e6f 6666 5f6f 6273  _agg, runoff_obs
+000147b0: 2c20 7275 6e6f 6666 5f6f 6273 5f6d 6173  , runoff_obs_mas
+000147c0: 6b29 0a0a 2020 2020 2020 2120 4b47 450a  k)..      ! KGE.
+000147d0: 2020 2020 2020 6f62 6a65 6374 6976 655f        objective_
+000147e0: 7120 3d20 6f62 6a65 6374 6976 655f 7120  q = objective_q 
+000147f0: 2b20 260a 2020 2020 2020 2020 2020 2020  + &.            
+00014800: 2020 2828 312e 305f 6470 202d 206b 6765    ((1.0_dp - kge
+00014810: 2872 756e 6f66 665f 6f62 732c 2072 756e  (runoff_obs, run
+00014820: 6f66 665f 6167 672c 206d 6173 6b20 3d20  off_agg, mask = 
+00014830: 7275 6e6f 6666 5f6f 6273 5f6d 6173 6b29  runoff_obs_mask)
+00014840: 2920 2f20 7265 616c 286e 4761 7567 6573  ) / real(nGauges
+00014850: 546f 7461 6c2c 2064 7029 292a 2a36 0a0a  Total, dp))**6..
+00014860: 2020 2020 656e 6420 646f 0a0a 2020 2020      end do..    
+00014870: 6465 616c 6c6f 6361 7465 2872 756e 6f66  deallocate(runof
+00014880: 665f 6167 672c 2072 756e 6f66 665f 6f62  f_agg, runoff_ob
+00014890: 732c 2072 756e 6f66 665f 6f62 735f 6d61  s, runoff_obs_ma
+000148a0: 736b 290a 0a20 2020 2021 2063 6f6d 7072  sk)..    ! compr
+000148b0: 6f6d 6973 6520 736f 6c75 7469 6f6e 202d  omise solution -
+000148c0: 2073 6978 7468 2072 6f6f 740a 2020 2020   sixth root.    
+000148d0: 6f62 6a65 6374 6976 655f 7120 3d20 6f62  objective_q = ob
+000148e0: 6a65 6374 6976 655f 712a 2a6f 6e65 7369  jective_q**onesi
+000148f0: 7874 680a 0a20 2020 206f 626a 6563 7469  xth..    objecti
+00014900: 7665 5f6b 6765 5f71 5f42 4649 203d 2028  ve_kge_q_BFI = (
+00014910: 6f62 6a65 6374 6976 655f 4246 4920 2b20  objective_BFI + 
+00014920: 312e 5f64 7029 2a6f 626a 6563 7469 7665  1._dp)*objective
+00014930: 5f71 0a20 2020 2063 616c 6c20 6d65 7373  _q.    call mess
+00014940: 6167 6528 2720 2020 206f 626a 6563 7469  age('    objecti
+00014950: 7665 5f6b 6765 5f71 5f42 4649 203d 2027  ve_kge_q_BFI = '
+00014960: 2c20 6e75 6d32 7374 7228 6f62 6a65 6374  , num2str(object
+00014970: 6976 655f 6b67 655f 715f 4246 492c 2027  ive_kge_q_BFI, '
+00014980: 2846 392e 3529 2729 290a 0a20 2045 4e44  (F9.5)'))..  END
+00014990: 2046 554e 4354 494f 4e20 6f62 6a65 6374   FUNCTION object
+000149a0: 6976 655f 6b67 655f 715f 4246 490a 0a0a  ive_kge_q_BFI...
+000149b0: 2020 2120 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d    ! ------------
+000149c0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000149d0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000149e0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000149f0: 2d2d 2d2d 2d0a 0a20 2021 2020 2020 4e41  -----..  !    NA
+00014a00: 4d45 0a20 2021 2020 2020 2020 2020 6f62  ME.  !        ob
+00014a10: 6a65 6374 6976 655f 6b67 655f 715f 726d  jective_kge_q_rm
+00014a20: 7365 5f65 740a 0a20 2021 2020 2020 5055  se_et..  !    PU
+00014a30: 5250 4f53 450a 2020 213e 2020 2020 2020  RPOSE.  !>      
+00014a40: 205c 6272 6965 6620 4f62 6a65 6374 6976   \brief Objectiv
+00014a50: 6520 6675 6e63 7469 6f6e 206f 6620 4b47  e function of KG
+00014a60: 4520 666f 7220 7275 6e6f 6666 2061 6e64  E for runoff and
+00014a70: 2052 4d53 4520 666f 7220 646f 6d61 696e   RMSE for domain
+00014a80: 5f61 7667 2045 5420 2873 7461 6e64 6172  _avg ET (standar
+00014a90: 697a 6564 2073 636f 7265 7329 0a0a 2020  ized scores)..  
+00014aa0: 213e 2020 2020 2020 205c 6465 7461 696c  !>       \detail
+00014ab0: 7320 4f62 6a65 6374 6976 6520 6675 6e63  s Objective func
+00014ac0: 7469 6f6e 206f 6620 4b47 4520 666f 7220  tion of KGE for 
+00014ad0: 7275 6e6f 6666 2061 6e64 2052 4d53 4520  runoff and RMSE 
+00014ae0: 666f 7220 646f 6d61 696e 5f61 7667 2045  for domain_avg E
+00014af0: 5420 2873 7461 6e64 6172 697a 6564 2073  T (standarized s
+00014b00: 636f 7265 7329 0a0a 2020 2120 2020 2049  cores)..  !    I
+00014b10: 4e54 454e 5428 494e 290a 2020 213e 2020  NTENT(IN).  !>  
+00014b20: 2020 2020 205c 7061 7261 6d5b 696e 5d20       \param[in] 
+00014b30: 2272 6561 6c28 6470 292c 2064 696d 656e  "real(dp), dimen
+00014b40: 7369 6f6e 283a 2920 3a3a 2070 6172 616d  sion(:) :: param
+00014b50: 6574 6572 7365 7422 0a20 2021 3e20 2020  eterset".  !>   
+00014b60: 2020 2020 5c70 6172 616d 5b69 6e5d 2022      \param[in] "
+00014b70: 7072 6f63 6564 7572 6528 6576 616c 5f69  procedure(eval_i
+00014b80: 6e74 6572 6661 6365 2920 3a3a 2065 7661  nterface) :: eva
+00014b90: 6c22 0a0a 2020 2120 2020 2052 4554 5552  l"..  !    RETUR
+00014ba0: 4e0a 2020 213e 2020 2020 2020 205c 7265  N.  !>       \re
+00014bb0: 7475 726e 2072 6561 6c28 6470 2920 3a3a  turn real(dp) ::
+00014bc0: 206f 626a 6563 7469 7665 5f6b 6765 5f71   objective_kge_q
+00014bd0: 5f72 6d73 655f 6574 2026 6d64 6173 683b  _rmse_et &mdash;
+00014be0: 206f 626a 6563 7469 7665 2066 756e 6374   objective funct
+00014bf0: 696f 6e20 7661 6c75 650a 2020 213e 2020  ion value.  !>  
+00014c00: 2020 2020 2028 7768 6963 6820 7769 6c6c       (which will
+00014c10: 2062 6520 652e 672e 206d 696e 696d 697a   be e.g. minimiz
+00014c20: 6564 2062 7920 616e 206f 7074 696d 697a  ed by an optimiz
+00014c30: 6174 696f 6e20 726f 7574 696e 6520 6c69  ation routine li
+00014c40: 6b65 2044 4453 290a 0a20 2021 2020 2020  ke DDS)..  !    
+00014c50: 4849 5354 4f52 590a 2020 213e 2020 2020  HISTORY.  !>    
+00014c60: 2020 205c 6175 7468 6f72 7320 4a6f 6861     \authors Joha
+00014c70: 6e6e 6573 2042 7265 6e6e 6572 0a0a 2020  nnes Brenner..  
+00014c80: 213e 2020 2020 2020 205c 6461 7465 204a  !>       \date J
+00014c90: 756c 7920 3230 3137 0a0a 2020 2120 4d6f  uly 2017..  ! Mo
+00014ca0: 6469 6669 6361 7469 6f6e 733a 0a20 2021  difications:.  !
+00014cb0: 2052 6f62 6572 7420 5363 6877 6570 7065   Robert Schweppe
+00014cc0: 204a 756e 2032 3031 3820 2d20 7265 6661   Jun 2018 - refa
+00014cd0: 6374 6f72 696e 6720 616e 6420 7265 666f  ctoring and refo
+00014ce0: 726d 6174 7469 6e67 0a0a 2020 4655 4e43  rmatting..  FUNC
+00014cf0: 5449 4f4e 206f 626a 6563 7469 7665 5f6b  TION objective_k
+00014d00: 6765 5f71 5f72 6d73 655f 6574 2870 6172  ge_q_rmse_et(par
+00014d10: 616d 6574 6572 7365 742c 2065 7661 6c29  ameterset, eval)
+00014d20: 0a0a 2020 2020 7573 6520 6d6f 5f6f 7074  ..    use mo_opt
+00014d30: 696d 697a 6174 696f 6e5f 7479 7065 732c  imization_types,
+00014d40: 206f 6e6c 7920 3a20 6f70 7469 6461 7461   only : optidata
+00014d50: 5f73 696d 0a20 2020 2075 7365 206d 6f5f  _sim.    use mo_
+00014d60: 636f 6d6d 6f6e 5f63 6f6e 7374 616e 7473  common_constants
+00014d70: 2c20 6f6e 6c79 203a 2065 7073 5f64 702c  , only : eps_dp,
+00014d80: 206e 6f64 6174 615f 6470 0a20 2020 2075   nodata_dp.    u
+00014d90: 7365 206d 6f5f 636f 6d6d 6f6e 5f6d 686d  se mo_common_mhm
+00014da0: 5f6d 726d 5f76 6172 6961 626c 6573 2c20  _mrm_variables, 
+00014db0: 6f6e 6c79 203a 2065 7661 6c50 6572 0a20  only : evalPer. 
+00014dc0: 2020 2075 7365 206d 6f5f 636f 6d6d 6f6e     use mo_common
+00014dd0: 5f76 6172 6961 626c 6573 2c20 6f6e 6c79  _variables, only
+00014de0: 203a 2064 6f6d 6169 6e4d 6574 610a 2020   : domainMeta.  
+00014df0: 2020 7573 6520 6d6f 5f65 7272 6f72 6d65    use mo_errorme
+00014e00: 6173 7572 6573 2c20 6f6e 6c79 203a 2072  asures, only : r
+00014e10: 6d73 650a 2020 2020 7573 6520 6d6f 5f67  mse.    use mo_g
+00014e20: 6c6f 6261 6c5f 7661 7269 6162 6c65 732c  lobal_variables,
+00014e30: 206f 6e6c 7920 3a20 4c31 5f65 744f 6273   only : L1_etObs
+00014e40: 0a20 2020 2075 7365 206d 6f5f 6a75 6c69  .    use mo_juli
+00014e50: 616e 2c20 6f6e 6c79 203a 2063 616c 6461  an, only : calda
+00014e60: 740a 2020 2020 7573 6520 6d6f 5f6d 6f6d  t.    use mo_mom
+00014e70: 656e 742c 206f 6e6c 7920 3a20 6176 6572  ent, only : aver
+00014e80: 6167 652c 206d 6561 6e0a 2020 2020 7573  age, mean.    us
+00014e90: 6520 6d6f 5f73 7461 6e64 6172 645f 7363  e mo_standard_sc
+00014ea0: 6f72 652c 206f 6e6c 7920 3a20 636c 6173  ore, only : clas
+00014eb0: 7369 6669 6564 5f73 7461 6e64 6172 645f  sified_standard_
+00014ec0: 7363 6f72 650a 2020 2020 7573 6520 6d6f  score.    use mo
+00014ed0: 5f73 7472 696e 675f 7574 696c 732c 206f  _string_utils, o
+00014ee0: 6e6c 7920 3a20 6e75 6d32 7374 720a 2020  nly : num2str.  
+00014ef0: 2020 7573 6520 6d6f 5f74 656d 706f 7261    use mo_tempora
+00014f00: 6c5f 6167 6772 6567 6174 696f 6e2c 206f  l_aggregation, o
+00014f10: 6e6c 7920 3a20 6461 7932 6d6f 6e5f 6176  nly : day2mon_av
+00014f20: 6572 6167 650a 2020 2020 7573 6520 6d6f  erage.    use mo
+00014f30: 5f65 7272 6f72 6d65 6173 7572 6573 2c20  _errormeasures, 
+00014f40: 6f6e 6c79 203a 206b 6765 0a20 2020 2075  only : kge.    u
+00014f50: 7365 206d 6f5f 6d72 6d5f 6f62 6a65 6374  se mo_mrm_object
+00014f60: 6976 655f 6675 6e63 7469 6f6e 5f72 756e  ive_function_run
+00014f70: 6f66 662c 206f 6e6c 7920 3a20 6578 7472  off, only : extr
+00014f80: 6163 745f 7275 6e6f 6666 0a0a 2020 2020  act_runoff..    
+00014f90: 696d 706c 6963 6974 206e 6f6e 650a 0a20  implicit none.. 
+00014fa0: 2020 2072 6561 6c28 6470 292c 2064 696d     real(dp), dim
+00014fb0: 656e 7369 6f6e 283a 292c 2069 6e74 656e  ension(:), inten
+00014fc0: 7428 696e 2920 3a3a 2070 6172 616d 6574  t(in) :: paramet
+00014fd0: 6572 7365 740a 0a20 2020 2070 726f 6365  erset..    proce
+00014fe0: 6475 7265 2865 7661 6c5f 696e 7465 7266  dure(eval_interf
+00014ff0: 6163 6529 2c20 494e 5445 4e54 2849 4e29  ace), INTENT(IN)
+00015000: 2c20 504f 494e 5445 5220 3a3a 2065 7661  , POINTER :: eva
+00015010: 6c0a 0a20 2020 2072 6561 6c28 6470 2920  l..    real(dp) 
+00015020: 3a3a 206f 626a 6563 7469 7665 5f6b 6765  :: objective_kge
+00015030: 5f71 5f72 6d73 655f 6574 0a0a 2020 2020  _q_rmse_et..    
+00015040: 2120 6d6f 6465 6c6c 6564 2072 756e 6f66  ! modelled runof
+00015050: 6620 666f 7220 6120 6769 7665 6e20 7061  f for a given pa
+00015060: 7261 6d65 7465 7220 7365 740a 2020 2020  rameter set.    
+00015070: 2120 6469 6d31 3d6e 5469 6d65 5374 6570  ! dim1=nTimeStep
+00015080: 732c 2064 696d 323d 6e47 6175 6765 730a  s, dim2=nGauges.
+00015090: 2020 2020 7265 616c 2864 7029 2c20 616c      real(dp), al
+000150a0: 6c6f 6361 7461 626c 652c 2064 696d 656e  locatable, dimen
+000150b0: 7369 6f6e 283a 2c20 3a29 203a 3a20 7275  sion(:, :) :: ru
+000150c0: 6e6f 6666 0a0a 2020 2020 213e 2073 696d  noff..    !> sim
+000150d0: 756c 6174 6564 2065 740a 2020 2020 7479  ulated et.    ty
+000150e0: 7065 286f 7074 6964 6174 615f 7369 6d29  pe(optidata_sim)
+000150f0: 2c20 6469 6d65 6e73 696f 6e28 3a29 2c20  , dimension(:), 
+00015100: 616c 6c6f 6361 7461 626c 6520 3a3a 2065  allocatable :: e
+00015110: 744f 7074 6953 696d 0a0a 2020 2020 2120  tOptiSim..    ! 
+00015120: 7469 6d65 206c 6f6f 7020 636f 756e 7465  time loop counte
+00015130: 720a 2020 2020 696e 7465 6765 7228 6934  r.    integer(i4
+00015140: 2920 3a3a 2069 5469 6d65 0a0a 2020 2020  ) :: iTime..    
+00015150: 2120 646f 6d61 696e 2063 6f75 6e74 6572  ! domain counter
+00015160: 2c20 6d6f 6e74 6820 636f 756e 7465 7273  , month counters
+00015170: 0a20 2020 2069 6e74 6567 6572 2869 3429  .    integer(i4)
+00015180: 203a 3a20 6944 6f6d 6169 6e2c 2070 702c   :: iDomain, pp,
+00015190: 206d 6d6d 0a0a 2020 2020 696e 7465 6765   mmm..    intege
+000151a0: 7228 6934 2920 3a3a 2079 6561 722c 206d  r(i4) :: year, m
+000151b0: 6f6e 7468 2c20 6461 790a 0a20 2020 2072  onth, day..    r
+000151c0: 6561 6c28 6470 292c 2064 696d 656e 7369  eal(dp), dimensi
+000151d0: 6f6e 2864 6f6d 6169 6e4d 6574 6125 6e44  on(domainMeta%nD
+000151e0: 6f6d 6169 6e73 2920 3a3a 2069 6e69 7454  omains) :: initT
+000151f0: 696d 650a 0a20 2020 2021 2074 6f74 616c  ime..    ! total
+00015200: 206e 756d 6265 7220 6f66 206d 6f6e 7468   number of month
+00015210: 730a 2020 2020 696e 7465 6765 7228 6934  s.    integer(i4
+00015220: 2920 3a3a 206e 4d6f 6e74 6873 0a0a 2020  ) :: nMonths..  
+00015230: 2020 2120 7665 6374 6f72 2077 6974 6820    ! vector with 
+00015240: 6d6f 6e74 6873 2720 636c 6173 7365 730a  months' classes.
+00015250: 2020 2020 696e 7465 6765 7228 6934 292c      integer(i4),
+00015260: 2064 696d 656e 7369 6f6e 283a 292c 2061   dimension(:), a
+00015270: 6c6c 6f63 6174 6162 6c65 203a 3a20 6d6f  llocatable :: mo
+00015280: 6e74 685f 636c 6173 7365 730a 0a20 2020  nth_classes..   
+00015290: 2021 206d 6f6e 7468 6c79 2076 616c 7565   ! monthly value
+000152a0: 7320 6f72 6967 696e 616c 2074 696d 6520  s original time 
+000152b0: 7365 7269 6573 0a20 2020 2072 6561 6c28  series.    real(
+000152c0: 6470 292c 2064 696d 656e 7369 6f6e 283a  dp), dimension(:
+000152d0: 292c 2061 6c6c 6f63 6174 6162 6c65 203a  ), allocatable :
+000152e0: 3a20 6574 5f73 696d 5f6d 2c20 6574 5f6f  : et_sim_m, et_o
+000152f0: 6273 5f6d 0a0a 2020 2020 2120 6d6f 6e74  bs_m..    ! mont
+00015300: 686c 7920 7661 6c75 6573 2061 6e6f 6d61  hly values anoma
+00015310: 6c79 2074 696d 6520 7365 7269 6573 0a20  ly time series. 
+00015320: 2020 2072 6561 6c28 6470 292c 2064 696d     real(dp), dim
+00015330: 656e 7369 6f6e 283a 292c 2061 6c6c 6f63  ension(:), alloc
+00015340: 6174 6162 6c65 203a 3a20 6574 5f73 696d  atable :: et_sim
+00015350: 5f6d 5f61 6e6f 6d2c 2065 745f 6f62 735f  _m_anom, et_obs_
+00015360: 6d5f 616e 6f6d 0a0a 2020 2020 6c6f 6769  m_anom..    logi
+00015370: 6361 6c2c 2064 696d 656e 7369 6f6e 283a  cal, dimension(:
+00015380: 292c 2061 6c6c 6f63 6174 6162 6c65 203a  ), allocatable :
+00015390: 3a20 6574 5f6f 6273 5f6d 5f6d 6173 6b0a  : et_obs_m_mask.
+000153a0: 0a20 2020 2021 206b 6765 5f71 286e 4761  .    ! kge_q(nGa
+000153b0: 7567 6573 546f 7461 6c29 0a20 2020 2072  ugesTotal).    r
+000153c0: 6561 6c28 6470 292c 2064 696d 656e 7369  eal(dp), dimensi
+000153d0: 6f6e 283a 292c 2061 6c6c 6f63 6174 6162  on(:), allocatab
+000153e0: 6c65 203a 3a20 726d 7365 5f65 740a 0a20  le :: rmse_et.. 
+000153f0: 2020 2021 206f 626a 2e20 6675 6e63 7469     ! obj. functi
+00015400: 6f6e 730a 2020 2020 7265 616c 2864 7029  ons.    real(dp)
+00015410: 203a 3a20 726d 7365 5f65 745f 6176 672c   :: rmse_et_avg,
+00015420: 206b 6765 5f71 5f61 7667 0a0a 2020 2020   kge_q_avg..    
+00015430: 2120 7370 6174 6961 6c20 6176 6572 6167  ! spatial averag
+00015440: 6520 6f66 206f 6273 6572 7665 6420 6574  e of observed et
+00015450: 0a20 2020 2072 6561 6c28 6470 292c 2064  .    real(dp), d
+00015460: 696d 656e 7369 6f6e 283a 292c 2061 6c6c  imension(:), all
+00015470: 6f63 6174 6162 6c65 203a 3a20 6574 5f63  ocatable :: et_c
+00015480: 6174 6368 5f61 7667 5f64 6f6d 6169 6e0a  atch_avg_domain.
+00015490: 0a20 2020 2021 2073 7061 7469 616c 2061  .    ! spatial a
+000154a0: 7665 7267 6165 206f 6620 6d6f 6465 6c65  vergae of modele
+000154b0: 6420 2065 740a 2020 2020 7265 616c 2864  d  et.    real(d
+000154c0: 7029 2c20 6469 6d65 6e73 696f 6e28 3a29  p), dimension(:)
+000154d0: 2c20 616c 6c6f 6361 7461 626c 6520 3a3a  , allocatable ::
+000154e0: 2065 745f 6f70 7469 5f63 6174 6368 5f61   et_opti_catch_a
+000154f0: 7667 5f64 6f6d 6169 6e0a 0a20 2020 2021  vg_domain..    !
+00015500: 206d 6173 6b20 666f 7220 7661 6c69 6420   mask for valid 
+00015510: 6574 2063 6174 6368 6d65 6e74 2061 7667  et catchment avg
+00015520: 2074 696d 6520 7374 6570 730a 2020 2020   time steps.    
+00015530: 6c6f 6769 6361 6c2c 2064 696d 656e 7369  logical, dimensi
+00015540: 6f6e 283a 292c 2061 6c6c 6f63 6174 6162  on(:), allocatab
+00015550: 6c65 203a 3a20 6d61 736b 5f74 696d 6573  le :: mask_times
+00015560: 0a0a 2020 2020 2120 726d 7365 5f65 7428  ..    ! rmse_et(
+00015570: 646f 6d61 696e 4d65 7461 256e 446f 6d61  domainMeta%nDoma
+00015580: 696e 7329 0a20 2020 2072 6561 6c28 6470  ins).    real(dp
+00015590: 292c 2064 696d 656e 7369 6f6e 283a 292c  ), dimension(:),
+000155a0: 2061 6c6c 6f63 6174 6162 6c65 203a 3a20   allocatable :: 
+000155b0: 6b67 655f 710a 0a20 2020 2021 2067 6175  kge_q..    ! gau
+000155c0: 6765 7320 636f 756e 7465 720a 2020 2020  ges counter.    
+000155d0: 696e 7465 6765 7228 6934 2920 3a3a 2067  integer(i4) :: g
+000155e0: 670a 0a20 2020 2069 6e74 6567 6572 2869  g..    integer(i
+000155f0: 3429 203a 3a20 6e47 6175 6765 7354 6f74  4) :: nGaugesTot
+00015600: 616c 0a0a 2020 2020 2120 6167 6772 6567  al..    ! aggreg
+00015610: 6174 6564 2073 696d 756c 6174 6564 2072  ated simulated r
+00015620: 756e 6f66 660a 2020 2020 7265 616c 2864  unoff.    real(d
+00015630: 7029 2c20 6469 6d65 6e73 696f 6e28 3a29  p), dimension(:)
+00015640: 2c20 616c 6c6f 6361 7461 626c 6520 3a3a  , allocatable ::
+00015650: 2072 756e 6f66 665f 6167 670a 0a20 2020   runoff_agg..   
+00015660: 2021 206d 6561 7375 7265 6420 7275 6e6f   ! measured runo
+00015670: 6666 0a20 2020 2072 6561 6c28 6470 292c  ff.    real(dp),
+00015680: 2064 696d 656e 7369 6f6e 283a 292c 2061   dimension(:), a
+00015690: 6c6c 6f63 6174 6162 6c65 203a 3a20 7275  llocatable :: ru
+000156a0: 6e6f 6666 5f6f 6273 0a0a 2020 2020 2120  noff_obs..    ! 
+000156b0: 6d61 736b 2066 6f72 206d 6561 7375 7265  mask for measure
+000156c0: 6420 7275 6e6f 6666 0a20 2020 206c 6f67  d runoff.    log
+000156d0: 6963 616c 2c20 6469 6d65 6e73 696f 6e28  ical, dimension(
+000156e0: 3a29 2c20 616c 6c6f 6361 7461 626c 6520  :), allocatable 
+000156f0: 3a3a 2072 756e 6f66 665f 6f62 735f 6d61  :: runoff_obs_ma
+00015700: 736b 0a0a 2020 2020 2120 6f62 7461 696e  sk..    ! obtain
+00015710: 2073 696d 756c 6174 696f 6e20 7661 6c75   simulation valu
+00015720: 6573 206f 6620 7275 6e6f 6666 2028 686f  es of runoff (ho
+00015730: 7572 6c79 2920 616e 6420 4554 0a20 2020  urly) and ET.   
+00015740: 2021 2066 6f72 2045 5420 6f6e 6c79 2076   ! for ET only v
+00015750: 616c 6964 2063 656c 6c73 2028 646f 6d61  alid cells (doma
+00015760: 696e 7320 636f 6e63 6174 656e 6174 6564  ins concatenated
+00015770: 290a 2020 2020 2120 6574 5f6f 7074 693a  ).    ! et_opti:
+00015780: 2061 6767 7265 6761 7465 2045 5420 746f   aggregate ET to
+00015790: 206e 6565 6465 6420 7469 6d65 2073 7465   needed time ste
+000157a0: 7020 666f 7220 6f70 7469 6d69 7a61 7469  p for optimizati
+000157b0: 6f6e 2028 7365 6520 7469 6d65 5374 6570  on (see timeStep
+000157c0: 5f65 745f 696e 7075 7429 0a20 2020 2061  _et_input).    a
+000157d0: 6c6c 6f63 6174 6528 6574 4f70 7469 5369  llocate(etOptiSi
+000157e0: 6d28 646f 6d61 696e 4d65 7461 256e 446f  m(domainMeta%nDo
+000157f0: 6d61 696e 7329 290a 2020 2020 6361 6c6c  mains)).    call
+00015800: 2065 7661 6c28 7061 7261 6d65 7465 7273   eval(parameters
+00015810: 6574 2c20 7275 6e6f 6666 203d 2072 756e  et, runoff = run
+00015820: 6f66 662c 2065 744f 7074 6953 696d 203d  off, etOptiSim =
+00015830: 2065 744f 7074 6953 696d 290a 0a20 2020   etOptiSim)..   
+00015840: 2021 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d   !--------------
+00015850: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00015860: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a20  --------------. 
+00015870: 2020 2021 2120 4556 4150 4f54 5241 4e53     !! EVAPOTRANS
+00015880: 5049 5241 5449 4f4e 0a20 2020 2021 2d2d  PIRATION.    !--
+00015890: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000158a0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000158b0: 2d2d 2d2d 2d2d 2d2d 2d2d 0a0a 2020 2020  ----------..    
+000158c0: 2120 616c 6c6f 6361 7465 0a20 2020 2061  ! allocate.    a
+000158d0: 6c6c 6f63 6174 6528 726d 7365 5f65 7428  llocate(rmse_et(
+000158e0: 646f 6d61 696e 4d65 7461 256e 446f 6d61  domainMeta%nDoma
+000158f0: 696e 7329 290a 2020 2020 726d 7365 5f65  ins)).    rmse_e
+00015900: 7428 3a29 203d 206e 6f64 6174 615f 6470  t(:) = nodata_dp
+00015910: 0a0a 2020 2020 646f 2069 446f 6d61 696e  ..    do iDomain
+00015920: 203d 2031 2c20 646f 6d61 696e 4d65 7461   = 1, domainMeta
+00015930: 256e 446f 6d61 696e 730a 0a20 2020 2020  %nDomains..     
+00015940: 2021 2061 6c6c 6f63 6174 650a 2020 2020   ! allocate.    
+00015950: 2020 616c 6c6f 6361 7465 286d 6173 6b5f    allocate(mask_
+00015960: 7469 6d65 7320 2020 2020 2020 2020 2020  times           
+00015970: 2020 2028 7369 7a65 2865 744f 7074 6953     (size(etOptiS
+00015980: 696d 2869 446f 6d61 696e 2925 6461 7461  im(iDomain)%data
+00015990: 5369 6d2c 2064 696d 203d 2032 2929 290a  Sim, dim = 2))).
+000159a0: 2020 2020 2020 616c 6c6f 6361 7465 2865        allocate(e
+000159b0: 745f 6361 7463 685f 6176 675f 646f 6d61  t_catch_avg_doma
+000159c0: 696e 2020 2020 2028 7369 7a65 2865 744f  in     (size(etO
+000159d0: 7074 6953 696d 2869 446f 6d61 696e 2925  ptiSim(iDomain)%
+000159e0: 6461 7461 5369 6d2c 2064 696d 203d 2032  dataSim, dim = 2
+000159f0: 2929 290a 2020 2020 2020 616c 6c6f 6361  ))).      alloca
+00015a00: 7465 2865 745f 6f70 7469 5f63 6174 6368  te(et_opti_catch
+00015a10: 5f61 7667 5f64 6f6d 6169 6e28 7369 7a65  _avg_domain(size
+00015a20: 2865 744f 7074 6953 696d 2869 446f 6d61  (etOptiSim(iDoma
+00015a30: 696e 2925 6461 7461 5369 6d2c 2064 696d  in)%dataSim, dim
+00015a40: 203d 2032 2929 290a 0a20 2020 2020 2021   = 2)))..      !
+00015a50: 2069 6e69 7461 6c69 7a65 0a20 2020 2020   initalize.     
+00015a60: 206d 6173 6b5f 7469 6d65 7320 3d20 2e54   mask_times = .T
+00015a70: 5255 452e 0a20 2020 2020 2065 745f 6361  RUE..      et_ca
+00015a80: 7463 685f 6176 675f 646f 6d61 696e 203d  tch_avg_domain =
+00015a90: 206e 6f64 6174 615f 6470 0a20 2020 2020   nodata_dp.     
+00015aa0: 2065 745f 6f70 7469 5f63 6174 6368 5f61   et_opti_catch_a
+00015ab0: 7667 5f64 6f6d 6169 6e20 3d20 6e6f 6461  vg_domain = noda
+00015ac0: 7461 5f64 700a 0a20 2020 2020 2021 2063  ta_dp..      ! c
+00015ad0: 616c 6375 6c61 7465 2063 6174 6368 6d65  alculate catchme
+00015ae0: 6e74 2061 7665 7261 6765 2065 7661 706f  nt average evapo
+00015af0: 7472 616e 7370 6972 6174 696f 6e0a 2020  transpiration.  
+00015b00: 2020 2020 646f 2069 5469 6d65 203d 2031      do iTime = 1
+00015b10: 2c20 7369 7a65 2865 744f 7074 6953 696d  , size(etOptiSim
+00015b20: 2869 446f 6d61 696e 2925 6461 7461 5369  (iDomain)%dataSi
+00015b30: 6d2c 2064 696d 203d 2032 290a 2020 2020  m, dim = 2).    
+00015b40: 2020 2020 2120 6368 6563 6b20 666f 7220      ! check for 
+00015b50: 656e 6f75 6768 2064 6174 6120 706f 696e  enough data poin
+00015b60: 7473 2069 6e20 7469 6d65 2066 6f72 2063  ts in time for c
+00015b70: 6f72 7265 6c61 7469 6f6e 0a20 2020 2020  orrelation.     
+00015b80: 2020 2069 6620 2861 6c6c 282e 4e4f 542e     if (all(.NOT.
+00015b90: 204c 315f 6574 4f62 7328 6944 6f6d 6169   L1_etObs(iDomai
+00015ba0: 6e29 256d 6173 6b4f 6273 283a 2c20 6954  n)%maskObs(:, iT
+00015bb0: 696d 6529 2929 2074 6865 6e0a 2020 2020  ime))) then.    
+00015bc0: 2020 2020 2020 2177 7269 7465 2028 2a2c        !write (*,
+00015bd0: 2a29 2027 5741 524e 494e 473a 2065 7420  *) 'WARNING: et 
+00015be0: 6461 7461 2061 7420 7469 6d65 2027 2c20  data at time ', 
+00015bf0: 6954 696d 652c 2027 2069 7320 656d 7074  iTime, ' is empt
+00015c00: 792e 270a 2020 2020 2020 2020 2020 2163  y.'.          !c
+00015c10: 616c 6c20 6d65 7373 6167 6528 2757 4152  all message('WAR
+00015c20: 4e49 4e47 3a20 6f62 6a65 6374 6976 655f  NING: objective_
+00015c30: 6574 5f6b 6765 5f63 6174 6368 6d65 6e74  et_kge_catchment
+00015c40: 5f61 7667 3a20 6967 6e6f 7265 6420 6375  _avg: ignored cu
+00015c50: 7272 656e 7420 7469 6d65 2073 7465 7020  rrent time step 
+00015c60: 7369 6e63 6520 6c65 7373 2074 6861 6e27  since less than'
+00015c70: 290a 2020 2020 2020 2020 2020 2163 616c  ).          !cal
+00015c80: 6c20 6d65 7373 6167 6528 2720 2020 2020  l message('     
+00015c90: 2020 2020 3130 2076 616c 6964 2063 656c      10 valid cel
+00015ca0: 6c73 2061 7661 696c 6162 6c65 2069 6e20  ls available in 
+00015cb0: 6576 6170 6f74 7261 6e73 7069 7261 7469  evapotranspirati
+00015cc0: 6f6e 206f 6273 6572 7661 7469 6f6e 2729  on observation')
+00015cd0: 0a20 2020 2020 2020 2020 206d 6173 6b5f  .          mask_
+00015ce0: 7469 6d65 7328 6954 696d 6529 203d 202e  times(iTime) = .
+00015cf0: 4641 4c53 452e 0a20 2020 2020 2020 2020  FALSE..         
+00015d00: 2063 7963 6c65 0a20 2020 2020 2020 2065   cycle.        e
+00015d10: 6e64 2069 660a 2020 2020 2020 2020 2120  nd if.        ! 
+00015d20: 7370 6174 6961 6c20 6176 6572 6167 6520  spatial average 
+00015d30: 6f66 206f 6273 6572 7665 6420 4554 0a20  of observed ET. 
+00015d40: 2020 2020 2020 2065 745f 6361 7463 685f         et_catch_
+00015d50: 6176 675f 646f 6d61 696e 2869 5469 6d65  avg_domain(iTime
+00015d60: 2920 3d20 6176 6572 6167 6528 4c31 5f65  ) = average(L1_e
+00015d70: 744f 6273 2869 446f 6d61 696e 2925 6461  tObs(iDomain)%da
+00015d80: 7461 4f62 7328 3a2c 2069 5469 6d65 292c  taObs(:, iTime),
+00015d90: 2026 0a20 2020 2020 2020 2020 2020 2020   &.             
+00015da0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015db0: 2020 2020 2020 2020 206d 6173 6b20 3d20           mask = 
+00015dc0: 4c31 5f65 744f 6273 2869 446f 6d61 696e  L1_etObs(iDomain
+00015dd0: 2925 6d61 736b 4f62 7328 3a2c 2069 5469  )%maskObs(:, iTi
+00015de0: 6d65 2929 0a20 2020 2020 2020 2021 2073  me)).        ! s
+00015df0: 7061 7469 616c 2061 7665 7267 6165 206f  patial avergae o
+00015e00: 6620 6d6f 6465 6c65 6420 4554 0a20 2020  f modeled ET.   
+00015e10: 2020 2020 2065 745f 6f70 7469 5f63 6174       et_opti_cat
+00015e20: 6368 5f61 7667 5f64 6f6d 6169 6e28 6954  ch_avg_domain(iT
+00015e30: 696d 6529 203d 2061 7665 7261 6765 2865  ime) = average(e
+00015e40: 744f 7074 6953 696d 2869 446f 6d61 696e  tOptiSim(iDomain
+00015e50: 2925 6461 7461 5369 6d28 3a2c 2069 5469  )%dataSim(:, iTi
+00015e60: 6d65 292c 2026 0a20 2020 2020 2020 2020  me), &.         
+00015e70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015e80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015e90: 2020 206d 6173 6b20 3d20 4c31 5f65 744f     mask = L1_etO
+00015ea0: 6273 2869 446f 6d61 696e 2925 6d61 736b  bs(iDomain)%mask
+00015eb0: 4f62 7328 3a2c 2069 5469 6d65 2929 0a20  Obs(:, iTime)). 
+00015ec0: 2020 2020 2065 6e64 2064 6f0a 0a20 2020       end do..   
+00015ed0: 2020 2021 2067 6574 2069 6e69 7469 616c     ! get initial
+00015ee0: 2074 696d 6520 6f66 2074 6865 2065 7661   time of the eva
+00015ef0: 6c75 6174 696f 6e20 7065 7269 6f64 0a20  luation period. 
+00015f00: 2020 2020 2069 6e69 7454 696d 6528 6944       initTime(iD
+00015f10: 6f6d 6169 6e29 203d 2072 6561 6c28 6576  omain) = real(ev
+00015f20: 616c 5065 7228 6944 6f6d 6169 6e29 256a  alPer(iDomain)%j
+00015f30: 756c 5374 6172 742c 2064 7029 0a0a 2020  ulStart, dp)..  
+00015f40: 2020 2020 2120 6765 7420 6361 6c65 6e64      ! get calend
+00015f50: 6172 2064 6179 732c 206d 6f6e 7468 732c  ar days, months,
+00015f60: 2079 6561 720a 2020 2020 2020 6361 6c6c   year.      call
+00015f70: 2063 616c 6461 7428 696e 7428 696e 6974   caldat(int(init
+00015f80: 5469 6d65 2869 446f 6d61 696e 2929 2c20  Time(iDomain)), 
+00015f90: 7979 203d 2079 6561 722c 206d 6d20 3d20  yy = year, mm = 
+00015fa0: 6d6f 6e74 682c 2064 6420 3d20 6461 7929  month, dd = day)
+00015fb0: 0a0a 2020 2020 2020 2120 6966 2065 7661  ..      ! if eva
+00015fc0: 706f 7472 616e 7370 6972 6174 696f 6e20  potranspiration 
+00015fd0: 696e 7075 7420 6461 696c 790a 2020 2020  input daily.    
+00015fe0: 2020 7365 6c65 6374 2063 6173 6528 4c31    select case(L1
+00015ff0: 5f65 744f 6273 2869 446f 6d61 696e 2925  _etObs(iDomain)%
+00016000: 7469 6d65 5374 6570 496e 7075 7429 0a20  timeStepInput). 
+00016010: 2020 2020 2020 2021 204a 424a 424a 420a         ! JBJBJB.
+00016020: 2020 2020 2020 2020 2120 6461 696c 793a          ! daily:
+00016030: 2061 6767 7265 6761 7465 2074 6f20 6d6f   aggregate to mo
+00016040: 6e74 686c 7920 6d65 616e 0a20 2020 2020  nthly mean.     
+00016050: 2063 6173 6528 2d31 290a 2020 2020 2020   case(-1).      
+00016060: 2020 2120 6361 6c63 756c 6174 6520 6d6f    ! calculate mo
+00016070: 6e74 686c 7920 6176 6572 6167 6573 2066  nthly averages f
+00016080: 726f 6d20 6461 696c 7920 7661 6c75 6573  rom daily values
+00016090: 206f 6620 7468 6520 6d6f 6465 6c0a 2020   of the model.  
+000160a0: 2020 2020 2020 6361 6c6c 2064 6179 326d        call day2m
+000160b0: 6f6e 5f61 7665 7261 6765 2865 745f 6f70  on_average(et_op
+000160c0: 7469 5f63 6174 6368 5f61 7667 5f64 6f6d  ti_catch_avg_dom
+000160d0: 6169 6e2c 2079 6561 722c 206d 6f6e 7468  ain, year, month
+000160e0: 2c20 6461 792c 2065 745f 7369 6d5f 6d2c  , day, et_sim_m,
+000160f0: 206d 6973 7661 6c20 3d20 6e6f 6461 7461   misval = nodata
+00016100: 5f64 7029 0a20 2020 2020 2020 2021 2063  _dp).        ! c
+00016110: 616c 6375 6c61 7465 206d 6f6e 7468 6c79  alculate monthly
+00016120: 2061 7665 7261 6765 7320 6672 6f6d 2064   averages from d
+00016130: 6169 6c79 2076 616c 7565 7320 6f66 2074  aily values of t
+00016140: 6865 206f 6273 6572 7661 7469 6f6e 730a  he observations.
+00016150: 2020 2020 2020 2020 6361 6c6c 2064 6179          call day
+00016160: 326d 6f6e 5f61 7665 7261 6765 2865 745f  2mon_average(et_
+00016170: 6361 7463 685f 6176 675f 646f 6d61 696e  catch_avg_domain
+00016180: 2c20 7965 6172 2c20 6d6f 6e74 682c 2064  , year, month, d
+00016190: 6179 2c20 6574 5f6f 6273 5f6d 2c20 6d69  ay, et_obs_m, mi
+000161a0: 7376 616c 203d 206e 6f64 6174 615f 6470  sval = nodata_dp
+000161b0: 290a 2020 2020 2020 2020 210a 2020 2020  ).        !.    
+000161c0: 2020 2020 2120 6d6f 6e74 686c 793a 2070      ! monthly: p
+000161d0: 726f 6365 6564 2077 6974 686f 7574 2061  roceed without a
+000161e0: 6374 696f 6e0a 2020 2020 2020 6361 7365  ction.      case
+000161f0: 282d 3229 0a20 2020 2020 2020 2021 2073  (-2).        ! s
+00016200: 696d 756c 6174 696f 6e0a 2020 2020 2020  imulation.      
+00016210: 2020 616c 6c6f 6361 7465 2865 745f 7369    allocate(et_si
+00016220: 6d5f 6d28 7369 7a65 2865 744f 7074 6953  m_m(size(etOptiS
+00016230: 696d 2869 446f 6d61 696e 2925 6461 7461  im(iDomain)%data
+00016240: 5369 6d2c 2064 696d 203d 2032 2929 290a  Sim, dim = 2))).
+00016250: 2020 2020 2020 2020 6574 5f73 696d 5f6d          et_sim_m
+00016260: 203d 2065 745f 6f70 7469 5f63 6174 6368   = et_opti_catch
+00016270: 5f61 7667 5f64 6f6d 6169 6e0a 2020 2020  _avg_domain.    
+00016280: 2020 2020 2120 6f62 7365 7276 6174 696f      ! observatio
+00016290: 6e0a 2020 2020 2020 2020 616c 6c6f 6361  n.        alloca
+000162a0: 7465 2865 745f 6f62 735f 6d28 7369 7a65  te(et_obs_m(size
+000162b0: 2865 744f 7074 6953 696d 2869 446f 6d61  (etOptiSim(iDoma
+000162c0: 696e 2925 6461 7461 5369 6d2c 2064 696d  in)%dataSim, dim
+000162d0: 203d 2032 2929 290a 2020 2020 2020 2020   = 2))).        
+000162e0: 6574 5f6f 6273 5f6d 203d 2065 745f 6361  et_obs_m = et_ca
+000162f0: 7463 685f 6176 675f 646f 6d61 696e 0a0a  tch_avg_domain..
+00016300: 2020 2020 2020 2020 2120 7965 6172 6c79          ! yearly
+00016310: 3a20 4552 524f 5220 7374 6f70 2070 726f  : ERROR stop pro
+00016320: 6772 616d 0a20 2020 2020 2063 6173 6528  gram.      case(
+00016330: 2d33 290a 2020 2020 2020 2020 6361 6c6c  -3).        call
+00016340: 2065 7272 6f72 5f6d 6573 7361 6765 2827   error_message('
+00016350: 2a2a 2a45 5252 4f52 3a20 6f62 6a65 6374  ***ERROR: object
+00016360: 6976 655f 6b67 655f 715f 726d 7365 5f65  ive_kge_q_rmse_e
+00016370: 743a 2074 696d 6520 7374 6570 206f 6620  t: time step of 
+00016380: 6576 6170 6f74 7261 6e73 7069 7261 7469  evapotranspirati
+00016390: 6f6e 2079 6561 726c 792e 2729 0a20 2020  on yearly.').   
+000163a0: 2020 2065 6e64 2073 656c 6563 740a 2020     end select.  
+000163b0: 2020 2020 2120 7265 6d6f 7665 206d 6561      ! remove mea
+000163c0: 6e20 6672 6f6d 206d 6f64 656c 6c65 6420  n from modelled 
+000163d0: 7469 6d65 2073 6572 6965 730a 2020 2020  time series.    
+000163e0: 2020 6574 5f73 696d 5f6d 283a 2920 3d20    et_sim_m(:) = 
+000163f0: 6574 5f73 696d 5f6d 283a 2920 2d20 6d65  et_sim_m(:) - me
+00016400: 616e 2865 745f 7369 6d5f 6d28 3a29 290a  an(et_sim_m(:)).
+00016410: 2020 2020 2020 2120 7265 6d6f 7665 206d        ! remove m
+00016420: 6561 6e20 6672 6f6d 206f 6273 6572 7665  ean from observe
+00016430: 6420 7469 6d65 2073 6572 6965 730a 2020  d time series.  
+00016440: 2020 2020 6574 5f6f 6273 5f6d 283a 2920      et_obs_m(:) 
+00016450: 3d20 6574 5f6f 6273 5f6d 283a 2920 2d20  = et_obs_m(:) - 
+00016460: 6d65 616e 2865 745f 6f62 735f 6d28 3a29  mean(et_obs_m(:)
+00016470: 290a 2020 2020 2020 2120 6765 7420 6e75  ).      ! get nu
+00016480: 6d62 6572 206f 6620 6d6f 6e74 6873 2066  mber of months f
+00016490: 6f72 2067 6976 656e 2064 6f6d 6169 6e0a  or given domain.
+000164a0: 2020 2020 2020 6e4d 6f6e 7468 7320 3d20        nMonths = 
+000164b0: 7369 7a65 2865 745f 6f62 735f 6d29 0a20  size(et_obs_m). 
+000164c0: 2020 2020 2061 6c6c 6f63 6174 6520 286d       allocate (m
+000164d0: 6f6e 7468 5f63 6c61 7373 6573 286e 4d6f  onth_classes(nMo
+000164e0: 6e74 6873 2929 0a20 2020 2020 2061 6c6c  nths)).      all
+000164f0: 6f63 6174 6520 2865 745f 6f62 735f 6d5f  ocate (et_obs_m_
+00016500: 6d61 736b 286e 4d6f 6e74 6873 2929 0a20  mask(nMonths)). 
+00016510: 2020 2020 2061 6c6c 6f63 6174 6520 2865       allocate (e
+00016520: 745f 6f62 735f 6d5f 616e 6f6d 286e 4d6f  t_obs_m_anom(nMo
+00016530: 6e74 6873 2929 0a20 2020 2020 2061 6c6c  nths)).      all
+00016540: 6f63 6174 6520 2865 745f 7369 6d5f 6d5f  ocate (et_sim_m_
+00016550: 616e 6f6d 286e 4d6f 6e74 6873 2929 0a0a  anom(nMonths))..
+00016560: 2020 2020 2020 6d6f 6e74 685f 636c 6173        month_clas
+00016570: 7365 7328 3a29 203d 2030 0a20 2020 2020  ses(:) = 0.     
+00016580: 2065 745f 6f62 735f 6d5f 6d61 736b 283a   et_obs_m_mask(:
+00016590: 2920 3d20 2e54 5255 452e 0a20 2020 2020  ) = .TRUE..     
+000165a0: 2065 745f 6f62 735f 6d5f 616e 6f6d 283a   et_obs_m_anom(:
+000165b0: 2920 3d20 6e6f 6461 7461 5f64 700a 2020  ) = nodata_dp.  
+000165c0: 2020 2020 6574 5f73 696d 5f6d 5f61 6e6f      et_sim_m_ano
+000165d0: 6d28 3a29 203d 206e 6f64 6174 615f 6470  m(:) = nodata_dp
+000165e0: 0a0a 2020 2020 2020 2120 6465 6669 6e65  ..      ! define
+000165f0: 206d 6f6e 7468 7327 2063 6c61 7373 6573   months' classes
+00016600: 0a20 2020 2020 206d 6d6d 203d 206d 6f6e  .      mmm = mon
+00016610: 7468 0a20 2020 2020 2064 6f20 7070 203d  th.      do pp =
+00016620: 2031 2c20 6e4d 6f6e 7468 730a 2020 2020   1, nMonths.    
+00016630: 2020 2020 6d6f 6e74 685f 636c 6173 7365      month_classe
+00016640: 7328 7070 2920 3d20 6d6d 6d0a 2020 2020  s(pp) = mmm.    
+00016650: 2020 2020 6966 2028 6d6d 6d20 2e4c 542e      if (mmm .LT.
+00016660: 2031 3229 2074 6865 6e0a 2020 2020 2020   12) then.      
+00016670: 2020 2020 6d6d 6d20 3d20 6d6d 6d20 2b20      mmm = mmm + 
+00016680: 310a 2020 2020 2020 2020 656c 7365 0a20  1.        else. 
+00016690: 2020 2020 2020 2020 206d 6d6d 203d 2031           mmm = 1
+000166a0: 0a20 2020 2020 2020 2065 6e64 2069 660a  .        end if.
+000166b0: 2020 2020 2020 656e 6420 646f 0a20 2020        end do.   
+000166c0: 2020 2021 2064 6f75 626c 6520 6368 6563     ! double chec
+000166d0: 6b20 6d69 7373 696e 6720 6461 7461 0a20  k missing data. 
+000166e0: 2020 2020 2021 2064 6566 696e 6520 6d61       ! define ma
+000166f0: 736b 2066 6f72 206d 6973 7369 6e67 2064  sk for missing d
+00016700: 6174 6120 696e 206f 6273 6572 7661 7469  ata in observati
+00016710: 6f6e 7320 2874 6865 7265 2061 7265 2061  ons (there are a
+00016720: 6c77 6179 7320 6461 7461 2066 6f72 2073  lways data for s
+00016730: 696d 756c 6174 696f 6e73 290a 2020 2020  imulations).    
+00016740: 2020 7768 6572 6528 6162 7328 6574 5f6f    where(abs(et_o
+00016750: 6273 5f6d 202d 206e 6f64 6174 615f 6470  bs_m - nodata_dp
+00016760: 2920 2e6c 742e 2065 7073 5f64 7029 2065  ) .lt. eps_dp) e
+00016770: 745f 6f62 735f 6d5f 6d61 736b 203d 202e  t_obs_m_mask = .
+00016780: 4641 4c53 452e 0a0a 2020 2020 2020 2120  FALSE...      ! 
+00016790: 6361 6c63 756c 6174 6520 7374 616e 6461  calculate standa
+000167a0: 7264 2073 636f 7265 0a20 2020 2020 2065  rd score.      e
+000167b0: 745f 6f62 735f 6d5f 616e 6f6d 203d 2063  t_obs_m_anom = c
+000167c0: 6c61 7373 6966 6965 645f 7374 616e 6461  lassified_standa
+000167d0: 7264 5f73 636f 7265 2865 745f 6f62 735f  rd_score(et_obs_
+000167e0: 6d2c 206d 6f6e 7468 5f63 6c61 7373 6573  m, month_classes
+000167f0: 2c20 6d61 736b 203d 2065 745f 6f62 735f  , mask = et_obs_
+00016800: 6d5f 6d61 736b 290a 2020 2020 2020 6574  m_mask).      et
+00016810: 5f73 696d 5f6d 5f61 6e6f 6d20 3d20 636c  _sim_m_anom = cl
+00016820: 6173 7369 6669 6564 5f73 7461 6e64 6172  assified_standar
+00016830: 645f 7363 6f72 6528 6574 5f73 696d 5f6d  d_score(et_sim_m
+00016840: 2c20 6d6f 6e74 685f 636c 6173 7365 732c  , month_classes,
+00016850: 206d 6173 6b20 3d20 6574 5f6f 6273 5f6d   mask = et_obs_m
+00016860: 5f6d 6173 6b29 0a20 2020 2020 2072 6d73  _mask).      rms
+00016870: 655f 6574 2869 446f 6d61 696e 2920 3d20  e_et(iDomain) = 
+00016880: 726d 7365 2865 745f 7369 6d5f 6d5f 616e  rmse(et_sim_m_an
+00016890: 6f6d 2c20 6574 5f6f 6273 5f6d 5f61 6e6f  om, et_obs_m_ano
+000168a0: 6d2c 206d 6173 6b20 3d20 6574 5f6f 6273  m, mask = et_obs
+000168b0: 5f6d 5f6d 6173 6b29 0a0a 2020 2020 2020  _m_mask)..      
+000168c0: 6465 616c 6c6f 6361 7465 2028 6d6f 6e74  deallocate (mont
+000168d0: 685f 636c 6173 7365 7329 0a20 2020 2020  h_classes).     
+000168e0: 2064 6561 6c6c 6f63 6174 6520 2865 745f   deallocate (et_
+000168f0: 6f62 735f 6d29 0a20 2020 2020 2064 6561  obs_m).      dea
+00016900: 6c6c 6f63 6174 6520 2865 745f 7369 6d5f  llocate (et_sim_
+00016910: 6d29 0a20 2020 2020 2064 6561 6c6c 6f63  m).      dealloc
+00016920: 6174 6520 2865 745f 6f62 735f 6d5f 6d61  ate (et_obs_m_ma
+00016930: 736b 290a 2020 2020 2020 6465 616c 6c6f  sk).      deallo
+00016940: 6361 7465 2028 6574 5f73 696d 5f6d 5f61  cate (et_sim_m_a
+00016950: 6e6f 6d29 0a20 2020 2020 2064 6561 6c6c  nom).      deall
+00016960: 6f63 6174 6520 2865 745f 6f62 735f 6d5f  ocate (et_obs_m_
+00016970: 616e 6f6d 290a 2020 2020 2020 2165 6e64  anom).      !end
+00016980: 2069 660a 0a20 2020 2020 2063 616c 6c20   if..      call 
+00016990: 6574 4f70 7469 5369 6d28 6944 6f6d 6169  etOptiSim(iDomai
+000169a0: 6e29 2564 6573 7472 6f79 2829 0a20 2020  n)%destroy().   
+000169b0: 2065 6e64 2064 6f0a 0a20 2020 2072 6d73   end do..    rms
+000169c0: 655f 6574 5f61 7667 203d 2073 756d 2872  e_et_avg = sum(r
+000169d0: 6d73 655f 6574 283a 292c 2061 6273 2872  mse_et(:), abs(r
+000169e0: 6d73 655f 6574 202d 206e 6f64 6174 615f  mse_et - nodata_
+000169f0: 6470 2920 2e67 742e 2065 7073 5f64 7029  dp) .gt. eps_dp)
+00016a00: 202f 2026 0a20 2020 2020 2020 2020 2020   / &.           
+00016a10: 2072 6561 6c28 636f 756e 7428 6162 7328   real(count(abs(
+00016a20: 726d 7365 5f65 7420 2d20 6e6f 6461 7461  rmse_et - nodata
+00016a30: 5f64 7029 202e 6774 2e20 6570 735f 6470  _dp) .gt. eps_dp
+00016a40: 292c 2064 7029 0a20 2020 2064 6561 6c6c  ), dp).    deall
+00016a50: 6f63 6174 6528 726d 7365 5f65 7429 0a20  ocate(rmse_et). 
+00016a60: 2020 2064 6561 6c6c 6f63 6174 6528 6574     deallocate(et
+00016a70: 4f70 7469 5369 6d29 0a0a 2020 2020 212d  OptiSim)..    !-
+00016a80: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00016a90: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00016aa0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020  -----------.    
+00016ab0: 2121 2052 554e 4f46 460a 2020 2020 212d  !! RUNOFF.    !-
+00016ac0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00016ad0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00016ae0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020  -----------.    
+00016af0: 6b67 655f 715f 6176 6720 3d20 305f 6470  kge_q_avg = 0_dp
+00016b00: 0a20 2020 206e 4761 7567 6573 546f 7461  .    nGaugesTota
+00016b10: 6c20 3d20 7369 7a65 2872 756e 6f66 662c  l = size(runoff,
+00016b20: 2064 696d 203d 2032 290a 2020 2020 616c   dim = 2).    al
+00016b30: 6c6f 6361 7465 286b 6765 5f71 286e 4761  locate(kge_q(nGa
+00016b40: 7567 6573 546f 7461 6c29 290a 2020 2020  ugesTotal)).    
+00016b50: 6b67 655f 7128 3a29 203d 206e 6f64 6174  kge_q(:) = nodat
+00016b60: 615f 6470 0a0a 2020 2020 646f 2067 6720  a_dp..    do gg 
+00016b70: 3d20 312c 206e 4761 7567 6573 546f 7461  = 1, nGaugesTota
+00016b80: 6c0a 0a20 2020 2020 2021 2065 7874 7261  l..      ! extra
+00016b90: 6374 2072 756e 6f66 660a 2020 2020 2020  ct runoff.      
+00016ba0: 6361 6c6c 2065 7874 7261 6374 5f72 756e  call extract_run
+00016bb0: 6f66 6628 6767 2c20 7275 6e6f 6666 2c20  off(gg, runoff, 
+00016bc0: 7275 6e6f 6666 5f61 6767 2c20 7275 6e6f  runoff_agg, runo
+00016bd0: 6666 5f6f 6273 2c20 7275 6e6f 6666 5f6f  ff_obs, runoff_o
+00016be0: 6273 5f6d 6173 6b29 0a0a 2020 2020 2020  bs_mask)..      
+00016bf0: 2120 6368 6563 6b20 666f 7220 7768 6574  ! check for whet
+00016c00: 6865 7220 746f 2070 726f 6365 6564 2077  her to proceed w
+00016c10: 6974 6820 7468 6973 2064 6f6d 6169 6e20  ith this domain 
+00016c20: 6f72 206e 6f74 0a20 2020 2020 2021 2070  or not.      ! p
+00016c30: 6f74 656e 7469 616c 6c79 2033 2079 6561  otentially 3 yea
+00016c40: 7273 206f 6620 6461 7461 0a20 2020 2020  rs of data.     
+00016c50: 2021 7070 203d 2063 6f75 6e74 2872 756e   !pp = count(run
+00016c60: 6f66 665f 6167 6720 2e67 652e 2030 2e30  off_agg .ge. 0.0
+00016c70: 5f64 7020 290a 2020 2020 2020 2169 6620  _dp ).      !if 
+00016c80: 2870 7020 2e6c 742e 2020 3336 352a 3320  (pp .lt.  365*3 
+00016c90: 2920 7468 656e 0a20 2020 2020 2021 2020  ) then.      !  
+00016ca0: 2020 6465 616c 6c6f 6361 7465 2028 7275    deallocate (ru
+00016cb0: 6e6f 6666 5f61 6767 2c20 7275 6e6f 6666  noff_agg, runoff
+00016cc0: 5f6f 6273 2c20 7275 6e6f 6666 5f6f 6273  _obs, runoff_obs
+00016cd0: 5f6d 6173 6b29 0a20 2020 2020 2021 2020  _mask).      !  
+00016ce0: 2020 6379 636c 650a 2020 2020 2020 2120    cycle.      ! 
+00016cf0: 656c 7365 0a20 2020 2020 2021 2063 616c  else.      ! cal
+00016d00: 6375 6c61 7465 204b 4745 2066 6f72 2065  culate KGE for e
+00016d10: 6163 6820 646f 6d61 696e 3a0a 2020 2020  ach domain:.    
+00016d20: 2020 6b67 655f 7128 6767 2920 3d20 6b67    kge_q(gg) = kg
+00016d30: 6528 7275 6e6f 6666 5f6f 6273 2c20 7275  e(runoff_obs, ru
+00016d40: 6e6f 6666 5f61 6767 2c20 6d61 736b 203d  noff_agg, mask =
+00016d50: 2072 756e 6f66 665f 6f62 735f 6d61 736b   runoff_obs_mask
+00016d60: 290a 2020 2020 2020 6465 616c 6c6f 6361  ).      dealloca
+00016d70: 7465 2028 7275 6e6f 6666 5f61 6767 2c20  te (runoff_agg, 
+00016d80: 7275 6e6f 6666 5f6f 6273 2c20 7275 6e6f  runoff_obs, runo
+00016d90: 6666 5f6f 6273 5f6d 6173 6b29 0a20 2020  ff_obs_mask).   
+00016da0: 2020 2021 2065 6e64 2069 660a 0a20 2020     ! end if..   
+00016db0: 2065 6e64 2064 6f0a 0a20 2020 2021 2063   end do..    ! c
+00016dc0: 616c 6375 6c61 7465 2061 7665 7261 6765  alculate average
+00016dd0: 204b 4745 2076 616c 7565 2066 6f72 2072   KGE value for r
+00016de0: 756e 6f66 660a 2020 2020 6b67 655f 715f  unoff.    kge_q_
+00016df0: 6176 6720 3d20 7375 6d28 6b67 655f 7128  avg = sum(kge_q(
+00016e00: 3a29 2c20 6162 7328 6b67 655f 7120 2d20  :), abs(kge_q - 
+00016e10: 6e6f 6461 7461 5f64 7029 202e 6774 2e20  nodata_dp) .gt. 
+00016e20: 6570 735f 6470 2920 2f20 260a 2020 2020  eps_dp) / &.    
+00016e30: 2020 2020 2020 2020 7265 616c 2863 6f75          real(cou
+00016e40: 6e74 2861 6273 286b 6765 5f71 202d 206e  nt(abs(kge_q - n
+00016e50: 6f64 6174 615f 6470 2920 2e67 742e 2065  odata_dp) .gt. e
+00016e60: 7073 5f64 7029 2c20 6470 290a 2020 2020  ps_dp), dp).    
+00016e70: 6465 616c 6c6f 6361 7465 286b 6765 5f71  deallocate(kge_q
+00016e80: 290a 0a20 2020 2021 0a20 2020 206f 626a  )..    !.    obj
+00016e90: 6563 7469 7665 5f6b 6765 5f71 5f72 6d73  ective_kge_q_rms
+00016ea0: 655f 6574 203d 2072 6d73 655f 6574 5f61  e_et = rmse_et_a
+00016eb0: 7667 202a 2028 312e 5f64 7020 2d20 6b67  vg * (1._dp - kg
+00016ec0: 655f 715f 6176 6729 0a0a 2020 2020 6361  e_q_avg)..    ca
+00016ed0: 6c6c 206d 6573 7361 6765 2827 2020 2020  ll message('    
+00016ee0: 6f62 6a65 6374 6976 655f 6b67 655f 715f  objective_kge_q_
+00016ef0: 726d 7365 5f65 7420 3d20 272c 206e 756d  rmse_et = ', num
+00016f00: 3273 7472 286f 626a 6563 7469 7665 5f6b  2str(objective_k
+00016f10: 6765 5f71 5f72 6d73 655f 6574 2c20 2728  ge_q_rmse_et, '(
+00016f20: 4639 2e35 2927 2929 0a0a 2020 454e 4420  F9.5)'))..  END 
+00016f30: 4655 4e43 5449 4f4e 206f 626a 6563 7469  FUNCTION objecti
+00016f40: 7665 5f6b 6765 5f71 5f72 6d73 655f 6574  ve_kge_q_rmse_et
+00016f50: 0a0a 2020 7375 6272 6f75 7469 6e65 2063  ..  subroutine c
+00016f60: 7265 6174 655f 646f 6d61 696e 5f61 7667  reate_domain_avg
+00016f70: 5f74 7773 2869 446f 6d61 696e 2c20 7477  _tws(iDomain, tw
+00016f80: 734f 7074 6953 696d 2c20 7477 735f 6361  sOptiSim, tws_ca
+00016f90: 7463 685f 6176 675f 646f 6d61 696e 2c20  tch_avg_domain, 
+00016fa0: 260a 2020 2020 2020 2020 2020 2020 2020  &.              
+00016fb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016fc0: 2020 2020 2020 2020 2020 2020 2074 7773               tws
+00016fd0: 5f6f 7074 695f 6361 7463 685f 6176 675f  _opti_catch_avg_
+00016fe0: 646f 6d61 696e 2c20 6d61 736b 5f74 696d  domain, mask_tim
+00016ff0: 6573 290a 2020 2020 7573 6520 6d6f 5f6f  es).    use mo_o
+00017000: 7074 696d 697a 6174 696f 6e5f 7479 7065  ptimization_type
+00017010: 732c 206f 6e6c 7920 3a20 6f70 7469 6461  s, only : optida
+00017020: 7461 5f73 696d 0a20 2020 2075 7365 206d  ta_sim.    use m
+00017030: 6f5f 636f 6d6d 6f6e 5f63 6f6e 7374 616e  o_common_constan
+00017040: 7473 2c20 6f6e 6c79 203a 206e 6f64 6174  ts, only : nodat
+00017050: 615f 6470 0a20 2020 2075 7365 206d 6f5f  a_dp.    use mo_
+00017060: 676c 6f62 616c 5f76 6172 6961 626c 6573  global_variables
+00017070: 2c20 6f6e 6c79 203a 204c 315f 7477 7361  , only : L1_twsa
+00017080: 4f62 730a 2020 2020 7573 6520 6d6f 5f6d  Obs.    use mo_m
+00017090: 6f6d 656e 742c 206f 6e6c 7920 3a20 6176  oment, only : av
+000170a0: 6572 6167 650a 2020 2020 2120 6375 7272  erage.    ! curr
+000170b0: 656e 7420 646f 6d61 696e 2049 640a 2020  ent domain Id.  
+000170c0: 2020 696e 7465 6765 7228 6934 292c 2069    integer(i4), i
+000170d0: 6e74 656e 7428 696e 2920 3a3a 2069 446f  ntent(in) :: iDo
+000170e0: 6d61 696e 0a0a 2020 2020 2120 7369 6d75  main..    ! simu
+000170f0: 6c61 7465 6420 7477 730a 2020 2020 7479  lated tws.    ty
+00017100: 7065 286f 7074 6964 6174 615f 7369 6d29  pe(optidata_sim)
+00017110: 2c20 6469 6d65 6e73 696f 6e28 3a29 2c20  , dimension(:), 
+00017120: 696e 7465 6e74 2869 6e29 203a 3a20 7477  intent(in) :: tw
+00017130: 734f 7074 6953 696d 0a0a 2020 2020 2120  sOptiSim..    ! 
+00017140: 6167 6772 6567 6174 6564 2073 696d 756c  aggregated simul
+00017150: 6174 6564 0a20 2020 2072 6561 6c28 6470  ated.    real(dp
+00017160: 292c 2064 696d 656e 7369 6f6e 283a 292c  ), dimension(:),
+00017170: 2061 6c6c 6f63 6174 6162 6c65 2c20 696e   allocatable, in
+00017180: 7465 6e74 286f 7574 2920 3a3a 2074 7773  tent(out) :: tws
+00017190: 5f63 6174 6368 5f61 7667 5f64 6f6d 6169  _catch_avg_domai
+000171a0: 6e0a 0a20 2020 2021 2065 7874 7261 6374  n..    ! extract
+000171b0: 6564 206d 6561 7375 7265 640a 2020 2020  ed measured.    
+000171c0: 7265 616c 2864 7029 2c20 6469 6d65 6e73  real(dp), dimens
+000171d0: 696f 6e28 3a29 2c20 616c 6c6f 6361 7461  ion(:), allocata
+000171e0: 626c 652c 2069 6e74 656e 7428 6f75 7429  ble, intent(out)
+000171f0: 203a 3a20 7477 735f 6f70 7469 5f63 6174   :: tws_opti_cat
+00017200: 6368 5f61 7667 5f64 6f6d 6169 6e0a 0a20  ch_avg_domain.. 
+00017210: 2020 2021 206d 6173 6b20 6f66 206e 6f20     ! mask of no 
+00017220: 6461 7461 2076 616c 7565 730a 2020 2020  data values.    
+00017230: 6c6f 6769 6361 6c2c 2064 696d 656e 7369  logical, dimensi
+00017240: 6f6e 283a 292c 2061 6c6c 6f63 6174 6162  on(:), allocatab
+00017250: 6c65 2c20 696e 7465 6e74 286f 7574 2920  le, intent(out) 
+00017260: 3a3a 206d 6173 6b5f 7469 6d65 730a 0a20  :: mask_times.. 
+00017270: 2020 2021 206c 6f63 616c 0a20 2020 2021     ! local.    !
+00017280: 2074 696d 6520 6c6f 6f70 2063 6f75 6e74   time loop count
+00017290: 6572 0a20 2020 2069 6e74 6567 6572 2869  er.    integer(i
+000172a0: 3429 203a 3a20 6954 696d 650a 0a20 2020  4) :: iTime..   
+000172b0: 2021 2061 6c6c 6f63 6174 650a 2020 2020   ! allocate.    
+000172c0: 616c 6c6f 6361 7465 286d 6173 6b5f 7469  allocate(mask_ti
+000172d0: 6d65 7320 2020 2020 2020 2020 2020 2020  mes             
+000172e0: 2020 2873 697a 6528 7477 734f 7074 6953    (size(twsOptiS
+000172f0: 696d 2869 446f 6d61 696e 2925 6461 7461  im(iDomain)%data
+00017300: 5369 6d2c 2064 696d 203d 2032 2929 290a  Sim, dim = 2))).
+00017310: 2020 2020 616c 6c6f 6361 7465 2874 7773      allocate(tws
+00017320: 5f63 6174 6368 5f61 7667 5f64 6f6d 6169  _catch_avg_domai
+00017330: 6e20 2020 2020 2873 697a 6528 7477 734f  n     (size(twsO
+00017340: 7074 6953 696d 2869 446f 6d61 696e 2925  ptiSim(iDomain)%
+00017350: 6461 7461 5369 6d2c 2064 696d 203d 2032  dataSim, dim = 2
+00017360: 2929 290a 2020 2020 616c 6c6f 6361 7465  ))).    allocate
+00017370: 2874 7773 5f6f 7074 695f 6361 7463 685f  (tws_opti_catch_
+00017380: 6176 675f 646f 6d61 696e 2873 697a 6528  avg_domain(size(
+00017390: 7477 734f 7074 6953 696d 2869 446f 6d61  twsOptiSim(iDoma
+000173a0: 696e 2925 6461 7461 5369 6d2c 2064 696d  in)%dataSim, dim
+000173b0: 203d 2032 2929 290a 0a20 2020 2021 2069   = 2)))..    ! i
+000173c0: 6e69 7461 6c69 7a65 0a20 2020 206d 6173  nitalize.    mas
+000173d0: 6b5f 7469 6d65 7320 3d20 2e54 5255 452e  k_times = .TRUE.
+000173e0: 0a20 2020 2074 7773 5f63 6174 6368 5f61  .    tws_catch_a
+000173f0: 7667 5f64 6f6d 6169 6e20 3d20 6e6f 6461  vg_domain = noda
+00017400: 7461 5f64 700a 2020 2020 7477 735f 6f70  ta_dp.    tws_op
+00017410: 7469 5f63 6174 6368 5f61 7667 5f64 6f6d  ti_catch_avg_dom
+00017420: 6169 6e20 3d20 6e6f 6461 7461 5f64 700a  ain = nodata_dp.
+00017430: 0a20 2020 2021 2063 616c 6375 6c61 7465  .    ! calculate
+00017440: 2063 6174 6368 6d65 6e74 2061 7665 7261   catchment avera
+00017450: 6765 2065 7661 706f 7472 616e 7370 6972  ge evapotranspir
+00017460: 6174 696f 6e0a 2020 2020 646f 2069 5469  ation.    do iTi
+00017470: 6d65 203d 2031 2c20 7369 7a65 2874 7773  me = 1, size(tws
+00017480: 4f70 7469 5369 6d28 6944 6f6d 6169 6e29  OptiSim(iDomain)
+00017490: 2564 6174 6153 696d 2c20 6469 6d20 3d20  %dataSim, dim = 
+000174a0: 3229 0a0a 2020 2020 2020 2120 6368 6563  2)..      ! chec
+000174b0: 6b20 666f 7220 656e 6f75 6768 2064 6174  k for enough dat
+000174c0: 6120 706f 696e 7473 2069 6e20 7469 6d65  a points in time
+000174d0: 2066 6f72 2063 6f72 7265 6c61 7469 6f6e   for correlation
+000174e0: 0a20 2020 2020 2069 6620 2861 6c6c 282e  .      if (all(.
+000174f0: 4e4f 542e 204c 315f 7477 7361 4f62 7328  NOT. L1_twsaObs(
+00017500: 6944 6f6d 6169 6e29 256d 6173 6b4f 6273  iDomain)%maskObs
+00017510: 283a 2c20 6954 696d 6529 2929 2074 6865  (:, iTime))) the
+00017520: 6e0a 2020 2020 2020 2020 2177 7269 7465  n.        !write
+00017530: 2028 2a2c 2a29 2027 5741 524e 494e 473a   (*,*) 'WARNING:
+00017540: 2065 7420 6461 7461 2061 7420 7469 6d65   et data at time
+00017550: 2027 2c20 6954 696d 652c 2027 2069 7320   ', iTime, ' is 
+00017560: 656d 7074 792e 270a 2020 2020 2020 2020  empty.'.        
+00017570: 2163 616c 6c20 6d65 7373 6167 6528 2757  !call message('W
+00017580: 4152 4e49 4e47 3a20 6f62 6a65 6374 6976  ARNING: objectiv
+00017590: 655f 6574 5f6b 6765 5f63 6174 6368 6d65  e_et_kge_catchme
+000175a0: 6e74 5f61 7667 3a20 6967 6e6f 7265 6420  nt_avg: ignored 
+000175b0: 6375 7272 656e 7420 7469 6d65 2073 7465  current time ste
+000175c0: 7020 7369 6e63 6520 6c65 7373 2074 6861  p since less tha
+000175d0: 6e27 290a 2020 2020 2020 2020 2163 616c  n').        !cal
+000175e0: 6c20 6d65 7373 6167 6528 2720 2020 2020  l message('     
+000175f0: 2020 2020 3130 2076 616c 6964 2063 656c      10 valid cel
+00017600: 6c73 2061 7661 696c 6162 6c65 2069 6e20  ls available in 
+00017610: 6576 6170 6f74 7261 6e73 7069 7261 7469  evapotranspirati
+00017620: 6f6e 206f 6273 6572 7661 7469 6f6e 2729  on observation')
+00017630: 0a20 2020 2020 2020 206d 6173 6b5f 7469  .        mask_ti
+00017640: 6d65 7328 6954 696d 6529 203d 202e 4641  mes(iTime) = .FA
+00017650: 4c53 452e 0a20 2020 2020 2020 2063 7963  LSE..        cyc
+00017660: 6c65 0a20 2020 2020 2065 6e64 2069 660a  le.      end if.
+00017670: 0a20 2020 2020 2074 7773 5f63 6174 6368  .      tws_catch
+00017680: 5f61 7667 5f64 6f6d 6169 6e28 6954 696d  _avg_domain(iTim
+00017690: 6529 203d 2061 7665 7261 6765 284c 315f  e) = average(L1_
+000176a0: 7477 7361 4f62 7328 6944 6f6d 6169 6e29  twsaObs(iDomain)
+000176b0: 2564 6174 614f 6273 283a 2c20 6954 696d  %dataObs(:, iTim
+000176c0: 6529 2c20 260a 2020 2020 2020 2020 2020  e), &.          
+000176d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000176e0: 2020 2020 2020 2020 2020 206d 6173 6b20             mask 
+000176f0: 3d20 4c31 5f74 7773 614f 6273 2869 446f  = L1_twsaObs(iDo
+00017700: 6d61 696e 2925 6d61 736b 4f62 7328 3a2c  main)%maskObs(:,
+00017710: 2069 5469 6d65 2929 0a20 2020 2020 2074   iTime)).      t
+00017720: 7773 5f6f 7074 695f 6361 7463 685f 6176  ws_opti_catch_av
+00017730: 675f 646f 6d61 696e 2869 5469 6d65 2920  g_domain(iTime) 
+00017740: 3d20 6176 6572 6167 6528 7477 734f 7074  = average(twsOpt
+00017750: 6953 696d 2869 446f 6d61 696e 2925 6461  iSim(iDomain)%da
+00017760: 7461 5369 6d28 3a2c 2069 5469 6d65 292c  taSim(:, iTime),
+00017770: 2026 0a20 2020 2020 2020 2020 2020 2020   &.             
+00017780: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017790: 2020 2020 2020 2020 6d61 736b 203d 204c          mask = L
+000177a0: 315f 7477 7361 4f62 7328 6944 6f6d 6169  1_twsaObs(iDomai
+000177b0: 6e29 256d 6173 6b4f 6273 283a 2c20 6954  n)%maskObs(:, iT
+000177c0: 696d 6529 290a 2020 2020 656e 6420 646f  ime)).    end do
+000177d0: 0a0a 2020 656e 6420 7375 6272 6f75 7469  ..  end subrouti
+000177e0: 6e65 2063 7265 6174 655f 646f 6d61 696e  ne create_domain
+000177f0: 5f61 7667 5f74 7773 0a0a 2020 7375 6272  _avg_tws..  subr
+00017800: 6f75 7469 6e65 2063 7265 6174 655f 646f  outine create_do
+00017810: 6d61 696e 5f61 7667 5f65 7428 6944 6f6d  main_avg_et(iDom
+00017820: 6169 6e2c 2065 744f 7074 6953 696d 2c20  ain, etOptiSim, 
+00017830: 6574 5f63 6174 6368 5f61 7667 5f64 6f6d  et_catch_avg_dom
+00017840: 6169 6e2c 2026 0a20 2020 2020 2020 2020  ain, &.         
+00017850: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017860: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017870: 2020 6574 5f6f 7074 695f 6361 7463 685f    et_opti_catch_
+00017880: 6176 675f 646f 6d61 696e 2c20 6d61 736b  avg_domain, mask
+00017890: 5f74 696d 6573 290a 2020 2020 7573 6520  _times).    use 
+000178a0: 6d6f 5f6f 7074 696d 697a 6174 696f 6e5f  mo_optimization_
+000178b0: 7479 7065 732c 206f 6e6c 7920 3a20 6f70  types, only : op
+000178c0: 7469 6461 7461 5f73 696d 0a20 2020 2075  tidata_sim.    u
+000178d0: 7365 206d 6f5f 636f 6d6d 6f6e 5f63 6f6e  se mo_common_con
+000178e0: 7374 616e 7473 2c20 6f6e 6c79 203a 206e  stants, only : n
+000178f0: 6f64 6174 615f 6470 0a20 2020 2075 7365  odata_dp.    use
+00017900: 206d 6f5f 676c 6f62 616c 5f76 6172 6961   mo_global_varia
+00017910: 626c 6573 2c20 6f6e 6c79 203a 204c 315f  bles, only : L1_
+00017920: 6574 4f62 730a 2020 2020 7573 6520 6d6f  etObs.    use mo
+00017930: 5f6d 6f6d 656e 742c 206f 6e6c 7920 3a20  _moment, only : 
+00017940: 6176 6572 6167 650a 2020 2020 2120 6375  average.    ! cu
+00017950: 7272 656e 7420 646f 6d61 696e 2049 640a  rrent domain Id.
+00017960: 2020 2020 696e 7465 6765 7228 6934 292c      integer(i4),
+00017970: 2069 6e74 656e 7428 696e 2920 3a3a 2069   intent(in) :: i
+00017980: 446f 6d61 696e 0a0a 2020 2020 2120 7369  Domain..    ! si
+00017990: 6d75 6c61 7465 6420 6574 0a20 2020 2074  mulated et.    t
+000179a0: 7970 6528 6f70 7469 6461 7461 5f73 696d  ype(optidata_sim
+000179b0: 292c 2064 696d 656e 7369 6f6e 283a 292c  ), dimension(:),
+000179c0: 2069 6e74 656e 7428 696e 2920 3a3a 2065   intent(in) :: e
+000179d0: 744f 7074 6953 696d 0a0a 2020 2020 2120  tOptiSim..    ! 
+000179e0: 6167 6772 6567 6174 6564 2073 696d 756c  aggregated simul
+000179f0: 6174 6564 0a20 2020 2072 6561 6c28 6470  ated.    real(dp
+00017a00: 292c 2064 696d 656e 7369 6f6e 283a 292c  ), dimension(:),
+00017a10: 2061 6c6c 6f63 6174 6162 6c65 2c20 696e   allocatable, in
+00017a20: 7465 6e74 286f 7574 2920 3a3a 2065 745f  tent(out) :: et_
+00017a30: 6361 7463 685f 6176 675f 646f 6d61 696e  catch_avg_domain
+00017a40: 0a0a 2020 2020 2120 6578 7472 6163 7465  ..    ! extracte
+00017a50: 6420 6d65 6173 7572 6564 0a20 2020 2072  d measured.    r
+00017a60: 6561 6c28 6470 292c 2064 696d 656e 7369  eal(dp), dimensi
+00017a70: 6f6e 283a 292c 2061 6c6c 6f63 6174 6162  on(:), allocatab
+00017a80: 6c65 2c20 696e 7465 6e74 286f 7574 2920  le, intent(out) 
+00017a90: 3a3a 2065 745f 6f70 7469 5f63 6174 6368  :: et_opti_catch
+00017aa0: 5f61 7667 5f64 6f6d 6169 6e0a 0a20 2020  _avg_domain..   
+00017ab0: 2021 206d 6173 6b20 6f66 206e 6f20 6461   ! mask of no da
+00017ac0: 7461 2076 616c 7565 730a 2020 2020 6c6f  ta values.    lo
+00017ad0: 6769 6361 6c2c 2064 696d 656e 7369 6f6e  gical, dimension
+00017ae0: 283a 292c 2061 6c6c 6f63 6174 6162 6c65  (:), allocatable
+00017af0: 2c20 696e 7465 6e74 286f 7574 2920 3a3a  , intent(out) ::
+00017b00: 206d 6173 6b5f 7469 6d65 730a 0a20 2020   mask_times..   
+00017b10: 2021 206c 6f63 616c 0a20 2020 2021 2074   ! local.    ! t
+00017b20: 696d 6520 6c6f 6f70 2063 6f75 6e74 6572  ime loop counter
+00017b30: 0a20 2020 2069 6e74 6567 6572 2869 3429  .    integer(i4)
+00017b40: 203a 3a20 6954 696d 650a 0a20 2020 2021   :: iTime..    !
+00017b50: 2061 6c6c 6f63 6174 650a 2020 2020 616c   allocate.    al
+00017b60: 6c6f 6361 7465 286d 6173 6b5f 7469 6d65  locate(mask_time
+00017b70: 7320 2020 2020 2020 2020 2020 2020 2028  s              (
+00017b80: 7369 7a65 2865 744f 7074 6953 696d 2869  size(etOptiSim(i
+00017b90: 446f 6d61 696e 2925 6461 7461 5369 6d2c  Domain)%dataSim,
+00017ba0: 2064 696d 203d 2032 2929 290a 2020 2020   dim = 2))).    
+00017bb0: 616c 6c6f 6361 7465 2865 745f 6361 7463  allocate(et_catc
+00017bc0: 685f 6176 675f 646f 6d61 696e 2020 2020  h_avg_domain    
+00017bd0: 2028 7369 7a65 2865 744f 7074 6953 696d   (size(etOptiSim
+00017be0: 2869 446f 6d61 696e 2925 6461 7461 5369  (iDomain)%dataSi
+00017bf0: 6d2c 2064 696d 203d 2032 2929 290a 2020  m, dim = 2))).  
+00017c00: 2020 616c 6c6f 6361 7465 2865 745f 6f70    allocate(et_op
+00017c10: 7469 5f63 6174 6368 5f61 7667 5f64 6f6d  ti_catch_avg_dom
+00017c20: 6169 6e28 7369 7a65 2865 744f 7074 6953  ain(size(etOptiS
+00017c30: 696d 2869 446f 6d61 696e 2925 6461 7461  im(iDomain)%data
+00017c40: 5369 6d2c 2064 696d 203d 2032 2929 290a  Sim, dim = 2))).
+00017c50: 0a20 2020 2021 2069 6e69 7461 6c69 7a65  .    ! initalize
+00017c60: 0a20 2020 206d 6173 6b5f 7469 6d65 7320  .    mask_times 
+00017c70: 3d20 2e54 5255 452e 0a20 2020 2065 745f  = .TRUE..    et_
+00017c80: 6361 7463 685f 6176 675f 646f 6d61 696e  catch_avg_domain
+00017c90: 203d 206e 6f64 6174 615f 6470 0a20 2020   = nodata_dp.   
+00017ca0: 2065 745f 6f70 7469 5f63 6174 6368 5f61   et_opti_catch_a
+00017cb0: 7667 5f64 6f6d 6169 6e20 3d20 6e6f 6461  vg_domain = noda
+00017cc0: 7461 5f64 700a 0a20 2020 2021 2063 616c  ta_dp..    ! cal
+00017cd0: 6375 6c61 7465 2063 6174 6368 6d65 6e74  culate catchment
+00017ce0: 2061 7665 7261 6765 2065 7661 706f 7472   average evapotr
+00017cf0: 616e 7370 6972 6174 696f 6e0a 2020 2020  anspiration.    
+00017d00: 646f 2069 5469 6d65 203d 2031 2c20 7369  do iTime = 1, si
+00017d10: 7a65 2865 744f 7074 6953 696d 2869 446f  ze(etOptiSim(iDo
+00017d20: 6d61 696e 2925 6461 7461 5369 6d2c 2064  main)%dataSim, d
+00017d30: 696d 203d 2032 290a 0a20 2020 2020 2021  im = 2)..      !
+00017d40: 2063 6865 636b 2066 6f72 2065 6e6f 7567   check for enoug
+00017d50: 6820 6461 7461 2070 6f69 6e74 7320 696e  h data points in
+00017d60: 2074 696d 6520 666f 7220 636f 7272 656c   time for correl
+00017d70: 6174 696f 6e0a 2020 2020 2020 6966 2028  ation.      if (
+00017d80: 616c 6c28 2e4e 4f54 2e20 4c31 5f65 744f  all(.NOT. L1_etO
+00017d90: 6273 2869 446f 6d61 696e 2925 6d61 736b  bs(iDomain)%mask
+00017da0: 4f62 7328 3a2c 2069 5469 6d65 2929 2920  Obs(:, iTime))) 
+00017db0: 7468 656e 0a20 2020 2020 2020 2021 7772  then.        !wr
+00017dc0: 6974 6520 282a 2c2a 2920 2757 4152 4e49  ite (*,*) 'WARNI
+00017dd0: 4e47 3a20 6574 2064 6174 6120 6174 2074  NG: et data at t
+00017de0: 696d 6520 272c 2069 5469 6d65 2c20 2720  ime ', iTime, ' 
+00017df0: 6973 2065 6d70 7479 2e27 0a20 2020 2020  is empty.'.     
+00017e00: 2020 2021 6361 6c6c 206d 6573 7361 6765     !call message
+00017e10: 2827 5741 524e 494e 473a 206f 626a 6563  ('WARNING: objec
+00017e20: 7469 7665 5f65 745f 6b67 655f 6361 7463  tive_et_kge_catc
+00017e30: 686d 656e 745f 6176 673a 2069 676e 6f72  hment_avg: ignor
+00017e40: 6564 2063 7572 7265 6e74 2074 696d 6520  ed current time 
+00017e50: 7374 6570 2073 696e 6365 206c 6573 7320  step since less 
+00017e60: 7468 616e 2729 0a20 2020 2020 2020 2021  than').        !
+00017e70: 6361 6c6c 206d 6573 7361 6765 2827 2020  call message('  
+00017e80: 2020 2020 2020 2031 3020 7661 6c69 6420         10 valid 
+00017e90: 6365 6c6c 7320 6176 6169 6c61 626c 6520  cells available 
+00017ea0: 696e 2065 7661 706f 7472 616e 7370 6972  in evapotranspir
+00017eb0: 6174 696f 6e20 6f62 7365 7276 6174 696f  ation observatio
+00017ec0: 6e27 290a 2020 2020 2020 2020 6d61 736b  n').        mask
+00017ed0: 5f74 696d 6573 2869 5469 6d65 2920 3d20  _times(iTime) = 
+00017ee0: 2e46 414c 5345 2e0a 2020 2020 2020 2020  .FALSE..        
+00017ef0: 6379 636c 650a 2020 2020 2020 656e 6420  cycle.      end 
+00017f00: 6966 0a0a 2020 2020 2020 6574 5f63 6174  if..      et_cat
+00017f10: 6368 5f61 7667 5f64 6f6d 6169 6e28 6954  ch_avg_domain(iT
+00017f20: 696d 6529 203d 2061 7665 7261 6765 284c  ime) = average(L
+00017f30: 315f 6574 4f62 7328 6944 6f6d 6169 6e29  1_etObs(iDomain)
+00017f40: 2564 6174 614f 6273 283a 2c20 6954 696d  %dataObs(:, iTim
+00017f50: 6529 2c20 260a 2020 2020 2020 2020 2020  e), &.          
+00017f60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017f70: 2020 2020 2020 2020 2020 6d61 736b 203d            mask =
+00017f80: 204c 315f 6574 4f62 7328 6944 6f6d 6169   L1_etObs(iDomai
+00017f90: 6e29 256d 6173 6b4f 6273 283a 2c20 6954  n)%maskObs(:, iT
+00017fa0: 696d 6529 290a 2020 2020 2020 6574 5f6f  ime)).      et_o
+00017fb0: 7074 695f 6361 7463 685f 6176 675f 646f  pti_catch_avg_do
+00017fc0: 6d61 696e 2869 5469 6d65 2920 3d20 6176  main(iTime) = av
+00017fd0: 6572 6167 6528 6574 4f70 7469 5369 6d28  erage(etOptiSim(
+00017fe0: 6944 6f6d 6169 6e29 2564 6174 6153 696d  iDomain)%dataSim
+00017ff0: 283a 2c20 6954 696d 6529 2c20 260a 2020  (:, iTime), &.  
+00018000: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018010: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018020: 2020 2020 2020 2020 6d61 736b 203d 204c          mask = L
+00018030: 315f 6574 4f62 7328 6944 6f6d 6169 6e29  1_etObs(iDomain)
+00018040: 256d 6173 6b4f 6273 283a 2c20 6954 696d  %maskObs(:, iTim
+00018050: 6529 290a 2020 2020 656e 6420 646f 0a0a  e)).    end do..
+00018060: 2020 656e 6420 7375 6272 6f75 7469 6e65    end subroutine
+00018070: 2063 7265 6174 655f 646f 6d61 696e 5f61   create_domain_a
+00018080: 7667 5f65 740a 0a20 2073 7562 726f 7574  vg_et..  subrout
+00018090: 696e 6520 636f 6e76 6572 745f 7477 735f  ine convert_tws_
+000180a0: 746f 5f74 7773 6128 7477 734f 7074 6953  to_twsa(twsOptiS
+000180b0: 696d 2c20 4c31 5f74 7773 614f 6273 2c20  im, L1_twsaObs, 
+000180c0: 7477 7361 4f70 7469 5369 6d29 0a20 2020  twsaOptiSim).   
+000180d0: 2075 7365 206d 6f5f 6f70 7469 6d69 7a61   use mo_optimiza
+000180e0: 7469 6f6e 5f74 7970 6573 2c20 6f6e 6c79  tion_types, only
+000180f0: 203a 206f 7074 6964 6174 615f 7369 6d2c   : optidata_sim,
+00018100: 206f 7074 6964 6174 610a 2020 2020 7573   optidata.    us
+00018110: 6520 6d6f 5f6d 6f6d 656e 742c 206f 6e6c  e mo_moment, onl
+00018120: 7920 3a20 6176 6572 6167 650a 2020 2020  y : average.    
+00018130: 2120 7369 6d75 6c61 7465 6420 7477 730a  ! simulated tws.
+00018140: 2020 2020 7479 7065 286f 7074 6964 6174      type(optidat
+00018150: 615f 7369 6d29 2c20 696e 7465 6e74 2869  a_sim), intent(i
+00018160: 6e29 2020 2020 3a3a 2074 7773 4f70 7469  n)    :: twsOpti
+00018170: 5369 6d0a 2020 2020 2120 6f62 7365 7276  Sim.    ! observ
+00018180: 6564 2074 7773 610a 2020 2020 7479 7065  ed twsa.    type
+00018190: 286f 7074 6964 6174 6129 2c20 2020 2020  (optidata),     
+000181a0: 696e 7465 6e74 2869 6e29 2020 2020 3a3a  intent(in)    ::
+000181b0: 204c 315f 7477 7361 4f62 730a 2020 2020   L1_twsaObs.    
+000181c0: 2120 7369 6d75 6c61 7465 6420 7477 7361  ! simulated twsa
+000181d0: 0a20 2020 2074 7970 6528 6f70 7469 6461  .    type(optida
+000181e0: 7461 5f73 696d 292c 2069 6e74 656e 7428  ta_sim), intent(
+000181f0: 696e 6f75 7429 203a 3a20 7477 7361 4f70  inout) :: twsaOp
+00018200: 7469 5369 6d0a 0a20 2020 2021 206c 6f63  tiSim..    ! loc
+00018210: 616c 0a20 2020 2069 6e74 6567 6572 2869  al.    integer(i
+00018220: 3429 203a 3a20 6943 656c 6c0a 2020 2020  4) :: iCell.    
+00018230: 7265 616c 2864 7029 2020 2020 3a3a 2074  real(dp)    :: t
+00018240: 7773 615f 6176 5f63 656c 6c0a 0a20 2020  wsa_av_cell..   
+00018250: 2061 6c6c 6f63 6174 6528 7477 7361 4f70   allocate(twsaOp
+00018260: 7469 5369 6d25 6461 7461 5369 6d28 7369  tiSim%dataSim(si
+00018270: 7a65 2874 7773 4f70 7469 5369 6d25 6461  ze(twsOptiSim%da
+00018280: 7461 5369 6d28 3a2c 203a 292c 2064 696d  taSim(:, :), dim
+00018290: 203d 2031 292c 2073 697a 6528 7477 734f   = 1), size(twsO
+000182a0: 7074 6953 696d 2564 6174 6153 696d 283a  ptiSim%dataSim(:
+000182b0: 2c20 3a29 2c20 6469 6d20 3d20 3229 2929  , :), dim = 2)))
+000182c0: 0a0a 2020 2020 646f 2069 4365 6c6c 203d  ..    do iCell =
+000182d0: 2031 2c20 7369 7a65 2874 7773 4f70 7469   1, size(twsOpti
+000182e0: 5369 6d25 6461 7461 5369 6d28 3a2c 203a  Sim%dataSim(:, :
+000182f0: 292c 2064 696d 203d 2031 290a 2020 2020  ), dim = 1).    
+00018300: 2020 7477 7361 5f61 765f 6365 6c6c 203d    twsa_av_cell =
+00018310: 2061 7665 7261 6765 2874 7773 4f70 7469   average(twsOpti
+00018320: 5369 6d25 6461 7461 5369 6d28 6943 656c  Sim%dataSim(iCel
+00018330: 6c2c 203a 292c 206d 6173 6b20 3d20 4c31  l, :), mask = L1
+00018340: 5f74 7773 614f 6273 256d 6173 6b4f 6273  _twsaObs%maskObs
+00018350: 2869 4365 6c6c 2c20 3a29 290a 2020 2020  (iCell, :)).    
+00018360: 2020 7477 7361 4f70 7469 5369 6d25 6461    twsaOptiSim%da
+00018370: 7461 5369 6d28 6943 656c 6c2c 203a 2920  taSim(iCell, :) 
+00018380: 3d20 7477 734f 7074 6953 696d 2564 6174  = twsOptiSim%dat
+00018390: 6153 696d 2869 4365 6c6c 2c20 3a29 202d  aSim(iCell, :) -
+000183a0: 2074 7773 615f 6176 5f63 656c 6c0a 2020   twsa_av_cell.  
+000183b0: 2020 656e 6420 646f 0a0a 2020 656e 6420    end do..  end 
+000183c0: 7375 6272 6f75 7469 6e65 2063 6f6e 7665  subroutine conve
+000183d0: 7274 5f74 7773 5f74 6f5f 7477 7361 0a0a  rt_tws_to_twsa..
+000183e0: 454e 4420 4d4f 4455 4c45 206d 6f5f 6f62  END MODULE mo_ob
+000183f0: 6a65 6374 6976 655f 6675 6e63 7469 6f6e  jective_function
+00018400: 0a                                       .
```

### Comparing `mhm-5.12.1.dev21/src/mHM/mo_pet.f90` & `mhm-5.13.0/src/mHM/mo_pet.f90`

 * *Files 2% similar despite different names*

```diff
@@ -1,22 +1,21 @@
-!>       \file mo_pet.f90
-
-!>       \brief Module for calculating reference/potential evapotranspiration  [mm d-1]
-
-!>       \details This module calculates PET [mm/d] based on one of the methods
-!>       - Hargreaves-Samani (1982)
-!>       - Priestly-Taylor (1972)
-!>       - Penman-Monteith FAO (1998)
-
-!>       \authors Matthias Zink, Christoph Schneider, Matthias Cuntz
-
-!>       \date Apr 2014
-
-! Modifications:
-
+!> \file mo_pet.f90
+!> \brief   \copybrief mo_pet
+!> \details \copydetails mo_pet
+
+!> \brief Module for calculating reference/potential evapotranspiration  [mm d-1]
+!> \details This module calculates PET [mm/d] based on one of the methods
+!!       - Hargreaves-Samani (1982)
+!!       - Priestly-Taylor (1972)
+!!       - Penman-Monteith FAO (1998)
+!> \authors Matthias Zink, Christoph Schneider, Matthias Cuntz
+!> \date Apr 2014
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mhm
 MODULE mo_pet
 
   ! This module is for the UFZ CHS mesoscale hydrologic model mHM.
 
   USE mo_kind, ONLY : i4, dp
 
   IMPLICIT NONE
```

### Comparing `mhm-5.12.1.dev21/src/mHM/mo_read_optional_data.f90` & `mhm-5.13.0/src/mHM/mo_read_optional_data.f90`

 * *Files 8% similar despite different names*

```diff
@@ -1,19 +1,18 @@
-!>       \file mo_read_optional_data.f90
-
-!>       \brief Read optional data for mHM calibration.
-
-!>       \details Data have to be provided in resolution of the hydrology.
-
-!>       \authors Matthias Zink
-
-!>       \date Mar 2015
-
-! Modifications:
-
+!> \file mo_read_optional_data.f90
+!> \brief   \copybrief mo_read_optional_data
+!> \details \copydetails mo_read_optional_data
+
+!> \brief Read optional data for mHM calibration.
+!> \details Data have to be provided in resolution of the hydrology.
+!> \authors Matthias Zink
+!> \date Mar 2015
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mhm
 MODULE mo_read_optional_data
 
   USE mo_kind, ONLY : i4, dp
 
   IMPLICIT NONE
 
   PRIVATE
@@ -49,16 +48,14 @@
   ! Modifications:
   ! Robert Schweppe Jun 2018 - refactoring and reformatting
   ! Maren Kaluza Oct 2019 - copied from evapotranspiration and adopted for tws
   ! Maren Kaluza Nov 2019 - removed redundant code, reading works for any gridded optidata
 
   subroutine readOptidataObs(iDomain, domainID, L1_optiObs)
 
-    use mo_append, only : append
-    use mo_common_constants, only : nodata_dp
     use mo_common_mhm_mrm_variables, only : evalPer
     use mo_common_variables, only : level1
     use mo_optimization_types, only: optidata
     use mo_message, only : message
     use mo_read_nc, only : read_nc
     use mo_string_utils, only : num2str
     use mo_timer, only : timer_get, timer_start, &
```

### Comparing `mhm-5.12.1.dev21/src/mHM/mo_restart.f90` & `mhm-5.13.0/src/mHM/mo_restart.f90`

 * *Files 17% similar despite different names*

```diff
@@ -1,110 +1,64 @@
-!>       \file mo_restart.f90
-
-!>       \brief reading and writing states, fluxes and configuration for restart of mHM.
-
-!>       \details routines are seperated for reading and writing variables for:
-!>       - states and fluxes, and
-!>       - configuration.
-!>       Reading of L11 configuration is also seperated from the rest,
-!>       since it is only required when routing is activated.
-
-!>       \authors Stephan Thober
-
-!>       \date Jul 2013
-
-! Modifications:
-
+!> \file mo_restart.f90
+!> \brief   \copybrief mo_restart
+!> \details \copydetails mo_restart
+
+!> \brief reading and writing states, fluxes and configuration for restart of mHM.
+!> \details routines are seperated for reading and writing variables for:
+!!       - states and fluxes, and
+!!       - configuration.
+!!
+!! Reading of L11 configuration is also seperated from the rest,
+!! since it is only required when routing is activated.
+!> \authors Stephan Thober
+!> \date Jul 2013
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mhm
 MODULE mo_restart
 
-  ! This module is a restart for the UFZ CHS mesoscale hydrologic model mHM.
-
-  ! Written  Stephan Thober, Apr 2011
   use mo_common_constants, only : soilHorizonsVarName, landCoverPeriodsVarName, LAIVarName
 
   IMPLICIT NONE
 
   PRIVATE
 
   PUBLIC :: read_restart_states     ! read restart files for state variables from a given path
   PUBLIC :: write_restart_files     ! write restart files for configuration to a given path
 
-  !    NAME
-  !        unpack_field_and_write
-
-  !    PURPOSE
-  !>       \brief TODO: add description
-
-  !>       \details TODO: add description
-
-  !    INTENT(INOUT)
-  !>       \param[inout] "type(NcDataset) :: nc" NcDataset to add variable to
-
-  !    INTENT(IN)
-  !>       \param[in] "character(*) :: var_name"                    variable name
-  !>       \param[in] "type(NcDimension), dimension(:) :: var_dims" vector of Variable dimensions
-  !>       \param[in] "integer(i4) :: fill_value"                   fill value used for missing values
-  !>       \param[in] "integer(i4), dimension(:) :: data"           packed data to be set to variable
-  !>       \param[in] "logical, dimension(:, :) :: mask"            mask used for unpacking
-
-  !    INTENT(IN), OPTIONAL
-  !>       \param[in] "character(*), optional :: var_long_name" variable long name attribute
-
-  !    HISTORY
-  !>       \authors Robert Schweppe
-
-  !>       \date Jun 2018
-
-  ! Modifications:
-
-
-  INTERFACE unpack_field_and_write
-    MODULE PROCEDURE unpack_field_and_write_1d_i4, &
-            unpack_field_and_write_1d_dp, &
-            unpack_field_and_write_2d_dp, &
-            unpack_field_and_write_3d_dp
-  end interface unpack_field_and_write
-
-
 CONTAINS
-  ! ------------------------------------------------------------------
-
-  !    NAME
-  !        write_restart_files
-
-  !    PURPOSE
-  !>       \brief write restart files for each domain
-
-  !>       \details write restart files for each domain. For each domain
-  !>       three restart files are written. These are xxx_states.nc,
-  !>       xxx_L11_config.nc, and xxx_config.nc (xxx being the three digit
-  !>       domain index). If a variable is added here, it should also be added
-  !>       in the read restart routines below.
-
-  !    INTENT(IN)
-  !>       \param[in] "character(256), dimension(:) :: OutFile" Output Path for each domain
-
-  !    HISTORY
-  !>       \authors Stephan Thober
-
-  !>       \date Jun 2014
-
-  ! Modifications:
-  ! Stephan Thober     Aug  2015 - moved write of routing states to mRM
-  ! David Schaefer     Nov  2015 - mo_netcdf
-  ! Stephan Thober     Nov  2016 - moved processMatrix to common variables
-  ! Zink M. Demirel C. Mar 2017 - Added Jarvis soil water stress function at SM process(3)
-  ! Robert Schweppe    Feb 2018 - Removed all L0 references
-  ! Robert Schweppe Jun 2018 - refactoring and reformatting
 
+  !> \brief write restart files for each domain
+  !> \details write restart files for each domain. For each domain
+  !! three restart files are written. These are xxx_states.nc,
+  !! xxx_L11_config.nc, and xxx_config.nc (xxx being the three digit
+  !! domain index). If a variable is added here, it should also be added
+  !! in the read restart routines below.
+  !> \changelog
+  !! - Stephan Thober     Aug  2015
+  !!   - moved write of routing states to mRM
+  !! - David Schaefer     Nov  2015
+  !!   - mo_netcdf
+  !! - Stephan Thober     Nov  2016
+  !!   - moved processMatrix to common variables
+  !! - Zink M. Demirel C. Mar 2017
+  !!   - Added Jarvis soil water stress function at SM process(3)
+  !! - Robert Schweppe    Feb 2018
+  !!   - Removed all L0 references
+  !! - Robert Schweppe    Jun 2018
+  !!   - refactoring and reformatting
+  !! - Stephan Thober     Dec 2022
+  !!   - added grid info for level0
+  !> \authors Stephan Thober
+  !> \date Jun 2014
   subroutine write_restart_files(OutFile)
 
     use mo_common_constants, only : nodata_dp
     use mo_common_restart, only : write_grid_info
-    use mo_common_variables, only : level1, nLCoverScene, domainMeta, LC_year_start, LC_year_end
+    use mo_common_variables, only : level0, level1, nLCoverScene, domainMeta, LC_year_start, LC_year_end
     use mo_global_variables, only : L1_Inter, L1_Throughfall, L1_aETCanopy, L1_aETSealed, L1_aETSoil, L1_baseflow, &
                                     L1_fastRunoff, L1_infilSoil, L1_melt, L1_percol, L1_preEffect, L1_rain, &
                                     L1_runoffSeal, L1_satSTW, L1_sealSTW, L1_slowRunoff, L1_snow, L1_snowPack, &
                                     L1_soilMoist, L1_total_runoff, L1_unsatSTW
 
     use mo_kind, only : dp, i4
     use mo_message, only : message
@@ -156,14 +110,15 @@
       Fname = trim(OutFile(iDomain))
       ! print a message
       call message("    Writing Restart-file: ", trim(adjustl(Fname)), " ...")
 
       nc = NcDataset(fname, "w")
 
       call write_grid_info(level1(iDomain), "1", nc)
+      call write_grid_info(level0(domainMeta%L0DataFrom(iDomain)), "0", nc)
 
       rows1 = nc%getDimension("nrows1")
       cols1 = nc%getDimension("ncols1")
 
       ! write the dimension to the file and also save bounds
       allocate(dummy_1D(nSoilHorizons_mHM+1))
       dummy_1D(1) = 0.0_dp
@@ -310,42 +265,34 @@
       call nc%close()
 
       deallocate(dummy_3D, mask1)
     end do domain_loop
 
   end subroutine write_restart_files
 
-  ! ------------------------------------------------------------------
-
-  !    NAME
-  !        read_restart_states
-
-  !    PURPOSE
-  !>       \brief reads fluxes and state variables from file
-
-  !>       \details read fluxes and state variables from given
-  !>       restart directory and initialises all state variables
-  !>       that are initialized in the subroutine initialise,
-  !>       contained in module mo_startup.
-
-  !    INTENT(IN)
-  !>       \param[in] "integer(i4) :: iDomain"    number of domains
-  !>       \param[in] "character(256) :: InFile" Input Path including trailing slash
-
-  !    HISTORY
-  !>       \authors Stephan Thober
-
-  !>       \date Apr 2013
-
-  ! Modifications:
-  ! Stephan Thober Aug  2015 - moved read of routing states to mRM
-  ! David Schaefer Nov  2015 - mo_netcdf
-  ! Stephan Thober Nov  2016 - moved processMatrix to common variables
-  ! Robert Schweppe Jun 2018 - refactoring and reformatting
 
+  !> \brief reads fluxes and state variables from file
+  !> \details read fluxes and state variables from given
+  !! restart directory and initialises all state variables
+  !! that are initialized in the subroutine initialise,
+  !! contained in module mo_startup.
+  !> \changelog
+  !! - Stephan Thober Aug  2015
+  !!   - moved read of routing states to mRM
+  !! - David Schaefer Nov  2015
+  !!   - mo_netcdf
+  !! - Stephan Thober Nov  2016
+  !!   - moved processMatrix to common variables
+  !! - Robert Schweppe Jun 2018
+  !!   - refactoring and reformatting
+  !! - Sebastian Mller Mar 2023
+  !!   - compatibility layer for 2D/3D data
+  !!   - move reading of nLAI to mo_startup (needed beforehand)
+  !> \authors Stephan Thober
+  !> \date Apr 2013
   subroutine read_restart_states(iDomain, domainID, InFile)
 
     use mo_common_variables, only : LC_year_end, LC_year_start, level1, nLCoverScene, processMatrix
     use mo_global_variables, only : L1_Inter, L1_Throughfall, L1_aETCanopy, &
                                     L1_aETSealed, L1_aETSoil, L1_baseflow, L1_fastRunoff, L1_infilSoil, L1_melt, &
                                     L1_percol, L1_preEffect, L1_rain, L1_runoffSeal, L1_satSTW, L1_sealSTW, &
                                     L1_slowRunoff, L1_snow, L1_snowPack, L1_soilMoist, L1_total_runoff, L1_unsatSTW
@@ -355,138 +302,61 @@
                                         L1_degDayNoPre, L1_fAsp, L1_fRoots, L1_fSealed, L1_jarvis_thresh_c1, &
                                         L1_kBaseFlow, L1_kPerco, L1_kSlowFlow, L1_karstLoss, L1_kfastFlow, L1_maxInter, &
                                         L1_petLAIcorFactor, L1_sealedThresh, L1_soilMoistExp, L1_soilMoistFC, &
                                         L1_soilMoistSat, L1_surfResist, L1_tempThresh, L1_unsatThresh, L1_wiltingPoint, &
                                         nLAI, nSoilHorizons_mHM, &
                                         ! neutron count
                                         L1_No_Count, L1_bulkDens, L1_latticeWater, L1_COSMICL3
-    
+
     use mo_netcdf, only : NcDataset, NcDimension, NcVariable
     use mo_string_utils, only : num2str
-    use mo_common_mHM_mRM_restart, only: check_dimension_consistency
-    use mo_common_mHM_mRM_variables, only: read_old_style_restart_bounds
+    use mo_message, only: message, error_message
 
     implicit none
 
-    ! number of domain
+    !> number of domain
     integer(i4), intent(in) :: iDomain
-
+    !> ID of domain
     integer(i4), intent(in) :: domainID
-
-    ! Input Path including trailing slash
+    !> Input Path including trailing slash
     character(256), intent(in) :: InFile
 
     character(256) :: Fname
-
+    ! variable rank
+    integer(i4) :: var_rank
     ! loop index
     integer(i4) :: ii, jj
-
     ! start index at level 1
     integer(i4) :: s1
-
     ! end index at level 1
     integer(i4) :: e1
-
     ! mask at level 1
     logical, dimension(:, :), allocatable :: mask1
-
     ! dummy, 2 dimension
-    real(dp), dimension(:, :), allocatable :: dummyD2, dummyD2_tmp
-
+    real(dp), dimension(:, :), allocatable :: dummyD2
     ! dummy, 3 dimension
     real(dp), dimension(:, :, :), allocatable :: dummyD3
-
-    ! dummy, 3 dimension
+    ! dummy, 4 dimension
     real(dp), dimension(:, :, :, :), allocatable :: dummyD4
 
     type(NcDataset) :: nc
-
     type(NcVariable) :: var
 
-    type(NcDimension) :: nc_dim
-
-    integer(i4) :: nSoilHorizons_temp, nLAIs_temp, nLandCoverPeriods_temp
-    real(dp), dimension(:), allocatable :: landCoverPeriodBoundaries_temp, soilHorizonBoundaries_temp, &
-            LAIBoundaries_temp
-
 
     Fname = trim(InFile)
-    ! call message('    Reading states from ', trim(adjustl(Fname)),' ...')
+    call message('    Reading states from ', trim(adjustl(Fname)),' ...')
 
     ! get domain information at level 1
     allocate(mask1 (level1(iDomain)%nrows, level1(iDomain)%ncols))
     mask1 = level1(iDomain)%mask
     s1 = level1(iDomain)%iStart
     e1 = level1(iDomain)%iEnd
 
     nc = NcDataset(fname, "r")
 
-    ! get the dimensions
-    var = nc%getVariable(trim(soilHorizonsVarName)//'_bnds')
-    call var%getData(dummyD2_tmp)
-    if (allocated(dummyD2)) deallocate(dummyD2)
-    if ( read_old_style_restart_bounds ) then
-      allocate(dummyD2(size(dummyD2_tmp,2), size(dummyD2_tmp,1)))
-      dummyD2 = transpose(dummyD2_tmp)
-    else
-      allocate(dummyD2(size(dummyD2_tmp,1), size(dummyD2_tmp,2)))
-      dummyD2 = dummyD2_tmp
-    end if
-    deallocate(dummyD2_tmp)
-    nSoilHorizons_temp = size(dummyD2, 2)
-    allocate(soilHorizonBoundaries_temp(nSoilHorizons_temp+1))
-    soilHorizonBoundaries_temp(1:nSoilHorizons_temp) = dummyD2(1, :)
-    soilHorizonBoundaries_temp(nSoilHorizons_temp+1) = dummyD2(2, nSoilHorizons_temp)
-
-    ! get the landcover dimension
-    var = nc%getVariable(trim(landCoverPeriodsVarName)//'_bnds')
-    call var%getData(dummyD2_tmp)
-    if (allocated(dummyD2)) deallocate(dummyD2)
-    if ( read_old_style_restart_bounds ) then
-      allocate(dummyD2(size(dummyD2_tmp,2), size(dummyD2_tmp,1)))
-      dummyD2 = transpose(dummyD2_tmp)
-    else
-      allocate(dummyD2(size(dummyD2_tmp,1), size(dummyD2_tmp,2)))
-      dummyD2 = dummyD2_tmp
-    end if
-    deallocate(dummyD2_tmp)
-    nLandCoverPeriods_temp = size(dummyD2, 2)
-    allocate(landCoverPeriodBoundaries_temp(nLandCoverPeriods_temp+1))
-    landCoverPeriodBoundaries_temp(1:nLandCoverPeriods_temp) = dummyD2(1, :)
-    landCoverPeriodBoundaries_temp(nLandCoverPeriods_temp+1) = dummyD2(2, nLandCoverPeriods_temp)
-
-    ! get the LAI dimension
-    if (nc%hasVariable(trim(LAIVarName)//'_bnds')) then
-      var = nc%getVariable(trim(LAIVarName)//'_bnds')
-      call var%getData(dummyD2_tmp)
-      if (allocated(dummyD2)) deallocate(dummyD2)
-      if ( read_old_style_restart_bounds ) then
-        allocate(dummyD2(size(dummyD2_tmp,2), size(dummyD2_tmp,1)))
-        dummyD2 = transpose(dummyD2_tmp)
-      else
-        allocate(dummyD2(size(dummyD2_tmp,1), size(dummyD2_tmp,2)))
-        dummyD2 = dummyD2_tmp
-      end if
-      deallocate(dummyD2_tmp)
-      nLAIs_temp = size(dummyD2, 2)
-      allocate(LAIBoundaries_temp(nLAIs_temp+1))
-      LAIBoundaries_temp(1:nLAIs_temp) = dummyD2(1, :)
-      LAIBoundaries_temp(nLAIs_temp+1) = dummyD2(2, nLAIs_temp)
-    else if (nc%hasDimension('L1_LAITimesteps')) then
-      nc_dim = nc%getDimension('L1_LAITimesteps')
-      nLAIs_temp = nc_dim%getLength()
-      allocate(LAIBoundaries_temp(nLAIs_temp+1))
-      LAIBoundaries_temp = [(ii, ii=1, nLAIs_temp+1)]
-    end if
-
-
-    call check_dimension_consistency(iDomain, nSoilHorizons_temp, soilHorizonBoundaries_temp, &
-          nLAIs_temp, LAIBoundaries_temp, nLandCoverPeriods_temp, landCoverPeriodBoundaries_temp)
-
-
     if (nc%hasVariable('L1_Inter')) then
       !-------------------------------------------
       ! STATE VARIABLES (optionally)
       !-------------------------------------------
 
       ! Interception
       var = nc%getVariable("L1_Inter")
@@ -611,16 +481,30 @@
     call var%getData(dummyD3)
     do ii = 1, nLCoverScene
       L1_fSealed(s1 : e1, 1, ii) = pack(dummyD3(:, :, ii), mask1)
     end do
 
     ! exponent for the upper reservoir
     var = nc%getVariable("L1_alpha")
-    call var%getData(dummyD2)
-    L1_alpha(s1 : e1, 1, 1) = pack(dummyD2, mask1)
+    var_rank = var%getrank()
+    select case(var_rank)
+      case(2)
+        ! distribute over all land cover scenes
+        call var%getData(dummyD2)
+        do ii = 1, nLCoverScene
+          L1_alpha(s1 : e1, 1, ii) = pack(dummyD2, mask1)
+        end do
+      case(3)
+        call var%getData(dummyD3)
+        do ii = 1, nLCoverScene
+          L1_alpha(s1 : e1, 1, ii) = pack(dummyD3(:, :, ii), mask1)
+        end do
+      case default
+        call error_message("Restart: L1_alpha rank needs to be 2 or 3")
+    end select
 
     ! increase of the Degree-day factor per mm of increase in precipitation
     var = nc%getVariable("L1_degDayInc")
     call var%getData(dummyD3)
     do ii = 1, nLCoverScene
       L1_degDayInc(s1 : e1, 1, ii) = pack(dummyD3(:, :, ii), mask1)
     end do
@@ -637,18 +521,30 @@
     call var%getData(dummyD3)
     do ii = 1, nLCoverScene
       L1_degDayNoPre(s1 : e1, 1, ii) = pack(dummyD3(:, :, ii), mask1)
     end do
 
     ! degree-day factor
     var = nc%getVariable("L1_degDay")
-    call var%getData(dummyD3)
-    do ii = 1, nLCoverScene
-      L1_degDay(s1 : e1, 1, ii) = pack(dummyD3(:, :, ii), mask1)
-    end do
+    var_rank = var%getrank()
+    select case(var_rank)
+      case(2)
+        ! distribute over all land cover scenes
+        call var%getData(dummyD2)
+        do ii = 1, nLCoverScene
+          L1_degDay(s1 : e1, 1, ii) = pack(dummyD2, mask1)
+        end do
+      case(3)
+        call var%getData(dummyD3)
+        do ii = 1, nLCoverScene
+          L1_degDay(s1 : e1, 1, ii) = pack(dummyD3(:, :, ii), mask1)
+        end do
+      case default
+        call error_message("Restart: L1_degDay rank needs to be 2 or 3")
+    end select
 
     ! Karstic percolation loss
     var = nc%getVariable("L1_karstLoss")
     call var%getData(dummyD2)
     L1_karstLoss(s1 : e1, 1, 1) = pack(dummyD2, mask1)
 
     ! Fraction of roots in soil horizons
@@ -663,35 +559,81 @@
     ! Maximum interception
     var = nc%getVariable("L1_maxInter")
     call var%getData(dummyD3)
     do ii = 1, nLAI
       L1_maxInter(s1 : e1, ii, 1) = pack(dummyD3(:, :, ii), mask1)
     end do
 
-    ! fast interflow recession coefficient
-    var = nc%getVariable("L1_kfastFlow")
+    ! fast interflow recession coefficient ("L1_kFastFlow" or "L1_kfastFlow")
+    if (nc%hasvariable("L1_kFastFlow")) then
+      var = nc%getVariable("L1_kFastFlow")
+    else
+      var = nc%getVariable("L1_kfastFlow")
+    end if
     call var%getData(dummyD3)
     do ii = 1, nLCoverScene
       L1_kfastFlow(s1 : e1, 1, ii) = pack(dummyD3(:, :, ii), mask1)
     end do
 
     ! slow interflow recession coefficient
     var = nc%getVariable("L1_kSlowFlow")
-    call var%getData(dummyD2)
-    L1_kSlowFlow(s1 : e1, 1, 1) = pack(dummyD2, mask1)
+    var_rank = var%getrank()
+    select case(var_rank)
+      case(2)
+        ! distribute over all land cover scenes
+        call var%getData(dummyD2)
+        do ii = 1, nLCoverScene
+          L1_kSlowFlow(s1 : e1, 1, ii) = pack(dummyD2, mask1)
+        end do
+      case(3)
+        call var%getData(dummyD3)
+        do ii = 1, nLCoverScene
+          L1_kSlowFlow(s1 : e1, 1, ii) = pack(dummyD3(:, :, ii), mask1)
+        end do
+      case default
+        call error_message("Restart: L1_kSlowFlow rank needs to be 2 or 3")
+    end select
 
     ! baseflow recession coefficient
     var = nc%getVariable("L1_kBaseFlow")
-    call var%getData(dummyD2)
-    L1_kBaseFlow(s1 : e1, 1, 1) = pack(dummyD2, mask1)
+    var_rank = var%getrank()
+    select case(var_rank)
+      case(2)
+        ! distribute over all land cover scenes
+        call var%getData(dummyD2)
+        do ii = 1, nLCoverScene
+          L1_kBaseFlow(s1 : e1, 1, ii) = pack(dummyD2, mask1)
+        end do
+      case(3)
+        call var%getData(dummyD3)
+        do ii = 1, nLCoverScene
+          L1_kBaseFlow(s1 : e1, 1, ii) = pack(dummyD3(:, :, ii), mask1)
+        end do
+      case default
+        call error_message("Restart: L1_kBaseFlow rank needs to be 2 or 3")
+    end select
 
     ! percolation coefficient
     var = nc%getVariable("L1_kPerco")
-    call var%getData(dummyD2)
-    L1_kPerco(s1 : e1, 1, 1) = pack(dummyD2, mask1)
+    var_rank = var%getrank()
+    select case(var_rank)
+      case(2)
+        ! distribute over all land cover scenes
+        call var%getData(dummyD2)
+        do ii = 1, nLCoverScene
+          L1_kPerco(s1 : e1, 1, ii) = pack(dummyD2, mask1)
+        end do
+      case(3)
+        call var%getData(dummyD3)
+        do ii = 1, nLCoverScene
+          L1_kPerco(s1 : e1, 1, ii) = pack(dummyD3(:, :, ii), mask1)
+        end do
+      case default
+        call error_message("Restart: L1_kPerco rank needs to be 2 or 3")
+    end select
 
     ! Soil moisture below which actual ET is reduced linearly till PWP
     ! for processCase(3) = 1
     var = nc%getVariable("L1_soilMoistFC")
     call var%getData(dummyD4)
     do jj = 1, nLCoverScene
       do ii = 1, nSoilHorizons_mHM
@@ -825,23 +767,23 @@
       call var%getData(dummyD4)
       do jj = 1, nLCoverScene
          do ii = 1, nSoilHorizons_mHM
             L1_bulkDens(s1:e1, ii, jj) = pack(dummyD4(:, :, ii, jj), mask1)
          end do
       end do
 
-      ! Lattice water 
+      ! Lattice water
       var = nc%getVariable("L1_latticeWater")
       call var%getData(dummyD4)
       do jj = 1, nLCoverScene
          do ii = 1, nSoilHorizons_mHM
             L1_latticeWater(s1:e1, ii, jj) = pack(dummyD4(:, :, ii, jj), mask1)
          end do
       end do
-      
+
    case(2) ! COSMIC
       ! N0 count
       var = nc%getVariable("L1_No_Count")
       call var%getData(dummyD2)
       L1_No_Count(s1 : e1, 1, 1) = pack(dummyD2, mask1)
 
       ! Bulk density
@@ -849,239 +791,33 @@
       call var%getData(dummyD4)
       do jj = 1, nLCoverScene
          do ii = 1, nSoilHorizons_mHM
             L1_bulkDens(s1:e1, ii, jj) = pack(dummyD4(:, :, ii, jj), mask1)
          end do
       end do
 
-      ! Lattice water 
+      ! Lattice water
       var = nc%getVariable("L1_latticeWater")
       call var%getData(dummyD4)
       do jj = 1, nLCoverScene
          do ii = 1, nSoilHorizons_mHM
             L1_latticeWater(s1: e1, ii, jj) = pack(dummyD4(:, :, ii, jj), mask1)
          end do
       end do
 
-      ! COSMIC L3 parameter 
+      ! COSMIC L3 parameter
       var = nc%getVariable("L1_COSMICL3")
       call var%getData(dummyD4)
       do jj = 1, nLCoverScene
          do ii = 1, nSoilHorizons_mHM
             L1_COSMICL3(s1:e1, ii, jj) = pack(dummyD4(:, :, ii, jj), mask1)
          end do
       end do
 
    end select
-   
+
    ! close file
    call nc%close()
 
   end subroutine read_restart_states
 
-  subroutine unpack_field_and_write_1d_i4(nc, var_name, var_dims, fill_value, data, mask, var_long_name)
-
-    use mo_kind, only : i4
-    use mo_netcdf, only : NcDataset, NcDimension, NcVariable
-
-    implicit none
-
-    ! NcDataset to add variable to
-    type(NcDataset), intent(inout) :: nc
-
-    ! variable name
-    character(*), intent(in) :: var_name
-
-    ! vector of Variable dimensions
-    type(NcDimension), dimension(:), intent(in) :: var_dims
-
-    ! fill value used for missing values
-    integer(i4), intent(in) :: fill_value
-
-    ! packed data to be set to variable
-    integer(i4), dimension(:), intent(in) :: data
-
-    ! mask used for unpacking
-    logical, dimension(:, :), intent(in) :: mask
-
-    ! variable long name attribute
-    character(*), optional, intent(in) :: var_long_name
-
-    type(NcVariable) :: var
-
-
-    ! set variable
-    var = nc%setVariable(var_name, "i32", var_dims)
-    call var%setFillValue(fill_value)
-
-    ! set the unpacked data
-    call var%setData(unpack(data, mask, fill_value))
-
-    ! optionally set attributes
-    if (present(var_long_name)) then
-      call var%setAttribute("long_name", trim(var_long_name))
-    end if
-
-  end subroutine
-
-  subroutine unpack_field_and_write_1d_dp(nc, var_name, var_dims, fill_value, data, mask, var_long_name)
-
-    use mo_kind, only : dp
-    use mo_netcdf, only : NcDataset, NcDimension, NcVariable
-
-    implicit none
-
-    ! NcDataset to add variable to
-    type(NcDataset), intent(inout) :: nc
-
-    ! variable name
-    character(*), intent(in) :: var_name
-
-    ! vector of Variable dimensions
-    type(NcDimension), dimension(:), intent(in) :: var_dims
-
-    ! fill value used for missing values
-    real(dp), intent(in) :: fill_value
-
-    ! packed data to be set to variable
-    real(dp), dimension(:), intent(in) :: data
-
-    ! mask used for unpacking
-    logical, dimension(:, :), intent(in) :: mask
-
-    ! variable long name attribute
-    character(*), optional, intent(in) :: var_long_name
-
-    type(NcVariable) :: var
-
-
-    ! set variable
-    var = nc%setVariable(var_name, "f64", var_dims)
-    call var%setFillValue(fill_value)
-
-    ! set the unpacked data
-    call var%setData(unpack(data, mask, fill_value))
-
-    ! optionally set attributes
-    if (present(var_long_name)) then
-      call var%setAttribute("long_name", trim(var_long_name))
-    end if
-
-  end subroutine
-
-  subroutine unpack_field_and_write_2d_dp(nc, var_name, var_dims, fill_value, data, mask, var_long_name)
-
-    use mo_kind, only : dp, i4
-    use mo_netcdf, only : NcDataset, NcDimension, NcVariable
-
-    implicit none
-
-    ! NcDataset to add variable to
-    type(NcDataset), intent(inout) :: nc
-
-    ! variable name
-    character(*), intent(in) :: var_name
-
-    ! vector of Variable dimensions
-    type(NcDimension), dimension(:), intent(in) :: var_dims
-
-    ! fill value used for missing values
-    real(dp), intent(in) :: fill_value
-
-    ! packed data to be set to variable
-    real(dp), dimension(:, :), intent(in) :: data
-
-    ! mask used for unpacking
-    logical, dimension(:, :), intent(in) :: mask
-
-    ! variable long name attribute
-    character(*), optional, intent(in) :: var_long_name
-
-    type(NcVariable) :: var
-
-    real(dp), dimension(:, :, :), allocatable :: dummy_arr
-
-    integer(i4), dimension(3) :: dim_length
-
-    integer(i4) :: ii
-
-
-    ! set variable
-    var = nc%setVariable(var_name, "f64", var_dims)
-    call var%setFillValue(fill_value)
-
-    dim_length = var%getShape()
-    allocate(dummy_arr(dim_length(1), dim_length(2), dim_length(3)))
-    do ii = 1, size(data, 2)
-      dummy_arr(:, :, ii) = unpack(data(:, ii), mask, fill_value)
-    end do
-
-    ! set the unpacked data
-    call var%setData(dummy_arr)
-
-    ! optionally set attributes
-    if (present(var_long_name)) then
-      call var%setAttribute("long_name", trim(var_long_name))
-    end if
-
-  end subroutine
-
-  subroutine unpack_field_and_write_3d_dp(nc, var_name, var_dims, fill_value, data, mask, var_long_name)
-
-    use mo_kind, only : dp, i4
-    use mo_netcdf, only : NcDataset, NcDimension, NcVariable
-
-    implicit none
-
-    ! NcDataset to add variable to
-    type(NcDataset), intent(inout) :: nc
-
-    ! variable name
-    character(*), intent(in) :: var_name
-
-    ! vector of Variable dimensions
-    type(NcDimension), dimension(:), intent(in) :: var_dims
-
-    ! fill value used for missing values
-    real(dp), intent(in) :: fill_value
-
-    ! packed data to be set to variable
-    real(dp), dimension(:, :, :), intent(in) :: data
-
-    ! mask used for unpacking
-    logical, dimension(:, :), intent(in) :: mask
-
-    ! variable long name attribute
-    character(*), optional, intent(in) :: var_long_name
-
-    type(NcVariable) :: var
-
-    real(dp), dimension(:, :, :, :), allocatable :: dummy_arr
-
-    integer(i4), dimension(4) :: dim_length
-
-    integer(i4) :: ii, jj
-
-
-    ! set variable
-    var = nc%setVariable(var_name, "f64", var_dims)
-    call var%setFillValue(fill_value)
-
-    dim_length = var%getShape()
-    allocate(dummy_arr(dim_length(1), dim_length(2), dim_length(3), dim_length(4)))
-    do ii = 1, size(data, 2)
-      do jj = 1, size(data, 3)
-        dummy_arr(:, :, ii, jj) = unpack(data(:, ii, jj), mask, fill_value)
-      end do
-    end do
-
-    ! set the unpacked data
-    call var%setData(dummy_arr)
-
-    ! optionally set attributes
-    if (present(var_long_name)) then
-      call var%setAttribute("long_name", trim(var_long_name))
-    end if
-
-  end subroutine
-
 END MODULE mo_restart
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `mhm-5.12.1.dev21/src/mHM/mo_runoff.f90` & `mhm-5.13.0/src/mHM/mo_runoff.f90`

 * *Files 1% similar despite different names*

```diff
@@ -1,21 +1,18 @@
-!>       \file mo_runoff.f90
-
-!>       \brief Runoff generation for the  unsaturated zone, saturated zone (or groundwater zone),
-!>       and runoff accumulation.
-
-!>       \details This module generates the runoff for the unsaturated and saturated zones and provides
-!>       runoff accumulation.
-
-!>       \authors Vladyslav Prykhodko
-
-!>       \date Dec 2012
-
-! Modifications:
-
+!> \file mo_runoff.f90
+!> \brief \copybrief mo_runoff
+!> \details \copydetails mo_runoff
+
+!> \brief Runoff generation.
+!> \details This module generates the runoff for the unsaturated and saturated zones and provides runoff accumulation.
+!> \authors Vladyslav Prykhodko
+!> \date Dec 2012
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mhm
 MODULE mo_runoff
 
   USE mo_kind, ONLY : dp
   USE mo_common_constants, ONLY : eps_dp
 
   IMPLICIT NONE
```

### Comparing `mhm-5.12.1.dev21/src/mHM/mo_snow_accum_melt.f90` & `mhm-5.13.0/src/mHM/mo_snow_accum_melt.f90`

 * *Files 6% similar despite different names*

```diff
@@ -1,19 +1,18 @@
-!>       \file mo_snow_accum_melt.f90
-
-!>       \brief Snow melting and accumulation.
-
-!>       \details This module calculates snow melting and accumulation.
-
-!>       \authors Vladyslav Prykhodko
-
-!>       \date Dec 2012
-
-! Modifications:
-
+!> \file mo_snow_accum_melt.f90
+!> \brief \copybrief mo_snow_accum_melt
+!> \details \copydetails mo_snow_accum_melt
+
+!> \brief Snow melting and accumulation.
+!> \details This module calculates snow melting and accumulation.
+!> \authors Vladyslav Prykhodko
+!> \date Dec 2012
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mhm
 MODULE mo_snow_accum_melt
 
   USE mo_kind, ONLY : dp
 
   IMPLICIT NONE
 
   PRIVATE
```

### Comparing `mhm-5.12.1.dev21/src/mHM/mo_soil_moisture.f90` & `mhm-5.13.0/src/mHM/mo_soil_moisture.f90`

 * *Files 2% similar despite different names*

```diff
@@ -1,35 +1,34 @@
-!>       \file mo_soil_moisture.f90
-
-!>       \brief Soil moisture of the different layers
-
-!>       \details Soil moisture in the different layers is calculated with
-!>       infiltration as \f$ (\theta / \theta_{sat})^\beta \f$
-!>       Then evapotranspiration is calculated from PET with a soil water stress  factor \f$ f_{SM} \f$
-!>       either using  the Feddes equation - precessCase(1):
-!>       \f$ f_{SM} = \frac{\theta - \theta_\mathit{pwp}}{\theta_\mathit{fc} - \theta_\mathit{pwp}} \f$
-!>       or using the Jarvis equation - precessCase(1):
-!>       \f$ f_{SM} = \frac{1}{\theta_\mathit{stress-index-C1}}
-!>       \frac{\theta - \theta_\mathit{pwp}}{\theta_\mathit{sat} - \theta_\mathit{pwp}} \f$.
-
-!>       \authors Matthias Cuntz, Luis Samaniego
-
-!>       \date Dec 2012
-
-! Modifications:
-
+!> \file mo_soil_moisture.f90
+!> \brief \copybrief mo_soil_moisture
+!> \details \copydetails mo_soil_moisture
+
+!> \brief Soil moisture of the different layers
+!> \details Soil moisture in the different layers is calculated with
+!! infiltration as \f$ (\theta / \theta_{sat})^\beta \f$
+!! Then evapotranspiration is calculated from PET with a soil water stress  factor \f$ f_{SM} \f$
+!! either using  the Feddes equation - processCase(3) = 1:
+!! \f[ f_{SM} = \frac{\theta - \theta_\mathit{pwp}}{\theta_\mathit{fc} - \theta_\mathit{pwp}} \f]
+!! or using the Jarvis equation - processCase(3) = 2:
+!! \f[ f_{SM} = \frac{1}{\theta_\mathit{stress-index-C1}}
+!! \frac{\theta - \theta_\mathit{pwp}}{\theta_\mathit{sat} - \theta_\mathit{pwp}} \f]
+!> \authors Matthias Cuntz, Luis Samaniego
+!> \date Dec 2012
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mhm
 MODULE mo_soil_moisture
 
   USE mo_kind, ONLY : i4, dp
 
   IMPLICIT NONE
 
   PUBLIC :: feddes_et_reduction
   PUBLIC :: jarvis_et_reduction
-  
+
   PUBLIC :: soil_moisture  ! Soil moisture in different soil horizons
 
   ! ------------------------------------------------------------------
 
 CONTAINS
 
   ! ------------------------------------------------------------------
```

### Comparing `mhm-5.12.1.dev21/src/mHM/mo_write_ascii.f90` & `mhm-5.13.0/src/mHM/mo_write_ascii.f90`

 * *Files 2% similar despite different names*

```diff
@@ -1,38 +1,43 @@
-!>       \file mo_write_ascii.f90
-
-!>       \brief Module to write ascii file output.
-
-!>       \details Module to write ascii file output.
-!>       Writing model output to ASCII should be the exception. Therefore, output is written usually as NetCDF
-!>       and only:
-!>       (1) The configuration file of mHM,
-!>       (2) the final parameter set after optimization, and
-!>       (3) the simulated vs. observed daily discharge
-!>       is written in ASCII file format to allow for a quick assurance of proper model runs.
-
-!>       \authors Christoph Schneider, Juliane Mai, Luis Samaniego
-
-!>       \date May 2013
-
-! Modifications:
-
+!> \file mo_write_ascii.f90
+!> \brief \copybrief mo_write_ascii
+!> \details \copydetails mo_write_ascii
+
+!> \brief Module to write ascii file output.
+!> \details Module to write ascii file output.
+!! Writing model output to ASCII should be the exception. Therefore, output is written usually as NetCDF
+!! and only:
+!! 1. The configuration file of mHM,
+!! 2. the final parameter set after optimization, and
+!! 3. the simulated vs. observed daily discharge
+!!     is written in ASCII file format to allow for a quick assurance of proper model runs.
+!> \changelog
+!! - Modified, Juliane Mai,        May 2013
+!!   - module version and documentation
+!! - Modified, Luis Samaniego,     Nov 2013
+!!   - improving all formats
+!! - Modified, Luis Samaniego,     Mar 2014
+!!   - added inflow gauge information write out
+!! - Modified, Stephan Thober,     Jun 2014
+!!   - bug fixed: in writing network properties
+!! - Modified, Rohini Kumar,       Jun 2014
+!!   - bug fixed: writing of max and min value of discharge
+!! - Modified, Stephan Thober,     Aug 2015
+!!   - moved write_daily_obs_sim_discharge to mRM
+!> \authors Christoph Schneider, Juliane Mai, Luis Samaniego
+!> \date May 2013
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mhm
 MODULE mo_write_ascii
 
-  ! This module is a template for the UFZ CHS mesoscale hydrologic model mHM.
-
-  ! Written  Christoph Schneider, May 2013
-  ! Modified, Juliane Mai,        May 2013 - module version and documentation
-  ! Modified, Luis Samaniego,     Nov 2013 - improving all formats
-  ! Modified, Luis Samaniego,     Mar 2014 - added inflow gauge information write out
-  ! Modified, Stephan Thober,     Jun 2014 - bug fixed: in writing network properties
-  ! Modified, Rohini Kumar,       Jun 2014 - bug fixed: writing of max and min value of discharge
-  ! Modified, Stephan Thober,     Aug 2015 - moved write_daily_obs_sim_discharge to mRM
 
   USE mo_kind, ONLY : i4, dp
+  use mo_message, only: message, error_message
+
   IMPLICIT NONE
 
   PUBLIC :: write_configfile                   ! Writes configuration file
   PUBLIC :: write_optifile                     ! Write final OF and best parameter set
   PUBLIC :: write_optinamelist                 ! Write final OF and best parameter set in a namelist format
   ! ------------------------------------------------------------------
 
@@ -78,55 +83,54 @@
   !>       \date Jun 2018
 
   ! Modifications:
   ! Robert Schweppe Jun 2018 - refactoring and reformatting
   ! P Shrestha, S Thober Aug 2018 - resolved bug while printing River Network in
   !                                 cases with multiple outlets.
 
-  Subroutine write_configfile
+  Subroutine write_configfile(dirPrecipitation, dirReferenceET, dirTemperature)
 
     use mo_common_file, only : file_config, uconfig
     use mo_common_mHM_mRM_variables, only : LCyearId, SimPer, evalPer, read_restart, timeStep, warmPer
     use mo_common_variables, only : LC_year_end, &
                                     LC_year_start, LCfilename, dirConfigOut, dirLCover, dirMorpho, dirOut, mhmFileRestartOut, &
                                     global_parameters, global_parameters_name, iFlag_cordinate_sys, level0, level1, &
                                     domainMeta, nLCoverScene, resolutionHydrology, write_restart
     use mo_file, only : version
-    use mo_global_variables, only : dirPrecipitation, dirReferenceET, &
-                                    dirTemperature
     use mo_kind, only : i4
-    use mo_message, only : message
     use mo_string_utils, only : num2str
-    use mo_os, only : path_isdir
+    use mo_os, only : check_path_isdir
     use mo_common_constants, only : nodata_dp
     use mo_common_mHM_mRM_variables, only : resolutionRouting
     use mo_common_variables, only : processMatrix
     use mo_mrm_global_variables, only : InflowGauge, L11_fromN, L11_label, L11_length, L11_netPerm, L11_rOrder, &
                                         L11_slope, L11_toN, L1_L11_ID, dirGauges, gauge, level11, nGaugesTotal, &
                                         nGaugesLocal, nInflowGaugesTotal, L11_nOutlets
 
     implicit none
 
+    character(256), dimension(:), intent(in) :: dirPrecipitation  !< Directory where precipitation files are located
+    character(256), dimension(:), intent(in) :: dirReferenceET    !< Directory where reference-ET files are located
+    character(256), dimension(:), intent(in) :: dirTemperature    !< Directory where temperature files are located
+
     character(256) :: fName
 
     integer(i4) :: i, j, iDomain, domainID
 
     integer(i4) :: err
 
 
     fName = trim(adjustl(dirConfigOut)) // trim(adjustl(file_config))
     call message()
     call message('  Log-file written to ', trim(fName))
     !checking whether the directory exists where the file shall be created or opened
-    call path_isdir(trim(adjustl(dirConfigOut)), quiet_=.true., throwError_=.true.)
+    call check_path_isdir(trim(adjustl(dirConfigOut)), raise=.true.)
     open(uconfig, file = fName, status = 'unknown', action = 'write', iostat = err)
     if (err .ne. 0) then
-      call message('  Problems while creating File')
-      call message('  Error-Code', num2str(err))
-      stop
+      call error_message('  Problems while creating File. ', 'Error-Code ', num2str(err))
     end if
     write(uconfig, 200)
     write(uconfig, 100) 'mHM-UFZ v-' // trim(version)
     write(uconfig, 100) 'L. Samaniego & R. Kumar, UFZ'
     write(uconfig, 200)
     write(uconfig, 100)
     write(uconfig, 201) '         M A I N  mHM  C O N F I G U R A T I O N  I N F O R M A T I O N         '
@@ -424,17 +428,16 @@
   ! Robert Schweppe Jun 2018 - refactoring and reformatting
   ! M. Cuneyd Demirel, Simon Stisen Jun 2020 - added Feddes and FC dependency on root fraction coefficient processCase(3) = 4
 
   subroutine write_optifile(best_OF, best_paramSet, param_names)
 
     use mo_common_mhm_mrm_file, only : file_opti, uopti
     use mo_common_variables, only : dirConfigOut
-    use mo_message, only : message
     use mo_string_utils, only : num2str
-    use mo_os, only : path_isdir
+    use mo_os, only : check_path_isdir
 
     implicit none
 
     ! best objective function value as returnedby the optimization routine
     real(dp), intent(in) :: best_OF
 
     ! best associated global parameter setCalled only when optimize is .TRUE.
@@ -449,20 +452,18 @@
 
     ! number of parameters
     n_params = size(best_paramSet)
 
     ! open file
     fName = trim(adjustl(dirConfigOut)) // trim(adjustl(file_opti))
     !checking whether the directory exists where the file shall be created or opened
-    call path_isdir(trim(adjustl(dirConfigOut)), quiet_=.true., throwError_=.true.)
+    call check_path_isdir(trim(adjustl(dirConfigOut)), raise=.true.)
     open(uopti, file = fName, status = 'unknown', action = 'write', iostat = err, recl = (n_params + 1) * 40)
     if(err .ne. 0) then
-      call message ('  IOError while openening ', trim(fName))
-      call message ('  Error-Code ', num2str(err))
-      stop
+      call error_message('  IOError while openening "', trim(fName), '". Error-Code ', num2str(err))
     end if
 
     ! header
     write(formHeader, *) '(a40,', n_params, 'a40)'
     ! len(param_names(1))=256 but only 39 characters taken here
     ! write(uopti, formHeader) 'OF', (trim(adjustl(param_names(ii))), ii=1, n_params)
     write(uopti, formHeader) 'OF', (trim(adjustl(param_names(ii)(1 : 39))), ii = 1, n_params)
@@ -511,17 +512,16 @@
   ! Stephan Thober Nov  2016 - write namelist for routing process 2
   ! Robert Schweppe Jun 2018 - refactoring and reformatting
 
   subroutine write_optinamelist(processMatrix, parameters, maskpara, parameters_name)
 
     use mo_common_mhm_mrm_file, only : file_opti_nml, uopti_nml
     use mo_common_variables, only : dirConfigOut, nProcesses
-    use mo_message, only : message
     use mo_string_utils, only : num2str
-    use mo_os, only : path_isdir
+    use mo_os, only : check_path_isdir
 
     implicit none
 
     ! information about which process
     ! case was used
     integer(i4), dimension(nProcesses, 3), intent(in) :: processMatrix
 
@@ -553,20 +553,18 @@
     Process_descr(8) = 'routing'
     Process_descr(9) = 'geology'
     Process_descr(10) = 'neutrons'
 
     ! open file
     fName = trim(adjustl(dirConfigOut)) // trim(adjustl(file_opti_nml))
     !checking whether the directory exists where the file shall be created or opened
-    call path_isdir(trim(adjustl(dirConfigOut)), quiet_=.true., throwError_=.true.)
+    call check_path_isdir(trim(adjustl(dirConfigOut)), raise=.true.)
     open(uopti_nml, file = fName, status = 'unknown', action = 'write', iostat = err)
     if(err .ne. 0) then
-      call message ('  IOError while openening ', trim(fName))
-      call message ('  Error-Code ', num2str(err))
-      stop
+      call error_message('  IOError while openening "', trim(fName), '". Error-Code ', num2str(err))
     end if
 
     write(uopti_nml, *) '!global_parameters'
     write(uopti_nml, '( A47,T50,3(A20,2x),2(A8,1x) )') "!PARAMETER", "lower_bound", "upper_bound", "value", "FLAG", "SCALING"
 
     iPar_start = 1
     do iProc = 1, nProcesses
```

### Comparing `mhm-5.12.1.dev21/src/mRM/mo_mrm_file.f90` & `mhm-5.13.0/src/mRM/mo_mrm_file.f90`

 * *Files 25% similar despite different names*

```diff
@@ -1,19 +1,18 @@
-!>       \file mo_mrm_file.f90
-
-!>       \brief Provides file names and units for mRM
-
-!>       \details Provides all filenames as well as all units used for the multiscale Routing Model mRM.
-
-!>       \authors Matthias Cuntz, Stephan Thober
-
-!>       \date Aug 2015
-
-! Modifications:
-
+!> \file mo_mrm_file.f90
+!> \brief \copybrief mo_mrm_file
+!> \details \copydetails mo_mrm_file
+
+!> \brief Provides file names and units for mRM
+!> \details Provides all filenames as well as all units used for the multiscale Routing Model mRM.
+!> \authors Matthias Cuntz, Stephan Thober
+!> \date Aug 2015
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mrm
 MODULE mo_mrm_file
 
   IMPLICIT NONE
 
   !> Current mHM model version
   CHARACTER(len = *), PARAMETER :: version = '1.0'                         ! Version
   !> Time of current mHM model version release
```

### Comparing `mhm-5.12.1.dev21/src/mRM/mo_mrm_init.f90` & `mhm-5.13.0/src/mRM/mo_mrm_init.f90`

 * *Files 14% similar despite different names*

```diff
@@ -1,50 +1,52 @@
-!>       \file mo_mrm_init.f90
-
-!>       \brief Wrapper for initializing Routing.
-
-!>       \details Calling all routines to initialize all mRM variables
-
-!>       \authors Luis Samaniego, Rohini Kumar and Stephan Thober
-
-!>       \date Aug 2015
-
-! Modifications:
-
+!> \file mo_mrm_init.f90
+!> \brief \copybrief mo_mrm_init
+!> \details \copydetails mo_mrm_init
+
+!> \brief Wrapper for initializing Routing.
+!> \details Calling all routines to initialize all mRM variables
+!> \authors Luis Samaniego, Rohini Kumar and Stephan Thober
+!> \date Aug 2015
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mrm
 MODULE mo_mrm_init
 
     use mo_common_variables, only : dirOut
+    use mo_message, only : message, error_message
 
   ! This module sets the river network characteristics and routing order.
 
   ! Written  Luis Samaniego, Mar 2005
 
   IMPLICIT NONE
 
   public :: mrm_init, mrm_configuration
   public :: variables_default_init_routing
+  public :: fluxes_states_default_init_routing
 
   private
 
 CONTAINS
 
-subroutine mrm_configuration(file_namelist, unamelist, file_namelist_param, unamelist_param)
+  !> \brief read mRM configuration from namelists
+  subroutine mrm_configuration(file_namelist, unamelist, file_namelist_param, unamelist_param)
     use mo_common_mHM_mRM_variables, only : mrm_coupling_mode
     use mo_common_variables, only : processMatrix
     use mo_mrm_read_config, only : mrm_read_config
     use mo_mrm_global_variables, only: riv_temp_pcs
     use mo_common_read_config, only : common_read_config
     use mo_common_mHM_mRM_read_config, only : check_optimization_settings, common_mHM_mRM_read_config
     use mo_kind, only : i4
-    use mo_message, only : message
     implicit none
 
-    character(*), intent(in) :: file_namelist, file_namelist_param
-
-    integer, intent(in) :: unamelist, unamelist_param
+    character(*), intent(in) :: file_namelist !< namelist file name
+    integer, intent(in) :: unamelist !< unit to open namelist
+    character(*), intent(in) :: file_namelist_param !< parameter namelist file name
+    integer, intent(in) :: unamelist_param !< unit to open parameter namelist
 
     if (mrm_coupling_mode .eq. 0_i4) then
       call common_read_config(file_namelist, unamelist)
       call common_mHM_mRM_read_config(file_namelist, unamelist)
       !-----------------------------------------------------------
       ! PRINT STARTUP MESSAGE
       !-----------------------------------------------------------
@@ -69,80 +71,69 @@
     if (mrm_coupling_mode .eq. 0_i4) then
       call check_optimization_settings()
       !-----------------------------------------------------------
       ! CONFIG OUTPUT
       !-----------------------------------------------------------
       call config_output()
     end if
-end subroutine mrm_configuration
-  ! ------------------------------------------------------------------
-
-  !    NAME
-  !        mrm_init
-
-  !    PURPOSE
-  !>       \brief Initialize all mRM variables at all levels (i.e., L0, L1, and L11).
-
-  !>       \details Initialize all mRM variables at all levels (i.e., L0, L1, and L11)
-  !>       either with default values or with values from restart file. The L0 mask (L0_mask),
-  !>       L0 elevation (L0_elev), and L0 land cover (L0_LCover) can be provided as optional
-  !>       variables to save memory because these variable will then not be read in again.
-
-  !    INTENT(IN)
-  !>       \param[in] "character(*) :: file_namelist, file_namelist_param"
-  !>       \param[in] "integer :: unamelist, unamelist_param"
-  !>       \param[in] "character(*) :: file_namelist, file_namelist_param"
-  !>       \param[in] "integer :: unamelist, unamelist_param"
-
-  !    HISTORY
-  !>       \authors Stephan Thober
-
-  !>       \date Aug 2015
-
-  ! Modifications:
-  ! Stephan Thober Sep 2015 - added L0_mask, L0_elev, and L0_LCover
-  ! Stephan Thober May 2016 - added warning message in case no gauge is found in modelling domain
-  ! Matthias Kelbling Aug 2017 - added L11_flow_accumulation to Initialize Stream Netwo
-  ! Lennart Schueler May 2018 - added initialization for groundwater coupling
-  ! Stephan Thober Jun 2018 - refactored for mpr_extract version
-  ! Stephan Thober May 2019 - added init of level0 in case of read restart
+  end subroutine mrm_configuration
 
 
+  !> \brief Initialize all mRM variables at all levels (i.e., L0, L1, and L11).
+  !> \details Initialize all mRM variables at all levels (i.e., L0, L1, and L11)
+  !! either with default values or with values from restart file. The L0 mask (L0_mask),
+  !! L0 elevation (L0_elev), and L0 land cover (L0_LCover) can be provided as optional
+  !! variables to save memory because these variable will then not be read in again.
+  !> \changelog
+  !! - Stephan Thober Sep 2015
+  !!   - added L0_mask, L0_elev, and L0_LCover
+  !! - Stephan Thober May 2016
+  !!   - added warning message in case no gauge is found in modelling domain
+  !! - Matthias Kelbling Aug 2017
+  !!   - added L11_flow_accumulation to Initialize Stream Netwo
+  !! - Lennart Schueler May 2018
+  !!   - added initialization for groundwater coupling
+  !! - Stephan Thober Jun 2018
+  !!   - refactored for mpr_extract version
+  !! - Stephan Thober May 2019
+  !!   - added init of level0 in case of read restart
+  !> \authors Stephan Thober
+  !> \date Aug 2015
   subroutine mrm_init(file_namelist, unamelist, file_namelist_param, unamelist_param)
 
     use mo_common_constants, only : nodata_dp, nodata_i4
     use mo_common_mHM_mRM_variables, only : mrmFileRestartIn, mrm_coupling_mode, mrm_read_river_network, &
                                             resolutionRouting
     use mo_common_restart, only : read_grid_info
-    use mo_common_variables, only : domainMeta, global_parameters, l0_l1_remap, level0, level1, domainMeta, &
+    use mo_common_variables, only : global_parameters, l0_l1_remap, level0, level1, domainMeta, &
                                     processMatrix, resolutionHydrology
     use mo_grid, only : L0_grid_setup, init_lowres_level, set_domain_indices
     use mo_kind, only : i4
-    use mo_message, only : message
     use mo_mrm_global_variables, only : domain_mrm, &
-                                        l0_l11_remap, l1_l11_remap, level11, &
+                                        l0_l11_remap, level11, &
                                         gw_coupling, L0_river_head_mon_sum, &
                                         L11_netPerm, L11_fromN, L11_length, L11_nOutlets, &
                                         riv_temp_pcs, &
                                         readLatLon
     use mo_mrm_net_startup, only : L11_flow_direction, L11_flow_accumulation, L11_fraction_sealed_floodplain, &
                                    L11_link_location, L11_routing_order, L11_set_drain_outlet_gauges, &
                                    L11_set_network_topology, L11_stream_features, l11_l1_mapping
     use mo_mrm_read_data, only : mrm_read_L0_data, mrm_read_discharge, &
                                  mrm_read_total_runoff, mrm_read_bankfull_runoff
     use mo_mrm_restart, only : mrm_read_restart_config
     use mo_read_latlon, only : read_latlon
-    use mo_mrm_river_head, only: init_masked_zeros_l0, create_output, calc_channel_elevation
+    use mo_mrm_river_head, only: init_masked_zeros_l0, calc_channel_elevation
     use mo_mrm_mpr, only : mrm_init_param
 
     implicit none
 
-    character(*), intent(in) :: file_namelist, file_namelist_param
-
-    integer, intent(in) :: unamelist, unamelist_param
+    character(*), intent(in) :: file_namelist !< namelist file name
+    integer, intent(in) :: unamelist !< unit to open namelist
+    character(*), intent(in) :: file_namelist_param !< parameter namelist file name
+    integer, intent(in) :: unamelist_param !< unit to open parameter namelist
 
     ! start and end index for routing parameters
     integer(i4) :: iStart, iEnd
     ! start and end index at L11
     integer(i4) :: s11, e11
 
     integer(i4) :: domainID, iDomain, gauge_counter
@@ -154,35 +145,33 @@
     end if
 
     ! ----------------------------------------------------------
     ! READ DATA
     ! ----------------------------------------------------------
     allocate(level11(domainMeta%nDomains))
     allocate(l0_l11_remap(domainMeta%nDomains))
-    allocate(l1_l11_remap(domainMeta%nDomains))
 
     if (.not. mrm_read_river_network) then
       ! read all (still) necessary level 0 data
       if (processMatrix(8, 1) .eq. 1_i4) call mrm_read_L0_data(mrm_coupling_mode .eq. 0_i4, ReadLatLon, .true.)
       if (processMatrix(8, 1) .eq. 2_i4) call mrm_read_L0_data(mrm_coupling_mode .eq. 0_i4, ReadLatLon, .false.)
       if (processMatrix(8, 1) .eq. 3_i4) call mrm_read_L0_data(mrm_coupling_mode .eq. 0_i4, ReadLatLon, .false.)
     end if
 
     do iDomain = 1, domainMeta%nDomains
       domainID = domainMeta%indices(iDomain)
       if (mrm_read_river_network) then
         ! this reads the domain properties
         if (.not. allocated(level0)) allocate(level0(domainMeta%nDomains))
         ! ToDo: L0_Domain, parallel
-        call read_grid_info(domainMeta%indices(domainMeta%L0DataFrom(iDomain)), mrmFileRestartIn(iDomain), &
-                                                     "0", level0(domainMeta%L0DataFrom(iDomain)))
+        call read_grid_info(mrmFileRestartIn(iDomain), "0", level0(domainMeta%L0DataFrom(iDomain)))
         if (mrm_coupling_mode .eq. 0_i4) then
-          call read_grid_info(domainID, mrmFileRestartIn(iDomain), "1", level1(iDomain))
+          call read_grid_info(mrmFileRestartIn(iDomain), "1", level1(iDomain))
         end if
-        call read_grid_info(domainID, mrmFileRestartIn(iDomain), "11", level11(iDomain))
+        call read_grid_info(mrmFileRestartIn(iDomain), "11", level11(iDomain))
         call mrm_read_restart_config(iDomain, domainID, mrmFileRestartIn(iDomain))
       else
         if (iDomain .eq. 1) then
           call L0_check_input_routing(domainMeta%L0DataFrom(iDomain))
           if (mrm_coupling_mode .eq. 0_i4) then
             call L0_grid_setup(level0(domainMeta%L0DataFrom(iDomain)))
           end if
@@ -195,16 +184,14 @@
 
         if (mrm_coupling_mode .eq. 0_i4) then
           call init_lowres_level(level0(domainMeta%L0DataFrom(iDomain)), resolutionHydrology(iDomain), &
                   level1(iDomain), l0_l1_remap(iDomain))
         end if
         call init_lowres_level(level0(domainMeta%L0DataFrom(iDomain)), resolutionRouting(iDomain), &
                 level11(iDomain), l0_l11_remap(iDomain))
-        call init_lowres_level(level1(iDomain), resolutionRouting(iDomain), &
-                level11(iDomain), l1_l11_remap(iDomain))
         call L11_L1_mapping(iDomain)
 
         if (ReadLatLon) then
           ! read lat lon coordinates of each domain
           call read_latlon(iDomain, "lon", "lat", "level1", level1(iDomain))
           call read_latlon(iDomain, "lon_l11", "lat_l11", "level11", level11(iDomain))
         else
@@ -282,21 +269,21 @@
       do iDomain = 1, domainMeta%nDomains
         call mrm_read_total_runoff(iDomain)
       end do
     end if
     ! discharge data
     call mrm_read_discharge()
 
+    ! init groundwater coupling
     if (gw_coupling) then
-        do iDomain = 1, domainMeta%nDomains
-            call init_masked_zeros_l0(iDomain, L0_river_head_mon_sum)
-            call mrm_read_bankfull_runoff(iDomain)
-            call create_output(iDomain, dirOut(iDomain))
-        end do
-        call calc_channel_elevation()
+      do iDomain = 1, domainMeta%nDomains
+        call init_masked_zeros_l0(iDomain, L0_river_head_mon_sum)
+        call mrm_read_bankfull_runoff(iDomain)
+      end do
+      call calc_channel_elevation()
     end if
 
     ! init riv temp
     if ( riv_temp_pcs%active ) then
       call message('')
       call message('    Initialization of river temperature routing.')
       do iDomain = 1, domainMeta%nDomains
@@ -318,46 +305,27 @@
     end if
     call message('')
     call message('  Finished Initialization of mRM')
 
   end subroutine mrm_init
 
 
-  !===============================================================
-  ! PRINT STARTUP MESSAGE
-  !===============================================================
-  !    NAME
-  !        print_startup_message
-
-  !    PURPOSE
-  !>       \brief TODO: add description
-
-  !>       \details TODO: add description
-
-  !    INTENT(IN)
-  !>       \param[in] "character(*) :: file_namelist, file_namelist_param"
-  !>       \param[in] "character(*) :: file_namelist, file_namelist_param"
-
-  !    HISTORY
-  !>       \authors Robert Schweppe
-
-  !>       \date Jun 2018
-
-  ! Modifications:
-
+  !> \brief Print mRM startup message
+  !> \authors Robert Schweppe
+  !> \date Jun 2018
   subroutine print_startup_message(file_namelist, file_namelist_param)
 
     use mo_kind, only : i4
-    use mo_message, only : message
     use mo_mrm_file, only : file_defOutput, file_main, version, version_date
     use mo_string_utils, only : num2str, separator
 
     implicit none
 
-    character(*), intent(in) :: file_namelist, file_namelist_param
+    character(*), intent(in) :: file_namelist !< namelist file name
+    character(*), intent(in) :: file_namelist_param !< parameter namelist file name
 
     ! Date and time
     integer(i4), dimension(8) :: datetime
 
     CHARACTER(len=1024) :: message_text = ''
 
     call message(separator)
@@ -384,37 +352,21 @@
     call message('     ', trim(file_namelist_param))
     call message('     ', trim(file_defOutput), ' (if it is given)')
     call message()
 
   end subroutine print_startup_message
 
 
-  !---------------------------------------------------------------
-  ! Config output
-  !---------------------------------------------------------------
-  !    NAME
-  !        config_output
-
-  !    PURPOSE
-  !>       \brief TODO: add description
-
-  !>       \details TODO: add description
-
-  !    HISTORY
-  !>       \authors Robert Schweppe
-
-  !>       \date Jun 2018
-
-  ! Modifications:
-
+  !> \brief print mRM configuration
+  !> \authors Robert Schweppe
+  !> \date Jun 2018
   subroutine config_output
 
     use mo_common_variables, only : dirLCover, dirMorpho, dirOut, domainMeta
     use mo_kind, only : i4
-    use mo_message, only : message
     use mo_mrm_file, only : file_defOutput, file_namelist_mrm, file_namelist_param_mrm
     use mo_mrm_global_variables, only : domain_mrm, &
                                         dirGauges
     use mo_string_utils, only : num2str
 
     implicit none
 
@@ -454,170 +406,151 @@
                   trim(adjustl(num2str(domain_mrm(iDomain)%InflowGaugeIdList(jj)))))
         end do
       end if
     end do
   end subroutine config_output
 
 
-  ! ------------------------------------------------------------------
-
-  !    NAME
-  !        variables_default_init_routing
-
-  !    PURPOSE
-  !>       \brief Default initalization mRM related L11 variables
-
-  !>       \details Default initalization of mHM related L11 variables (e.g., states,
-  !>       fluxes, and parameters) as per given constant values given in mo_mhm_constants.
-  !>       Variables initalized here is defined in the mo_global_variables.f90 file.
-  !>       Only Variables that are defined in the variables_alloc subroutine are
-  !>       intialized here.
-  !>       If a variable is added or removed here, then it also has to be added or removed
-  !>       in the subroutine state_variables_set in the module mo_restart and in the
-  !>       subroutine set_state in the module mo_set_netcdf_restart.
-  !>       ADDITIONAL INFORMATION
-  !>       variables_default_init_routing
-
-
-  !>       call variables_default_init()
-  !>       \authors  Stephan Thober, Rohini Kumar, and Juliane Mai
-  !>       \date    Aug 2015
-
-  !    HISTORY
-  !>       \authors Robert Schweppe
-
-  !>       \date Jun 2018
-
-  ! Modifications:
-
+  !> \brief Default initalization mRM related L11 variables
+  !> \details Default initalization of mHM related L11 variables (e.g., states,
+  !! fluxes, and parameters) as per given constant values given in mo_mhm_constants.
+  !! Variables initalized here is defined in the mo_global_variables.f90 file.
+  !! Only Variables that are defined in the variables_alloc subroutine are
+  !! intialized here.
+  !! If a variable is added or removed here, then it also has to be added or removed
+  !! in the subroutine state_variables_set in the module mo_restart and in the
+  !! subroutine set_state in the module mo_set_netcdf_restart.
+  !> \authors  Stephan Thober, Rohini Kumar, and Juliane Mai
+  !> \date    Aug 2015
+  !> \authors Robert Schweppe
+  !> \date Jun 2018
   subroutine variables_default_init_routing
 
     use mo_common_constants, only : P1_InitStateFluxes
-    use mo_mrm_global_variables, only : L11_C1, L11_C2, L11_K, L11_Qmod, L11_qOUT, L11_qTIN, L11_qTR, L11_xi
+    use mo_mrm_global_variables, only : L11_C1, L11_C2, L11_K, L11_xi
 
     implicit none
 
-
     !-------------------------------------------
     ! L11 ROUTING STATE VARIABLES, FLUXES AND
     !             PARAMETERS
     !-------------------------------------------
-    ! simulated discharge at each node
-    L11_Qmod = P1_InitStateFluxes
-    ! Total outflow from cells L11 at time tt
-    L11_qOUT = P1_InitStateFluxes
-    ! Total discharge inputs at t-1 and t
-    L11_qTIN = P1_InitStateFluxes
-    !  Routed outflow leaving a node
-    L11_qTR = P1_InitStateFluxes
+
+    ! fluxes and states
+    call fluxes_states_default_init_routing()
+
     ! kappa: Muskingum travel time parameter.
     L11_K = P1_InitStateFluxes
     ! xi:    Muskingum diffusion parameter
     L11_xi = P1_InitStateFluxes
     ! Routing parameter C1=f(K,xi, DT) (Chow, 25-41)
     L11_C1 = P1_InitStateFluxes
     ! Routing parameter C2 =f(K,xi, DT) (Chow, 25-41)
     L11_C2 = P1_InitStateFluxes
 
   end subroutine variables_default_init_routing
 
+  !> \brief initialize fluxes and states with default values for mRM
+  subroutine fluxes_states_default_init_routing(iDomain)
 
-  ! --------------------------------------------------------------------------
-  ! L0_check_input_routing
-  ! --------------------------------------------------------------------------
-  !    NAME
-  !        L0_check_input_routing
+    use mo_kind, only: i4
+    use mo_mrm_global_variables, only : level11
+    use mo_common_constants, only : P1_InitStateFluxes
+    use mo_mrm_global_variables, only : L11_Qmod, L11_qOUT, L11_qTIN, L11_qTR
+
+    implicit none
 
-  !    PURPOSE
-  !>       \brief TODO: add description
+    !> number of Domain (if not present, set for all)
+    integer(i4), intent(in), optional :: iDomain
 
-  !>       \details TODO: add description
+    integer(i4) :: s11, e11
 
-  !    INTENT(IN)
-  !>       \param[in] "integer(i4) :: L0Domain_iDomain"
+    !-------------------------------------------
+    ! L11 ROUTING STATE VARIABLES, FLUXES AND
+    !             PARAMETERS
+    !-------------------------------------------
 
-  !    HISTORY
-  !>       \authors Robert Schweppe
+    if (present(iDomain)) then
+      s11 = level11(iDomain)%iStart
+      e11 = level11(iDomain)%iEnd
+      ! simulated discharge at each node
+      L11_Qmod(s11 : e11) = P1_InitStateFluxes
+      ! Total outflow from cells L11 at time tt
+      L11_qOUT(s11 : e11) = P1_InitStateFluxes
+      ! Total discharge inputs at t-1 and t
+      L11_qTIN(s11 : e11, :) = P1_InitStateFluxes
+      !  Routed outflow leaving a node
+      L11_qTR(s11 : e11, :) = P1_InitStateFluxes
+    else
+      ! simulated discharge at each node
+      L11_Qmod = P1_InitStateFluxes
+      ! Total outflow from cells L11 at time tt
+      L11_qOUT = P1_InitStateFluxes
+      ! Total discharge inputs at t-1 and t
+      L11_qTIN = P1_InitStateFluxes
+      !  Routed outflow leaving a node
+      L11_qTR = P1_InitStateFluxes
+    end if
 
-  !>       \date Jun 2018
+  end subroutine fluxes_states_default_init_routing
 
-  ! Modifications:
 
+  !> \brief check routing input on level-0
+  !> \authors Robert Schweppe
+  !> \date Jun 2018
   subroutine L0_check_input_routing(L0Domain_iDomain)
 
     use mo_common_constants, only : nodata_i4
     use mo_common_variables, only : level0
     use mo_kind, only : i4
-    use mo_message, only : message
     use mo_mrm_global_variables, only : L0_fAcc, L0_fDir
     use mo_string_utils, only : num2str
 
     implicit none
 
-    integer(i4), intent(in) :: L0Domain_iDomain
+    integer(i4), intent(in) :: L0Domain_iDomain !< domain index for associated level-0 data
 
     integer(i4) :: k
 
     CHARACTER(len=1024) :: message_text = ''
 
     do k = level0(L0Domain_iDomain)%iStart, level0(L0Domain_iDomain)%iEnd
       ! flow direction [-]
       if (L0_fDir(k) .eq. nodata_i4) then
         message_text = trim(num2str(k, '(I5)')) // ',' // trim(num2str(L0Domain_iDomain, '(I5)'))
-        call message(' Error: flow direction has missing value within the valid masked area at cell in domain ', &
+        call error_message(' Error: flow direction has missing value within the valid masked area at cell in domain ', &
                 trim(message_text))
-        stop
       end if
       ! flow accumulation [-]
       if (L0_fAcc(k) .eq. nodata_i4) then
         message_text = trim(num2str(k, '(I5)')) // ',' // trim(num2str(L0Domain_iDomain, '(I5)'))
-        call message(' Error: flow accumulation has missing values within the valid masked area at cell in domain ', &
+        call error_message(' Error: flow accumulation has missing values within the valid masked area at cell in domain ', &
                 trim(message_text))
-        stop
       end if
     end do
 
   end subroutine L0_check_input_routing
 
 
-  ! --------------------------------------------------------------------------
-  ! L11 ROUTING STATE VARIABLES, FLUXES AND
-  !             PARAMETERS
-  ! --------------------------------------------------------------------------
-  !    NAME
-  !        variables_alloc_routing
-
-  !    PURPOSE
-  !>       \brief TODO: add description
-
-  !>       \details TODO: add description
-
-  !    INTENT(IN)
-  !>       \param[in] "integer(i4) :: iDomain"
-
-  !    HISTORY
-  !>       \authors Robert Schweppe
-
-  !>       \date Jun 2018
-
-  ! Modifications:
-
+  !> \brief allocated routing related variables
+  !> \authors Robert Schweppe
+  !> \date Jun 2018
   subroutine variables_alloc_routing(iDomain)
 
     use mo_append, only : append
     use mo_kind, only : dp, i4
     use mo_mrm_constants, only : nRoutingStates
     use mo_common_variables, only : level0, domainMeta
     use mo_mrm_global_variables, only : L11_C1, L11_C2, L11_K, &
          L11_Qmod, L11_qOUT, L11_qTIN, L11_qTR, L11_xi, &
          level11, L11_celerity, L0_celerity
 
     implicit none
 
-    integer(i4), intent(in) :: iDomain
+    integer(i4), intent(in) :: iDomain !< domain index
 
     real(dp), dimension(:), allocatable :: dummy_Vector11
 
     real(dp), dimension(:, :), allocatable :: dummy_Matrix11_IT
 
 
     ! dummy vector and matrix
```

### Comparing `mhm-5.12.1.dev21/src/mRM/mo_mrm_mpr.f90` & `mhm-5.13.0/src/mRM/mo_mrm_mpr.f90`

 * *Files 4% similar despite different names*

```diff
@@ -1,24 +1,25 @@
-!>       \file mo_mrm_mpr.f90
-
-!>       \brief Perform Multiscale Parameter Regionalization on Routing Parameters
-
-!>       \details This module contains the subroutine for calculating the regionalized
-!>       routing parameters (beta-parameters) given the five global routing parameters
-!>       (gamma) at the level 0 scale.
-
-!>       \authors Luis Samaniego, Stephan Thober
-
-!>       \date Aug 2015
-
-! Modifications:
-
+!> \file mo_mrm_mpr.f90
+!> \brief \copybrief mo_mrm_mpr
+!> \details \copydetails mo_mrm_mpr
+
+!> \brief Perform Multiscale Parameter Regionalization on Routing Parameters
+!> \details This module contains the subroutine for calculating the regionalized
+!! routing parameters (beta-parameters) given the five global routing parameters (gamma) at the level 0 scale.
+!> \authors Luis Samaniego, Stephan Thober
+!> \date Aug 2015
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mrm
 module mo_mrm_mpr
   use mo_kind, only : dp
+  use mo_message, only : message
+
   implicit none
+
   public :: reg_rout
   public :: mrm_init_param
   public :: mrm_update_param
   private
 contains
 
   ! ----------------------------------------------------------------------------
@@ -143,15 +144,14 @@
 
   subroutine mrm_init_param(iDomain, param)
 
     use mo_constants, only : HourSecs
     use mo_common_mHM_mRM_variables, only : resolutionRouting, timeStep, optimize
     use mo_common_variables, only : iFlag_cordinate_sys, domainMeta, processMatrix
     use mo_kind, only : dp, i4
-    use mo_message, only : message
     use mo_mrm_constants, only : given_TS
     use mo_mrm_global_variables, only : level11, L11_tsRout, domain_mrm, L11_celerity
     use mo_string_utils, only : num2str
     use mo_utils, only : locate, notequal
     use mo_mrm_net_startup, only : L11_calc_celerity
 
     implicit none
@@ -252,15 +252,14 @@
     use mo_common_mHM_mRM_variables, only: resolutionRouting, optimize, timeStep, &
          optimize
     use mo_mrm_constants, only: rout_space_weight, given_TS
     use mo_utils, only: locate
     use mo_mrm_net_startup, only: L11_calc_celerity
     use mo_mrm_constants, only: given_TS
     use mo_constants, only: HourSecs
-    use mo_message, only: message
     use mo_string_utils, only: num2str
     use mo_utils, only: locate
 
     implicit none
 
     ! domain number
     integer(i4), intent(in) :: iDomain
```

### Comparing `mhm-5.12.1.dev21/src/mRM/mo_mrm_net_startup.f90` & `mhm-5.13.0/src/mRM/mo_mrm_net_startup.f90`

 * *Files 1% similar despite different names*

```diff
@@ -1,30 +1,36 @@
-!>       \file mo_mrm_net_startup.f90
-
-!>       \brief Startup drainage network for mHM.
-
-!>       \details This module initializes the drainage network at L11 in mHM.
-!>       - Delineation of drainage network at level 11.
-!>       - Setting network topology (i.e. nodes and link).
-!>       - Determining routing order.
-!>       - Determining cell locations for network links.
-!>       - Find drainage outlet.
-!>       - Determine stream (links) features.
-
-!>       \authors Luis Samaniego
-
-!>       \date Dec 2012
-
-! Modifications:
-! Rohini Kumar May 2014 - cell area calulation based on a regular lat-lon grid or on a regular X-Y coordinate system
-! Robert Schweppe Jun 2018 - refactoring and reformatting
-
+!> \file mo_mrm_net_startup.f90
+!> \brief \copybrief mo_mrm_net_startup
+!> \details \copydetails mo_mrm_net_startup
+
+!> \brief Startup drainage network for mHM.
+!> \details This module initializes the drainage network at L11 in mHM.
+!! - Delineation of drainage network at level 11.
+!! - Setting network topology (i.e. nodes and link).
+!! - Determining routing order.
+!! - Determining cell locations for network links.
+!! - Find drainage outlet.
+!! - Determine stream (links) features.
+!!
+!> \changelog
+!! - Rohini Kumar May 2014
+!!   - cell area calulation based on a regular lat-lon grid or on a regular X-Y coordinate system
+!! - Robert Schweppe Jun 2018
+!!   - refactoring and reformatting
+!> \authors Luis Samaniego
+!> \date Dec 2012
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mrm
 module mo_mrm_net_startup
   use mo_kind, only : i4, dp
+  use mo_message, only : message, error_message
+
   implicit none
+
   PUBLIC :: L11_L1_mapping
   PUBLIC :: L11_flow_direction
   PUBLIC :: L11_set_network_topology
   PUBLIC :: L11_routing_order
   PUBLIC :: L11_link_location
   PUBLIC :: L11_set_drain_outlet_gauges
   PUBLIC :: L11_stream_features
@@ -218,16 +224,16 @@
   ! Stephan Thober May 2016 - introducing multiple outlets
   ! Robert Schweppe Jun 2018 - refactoring and reformatting
 
   subroutine L11_flow_direction(iDomain)
 
     use mo_append, only : append
     use mo_common_constants, only : nodata_i4
-    use mo_common_variables, only : Grid, domainMeta, level0
-    use mo_message, only : message
+    use mo_common_types, only: Grid
+    use mo_common_variables, only : domainMeta, level0
     use mo_mrm_global_variables, only : L0_draSC, L0_fAcc, L0_fDir, L0_l11_remap, L11_colOut, L11_fDir, &
                                         L11_nOutlets, L11_rowOut, domain_mrm, level11
     use mo_string_utils, only : num2str
 
     implicit none
 
     ! Domain Id
@@ -361,15 +367,15 @@
       end do
       do kk = 1, ncells0
         ii = level0_iDomain%CellCoor(kk, 1)
         jj = level0_iDomain%CellCoor(kk, 2)
         draSC0(ii, jj) = kk
       end do
 
-      ! case where routing and input data scale differs 
+      ! case where routing and input data scale differs
     ELSE
       ! =======================================================================
       ! ST: find all cells whose downstream cells are outside the domain
       ! =======================================================================
       do ii = 1, nCells0
         iRow = level0_iDomain%CellCoor(ii, 1)
         jCol = level0_iDomain%CellCoor(ii, 2)
@@ -528,15 +534,15 @@
           case (2)
             fDir11(ic, jc) = 4
           case (3)
             fDir11(ic, jc) = 16
           case (4)
             fDir11(ic, jc) = 64
           case default
-            stop 'Error L11_flow_direction: side = -1'
+             call error_message('Error L11_flow_direction: side = -1')
           end select
         end if
 
       end do
 
     END IF
     !--------------------------------------------------------
@@ -640,29 +646,29 @@
 
     integer(i4) :: fn, tn
 
     integer(i4), dimension(:), allocatable :: nLinkFromN, nLinkToN
 
 
     !     Routing network vectors have nNodes size instead of nLinks to
-    !     avoid the need of having two extra indices to identify a Domain. 
+    !     avoid the need of having two extra indices to identify a Domain.
     ! allocate
     allocate (nLinkFromN (level11(iDomain)%nCells))  ! valid from (1 : nLinks)
     allocate (nLinkToN   (level11(iDomain)%nCells))  ! "
     allocate (fDir11     (level11(iDomain)%nrows, level11(iDomain)%ncols))
     allocate (dummy_2d_id(level11(iDomain)%nrows, level11(iDomain)%ncols))
     dummy_2d_id = unpack(level11(iDomain)%Id, level11(iDomain)%mask, nodata_i4)
 
 
     ! initialize
     nLinkFromN(:) = nodata_i4
     nLinkToN(:) = nodata_i4
     fDir11(:, :) = nodata_i4
 
-    ! get grids of L11 
+    ! get grids of L11
     fDir11(:, :) = UNPACK(L11_fDir (level11(iDomain)%iStart : level11(iDomain)%iEnd), level11(iDomain)%mask, nodata_i4)
 
     ! ------------------------------------------------------------------
     !  network topology
     ! ------------------------------------------------------------------
 
     jj = 0
@@ -754,15 +760,15 @@
     integer(i4) :: ii, jj, kk
 
     logical :: flag
 
 
     nLinks = level11(iDomain)%nCells - L11_nOutlets(iDomain)
     !  Routing network vectors have nNodes size instead of nLinks to
-    !  avoid the need of having two extra indices to identify a Domain. 
+    !  avoid the need of having two extra indices to identify a Domain.
 
     ! allocate
     allocate (nLinkFromN  (level11(iDomain)%nCells))  ! all vectors valid from (1 : nLinks)
     allocate (nLinkToN    (level11(iDomain)%nCells))
     allocate (nLinkROrder (level11(iDomain)%nCells))
     allocate (nLinkLabel  (level11(iDomain)%nCells))
     allocate (nLinkSink   (level11(iDomain)%nCells))
@@ -775,15 +781,15 @@
     nLinkLabel(1 : nLinks) = 0
     nLinkLabel(level11(iDomain)%nCells) = nodata_i4
     nLinkSink(:) = .FALSE.
     netPerm(:) = nodata_i4
 
     ! for a single node model run
     if(level11(iDomain)%nCells .GT. 1) then
-      ! get network vectors of L11 
+      ! get network vectors of L11
       nLinkFromN(:) = L11_fromN (level11(iDomain)%iStart : level11(iDomain)%iEnd)
       nLinkToN(:) = L11_toN   (level11(iDomain)%iStart : level11(iDomain)%iEnd)
 
       loop1 : do ii = 1, nLinks
         loop2 : do jj = 1, nLinks
           if (jj == ii) cycle loop2
           if (nLinkFromN(ii) == nLinkToN(jj)) then
@@ -837,15 +843,15 @@
 
       ! end of multi-node network design loop
     end if
 
     !--------------------------------------------------------
     ! Start padding up local variables to global variables
     !--------------------------------------------------------
-    ! L11 network data sets 
+    ! L11 network data sets
     call append(L11_rOrder, nLinkROrder(:))
     call append(L11_label, nLinkLabel(:))
     call append(L11_sink, nLinkSink(:))
     call append(L11_netPerm, netPerm(:))
 
     ! free space
     deallocate (nLinkFromN, nLinkToN, nLinkROrder, nLinkLabel, nLinkSink, netPerm)
@@ -878,16 +884,16 @@
   ! Stephan Thober Aug 2015 - ported to mRM
   ! Robert Schweppe Jun 2018 - refactoring and reformatting
 
   subroutine L11_link_location(iDomain)
 
     use mo_append, only : append
     use mo_common_constants, only : nodata_i4
-    use mo_common_variables, only : Grid, domainMeta, level0
-    use mo_message, only : message
+    use mo_common_types, only: Grid
+    use mo_common_variables, only : domainMeta, level0
     use mo_mrm_global_variables, only : L0_draSC, L0_fDir, L11_colOut, L11_fCol, L11_fRow, L11_fromN, &
                                         L11_nOutlets, L11_netPerm, L11_rowOut, L11_tCol, L11_tRow, domain_mrm, level11
     use mo_string_utils, only : num2str
 
     implicit none
 
     ! Domain Id
@@ -938,15 +944,15 @@
     e0 = level0_iDomain%iEnd
 
     nOutlets = L11_nOutlets(iDomain)
 
     nLinks = level11(iDomain)%nCells - nOutlets
 
     !  Routing network vectors have level11(iDomain)%nCells size instead of nLinks to
-    !  avoid the need of having two extra indices to identify a Domain. 
+    !  avoid the need of having two extra indices to identify a Domain.
     ! allocate
     allocate (rowOut        (level11(iDomain)%nCells))
     allocate (colOut        (level11(iDomain)%nCells))
     allocate (nLinkFromN    (level11(iDomain)%nCells))  ! all network vectors valid from (1 : nLinks)
     allocate (netPerm       (level11(iDomain)%nCells))
     allocate (nLinkFromRow  (level11(iDomain)%nCells))
     allocate (nLinkFromCol  (level11(iDomain)%nCells))
@@ -969,15 +975,15 @@
 
     ! for a single node model run
     if(level11(iDomain)%nCells .GT. 1) then
       ! get fDir at L0
       fDir0(:, :) = UNPACK(L0_fDir  (s0 : e0), level0_iDomain%mask, nodata_i4)
       draSC0(:, :) = UNPACK(L0_draSC (s0 : e0), level0_iDomain%mask, nodata_i4)
 
-      ! get network vectors of L11 
+      ! get network vectors of L11
       nLinkFromN(:) = L11_fromN   (level11(iDomain)%iStart : level11(iDomain)%iEnd)
       netPerm(:) = L11_netPerm (level11(iDomain)%iStart : level11(iDomain)%iEnd)
       rowOut(:) = L11_rowOut  (level11(iDomain)%iStart : level11(iDomain)%iEnd)
       colOut(:) = L11_colOut  (level11(iDomain)%iStart : level11(iDomain)%iEnd)
 
       ! finding main outlet (row, col) in L0
       allocate(oLoc(Noutlets, 2))
@@ -1014,18 +1020,17 @@
             prevCol = jCol
             call moveDownOneCell(fDir0(iRow, jcol), iRow, jCol)
             ! check whether this location is an outlet and exit
             do kk = 1, Noutlets
               if (iRow .eq. oLoc(kk, 1) .and. jCol .eq. oLoc(kk, 2)) exit
             end do
             if (prevRow .eq. iRow .and. prevCol .eq. jCol) then
-              call message('Something went wrong during L11_link_location, ', &
+              call error_message('Something went wrong during L11_link_location, ', &
                   'movedownonecell got stuck in infinite loop at cell (', num2str(iRow), ' ', &
                   num2str(jCol))
-              stop 1
             end if
           end do
           ! set "to" cell (when an outlet is reached)
           nLinkToRow(ii) = iRow
           nLinkToCol(ii) = jCol
 
         end if
@@ -1033,15 +1038,15 @@
 
       ! end of multi-node network design loop
     end if
 
     !--------------------------------------------------------
     ! Start padding up local variables to global variables
     !--------------------------------------------------------
-    ! L11 network data sets 
+    ! L11 network data sets
     call append(L11_fRow, nLinkFromRow(:))
     call append(L11_fCol, nLinkFromCol(:))
     call append(L11_tRow, nLinkToRow(:))
     call append(L11_tCol, nLinkToCol(:))
 
     ! free space
     deallocate (rowOut, colOut, nLinkFromN, netPerm, nLinkFromRow, &
@@ -1080,15 +1085,16 @@
   ! Stephan Thober Aug 2015 - ported to mRM
   ! Robert Schweppe Jun 2018 - refactoring and reformatting
 
   subroutine L11_set_drain_outlet_gauges(iDomain)
 
     use mo_append, only : append
     use mo_common_constants, only : nodata_i4
-    use mo_common_variables, only : Grid, domainMeta, level0
+    use mo_common_types, only: Grid
+    use mo_common_variables, only : domainMeta, level0
     use mo_mrm_global_variables, only : L0_InflowgaugeLoc, L0_draCell, L0_draSC, L0_fDir, L0_gaugeLoc, domain_mrm, &
                                         l0_l11_remap
 
     implicit none
 
     ! Domain Id
     integer(i4), intent(in) :: iDomain
@@ -1150,15 +1156,15 @@
       do while (.NOT. iSC > 0)
         ! move downstream
         call moveDownOneCell(fDir0(iRow, jCol), iRow, jCol)
         iSC = draSC0(iRow, jCol)
       end do
       draCell0(ii, jj) = iSC
 
-      ! find cell at L11 corresponding to gauges in Domain at L0 !>> L11_on_L0 is Id of
+      ! find cell at L11 corresponding to gauges in Domain at L0 ! >> L11_on_L0 is Id of
       ! the routing cell at level-11
       if (gaugeLoc0(ii, jj) .NE. nodata_i4) then
         ! evaluation gauges
         do ll = 1, domain_mrm(iDomain)%nGauges
           ! search for gaugeID in L0 grid and save ID on L11
           if (domain_mrm(iDomain)%gaugeIdList(ll) .EQ. gaugeLoc0(ii, jj)) then
             domain_mrm(iDomain)%gaugeNodeList(ll) = L0_L11_remap(iDomain)%lowres_id_on_highres(ii, jj)
@@ -1224,15 +1230,16 @@
   ! Stephan Thober Jul 2018 - introduced cut off Length at 40 percentile to neglect short paths in headwaters for adaptive timesteps
   ! Stephan Thober, Pallav Kumar Shrestha, Sep 2020 - bug fix in cut off Length at 40 percentile, neglecting links with -9999. that occur if multiple outlets are present
 
   subroutine L11_stream_features(iDomain)
 
     use mo_append, only : append
     use mo_common_constants, only : nodata_dp, nodata_i4
-    use mo_common_variables, only : Grid, domainMeta, L0_elev, iFlag_cordinate_sys, level0, processMatrix
+    use mo_common_types, only: Grid
+    use mo_common_variables, only : domainMeta, L0_elev, iFlag_cordinate_sys, level0, processMatrix
     use mo_mrm_global_variables, only : L0_fDir, &
         L0_floodPlain, L0_streamNet, L11_aFloodPlain, L11_fCol, L11_fRow, L11_length, &
         L11_nOutlets, L11_netPerm, L11_slope, L11_tCol, L11_tRow, level11
     use mo_percentile, only: percentile
 
     implicit none
 
@@ -1301,15 +1308,15 @@
     allocate (fDir0         (level0_iDomain%nrows, level0_iDomain%ncols))
     allocate (cellarea0     (level0_iDomain%nrows, level0_iDomain%ncols))
     allocate (streamNet0    (level0_iDomain%nrows, level0_iDomain%ncols))
     allocate (floodPlain0   (level0_iDomain%nrows, level0_iDomain%ncols))
 
     !  Routing network vectors have nNodes size instead of nLinks to
     !  avoid the need of having two extra indices to identify a Domain.
-    allocate (stack             (level11(iDomain)%nCells, 2)) !>> stack(nNodes, 2)
+    allocate (stack             (level11(iDomain)%nCells, 2)) ! >> stack(nNodes, 2)
     allocate (dummy_1d          (2))
     allocate (append_chunk      (8, 2))
     allocate (netPerm           (level11(iDomain)%nCells))
     allocate (nLinkFromRow      (level11(iDomain)%nCells))
     allocate (nLinkFromCol      (level11(iDomain)%nCells))
     allocate (nLinkToRow        (level11(iDomain)%nCells))
     allocate (nLinkToCol        (level11(iDomain)%nCells))
@@ -1500,15 +1507,16 @@
   ! Stephan Thober Aug 2015 - ported to mRM
   ! Robert Schweppe Jun 2018 - refactoring and reformatting
 
   subroutine L11_fraction_sealed_floodplain(LCClassImp, do_init)
 
     use mo_append, only : append
     use mo_common_constants, only : nodata_dp
-    use mo_common_variables, only : Grid, domainMeta, L0_LCover, level0, domainMeta, nLCoverScene
+    use mo_common_types, only: Grid
+    use mo_common_variables, only : domainMeta, L0_LCover, level0, domainMeta, nLCoverScene
     use mo_mrm_global_variables, only : L0_floodPlain, L11_aFloodPlain, &
                                         L11_nLinkFracFPimp, L11_nOutlets, level11
 
     implicit none
 
     ! Impervious land cover class Id, e.g. = 2 (old code)
     integer(i4), intent(in) :: LCClassImp
@@ -1818,15 +1826,16 @@
 
   !>       \date Jun 2018
 
   ! Modifications:
 
   subroutine cellLength(iDomain, fDir, iRow, jCol, iCoorSystem, length)
 
-    use mo_common_variables, only : Grid, domainMeta, level0
+    use mo_common_types, only: Grid
+    use mo_common_variables, only : domainMeta, level0
     use mo_constants, only : SQRT2_dp
 
     implicit none
 
     integer(i4), intent(IN) :: iDomain
 
     integer(i4), intent(IN) :: fDir
@@ -2161,15 +2170,15 @@
 
   !     PURPOSE
   !>        \brief L11 celerity based on L0 elevation and L0 fAcc
 
   !>        \details L11 celerity based on L0 elevation and L0 fAcc
 
   !     INTENT(IN)
-  !>        \param[in] 
+  !>        \param[in]
 
   !     INTENT(INOUT)
   !         None
 
   !     INTENT(OUT)
   !         None
 
@@ -2202,36 +2211,36 @@
 
   subroutine L11_calc_celerity(iDomain, param)
     use mo_common_constants, only: nodata_i4, nodata_dp
     use mo_mad, only: mad
     use mo_append, only: append
     use mo_mpr_global_variables, only: &
         L0_slope               ! IN:    slope [%]
+    use mo_common_types, only: Grid
     use mo_common_variables, only: &
-        Grid,                &
         domainMeta,          & ! IN:    for L0 Domain indexer
         level0                 ! IN:    level 0 grid
     use mo_mrm_global_variables, only: &
         L0_fDir,             & ! IN:    flow direction (standard notation) L0
         L0_fAcc,             & ! IN:    flow accumulation (number of cells)?
         L0_streamNet,        & ! IN:    stream Network at Level 0
         level11,             & ! IN:    level 11 grid
-        L11_fRow,            & ! IN:    from row in L0 grid 
+        L11_fRow,            & ! IN:    from row in L0 grid
         L11_fCol,            & ! IN:    from col in L0 grid
-        L11_tRow,            & ! IN:    to row in L0 grid 
-        L11_tCol,            & ! IN:    to col in L0 grid 
+        L11_tRow,            & ! IN:    to row in L0 grid
+        L11_tCol,            & ! IN:    to col in L0 grid
         L11_netPerm,         & ! IN:    routing order (permutation)
         L11_nOutlets,        & ! IN:    Number of Outlets/Sinks
         L11_celerity,        & ! INOUT: averaged celerity
         L0_celerity            ! INOUT
 
     implicit none
 
-    integer(i4), intent(in)                  :: iDomain         ! Domain 
-    real(dp), dimension(:), intent(in)       :: param 
+    integer(i4), intent(in)                  :: iDomain         ! Domain
+    real(dp), dimension(:), intent(in)       :: param
 
     ! local
     integer(i4)                              :: nCells0
     integer(i4)                              :: nNodes
     integer(i4)                              :: nLinks
     integer(i4)                              :: nrows0, ncols0
     integer(i4)                              :: iStart0, iEnd0
@@ -2241,18 +2250,18 @@
     integer(i4), dimension(:,:), allocatable :: iD0
     integer(i4), dimension(:,:), allocatable :: fDir0
     integer(i4), dimension(:,:), allocatable :: fAcc0
     real(dp),    dimension(:,:), allocatable :: slope0
     real(dp),    dimension(:), allocatable :: slope_tmp
     real(dp),    dimension(:,:), allocatable :: cellarea0
     integer(i4), dimension(:),   allocatable :: netPerm         ! routing order (permutation)
-    integer(i4), dimension(:),   allocatable :: nLinkFromRow   
+    integer(i4), dimension(:),   allocatable :: nLinkFromRow
     integer(i4), dimension(:),   allocatable :: nLinkFromCol
-    integer(i4), dimension(:),   allocatable :: nLinkToRow     
-    integer(i4), dimension(:),   allocatable :: nLinkToCol  
+    integer(i4), dimension(:),   allocatable :: nLinkToRow
+    integer(i4), dimension(:),   allocatable :: nLinkToCol
     integer(i4)                              :: ii, rr, ns
     integer(i4)                              :: frow, fcol
     integer(i4)                              :: fId,  tId
     real(dp),    dimension(:),   allocatable :: stack, append_chunk ! Stacks celerity along the L0 river-path
     integer(i4), dimension(:),   allocatable :: dummy_1d
 
     real(dp)                                 :: L0_link_slope
@@ -2291,21 +2300,21 @@
     allocate ( cellarea0   ( nrows0, ncols0 ) )
     allocate ( celerity0   ( nrows0, ncols0 ) )
     allocate ( slopemask0  ( ncells0 ) )
 
     !  Routing network vectors have nNodes size instead of nLinks to
     !  avoid the need of having two extra indices to identify a Domain.
     allocate ( stack       ( 1 ) )
-    allocate ( append_chunk( 1 ) ) 
+    allocate ( append_chunk( 1 ) )
     allocate ( dummy_1d    ( 2 ))
-    allocate ( netPerm     ( nNodes ) )  
+    allocate ( netPerm     ( nNodes ) )
     allocate ( nLinkFromRow( nNodes ) )
     allocate ( nLinkFromCol( nNodes ) )
-    allocate ( nLinkToRow  ( nNodes ) )  
-    allocate ( nLinkToCol  ( nNodes ) ) 
+    allocate ( nLinkToRow  ( nNodes ) )
+    allocate ( nLinkToCol  ( nNodes ) )
     allocate ( celerity11  ( nNodes ) )
     allocate ( slope_tmp   ( nNodes ) )
 
     allocate (nodata_i4_tmp( nrows0, ncols0 ) )
     allocate (nodata_dp_tmp( nrows0, ncols0 ) )
 
     ! initialize
@@ -2346,15 +2355,15 @@
 
       ! smooth river cells if there is more than one cell
       if( count(slopemask0) .GT. 1) then
         slope_tmp = mad(arr = slope_tmp, z = 2.25_dp, mask = slopemask0, tout='u', mval=0.1_dp)
       end if
       slope0(:,:) = UNPACK(slope_tmp,  mask0, nodata_dp_tmp )
 
-      ! get network vectors of L11 
+      ! get network vectors of L11
       netPerm(:)      = L11_netPerm ( iStart11 : iEnd11 )
       nLinkFromRow(:) = L11_fRow    ( iStart11 : iEnd11 )
       nLinkFromCol(:) = L11_fCol    ( iStart11 : iEnd11 )
       nLinkToRow(:)   = L11_tRow    ( iStart11 : iEnd11 )
       nLinkToCol(:)   = L11_tCol    ( iStart11 : iEnd11 )
 
       do rr = 1, nLinks
@@ -2372,15 +2381,15 @@
         do
           L0_link_slope = slope0(frow, fcol) / 100._dp
 
           ! celerity parametrization
           stack(ns) = param(1) * sqrt(L0_link_slope)
 
           celerity0(frow, fcol) = stack(ns)
-          ns = ns + 1                
+          ns = ns + 1
           fId = iD0(frow, fcol)
           if( .NOT. (fID == tID)) then
             call append(stack, append_chunk)
           else
             exit
           end if
           ! move downstream
@@ -2405,12 +2414,12 @@
     L11_celerity(iStart11:iEnd11) = celerity11(:)
     L0_celerity(iStart0:iEnd0) = PACK(celerity0(:,:), mask0)
 
     ! free space
     deallocate (&
         mask0, iD0, slope_tmp, slopemask0, &
         slope0, fDir0, cellarea0,   &
-        stack, netPerm, nLinkFromRow, nLinkFromCol, nLinkToRow, nLinkToCol) 
+        stack, netPerm, nLinkFromRow, nLinkFromCol, nLinkToRow, nLinkToCol)
 
   end subroutine L11_calc_celerity
 
 end module mo_mrm_net_startup
```

### Comparing `mhm-5.12.1.dev21/src/mRM/mo_mrm_objective_function_runoff.F90` & `mhm-5.13.0/src/mRM/mo_mrm_objective_function_runoff.F90`

 * *Files 2% similar despite different names*

```diff
@@ -1,68 +1,73 @@
-!>       \file mo_mrm_objective_function_runoff.f90
-
-!>       \brief Objective Functions for Optimization of mHM/mRM against runoff.
-
-!>       \details This module provides a wrapper for several objective functions used to optimize mRM/mHM against
-!>       runoff.
-!>       If the objective contains besides runoff another variable like TWS move it to mHM/mo_objective_function.f90.
-!>       If it is only regarding runoff implement it here.
-
-!>       All the objective functions are supposed to be minimized!
-!>       (1)  SO: Q:        1.0 - NSE
-!>       (2)  SO: Q:        1.0 - lnNSE
-!>       (3)  SO: Q:        1.0 - 0.5*(NSE+lnNSE)
-!>       (4)  SO: Q:       -1.0 * loglikelihood with trend removed from absolute errors and
-!>       then lag(1)-autocorrelation removed
-!>       (5)  SO: Q:        ((1-NSE)**6+(1-lnNSE)**6)**(1/6)
-!>       (6)  SO: Q:        SSE
-!>       (7)  SO: Q:       -1.0 * loglikelihood with trend removed from absolute errors
-!>       (8)  SO: Q:       -1.0 * loglikelihood with trend removed from the relative errors and
-!>       then lag(1)-autocorrelation removed
-!>       (9)  SO: Q:        1.0 - KGE (Kling-Gupta efficiency measure)
-!>       (14) SO: Q:        sum[((1.0-KGE_i)/ nGauges)**6]**(1/6) > combination of KGE of
-!>       every gauging station based on a power-6 norm
-!>       (16) MO: Q:        1st objective: 1.0 - NSE
-!>       Q:        2nd objective: 1.0 - lnNSE
-!>       (18) MO: Q:        1st objective: 1.0 - lnNSE(Q_highflow)  (95% percentile)
-!>       Q:        2nd objective: 1.0 - lnNSE(Q_lowflow)   (5% of data range)
-!>       (19) MO: Q:        1st objective: 1.0 - lnNSE(Q_highflow)  (non-low flow)
-!>       Q:        2nd objective: 1.0 - lnNSE(Q_lowflow)   (5% of data range)eshold for Q
-!>       (20) MO: Q:        1st objective: absolute difference in FDC's low-segment volume
-!>       Q:        2nd objective: 1.0 - NSE of discharge of months DJF
-!>       (31) SO: Q:        1.0 - wNSE - weighted NSE
-!>       (32) SO: Q:        SSE of boxcox-transformed streamflow
-
-!>       \authors Juliane Mai
-
-!>       \date Dec 2012
-
-! Modifications:
-! Stephan Thober             Oct 2015 - adapted for mRM
-! Juliane Mai                Nov 2015 - introducing multi
-!                                     - and single-objective
-!                                     - first multi-objective function (16), but not used yet
-! Juliane Mai                Feb 2016 - multi-objective function (18) using lnNSE(highflows) and lnNSE(lowflows)
-!                                     - multi-objective function (19) using lnNSE(highflows) and lnNSE(lowflows)
-!                                     - multi-objective function (20) using FDC and discharge of months DJF
-! Stephan Thober,Bjoern Guse May 2018 - single objective function (21) using weighted NSE following
-!                                       (Hundecha and Bardossy, 2004)
-! Robert Schweppe            Jun 2018 - refactoring and reformatting
-! Stephan Thober             Aug 2019 - added OF 32: SSE of boxcox-transformed streamflow
-
+!> \file mo_mrm_objective_function_runoff.f90
+!> \brief \copybrief mo_mrm_objective_function_runoff
+!> \details \copydetails mo_mrm_objective_function_runoff
+
+!> \brief Objective Functions for Optimization of mHM/mRM against runoff.
+!> \details This module provides a wrapper for several objective functions used to optimize mRM/mHM against
+!> runoff.
+!!
+!> If the objective contains besides runoff another variable like TWS move it to mHM/mo_objective_function.f90.
+!> If it is only regarding runoff implement it here.
+!!
+!! All the objective functions are supposed to be minimized!
+!! 1.  SO: Q:        1.0 - NSE
+!! 2.  SO: Q:        1.0 - lnNSE
+!! 3.  SO: Q:        1.0 - 0.5*(NSE+lnNSE)
+!! 4.  SO: Q:       -1.0 * loglikelihood with trend removed from absolute errors and then lag(1)-autocorrelation removed
+!! 5.  SO: Q:        ((1-NSE)**6+(1-lnNSE)**6)**(1/6)
+!! 6.  SO: Q:        SSE
+!! 7.  SO: Q:       -1.0 * loglikelihood with trend removed from absolute errors
+!! 8.  SO: Q:       -1.0 * loglikelihood with trend removed from the relative errors and then lag(1)-autocorrelation removed
+!! 9.  SO: Q:        1.0 - KGE (Kling-Gupta efficiency measure)
+!! 14. SO: Q:        sum[((1.0-KGE_i)/ nGauges)**6]**(1/6) > combination of KGE of every gauging station based on a power-6 norm
+!! 16. MO: Q:        1st objective: 1.0 - NSE
+!!         Q:        2nd objective: 1.0 - lnNSE
+!! 18. MO: Q:        1st objective: 1.0 - lnNSE(Q_highflow)  (95% percentile)
+!!         Q:        2nd objective: 1.0 - lnNSE(Q_lowflow)   (5% of data range)
+!! 19. MO: Q:        1st objective: 1.0 - lnNSE(Q_highflow)  (non-low flow)
+!!         Q:        2nd objective: 1.0 - lnNSE(Q_lowflow)   (5% of data range)eshold for Q
+!! 20. MO: Q:        1st objective: absolute difference in FDC's low-segment volume
+!!         Q:        2nd objective: 1.0 - NSE of discharge of months DJF
+!! 31. SO: Q:        1.0 - wNSE - weighted NSE
+!! 32. SO: Q:        SSE of boxcox-transformed streamflow
+!> \changelog
+!! - Stephan Thober             Oct 2015
+!!   - adapted for mRM
+!! - Juliane Mai                Nov 2015
+!!   - introducing multi
+!!   - and single-objective
+!!   - first multi-objective function (16), but not used yet
+!! - Juliane Mai                Feb 2016
+!!   - multi-objective function (18) using lnNSE(highflows) and lnNSE(lowflows)
+!!   - multi-objective function (19) using lnNSE(highflows) and lnNSE(lowflows)
+!!   - multi-objective function (20) using FDC and discharge of months DJF
+!! - Stephan Thober,Bjoern Guse May 2018
+!!   - single objective function (21) using weighted NSE following (Hundecha and Bardossy, 2004)
+!! - Robert Schweppe            Jun 2018
+!!   - refactoring and reformatting
+!! - Stephan Thober             Aug 2019
+!!   - added OF 32: SSE of boxcox-transformed streamflow
+!> \authors Juliane Mai
+!> \date Dec 2012
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mrm
 MODULE mo_mrm_objective_function_runoff
 
   ! This module provides objective functions for optimization of the UFZ CHS mesoscale hydrologic model mHM.
 
   ! Written  Juliane Mai, Dec 2012
   ! Modified Stephan Thober, Oct 2015 - removed all none runoff objectives,
   !                                     these can be found mo_objective_functions_sm
 
   USE mo_kind, ONLY : i4, dp
   use mo_optimization_utils, only : eval_interface
+  use mo_message, only: message, error_message
+  use mo_string_utils, only : num2str
 
   IMPLICIT NONE
 
   PRIVATE
 
   PUBLIC :: single_objective_runoff ! single-objective function wrapper
   PUBLIC :: multi_objective_runoff  ! multi-objective function wrapper
@@ -112,15 +117,14 @@
   ! Stephan Thober, Bjoern Guse May 2018 - added weighted objective function
   ! Robert Schweppe             Jun 2018 - refactoring and reformatting
 
 
   FUNCTION single_objective_runoff(parameterset, eval, arg1, arg2, arg3)
 
     use mo_common_mHM_mRM_variables, only : opti_function, opti_method
-    use mo_message, only : message
 
     implicit none
 
     REAL(dp), DIMENSION(:), INTENT(IN) :: parameterset
 
     procedure(eval_interface), INTENT(IN), POINTER :: eval
 
@@ -181,16 +185,15 @@
     case (31)
       ! weighted NSE with observed streamflow
       single_objective_runoff = objective_weighted_nse(parameterset, eval)
     case (32)
       ! sum of squared errors (SSE) of boxcox_transformed streamflow
       single_objective_runoff = objective_sse_boxcox(parameterset, eval)
     case default
-      call message("Error objective: This opti_function is either not implemented yet or is not a single-objective one.")
-      stop 1
+      call error_message("Error objective: This opti_function is either not implemented yet or is not a single-objective one.")
     end select
 
   END FUNCTION single_objective_runoff
 
 
   ! ------------------------------------------------------------------
 
@@ -232,15 +235,14 @@
 #ifdef MPI
   FUNCTION single_objective_runoff_master(parameterset, eval, arg1, arg2, arg3)
 
     use mo_common_mHM_mRM_variables, only : opti_function, opti_method
     use mo_common_mpi_tools, only : distribute_parameterset
     use mo_mrm_global_variables, only: nGaugesTotal
     use mo_common_variables, only : domainMeta
-    use mo_message, only : message
     use mpi_f08
 
     implicit none
 
     REAL(dp), DIMENSION(:), INTENT(IN) :: parameterset
 
     procedure(eval_interface), INTENT(IN), POINTER :: eval
@@ -282,63 +284,58 @@
         call MPI_Recv(partial_objective, 1, MPI_DOUBLE_PRECISION, iproc, 0, domainMeta%comMaster, status, ierror)
         single_objective_runoff_master = single_objective_runoff_master + partial_objective
       end do
       single_objective_runoff_master = single_objective_runoff_master**onesixth
     case(4, 7, 8)
       call message("case 4, 7, 8 are not implemented in parallel yet")
     case default
-      call message("Error single_objective_runoff_master:")
-      call message("This opti_function is either not implemented yet or is not a single-objective one.")
-      stop 1
+      call error_message("Error single_objective_runoff_master:", raise=.false.)
+      call error_message("This opti_function is either not implemented yet or is not a single-objective one.")
     end select
 
     select case (opti_function)
     case (1)
       ! 1.0-nse
-      write(*, *) 'objective_nse (i.e., 1 - NSE) = ', single_objective_runoff_master
+      call message('objective_nse (i.e., 1 - NSE) = ', num2str(single_objective_runoff_master))
     case (2)
       ! 1.0-lnnse
-      write(*, *) 'objective_lnnse = ', single_objective_runoff_master
+      call message('objective_lnnse = ', num2str(single_objective_runoff_master))
     case (3)
       ! 1.0-0.5*(nse+lnnse)
-      write(*, *) 'objective_equal_nse_lnnse = ', single_objective_runoff_master
+      call message('objective_equal_nse_lnnse = ', num2str(single_objective_runoff_master))
     case (4)
-      call message("case 4, loglikelihood_stddev not implemented in parallel yet")
-      stop
+      call error_message("case 4, loglikelihood_stddev not implemented in parallel yet")
     case (5)
       ! ((1-NSE)**6+(1-lnNSE)**6)**(1/6)
-      write(*, *) 'objective_power6_nse_lnnse = ', single_objective_runoff_master
+      call message('objective_power6_nse_lnnse = ', num2str(single_objective_runoff_master))
     case (6)
       ! SSE
-      write(*, *) 'objective_sse = ', single_objective_runoff_master
+      call message('objective_sse = ', num2str(single_objective_runoff_master))
     case (7)
       ! -loglikelihood with trend removed from absolute errors
-      call message("case 7, single_objective_runoff_master not implemented in parallel yet")
-      stop
+      call error_message("case 7, single_objective_runoff_master not implemented in parallel yet")
     case (8)
-      call message("case 8, loglikelihood_evin2013_2 not implemented in parallel yet")
-      stop
+      call error_message("case 8, loglikelihood_evin2013_2 not implemented in parallel yet")
     case (9)
       ! KGE
-      write(*, *) 'objective_kge (i.e., 1 - KGE) = ', single_objective_runoff_master
+      call message('objective_kge (i.e., 1 - KGE) = ', num2str(single_objective_runoff_master))
     case (14)
       ! combination of KGE of every gauging station based on a power-6 norm \n
       ! sum[((1.0-KGE_i)/ nGauges)**6]**(1/6)
-      write(*, *) 'objective_multiple_gauges_kge_power6 = ', single_objective_runoff_master
+      call message('objective_multiple_gauges_kge_power6 = ', num2str(single_objective_runoff_master))
     case (31)
       ! weighted NSE with observed streamflow
-      write(*,*) 'objective_weighted_nse (i.e., 1 - wNSE) = ', single_objective_runoff_master
+      call message('objective_weighted_nse (i.e., 1 - wNSE) = ', num2str(single_objective_runoff_master))
     case (32)
       ! SSE of boxcox-transformed streamflow
-      write(*,*) 'sse_boxcox_streamflow = ', single_objective_runoff_master
+      call message('sse_boxcox_streamflow = ', num2str(single_objective_runoff_master))
     case default
-      call message("Error single_objective_runoff_master:")
-      call message("This opti_function is either not implemented yet or is not a single-objective one.")
-      call message("This part of the code should never be executed.")
-      stop 1
+      call error_message("Error single_objective_runoff_master:", raise=.false.)
+      call error_message("This opti_function is either not implemented yet or is not a single-objective one.", raise=.false.)
+      call error_message("This part of the code should never be executed.")
     end select
 
   END FUNCTION single_objective_runoff_master
 
 
   ! ------------------------------------------------------------------
 
@@ -379,15 +376,14 @@
 
 
   subroutine single_objective_runoff_subprocess(eval, arg1, arg2, arg3)
 
     use mo_common_mHM_mRM_variables, only : opti_function, opti_method
     use mo_common_mpi_tools, only : get_parameterset
     use mo_common_variables, only : domainMeta
-    use mo_message, only : message
     use mpi_f08
 
     implicit none
 
     procedure(eval_interface), INTENT(IN), POINTER :: eval
 
     real(dp), optional, intent(in) :: arg1
@@ -422,35 +418,35 @@
         partial_single_objective_runoff = objective_lnnse(parameterset, eval)
       case (3)
         ! 1.0-0.5*(nse+lnnse)
         partial_single_objective_runoff = objective_equal_nse_lnnse(parameterset, eval)
       case (4)
         if (opti_method .eq. 0_i4) then
           ! MCMC
-          stop
-          partial_single_objective_runoff = loglikelihood_stddev(parameterset, eval, arg1, arg2, arg3)
+          ! partial_single_objective_runoff = loglikelihood_stddev(parameterset, eval, arg1, arg2, arg3)
+          call error_message("Error single_objective_runoff_subprocess: case 4 with optimethod 0 not supported")
         else
           ! -loglikelihood with trend removed from absolute errors and then lag(1)-autocorrelation removed
           partial_single_objective_runoff = - loglikelihood_stddev(parameterset, eval, 1.0_dp)
         end if
       case (5)
         ! ((1-NSE)**6+(1-lnNSE)**6)**(1/6)
         partial_single_objective_runoff = objective_power6_nse_lnnse(parameterset, eval)
       case (6)
         ! SSE
         partial_single_objective_runoff = objective_sse(parameterset, eval)
       case (7)
         ! -loglikelihood with trend removed from absolute errors
-        stop
-        partial_single_objective_runoff = -loglikelihood_trend_no_autocorr(parameterset, eval, 1.0_dp)
+        ! partial_single_objective_runoff = -loglikelihood_trend_no_autocorr(parameterset, eval, 1.0_dp)
+        call error_message("Error single_objective_runoff_subprocess: case 7 not supported")
       case (8)
         if (opti_method .eq. 0_i4) then
           ! MCMC
-          stop
-          partial_single_objective_runoff = loglikelihood_evin2013_2(parameterset, eval, regularize = .true.)
+          ! partial_single_objective_runoff = loglikelihood_evin2013_2(parameterset, eval, regularize = .true.)
+          call error_message("Error single_objective_runoff_subprocess: case 8 with optimethod 0 not supported")
         else
           ! -loglikelihood of approach 2 of Evin et al. (2013),
           !  i.e. linear error model with lag(1)-autocorrelation on relative errors
           partial_single_objective_runoff = -loglikelihood_evin2013_2(parameterset, eval)
         end if
 
       case (9)
@@ -463,25 +459,23 @@
       case (31)
          ! weighted NSE with observed streamflow
          partial_single_objective_runoff = objective_weighted_nse(parameterset, eval)
       case (32)
          ! SSE of transformed streamflow
          partial_single_objective_runoff = objective_sse_boxcox(parameterset, eval)
       case default
-        call message("Error single_objective_runoff_subprocess:")
-        call message("This opti_function is either not implemented yet or is not a single-objective one.")
-        stop 1
+        call error_message("Error single_objective_runoff_subprocess:", raise=.false.)
+        call error_message("This opti_function is either not implemented yet or is not a single-objective one.")
       end select
 
       select case (opti_function)
       case (1 : 3, 5, 6, 9, 14, 31)
         call MPI_Send(partial_single_objective_runoff,1, MPI_DOUBLE_PRECISION,0,0,domainMeta%comMaster,ierror)
       case default
-        call message("Error objective_subprocess: this part should not be executed -> error in the code.")
-        stop 1
+        call error_message("Error objective_subprocess: this part should not be executed -> error in the code.")
       end select
       deallocate(parameterset)
     end do
 
   END subroutine single_objective_runoff_subprocess
 
 #endif
@@ -540,15 +534,15 @@
       ! 2nd objective: 1.0 - lnNSE(Q_lowflow)   (5% of data range)
       multi_objectives = multi_objective_lnnse_highflow_lnnse_lowflow_2(parameterset, eval)
     case (20)
       ! 1st objective: 1.0 - difference in FDC's low-segment volume
       ! 2nd objective: 1.0 - NSE of discharge of months DJF
       multi_objectives = multi_objective_ae_fdc_lsv_nse_djf(parameterset, eval)
     case default
-      stop "Error objective: Either this opti_function is not implemented yet or it is not a multi-objective one."
+      call error_message("Error objective: Either this opti_function is not implemented yet or it is not a multi-objective one.")
     end select
 
   END SUBROUTINE multi_objective_runoff
 
   ! ------------------------------------------------------------------
 
   !    NAME
@@ -668,15 +662,15 @@
     errors(nmeas) = 0.0_dp
 
     ! you have to take stddev=const because otherwise loglikelihood is always N
     ! in MCMC stddev gets updated only when a better likelihood is found.
     loglikelihood_stddev = sum(errors(:) * errors(:) / stddev**2)
     loglikelihood_stddev = -0.5_dp * loglikelihood_stddev
 
-    write(*, *) '-loglikelihood_stddev = ', -loglikelihood_stddev
+    call message('-loglikelihood_stddev = ', num2str(-loglikelihood_stddev))
 
     stddev_tmp = sqrt(sum((errors(:) - mean(errors)) * (errors(:) - mean(errors))) / real(nmeas - 1, dp))
     if (present(stddev_new)) then
       stddev_new = stddev_tmp
     end if
     if (present(likeli_new)) then
       likeli_new = sum(errors(:) * errors(:) / stddev_tmp**2)
@@ -828,18 +822,25 @@
       penalty = parameter_regularization(&
               parameterset(1 : npara - 2), &        ! current parameter set
               global_parameters(1 : npara - 2, 3), &        ! prior/initial parameter set
               global_parameters(1 : npara - 2, 1 : 2), &        ! bounds
               eq(global_parameters(1 : npara - 2, 4), 1.0_dp)) ! used/unused
 
       tmp = loglikelihood_evin2013_2 + penalty
-      write(*, *) '-loglikelihood_evin2013_2, + penalty, chi^2: ', -loglikelihood_evin2013_2, -tmp, -tmp / real(nmeas, dp)
+      call message( &
+        '-loglikelihood_evin2013_2, + penalty, chi^2: ', &
+        num2str(-loglikelihood_evin2013_2), &
+        num2str(-tmp), &
+        num2str(-tmp / real(nmeas, dp)))
       loglikelihood_evin2013_2 = tmp
     else
-      write(*, *) '-loglikelihood_evin2013_2, chi^2: ', -loglikelihood_evin2013_2, -loglikelihood_evin2013_2 / real(nmeas, dp)
+      call message( &
+        '-loglikelihood_evin2013_2, chi^2: ', &
+        num2str(-loglikelihood_evin2013_2), &
+        num2str(-loglikelihood_evin2013_2 / real(nmeas, dp)))
     end if
 
     deallocate(runoff, runoff_agg, runoff_obs_mask, runoff_obs)
     deallocate(obs, calc, out, errors, sigma, eta, y)
 
   END FUNCTION loglikelihood_evin2013_2
 
@@ -1022,15 +1023,15 @@
     errors(:) = errors(:) - (a + calc(:) * b)
 
     ! you have to take stddev_old=const because otherwise loglikelihood_trend_no_autocorr is always N
     ! in MCMC stddev_old gets updated only when a better likelihood is found.
     loglikelihood_trend_no_autocorr = sum(errors(:) * errors(:) / stddev_old**2)
     loglikelihood_trend_no_autocorr = -0.5_dp * loglikelihood_trend_no_autocorr
 
-    write(*, *) '-loglikelihood_trend_no_autocorr = ', -loglikelihood_trend_no_autocorr
+    call message('-loglikelihood_trend_no_autocorr = ', num2str(-loglikelihood_trend_no_autocorr))
 
     stddev_tmp = 1.0_dp  ! initialization
     if (present(stddev_new) .or. present(likeli_new)) then
       stddev_tmp = stddev(errors(:))
     end if
     if (present(stddev_new)) then
       stddev_new = stddev_tmp
@@ -1123,15 +1124,15 @@
       objective_lnnse = objective_lnnse + &
               lnnse(runoff_obs, runoff_agg, mask = runoff_obs_mask)
     end do
 #ifndef MPI
     ! objective function value which will be minimized
     objective_lnnse = 1.0_dp - objective_lnnse / real(nGaugesTotal, dp)
 
-    write(*, *) 'objective_lnnse = ', objective_lnnse
+    call message('objective_lnnse = ', num2str(objective_lnnse))
     ! pause
 #endif
 
     deallocate(runoff_agg, runoff_obs, runoff_obs_mask)
 
   END FUNCTION objective_lnnse
 
@@ -1212,15 +1213,15 @@
       objective_sse = objective_sse + &
               sse(runoff_obs, runoff_agg, mask = runoff_obs_mask)
     end do
 #ifndef MPI
     ! objective_sse = objective_sse + sse(gauge%Q, runoff_model_agg) !, runoff_model_agg_mask)
     objective_sse = objective_sse / real(nGaugesTotal, dp)
 
-    write(*, *) 'objective_sse = ', objective_sse
+    call message('objective_sse = ', num2str(objective_sse))
     ! pause
 #endif
 
     deallocate(runoff_agg, runoff_obs, runoff_obs_mask)
 
   END FUNCTION objective_sse
 
@@ -1302,15 +1303,15 @@
       objective_nse = objective_nse + &
               nse(runoff_obs, runoff_agg, mask = runoff_obs_mask)
     end do
 #ifndef MPI
     ! objective_nse = objective_nse + nse(gauge%Q, runoff_model_agg) !, runoff_model_agg_mask)
     objective_nse = 1.0_dp - objective_nse / real(nGaugesTotal, dp)
 
-    write(*, *) 'objective_nse (i.e., 1 - NSE) = ', objective_nse
+    call message('objective_nse (i.e., 1 - NSE) = ', num2str(objective_nse))
     ! pause
 #endif
 
     deallocate(runoff_agg, runoff_obs, runoff_obs_mask)
 
   END FUNCTION objective_nse
 
@@ -1399,15 +1400,15 @@
       objective_equal_nse_lnnse = objective_equal_nse_lnnse + &
               0.5_dp * lnnse(runoff_obs, runoff_agg, mask = runoff_obs_mask)
     end do
 #ifndef MPI
     ! objective function value which will be minimized
     objective_equal_nse_lnnse = 1.0_dp - objective_equal_nse_lnnse / real(nGaugesTotal, dp)
 
-    write(*, *) 'objective_equal_nse_lnnse = ', objective_equal_nse_lnnse
+    call message('objective_equal_nse_lnnse = ', num2str(objective_equal_nse_lnnse))
 #endif
 
     ! clean up
     deallocate(runoff_agg, runoff_obs)
     deallocate(runoff_obs_mask)
 
   END FUNCTION objective_equal_nse_lnnse
@@ -1939,15 +1940,17 @@
     end do
     ! objective function value which will be minimized
     multi_objective_ae_fdc_lsv_nse_djf(1) = &
             multi_objective_ae_fdc_lsv_nse_djf(1) / real(nGaugesTotal, dp)
     multi_objective_ae_fdc_lsv_nse_djf(2) = 1.0_dp &
             - multi_objective_ae_fdc_lsv_nse_djf(2) / real(nGaugesTotal, dp)
 
-    write(*, *) 'multi_objective_ae_fdc_lsv_nse_djf = ', multi_objective_ae_fdc_lsv_nse_djf
+    call message('multi_objective_ae_fdc_lsv_nse_djf = [', &
+      num2str(multi_objective_ae_fdc_lsv_nse_djf(1)), ', ', &
+      num2str(multi_objective_ae_fdc_lsv_nse_djf(2)), ']')
 
     ! clean up
     deallocate(runoff_agg, runoff_obs)
     deallocate(runoff_obs_mask)
 
   END FUNCTION multi_objective_ae_fdc_lsv_nse_djf
 
@@ -2036,15 +2039,15 @@
               ((1.0_dp - nse(runoff_obs, runoff_agg, mask = runoff_obs_mask))**6 + &
                       (1.0_dp - lnnse(runoff_obs, runoff_agg, mask = runoff_obs_mask))**6)**onesixth
     end do
 #ifndef MPI
     ! objective function value which will be minimized
     objective_power6_nse_lnnse = objective_power6_nse_lnnse / real(nGaugesTotal, dp)
 
-    write(*, *) 'objective_power6_nse_lnnse = ', objective_power6_nse_lnnse
+    call message('objective_power6_nse_lnnse = ', num2str(objective_power6_nse_lnnse))
     ! pause
 #endif
 
     deallocate(runoff_agg, runoff_obs, runoff_obs_mask)
 
   END FUNCTION objective_power6_nse_lnnse
 
@@ -2134,15 +2137,15 @@
       objective_kge = objective_kge + &
               kge(runoff_obs, runoff_agg, mask = runoff_obs_mask)
     end do
 #ifndef MPI
     ! objective_kge = objective_kge + kge(gauge%Q, runoff_model_agg, runoff_model_agg_mask)
     objective_kge = 1.0_dp - objective_kge / real(nGaugesTotal, dp)
 
-    write(*, *) 'objective_kge (i.e., 1 - KGE) = ', objective_kge
+    call message('objective_kge (i.e., 1 - KGE) = ', num2str(objective_kge))
 #endif
     ! pause
 
     deallocate(runoff_agg, runoff_obs, runoff_obs_mask)
 
   END FUNCTION objective_kge
 
@@ -2236,15 +2239,15 @@
       call extract_runoff(gg, runoff, runoff_agg, runoff_obs, runoff_obs_mask)
       ! KGE
       objective_multiple_gauges_kge_power6 = objective_multiple_gauges_kge_power6 + &
               ((1.0_dp - kge(runoff_obs, runoff_agg, mask = runoff_obs_mask)) / real(nGaugesTotal, dp))**6
     end do
 #ifndef MPI
     objective_multiple_gauges_kge_power6 = objective_multiple_gauges_kge_power6**onesixth
-    write(*, *) 'objective_multiple_gauges_kge_power6 = ', objective_multiple_gauges_kge_power6
+    call message('objective_multiple_gauges_kge_power6 = ', num2str(objective_multiple_gauges_kge_power6))
 #endif
 
     deallocate(runoff_agg, runoff_obs, runoff_obs_mask)
 
   END FUNCTION objective_multiple_gauges_kge_power6
 
   ! ------------------------------------------------------------------
@@ -2323,15 +2326,15 @@
        objective_weighted_nse = objective_weighted_nse + &
             wnse( runoff_obs, runoff_agg, mask=runoff_obs_mask)
     end do
 #ifndef MPI
     ! objective_nse = objective_nse + nse(gauge%Q, runoff_model_agg) !, runoff_model_agg_mask)
     objective_weighted_nse = 1.0_dp - objective_weighted_nse / real(nGaugesTotal,dp)
 
-    write(*,*) 'objective_weighted_nse (i.e., 1 - wNSE) = ',objective_weighted_nse
+    call message('objective_weighted_nse (i.e., 1 - wNSE) = ', num2str(objective_weighted_nse))
     ! pause
 #endif
 
     deallocate( runoff_agg, runoff_obs, runoff_obs_mask )
 
   END FUNCTION objective_weighted_nse
 
@@ -2426,15 +2429,15 @@
        objective_sse_boxcox = objective_sse_boxcox + &
             SSE( boxcox(runoff_obs, lambda, mask=runoff_obs_mask), boxcox(runoff_agg, lambda), mask=runoff_obs_mask)
     end do
 #ifndef MPI
     ! objective_nse = objective_nse + nse(gauge%Q, runoff_model_agg) !, runoff_model_agg_mask)
     objective_sse_boxcox = objective_sse_boxcox / real(nGaugesTotal,dp)
 
-    write(*,*) 'objective_sse_boxcox = ',objective_sse_boxcox
+    call message('objective_sse_boxcox = ', num2str(objective_sse_boxcox))
     ! pause
 #endif
 
     deallocate( runoff_agg, runoff_obs, runoff_obs_mask )
 
   END FUNCTION objective_sse_boxcox
 
@@ -2471,15 +2474,14 @@
 
   ! Modifications:
   ! Robert Schweppe Jun 2018 - refactoring and reformatting
 
   subroutine extract_runoff(gaugeId, runoff, runoff_agg, runoff_obs, runoff_obs_mask)
 
     use mo_common_mhm_mrm_variables, only : evalPer, nTstepDay, warmingDays
-    use mo_message, only : message
     use mo_mrm_global_variables, only : gauge, nMeasPerDay
     use mo_utils, only : ge
 
     implicit none
 
     ! current gauge Id
     integer(i4), intent(in) :: gaugeId
@@ -2521,16 +2523,15 @@
     TPD_sim = nTstepDay
     TPD_obs = nMeasPerDay
 
     ! check if modelled timestep is an integer multiple of measured timesteps
     if (modulo(TPD_sim, TPD_obs) .eq. 0) then
       factor = TPD_sim / TPD_obs
     else
-      call message(' Error: Number of modelled datapoints is no multiple of measured datapoints per day')
-      stop
+      call error_message(' Error: Number of modelled datapoints is no multiple of measured datapoints per day')
     end if
 
     ! extract domain Id from gauge Id
     iDomain = gauge%domainId(gaugeId)
 
     ! get length of evaluation period times TPD_obs
     length = (evalPer(iDomain)%julEnd - evalPer(iDomain)%julStart + 1) * TPD_obs
```

### Comparing `mhm-5.12.1.dev21/src/mRM/mo_mrm_pre_routing.f90` & `mhm-5.13.0/src/mRM/mo_mrm_pre_routing.f90`

 * *Files 2% similar despite different names*

```diff
@@ -1,21 +1,23 @@
-!>       \file mo_mrm_routing.f90
-
-!>       \brief Performs pre-processing for routing for mHM at level L11.
-
-!>       \details This module performs runoff accumulation from L1 to L11 and inflow summation.
-
-!>       \authors Luis Samaniego
-
-!>       \date Dec 2012
-
-! Modifications:
-! Stephan Thober Aug 2015 - adapted to mRM
-! Sebastian Mueller Jun 2020 - separate module for pre-processing
-
+!> \file mo_mrm_pre_routing.f90
+!> \brief \copybrief mo_mrm_pre_routing
+!> \details \copydetails mo_mrm_pre_routing
+
+!> \brief Performs pre-processing for routing for mHM at level L11.
+!> \details This module performs runoff accumulation from L1 to L11 and inflow summation.
+!> \changelog
+!! - Stephan Thober Aug 2015
+!!   - adapted to mRM
+!! - Sebastian Mueller Jun 2020
+!!   - separate module for pre-processing
+!> \authors Luis Samaniego
+!> \date Dec 2012
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mrm
 MODULE mo_mrm_pre_routing
 
   ! This module performs  pre-processing for routing for mHM at level L11.
 
   ! Written Sebastian Mueller Jun 2020
 
   USE mo_kind, ONLY : i4, dp
```

### Comparing `mhm-5.12.1.dev21/src/mRM/mo_mrm_read_config.f90` & `mhm-5.13.0/src/mRM/mo_mrm_read_config.f90`

 * *Files 8% similar despite different names*

```diff
@@ -1,23 +1,22 @@
-!>       \file mo_mrm_read_config.f90
-
-!>       \brief read mRM config
-
-!>       \details This module contains all mRM subroutines related to
-!>       reading the mRM configuration either from file or copy from mHM.
-
-!>       \authors Stephan Thober
-
-!>       \date Aug 2015
-
-! Modifications:
-
+!> \file mo_mrm_read_config.f90
+!> \brief \copybrief mo_mrm_read_config
+!> \details \copydetails mo_mrm_read_config
+
+!> \brief read mRM config
+!> \details This module contains all mRM subroutines related to reading the mRM configuration either from file or copy from mHM.
+!> \authors Stephan Thober
+!> \date Aug 2015
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mrm
 module mo_mrm_read_config
 
   use mo_kind, only : i4, dp
+  use mo_message, only: message, error_message
 
   implicit none
 
   public :: mrm_read_config
 
 contains
 
@@ -51,23 +50,22 @@
   ! Robert Schweppe Jun 2018 - refactoring and reformatting
 
   subroutine mrm_read_config(file_namelist, unamelist, file_namelist_param, unamelist_param, do_message)
 
     use mo_common_constants, only : maxNoDomains, nodata_i4
     use mo_common_mHM_mRM_read_config, only : common_check_resolution
     use mo_common_variables, only : ALMA_convention, domainMeta, processMatrix
-    use mo_message, only : message
     use mo_mrm_constants, only : maxNoGauges
     use mo_mrm_file, only : file_defOutput, udefOutput
     use mo_mrm_global_variables, only : InflowGauge, domainInfo_mRM, domain_mrm, &
                                         dirGauges, dirTotalRunoff, filenameTotalRunoff, dirBankfullRunoff, gauge, is_start, &
                                         nGaugesTotal, nGaugesLocal, nInflowGaugesTotal, outputFlxState_mrm, &
                                         timeStep_model_outputs_mrm, &
                                         varnameTotalRunoff, gw_coupling, &
-                                        output_deflate_level_mrm, output_double_precision_mrm, &
+                                        output_deflate_level_mrm, output_double_precision_mrm, output_time_reference_mrm, &
                                         readLatLon
     use mo_nml, only : close_nml, open_nml, position_nml
     use mo_string_utils, only : num2str
 
     implicit none
 
     character(*), intent(in) :: file_namelist, file_namelist_param
@@ -117,14 +115,15 @@
     ! namelist for inflow gauges
     namelist /inflow_gauges/ nInflowGaugesTotal, NoInflowGauges_domain, InflowGauge_id, &
             InflowGauge_filename, InflowGauge_Headwater
     ! name list regarding output
     namelist /NLoutputResults/ &
             output_deflate_level_mrm, &
             output_double_precision_mrm, &
+            output_time_reference_mrm, &
             timeStep_model_outputs_mrm, &
             outputFlxState_mrm
 
     !===============================================================
     ! INITIALIZATION
     !===============================================================
     is_start = .True.
@@ -167,19 +166,17 @@
     !===============================================================
     ! READ EVALUATION GAUGES
     !===============================================================
     call position_nml('evaluation_gauges', unamelist)
     read(unamelist, nml = evaluation_gauges)
 
     if (nGaugesTotal .GT. maxNoGauges) then
-      call message()
-      call message('***ERROR: ', trim(file_namelist), ': Total number of evaluation gauges is restricted to', &
-              num2str(maxNoGauges))
-      call message('          Error occured in namlist: evaluation_gauges')
-      stop 1
+      call error_message('***ERROR: ', trim(file_namelist), ': Total number of evaluation gauges is restricted to', &
+              num2str(maxNoGauges), raise=.false.)
+      call error_message('          Error occured in namlist: evaluation_gauges')
     end if
 
     ! ToDo: check
     nGaugesLocal = 0
     do iDomain = 1, domainMeta%nDomains
       domainID = domainMeta%indices(iDomain)
       nGaugesLocal = nGaugesLocal + NoGauges_domain(domainID)
@@ -204,58 +201,50 @@
       domain_mrm_iDomain%gaugeIdList = nodata_i4
       allocate(domain_mrm_iDomain%gaugeIndexList(maxval(NoGauges_domain(:))))
       domain_mrm_iDomain%gaugeIndexList = nodata_i4
       allocate(domain_mrm_iDomain%gaugeNodeList(maxval(NoGauges_domain(:))))
       domain_mrm_iDomain%gaugeNodeList = nodata_i4
       ! check if NoGauges_domain has a valid value
       if (NoGauges_domain(domainID) .EQ. nodata_i4) then
-        call message()
-        call message('***ERROR: ', trim(file_namelist), ': Number of evaluation gauges for subdomain ', &
-                trim(adjustl(num2str(domainID))), ' is not defined!')
-        call message('          Error occured in namelist: evaluation_gauges')
-        stop 1
+        call error_message('***ERROR: ', trim(file_namelist), ': Number of evaluation gauges for subdomain ', &
+                trim(adjustl(num2str(domainID))), ' is not defined!', raise=.false.)
+        call error_message('          Error occured in namelist: evaluation_gauges')
       end if
 
       domain_mrm_iDomain%nGauges = NoGauges_domain(domainID)
 
       do iGauge = 1, NoGauges_domain(domainID)
         ! check if NoGauges_domain has a valid value
         if (Gauge_id(domainID, iGauge) .EQ. nodata_i4) then
-          call message()
-          call message('***ERROR: ', trim(file_namelist), ': ID ', &
+          call error_message('***ERROR: ', trim(file_namelist), ': ID ', &
                   trim(adjustl(num2str(Gauge_id(domainID, iGauge)))), ' of evaluation gauge ', &
                   trim(adjustl(num2str(iGauge))), ' for subdomain ', &
-                  trim(adjustl(num2str(iDomain))), ' is not defined!')
-          call message('          Error occured in namelist: evaluation_gauges')
-          stop 1
+                  trim(adjustl(num2str(iDomain))), ' is not defined!', raise=.false.)
+          call error_message('          Error occured in namelist: evaluation_gauges')
         else if (trim(gauge_filename(domainID, iGauge)) .EQ. trim(num2str(nodata_i4))) then
-          call message()
-          call message('***ERROR: ', trim(file_namelist), ': Filename of evaluation gauge ', &
+          call error_message('***ERROR: ', trim(file_namelist), ': Filename of evaluation gauge ', &
                   trim(adjustl(num2str(iGauge))), ' for subdomain ', &
-                  trim(adjustl(num2str(iDomain))), ' is not defined!')
-          call message('          Error occured in namelist: evaluation_gauges')
-          stop 1
+                  trim(adjustl(num2str(iDomain))), ' is not defined!', raise=.false.)
+          call error_message('          Error occured in namelist: evaluation_gauges')
         end if
         !
         idx = idx + 1
         gauge%domainId(idx) = iDomain
         gauge%gaugeId(idx) = Gauge_id(domainID, iGauge)
         gauge%fname(idx) = trim(dirGauges(iDomain)) // trim(gauge_filename(domainID, iGauge))
         domain_mrm_iDomain%gaugeIdList(iGauge) = Gauge_id(domainID, iGauge)
         domain_mrm_iDomain%gaugeIndexList(iGauge) = idx
       end do
     end do
 
     if (nGaugesLocal .NE. idx) then
-      call message()
-      call message('***ERROR: ', trim(file_namelist), ': Total number of evaluation gauges (', &
+      call error_message('***ERROR: ', trim(file_namelist), ': Total number of evaluation gauges (', &
               trim(adjustl(num2str(nGaugesLocal))), &
-              ') different from sum of gauges in subdomains (', trim(adjustl(num2str(idx))), ')!')
-      call message('          Error occured in namelist: evaluation_gauges')
-      stop
+              ') different from sum of gauges in subdomains (', trim(adjustl(num2str(idx))), ')!', raise=.false.)
+      call error_message('          Error occured in namelist: evaluation_gauges')
     end if
 
     !===============================================================
     ! Read inflow gauge information
     !===============================================================
 
     nInflowGaugesTotal = 0
@@ -263,19 +252,17 @@
     InflowGauge_id = nodata_i4
     InflowGauge_filename = num2str(nodata_i4)
 
     call position_nml('inflow_gauges', unamelist)
     read(unamelist, nml = inflow_gauges)
 
     if (nInflowGaugesTotal .GT. maxNoGauges) then
-      call message()
-      call message('***ERROR: ', trim(file_namelist), &
-              ':read_gauge_lut: Total number of inflow gauges is restricted to', num2str(maxNoGauges))
-      call message('          Error occured in namlist: inflow_gauges')
-      stop
+      call error_message('***ERROR: ', trim(file_namelist), &
+              ':read_gauge_lut: Total number of inflow gauges is restricted to', num2str(maxNoGauges), raise=.false.)
+      call error_message('          Error occured in namlist: inflow_gauges')
     end if
 
     ! allocation - max() to avoid allocation with zero, needed for mhm call
     allocate(InflowGauge%gaugeId (max(1, nInflowGaugesTotal)))
     allocate(InflowGauge%domainId (max(1, nInflowGaugesTotal)))
     allocate(InflowGauge%fName   (max(1, nInflowGaugesTotal)))
     ! dummy initialization
@@ -304,46 +291,40 @@
       end if
 
       domain_mrm_iDomain%nInflowGauges = NoInflowGauges_domain(domainID)
 
       do iGauge = 1, NoInflowGauges_domain(domainID)
         ! check if NoInflowGauges_domain has a valid value
         if (InflowGauge_id(domainID, iGauge) .EQ. nodata_i4) then
-          call message()
-          call message('***ERROR: ', trim(file_namelist), ':ID of inflow gauge ', &
+          call error_message('***ERROR: ', trim(file_namelist), ':ID of inflow gauge ', &
                   trim(adjustl(num2str(iGauge))), ' for subdomain ', &
-                  trim(adjustl(num2str(iDomain))), ' is not defined!')
-          call message('          Error occured in namlist: inflow_gauges')
-          stop
+                  trim(adjustl(num2str(iDomain))), ' is not defined!', raise=.false.)
+          call error_message('          Error occured in namlist: inflow_gauges')
         else if (trim(InflowGauge_filename(domainID, iGauge)) .EQ. trim(num2str(nodata_i4))) then
-          call message()
-          call message('***ERROR: ', trim(file_namelist), ':Filename of inflow gauge ', &
+          call error_message('***ERROR: ', trim(file_namelist), ':Filename of inflow gauge ', &
                   trim(adjustl(num2str(iGauge))), ' for subdomain ', &
-                  trim(adjustl(num2str(iDomain))), ' is not defined!')
-          call message('          Error occured in namlist: inflow_gauges')
-          stop
+                  trim(adjustl(num2str(iDomain))), ' is not defined!', raise=.false.)
+          call error_message('          Error occured in namlist: inflow_gauges')
         end if
         !
         idx = idx + 1
         InflowGauge%domainId(idx) = iDomain
         InflowGauge%gaugeId(idx) = InflowGauge_id(domainID, iGauge)
         InflowGauge%fname(idx) = trim(dirGauges(domainID)) // trim(InflowGauge_filename(domainID, iGauge))
         domain_mrm_iDomain%InflowGaugeIdList(iGauge) = InflowGauge_id(domainID, iGauge)
         domain_mrm_iDomain%InflowGaugeHeadwater(iGauge) = InflowGauge_Headwater(domainID, iGauge)
         domain_mrm_iDomain%InflowGaugeIndexList(iGauge) = idx
       end do
     end do
 
     if (nInflowGaugesTotal .NE. idx) then
-      call message()
-      call message('***ERROR: ', trim(file_namelist), ': Total number of inflow gauges (', &
+      call error_message('***ERROR: ', trim(file_namelist), ': Total number of inflow gauges (', &
               trim(adjustl(num2str(nInflowGaugesTotal))), &
-              ') different from sum of inflow gauges in subdomains (', trim(adjustl(num2str(idx))), ')!')
-      call message('          Error occured in namlist: inflow_gauges')
-      stop
+              ') different from sum of inflow gauges in subdomains (', trim(adjustl(num2str(idx))), ')!', raise=.false.)
+      call error_message('          Error occured in namlist: inflow_gauges')
     end if
 
     call common_check_resolution(do_message, .true.)
 
     call close_nml(unamelist)
 
     !===============================================================
@@ -351,14 +332,15 @@
     !===============================================================
     call read_mrm_routing_params(processMatrix(8, 1), file_namelist_param, unamelist_param)
 
     !===============================================================
     ! Read Output specifications for mRM
     !===============================================================
     output_deflate_level_mrm = 6
+    output_time_reference_mrm = 0
     output_double_precision_mrm = .true.
     outputFlxState_mrm = .FALSE.
     timeStep_model_outputs_mrm = -2
     inquire(file = file_defOutput, exist = file_exists)
     if (file_exists) then
       ! file exists
       call open_nml(file_defOutput, udefOutput, quiet = .true.)
@@ -376,14 +358,22 @@
       call message('    Following output will be written:')
       call message('    NetCDF deflate level: ', adjustl(trim(num2str(output_deflate_level_mrm))))
       if ( output_double_precision_mrm ) then
         call message('    NetCDF output precision: double')
       else
         call message('    NetCDF output precision: single')
       end if
+      select case(output_time_reference_mrm)
+        case(0)
+          call message('    NetCDF output time reference point: start of time interval')
+        case(1)
+          call message('    NetCDF output time reference point: center of time interval')
+        case(2)
+          call message('    NetCDF output time reference point: end of time interval')
+      end select
       call message('    FLUXES:')
       if (outputFlxState_mrm(1)) then
         call message('      routed streamflow      (L11_qMod)                [m3 s-1]')
       end if
       if (outputFlxState_mrm(2)) then
         call message('      river temperature      (RivTemp)                 [deg C]')
       end if
@@ -422,15 +412,14 @@
   ! Modifications:
 
   subroutine read_mrm_routing_params(processCase, file_namelist_param, unamelist_param)
 
     use mo_common_constants, only : nColPars
     use mo_common_functions, only : in_bound
     use mo_common_variables, only : global_parameters, global_parameters_name, processMatrix
-    use mo_message, only : message
     use mo_nml, only : close_nml, open_nml, position_nml
 
     implicit none
 
     ! it is the default case, should be one
     integer(i4), intent(in) :: processCase
 
@@ -517,16 +506,15 @@
 
         global_parameters_name(start_index + 1 : start_index + processMatrix(8,2)) = (/ &
              'slope_factor'/)
     end if
 
     ! check if parameter are in range
     if (.not. in_bound(global_parameters)) then
-      call message('***ERROR: parameter in routing namelist out of bound in ', &
+      call error_message('***ERROR: parameter in routing namelist out of bound in ', &
               trim(adjustl(file_namelist_param)))
-      stop
     end if
 
     call close_nml(unamelist_param)
 
   end subroutine read_mrm_routing_params
 end module mo_mrm_read_config
```

### Comparing `mhm-5.12.1.dev21/src/mRM/mo_mrm_read_data.f90` & `mhm-5.13.0/src/mRM/mo_mrm_read_data.f90`

 * *Files 6% similar despite different names*

```diff
@@ -1,23 +1,24 @@
-!>       \file mo_mrm_read_data.f90
-
-!>       \brief This module contains all routines to read mRM data from file.
-!>       \details
-
-!>       \details TODO: add description
-
-!>       \authors Stephan Thober
-
-!>       \date Aug 2015
-
-! Modifications:
-
+!> \file mo_mrm_read_data.f90
+!> \brief \copybrief mo_mrm_read_data
+!> \details \copydetails mo_mrm_read_data
+
+!> \brief mRM reading routines
+!> \details This module contains all routines to read mRM data from file.
+!> \authors Stephan Thober
+!> \date Aug 2015
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mrm
 module mo_mrm_read_data
   use mo_kind, only : i4, dp
+  use mo_message, only: message, error_message
+
   implicit none
+
   public :: mrm_read_L0_data
   public :: mrm_read_discharge
   public :: mrm_read_total_runoff
   public :: mrm_read_bankfull_runoff
   private
 contains
   ! ------------------------------------------------------------------
@@ -48,17 +49,17 @@
   ! Stephan Thober Jun 2018 - including varying celerity functionality
 
   subroutine mrm_read_L0_data(do_reinit, do_readlatlon, do_readlcover)
 
     use mo_append, only : append
     use mo_common_constants, only : nodata_i4
     use mo_common_read_data, only : read_dem, read_lcover
-    use mo_common_variables, only : Grid, L0_LCover, dirMorpho, level0, domainMeta, processMatrix
+    use mo_common_types, only: Grid
+    use mo_common_variables, only : L0_LCover, dirMorpho, level0, domainMeta, processMatrix
     use mo_mpr_file, only: file_slope, uslope
-    use mo_message, only : message
     use mo_mrm_file, only : file_facc, file_fdir, &
                             file_gaugeloc, ufacc, ufdir, ugaugeloc
     use mo_mrm_global_variables, only : L0_InflowGaugeLoc, L0_fAcc, L0_fDir, L0_gaugeLoc, domain_mrm
     use mo_read_latlon, only : read_latlon
     use mo_read_spatial_data, only : read_spatial_data_ascii
     use mo_string_utils, only : num2str
 
@@ -188,39 +189,35 @@
           call append(L0_fDir, pack(data_i4_2d, level0_iDomain%mask))
         case(3) ! location of evaluation and inflow gauging stations
           ! evaluation gauges
           ! Input data check
           do iGauge = 1, domain_mrm(iDomain)%nGauges
             ! If gaugeId is found in gauging location file?
             if (.not. any(data_i4_2d .EQ. domain_mrm(iDomain)%gaugeIdList(iGauge))) then
-              call message()
-              call message('***ERROR: Gauge ID "', trim(adjustl(num2str(domain_mrm(iDomain)%gaugeIdList(iGauge)))), &
-                      '" not found in ')
-              call message('          Gauge location input file: ', &
+              call error_message('***ERROR: Gauge ID "', trim(adjustl(num2str(domain_mrm(iDomain)%gaugeIdList(iGauge)))), &
+                      '" not found in ', raise=.false.)
+              call error_message('          Gauge location input file: ', &
                       trim(adjustl(dirMorpho(iDomain))) // trim(adjustl(file_gaugeloc)))
-              stop
             end if
           end do
 
           call append(L0_gaugeLoc, pack(data_i4_2d, level0_iDomain%mask))
 
           ! inflow gauges
           ! if no inflow gauge for this subdomain exists still matirx with dim of subdomain has to be paded
           if (domain_mrm(iDomain)%nInflowGauges .GT. 0_i4) then
             ! Input data check
             do iGauge = 1, domain_mrm(iDomain)%nInflowGauges
               ! If InflowGaugeId is found in gauging location file?
               if (.not. any(data_i4_2d .EQ. domain_mrm(iDomain)%InflowGaugeIdList(iGauge))) then
-                call message()
-                call message('***ERROR: Inflow Gauge ID "', &
+                call error_message('***ERROR: Inflow Gauge ID "', &
                         trim(adjustl(num2str(domain_mrm(iDomain)%InflowGaugeIdList(iGauge)))), &
-                        '" not found in ')
-                call message('          Gauge location input file: ', &
+                        '" not found in ', raise=.false.)
+                call error_message('          Gauge location input file: ', &
                         trim(adjustl(dirMorpho(iDomain))) // trim(adjustl(file_gaugeloc)))
-                stop 1
               end if
             end do
           end if
 
           call append(L0_InflowGaugeLoc, pack(data_i4_2d, level0_iDomain%mask))
 
         end select
@@ -255,15 +252,14 @@
 
   subroutine mrm_read_discharge
 
     use mo_append, only : paste
     use mo_common_constants, only : nodata_dp
     use mo_common_mHM_mRM_variables, only : evalPer, nTstepDay, opti_function, optimize, simPer
     use mo_common_variables, only : domainMeta
-    use mo_message, only : message
     use mo_mrm_file, only : udischarge
     use mo_mrm_global_variables, only : InflowGauge, gauge, mRM_runoff, nGaugesLocal, &
                                         nInflowGaugesTotal, nMeasPerDay, &
                                         riv_temp_pcs
     use mo_read_timeseries, only : read_timeseries
     use mo_string_utils, only : num2str
 
@@ -326,19 +322,17 @@
         end_tmp = (/simPer(iDomain)%yEnd, simPer(iDomain)%mEnd, simPer(iDomain)%dEnd  /)
         ! inflow gauge
         fName = trim(adjustl(InflowGauge%fname(iGauge)))
         call read_timeseries(trim(fName), udischarge, &
                 start_tmp, end_tmp, optimize, opti_function, &
                 data_dp_1d, mask = mask_1d, nMeasPerDay = nMeasPerDay)
         if (.NOT. (all(mask_1d))) then
-          call message()
-          call message('***ERROR: Nodata values in inflow gauge time series. File: ', trim(fName))
-          call message('          During simulation period from ', num2str(simPer(iDomain)%yStart) &
+          call error_message('***ERROR: Nodata values in inflow gauge time series. File: ', trim(fName), raise=.false.)
+          call error_message('          During simulation period from ', num2str(simPer(iDomain)%yStart) &
                   , ' to ', num2str(simPer(iDomain)%yEnd))
-          stop
         end if
         data_dp_1d = merge(data_dp_1d, nodata_dp, mask_1d)
         call paste(InflowGauge%Q, data_dp_1d, nodata_dp)
         deallocate (data_dp_1d)
       end do
     end if
```

### Comparing `mhm-5.12.1.dev21/src/mRM/mo_mrm_restart.f90` & `mhm-5.13.0/src/mRM/mo_mrm_restart.f90`

 * *Files 1% similar despite different names*

```diff
@@ -1,23 +1,24 @@
-!>       \file mo_mrm_restart.f90
-
-!>       \brief Restart routines
-
-!>       \details This module contains the subroutines for reading and writing
-!>       routing related variables to file.
-
-!>       \authors Stephan Thober
-
-!>       \date Aug 2015
-
-! Modifications:
-
+!> \file mo_mrm_restart.f90
+!> \brief \copybrief mo_mrm_restart
+!> \details \copydetails mo_mrm_restart
+
+!> \brief Restart routines
+!> \details This module contains the subroutines for reading and writing routing related variables to file.
+!> \authors Stephan Thober
+!> \date Aug 2015
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mrm
 module mo_mrm_restart
   use mo_kind, only : i4, dp
+  use mo_message, only : message, error_message
+
   implicit none
+
   public :: mrm_write_restart
   public :: mrm_read_restart_states
   public :: mrm_read_restart_config
 contains
 
   ! ------------------------------------------------------------------
 
@@ -55,15 +56,14 @@
   subroutine mrm_write_restart(iDomain, domainID, OutFile)
 
     use mo_common_constants, only : nodata_dp, nodata_i4
     use mo_common_restart, only : write_grid_info
     use mo_common_variables, only : level0, level1, nLCoverScene, processMatrix, domainMeta, &
             LC_year_start, LC_year_end
     use mo_common_constants, only : landCoverPeriodsVarName
-    use mo_message, only : message
     use mo_mrm_constants, only : nRoutingStates
     use mo_mpr_global_variables, only : L0_slope
     use mo_mrm_global_variables, only : L0_fdir, L0_fAcc, L0_streamnet, &
                                         L1_L11_Id, &
                                         L11_C1, L11_C2, L11_K, L11_L1_Id, L11_Qmod, &
                                         L11_TSrout, L11_aFloodPlain, L11_colOut, L11_colOut, L11_fCol, L11_fDir, &
                                         L11_fAcc, L11_fRow, L11_fromN, L11_label, L11_length, L11_nLinkFracFPimp, &
@@ -221,15 +221,14 @@
     var = nc%setVariable("L1_Id", "i32", (/rows1, cols1/))
     call var%setFillValue(nodata_i4)
     call var%setData(unpack(level1(iDomain)%Id(1:e1-s1+1), mask1, nodata_i4))
     call var%setAttribute("long_name", "cell IDs at level 1")
 
     var = nc%setVariable("L1_L11_Id", "i32", (/rows1, cols1/))
     call var%setFillValue(nodata_i4)
-    ! call var%setData(L1_L11_remap(iDomain)%lowres_id_on_highres)
     call var%setData(unpack(L1_L11_Id(s1 : e1), mask1, nodata_i4))
     call var%setAttribute("long_name", "Mapping of L1 Id on L11")
 
     var = nc%setVariable("L11_Qmod", "f64", (/rows11, cols11/))
     call var%setFillValue(nodata_dp)
     call var%setData(unpack(L11_Qmod(s11 : e11), mask11, nodata_dp))
     call var%setAttribute("long_name", "simulated discharge at each node at level 11")
@@ -602,15 +601,14 @@
 
   subroutine mrm_read_restart_config(iDomain, domainID, InFile)
 
     use mo_append, only : append
     use mo_common_constants, only : nodata_dp
     use mo_common_variables, only : level0, level1, domainMeta, processMatrix, domainMeta
     use mo_kind, only : dp, i4
-    use mo_message, only : message
     use mo_mpr_global_variables, only : L0_slope
     use mo_mrm_global_variables, only : L0_fdir, L0_fAcc, L0_streamnet, &
                                         L11_L1_Id, L11_TSrout, L11_aFloodPlain, L11_colOut, L11_fCol, &
                                         L11_fDir, L11_fAcc, L11_fRow, L11_fromN, L11_label, L11_length, L11_nOutlets, L11_netPerm, &
                                         L11_rOrder, L11_rowOut, L11_sink, L11_slope, L11_tCol, L11_tRow, L11_toN, &
                                         L1_L11_Id, domain_mrm, level11
     use mo_netcdf, only : NcDataset, NcVariable
@@ -668,20 +666,20 @@
     ! <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
     ! Read Process Matrix for check <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
     ! <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
     var = nc%getVariable("ProcessMatrix")
     allocate(dummyI1(size(processMatrix, dim = 1)))
     call var%getData(dummyI1)
     if (dummyI1(8) .ne. processMatrix(8, 1)) then
-      call message('***ERROR: process description for routing')
-      call message('***ERROR: given in restart file does not match')
-      call message('***ERROR: that in namelist')
-      call message('***ERROR: restart file value:. ' // num2str(dummyI1(8), '(i2)'))
-      call message('***ERROR: namelist value:..... ' // num2str(processMatrix(8, 1), '(i2)'))
-      stop 'ERROR: mrm_read_restart_config'
+      call error_message('***ERROR: process description for routing', raise=.false.)
+      call error_message('***ERROR: given in restart file does not match', raise=.false.)
+      call error_message('***ERROR: that in namelist', raise=.false.)
+      call error_message('***ERROR: restart file value:. ' // num2str(dummyI1(8), '(i2)'), raise=.false.)
+      call error_message('***ERROR: namelist value:..... ' // num2str(processMatrix(8, 1), '(i2)'), raise=.false.)
+      call error_message('ERROR: mrm_read_restart_config')
     end if
     deallocate(dummyI1)
 
     ! <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
     ! Read L0 variables <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
     ! <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
     if (processMatrix(8, 1) .eq. 3_i4) then
```

### Comparing `mhm-5.12.1.dev21/src/mRM/mo_mrm_riv_temp_class.f90` & `mhm-5.13.0/src/mRM/mo_mrm_riv_temp_class.f90`

 * *Files 6% similar despite different names*

```diff
@@ -1,15 +1,20 @@
 !> \file    mo_mrm_riv_temp_class.f90
+!> \brief   \copybrief mo_mrm_riv_temp_class
+!> \details \copydetails mo_mrm_riv_temp_class
 
 !> \brief   Class for the river temperature calculations
-!> \warning This feature is still experimental!
+!> \details River temperature routing on top of mRM.
+!> \warning This feature is still experimental! River freezing is still missing.
 !> \version 0.1
 !> \authors Sebastian Mueller
 !> \date    Sep 2020
-
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mrm
 module mo_mrm_riv_temp_class
 
   use mo_kind, only: dp, i4
 
   implicit none
 
   private
@@ -48,15 +53,18 @@
     logical :: bisect_iter   !< whether to do the bisection search part (after the interval is found)
     real(dp) :: up_bnd_iter  !< upper bound for the current bisection step
     real(dp) :: low_bnd_iter !< lower bound for the current bisection step
     ! accumulated later fluxes (in current time-step)
     real(dp), dimension(:), allocatable :: L1_runoff_E !< runoff energy at L1 level
     real(dp), dimension(:), allocatable :: L1_acc_ssrd !< accumulated shortwave radiation at L1 level
     real(dp), dimension(:), allocatable :: L1_acc_strd !< accumulated longwave radiation at L1 level
-    real(dp), dimension(:), allocatable :: L1_acc_temp !< accumulated air temperature radiation at L1 level
+    real(dp), dimension(:), allocatable :: L1_acc_temp !< accumulated air temperature at L1 level
+    real(dp), dimension(:), allocatable :: L1_ssrd_calc !< current shortwave radiation at L1 level
+    real(dp), dimension(:), allocatable :: L1_strd_calc !< current longwave radiation at L1 level
+    real(dp), dimension(:), allocatable :: L1_tann_calc !< current mean air temperature at L1 level
     integer(i4) :: ts_cnt !< sub time-step counter for accumulation of meteo
     ! vars for routing
     integer(i4) :: s11 !< starting index for current L11 domain
     integer(i4) :: e11 !< ending index for current L11 domain
     real(dp), dimension(:,:), allocatable :: netNode_E_IN !< Total energy inputs at t-1 and t
     real(dp), dimension(:,:), allocatable :: netNode_E_R  !< energy leaving at t-1 and t
     real(dp), dimension(:), allocatable :: netNode_E_mod  !< Simulated routed energy
@@ -135,14 +143,18 @@
     if ( allocated(self%netNode_E_R) ) deallocate(self%netNode_E_R)
     if ( allocated(self%netNode_E_mod) ) deallocate(self%netNode_E_mod)
     if ( allocated(self%netNode_E_out) ) deallocate(self%netNode_E_out)
     if ( allocated(self%L11_srad_net) ) deallocate(self%L11_srad_net)
     if ( allocated(self%L11_lrad_in) ) deallocate(self%L11_lrad_in)
     if ( allocated(self%L11_air_temp) ) deallocate(self%L11_air_temp)
     if ( allocated(self%river_temp) ) deallocate(self%river_temp)
+    ! meteo arrays
+    if ( allocated(self%L1_ssrd_calc) ) deallocate(self%L1_ssrd_calc)
+    if ( allocated(self%L1_strd_calc) ) deallocate(self%L1_strd_calc)
+    if ( allocated(self%L1_tann_calc) ) deallocate(self%L1_tann_calc)
 
   end subroutine clean_up
 
   !> \brief configure the \ref riv_temp_type class from the mhm namelist
   subroutine config( &
     self, &
     file_namelist, &
@@ -227,18 +239,18 @@
     ! closing the namelist file
     call close_nml(unamelist)
 
     do iDomain = 1, domainMeta%nDomains
       domainID = domainMeta%indices(iDomain)
       call check_dir( &
         path=self%dir_riv_widths(iDomain), &
-        text_="(domain "//trim(num2str(domainID,'(I3)'))//") River widths directory:", &
-        throwError_=.true., &
-        tab_=4, &
-        text_length_=40 &
+        text="(domain "//trim(num2str(domainID,'(I3)'))//") River widths directory:", &
+        raise=.true., &
+        tab=4, &
+        text_length=40 &
       )
     end do
 
   end subroutine config
 
   !> \brief initalize the \ref riv_temp_type class for the current domain
   subroutine init( &
@@ -248,42 +260,39 @@
     use mo_append, only : append
     use mo_mrm_constants, only : nRoutingStates
     ! use mo_common_variables, only : level0, domainMeta
 
     implicit none
 
     class(riv_temp_type), intent(inout) :: self
-    integer(i4), intent(in) :: nCells !< number of cells for the current domain
+    integer(i4), intent(in) :: nCells !< number of level-11 cells for the current domain
 
     real(dp), dimension(:), allocatable :: dummy_Vector11
     real(dp), dimension(:, :), allocatable :: dummy_Matrix11_IT
 
     ! dummy vector and matrix
     allocate(dummy_Vector11   (nCells))
     allocate(dummy_Matrix11_IT(nCells, nRoutingStates))
+    dummy_Vector11(:) = 0.0_dp
+    dummy_Matrix11_IT(:, :) = 0.0_dp
 
     ! simulated energy flux at each node
-    dummy_Vector11(:) = 0.0_dp
     call append(self%netNode_E_mod, dummy_Vector11)
     ! simulated river temperature at each node
-    dummy_Vector11(:) = 0.0_dp
     call append(self%river_temp, dummy_Vector11)
     ! Total outflow from cells L11 at time tt
-    dummy_Vector11(:) = 0.0_dp
     call append(self%netNode_E_out, dummy_Vector11)
     ! Total discharge inputs at t-1 and t
-    dummy_Matrix11_IT(:, :) = 0.0_dp
     call append(self%netNode_E_IN, dummy_Matrix11_IT)
     !  Routed outflow leaving a node
-    dummy_Matrix11_IT(:, :) = 0.0_dp
     call append(self%netNode_E_R, dummy_Matrix11_IT)
 
     ! free space
-    if (allocated(dummy_Vector11)) deallocate(dummy_Vector11)
-    if (allocated(dummy_Matrix11_IT)) deallocate(dummy_Matrix11_IT)
+    deallocate(dummy_Vector11)
+    deallocate(dummy_Matrix11_IT)
 
   end subroutine init
 
   !> \brief initialize the river area of \ref riv_temp_type class for the current domain
   subroutine init_area( &
     self, &
     iDomain, &
@@ -346,74 +355,37 @@
     deallocate(L11_riv_areas)
 
   end subroutine init_area
 
   !> \brief initialize the river temperature of \ref riv_temp_type class for the current domain
   subroutine init_riv_temp( &
     self, &
-    time, &
-    ntimesteps_day, &
     temp_air, &
-    read_meteo_weights, &
-    temp_weights, &
-    fday_temp, &
-    fnight_temp, &
     efecarea, &
     L1_L11_Id, &
     L11_areacell, &
     L11_L1_Id, &
     map_flag &
   )
 
-    use mo_constants, only : T0_dp  ! 273.15 - Celcius <-> Kelvin [K]
-    use mo_julian, only : dec2date
-    use mo_temporal_disagg_forcing, only: temporal_disagg_meteo_weights, temporal_disagg_state_daynight
     use mo_mrm_pre_routing, only : L11_meteo_acc
 
     implicit none
 
     class(riv_temp_type), intent(inout) :: self
-    real(dp), intent(in) :: time !< current decimal Julian day
-    real(dp), intent(in) :: ntimesteps_day !< number of time intervals per day, transformed in dp
-    real(dp), dimension(:), intent(in) :: temp_air !< air temperature [K]
-    logical, intent(in) :: read_meteo_weights !< flag whether weights for tavg and pet have read and should be used
-    real(dp), dimension(:, :, :), intent(in) :: temp_weights !< multiplicative weights for temperature (deg K)
-    real(dp), dimension(:), intent(in) :: fday_temp !< [-] day factor mean temp
-    real(dp), dimension(:), intent(in) :: fnight_temp !< [-] night factor mean temp
+    real(dp), dimension(:), intent(in) :: temp_air !< air temperature [degC] for current timestep
     real(dp), intent(in), dimension(:) :: efecarea !< effective area in [km2] at Level 1
     integer(i4), intent(in), dimension(:) :: L1_L11_Id !< L11 Ids mapped on L1
     real(dp), intent(in), dimension(:) :: L11_areacell !< effective area in [km2] at Level 11
     integer(i4), intent(in), dimension(:) :: L11_L1_Id !< L1 Ids mapped on L11
     logical, intent(in) :: map_flag !< Flag indicating whether routing resolution is higher than hydrologic one
 
-    ! internal temperature
-    real(dp), dimension(size(temp_air)) :: temp
-    ! is day or night
-    logical :: isday
-    ! current hour of a given day [0-23]
-    integer(i4) :: hour
-    ! Month of current day [1-12]
-    integer(i4) :: month
-
-    call dec2date(time, mm=month, hh=hour)
-    ! flag for day or night depending on hours of the day
-    isday = (hour .gt. 6) .AND. (hour .le. 18)
-
-    ! temporal disaggregate air temperature
-    if (read_meteo_weights) then
-      call temporal_disagg_meteo_weights( &
-        temp_air, temp_weights(:, month, hour + 1), temp, weights_correction=T0_dp)
-    else
-      call temporal_disagg_state_daynight( &
-        isday, ntimesteps_day, temp_air, fday_temp(month), fnight_temp(month), temp, add_correction=.true.)
-    end if
-
     ! map temperature from L1 to L11
     call L11_meteo_acc( &
-      temp, efecarea, L1_L11_Id, L11_areacell, L11_L1_Id, map_flag, self%river_temp(self%s11 : self%e11))
+      temp_air, efecarea, L1_L11_Id, L11_areacell, L11_L1_Id, map_flag, self%river_temp(self%s11 : self%e11))
 
     ! assure positive temperature
     self%river_temp(self%s11 : self%e11) = max(self%delta_T, self%river_temp(self%s11 : self%e11))
 
   end subroutine init_riv_temp
 
   !> \brief reset \ref riv_temp_type class for next timestep
@@ -436,20 +408,24 @@
   subroutine alloc_lateral( &
     self, &
     nCells &
   )
     implicit none
 
     class(riv_temp_type), intent(inout) :: self
-    integer(i4), intent(in) :: nCells !< number of cells for the current domain
+    integer(i4), intent(in) :: nCells !< number of level-1 cells for the current domain
 
     allocate(self%L1_runoff_E(nCells))
     allocate(self%L1_acc_strd(nCells))
     allocate(self%L1_acc_ssrd(nCells))
     allocate(self%L1_acc_temp(nCells))
+    ! meteo arrays
+    allocate(self%L1_ssrd_calc(nCells))
+    allocate(self%L1_strd_calc(nCells))
+    allocate(self%L1_tann_calc(nCells))
     ! init these arrays to 0
     call self%reset_timestep()
 
   end subroutine alloc_lateral
 
   !> \brief deallocate lateral temp components of \ref riv_temp_type
   subroutine dealloc_lateral( &
@@ -459,134 +435,72 @@
 
     class(riv_temp_type), intent(inout) :: self
 
     deallocate(self%L1_runoff_E)
     deallocate(self%L1_acc_strd)
     deallocate(self%L1_acc_ssrd)
     deallocate(self%L1_acc_temp)
+    deallocate(self%L1_ssrd_calc)
+    deallocate(self%L1_strd_calc)
+    deallocate(self%L1_tann_calc)
 
   end subroutine dealloc_lateral
 
   !> \brief accumulate energy sources of \ref riv_temp_type
   subroutine acc_source_e( &
     self, &
-    time, &
-    ntimesteps_day, &
     fSealed_area_fraction, &
     fast_interflow, &
     slow_interflow, &
     baseflow, &
     direct_runoff, &
-    temp_air, &
-    mean_temp_air, &
-    ssrd_day, &
-    strd_day, &
-    read_meteo_weights, &
-    temp_weights, &
-    fday_temp, &
-    fnight_temp, &
-    fday_ssrd, &
-    fnight_ssrd, &
-    fday_strd, &
-    fnight_strd &
+    temp_air &
   )
 
-    use mo_constants, only : T0_dp  ! 273.15 - Celcius <-> Kelvin [K]
-    use mo_julian, only : dec2date
-    use mo_temporal_disagg_forcing, only: temporal_disagg_meteo_weights, temporal_disagg_state_daynight
     use mo_mrm_pre_routing, only : calc_L1_runoff_E
 
     implicit none
 
     class(riv_temp_type), intent(inout) :: self
-    real(dp), intent(in) :: time !< current decimal Julian day
-    real(dp), intent(in) :: ntimesteps_day !< number of time intervals per day, transformed in dp
     real(dp), dimension(:), intent(in) :: fSealed_area_fraction !< sealed area fraction [1]
     real(dp), dimension(:), intent(in) :: fast_interflow !< \f$ q_0 \f$ Fast runoff component [mm TS-1]
     real(dp), dimension(:), intent(in) :: slow_interflow !< \f$ q_1 \f$ Slow runoff component [mm TS-1]
     real(dp), dimension(:), intent(in) :: baseflow !< \f$ q_2 \f$ Baseflow [mm TS-1]
     real(dp), dimension(:), intent(in) :: direct_runoff !< \f$ q_D \f$ Direct runoff from impervious areas  [mm TS-1]
     real(dp), dimension(:), intent(in) :: temp_air !< air temperature [K]
-    real(dp), dimension(:), intent(in) :: mean_temp_air !< annual mean air temperature [K]
-    real(dp), dimension(:), intent(in) :: ssrd_day !< Daily mean short radiation
-    real(dp), dimension(:), intent(in) :: strd_day !< Daily mean longwave radiation
-    logical, intent(in) :: read_meteo_weights !< flag whether weights for tavg and pet have read and should be used
-    real(dp), dimension(:, :, :), intent(in) :: temp_weights !< multiplicative weights for temperature (deg K)
-    real(dp), dimension(:), intent(in) :: fday_temp !< [-] day factor mean temp
-    real(dp), dimension(:), intent(in) :: fnight_temp !< [-] night factor mean temp
-    real(dp), dimension(:), intent(in) :: fday_ssrd !< Daytime fraction of ssrd
-    real(dp), dimension(:), intent(in) :: fnight_ssrd !< Nighttime fraction of ssrd
-    real(dp), dimension(:), intent(in) :: fday_strd !< Daytime fraction of strd
-    real(dp), dimension(:), intent(in) :: fnight_strd !< Nighttime fraction of strd
-
-    ! internal temperature
-    real(dp), dimension(size(temp_air)) :: temp
-    ! internal ssrd
-    real(dp), dimension(size(ssrd_day)) :: ssrd
-    ! internal strd
-    real(dp), dimension(size(strd_day)) :: strd
-    ! is day or night
-    logical :: isday
-    ! current hour of a given day
-    integer(i4) :: hour
-    ! Month of current day [1-12]
-    integer(i4) :: month
 
     ! increase the sub time-step counter
     self%ts_cnt = self%ts_cnt + 1_i4
 
-    call dec2date(time, mm=month, hh=hour)
-    ! flag for day or night depending on hours of the day
-    isday = (hour .gt. 6) .AND. (hour .le. 18)
-
-    ! temporal disaggregate air temperature
-    if (read_meteo_weights) then
-      call temporal_disagg_meteo_weights( &
-        temp_air, temp_weights(:, month, hour + 1), temp, weights_correction=T0_dp)
-    else
-      call temporal_disagg_state_daynight( &
-        isday, ntimesteps_day, temp_air, fday_temp(month), fnight_temp(month), temp, add_correction=.true.)
-    end if
-    ! temporal disaggregate ssrd
-    call temporal_disagg_state_daynight( &
-      isday, ntimesteps_day, ssrd_day, fday_ssrd(month), fnight_ssrd(month), ssrd)
-    ! temporal disaggregate strd
-    call temporal_disagg_state_daynight( &
-      isday, ntimesteps_day, strd_day, fday_strd(month), fnight_strd(month), strd)
-
     ! caclucate the temperature energy of the runoffs at L1 in [K mm]
     ! automatically accumulate them
     call calc_L1_runoff_E( &
       fSealed_area_fraction, &
       fast_interflow, slow_interflow, baseflow, direct_runoff, &
-      temp, mean_temp_air, &
+      temp_air, self%L1_tann_calc, &
       self%L1_runoff_E & ! will be added here
     )
     ! accumulate meteo forcings (will be averaged with sub time-step counter later)
-    self%L1_acc_ssrd = self%L1_acc_ssrd + ssrd
-    self%L1_acc_strd = self%L1_acc_strd + strd
-    self%L1_acc_temp = self%L1_acc_temp + temp
+    self%L1_acc_ssrd = self%L1_acc_ssrd + self%L1_ssrd_calc
+    self%L1_acc_strd = self%L1_acc_strd + self%L1_strd_calc
+    self%L1_acc_temp = self%L1_acc_temp + temp_air
 
   end subroutine acc_source_e
 
   !> \brief finalize energy sources of \ref riv_temp_type
   subroutine finalize_source_E( &
     self, &
     efecarea, &
     L1_L11_Id, &
     L11_areacell, &
     L11_L1_Id, &
     timestep, &
     map_flag &
   )
 
-    use mo_constants, only : T0_dp, cp_w_dp
-    use mo_mhm_constants, only : H2Odens
-    use mo_julian, only : dec2date
-    use mo_temporal_disagg_forcing, only : temporal_disagg_meteo_weights, temporal_disagg_state_daynight
     use mo_mrm_pre_routing, only : L11_meteo_acc, L11_runoff_acc
 
     implicit none
 
     class(riv_temp_type), intent(inout) :: self
     !> effective area in [km2] at Level 1
     real(dp), intent(in), dimension(:) :: efecarea
@@ -635,15 +549,15 @@
 
   end subroutine finalize_source_E
 
   !> \brief get outgoing longwave radiation of \ref riv_temp_type
   !> \return outgoing longwave radiation
   real(dp) function get_lrad_out(self, riv_temp) result(lrad_out)
 
-    use mo_constants, only: sigma_dp, T0_dp
+    use mo_constants, only: sigma_dp
 
     implicit none
 
     class(riv_temp_type), intent(in) :: self
     !> river temperature in K
     real(dp), intent(in) :: riv_temp
```

### Comparing `mhm-5.12.1.dev21/src/mRM/mo_mrm_routing.f90` & `mhm-5.13.0/src/mRM/mo_mrm_routing.f90`

 * *Files 3% similar despite different names*

```diff
@@ -1,23 +1,24 @@
-!>       \file mo_mrm_routing.f90
-
-!>       \brief Performs runoff routing for mHM at level L11.
-
-!>       \details This module performs flood routing at a given time step
-!>       through the stream network at level L11 to the sink cell.
-!>       The Muskingum flood routing algorithm is used.
-
-!>       \authors Luis Samaniego
-
-!>       \date Dec 2012
-
-! Modifications:
-! Stephan Thober Aug 2015 - adapted to mRM
-! Sebastian Mueller Jun 2020 - outsourcing helper functions
-
+!> \file mo_mrm_routing.f90
+!> \brief   \copybrief mo_mrm_routing
+!> \details \copydetails mo_mrm_routing
+
+!> \brief Performs runoff routing for mHM at level L11.
+!> \details This module performs flood routing at a given time step through the stream network at level L11 to the sink cell.
+!! The Muskingum flood routing algorithm is used.
+!> \changelog
+!! - Stephan Thober Aug 2015
+!!   - adapted to mRM
+!! - Sebastian Mueller Jun 2020
+!!   - outsourcing helper functions
+!> \authors Luis Samaniego
+!> \date Dec 2012
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mrm
 MODULE mo_mrm_routing
 
   ! This module performs runoff flood routing for mHM.
 
   ! Written Luis Samaniego, Dec 2012
 
   USE mo_kind, ONLY : i4, dp
@@ -405,15 +406,15 @@
     ! [m3 s-1] Total inputs at t-1 and t
     real(dp), dimension(:, :), intent(inout) :: netNode_qTIN
     ! [m3 s-1] Transformed outflow leaving node I (Muskingum)
     real(dp), dimension(:, :), intent(inout) :: netNode_qTR
     ! [m3 s-1] Simulated routed discharge
     real(dp), dimension(nNodes), intent(out) :: netNode_Qmod
 
-    integer(i4) :: i, k, iNode, tNode
+    integer(i4) :: g, i, k, iNode, tNode
     ! current routing state (2)
     integer(i4), parameter :: IT = 2
     ! past routing state (1)
     integer(i4), parameter :: IT1 = 1
 
     ! Entry value for the auxiliary vectors
     !   netNode_qTIN(iNode,:)
@@ -426,15 +427,15 @@
     ! initialize total input at point time IT in all nodes
     netNode_qTIN(:, IT) = 0.0_dp
     !--------------------------------------------------------------------------
     ! Links in sequential mode .... with single node
     !--------------------------------------------------------------------------
     ! ST - decent parallelization has to be done!!!
     !!$OMP parallel
-    !!$OMP do private( i, inode, tnode)
+    !!$OMP do private(g, i, inode, tnode)
     do k = 1, nLinks
       ! get LINK routing order -> i
       i = netPerm(k)
       iNode = netLink_fromN(i)
       tNode = netLink_toN(i)
 
       ! accumulate all inputs in iNode
@@ -443,17 +444,17 @@
       ! routing iNode
       netNode_qTR(iNode, IT) = netNode_qTR(iNode, IT1)                               &
               + netLink_C1(i) * (netNode_qTIN(iNode, IT1) - netNode_qTR (iNode, IT1)) &
               + netLink_C2(i) * (netNode_qTIN(iNode, IT) - netNode_qTIN(iNode, IT1))
 
       ! check if the inflow from upstream cells should be deactivated
       if (nInflowGauges .GT. 0) then
-        do i = 1, nInflowGauges
+        do g = 1, nInflowGauges
           ! check if downstream Node (tNode) is inflow gauge and headwaters should be ignored
-          if ((tNode == InflowNodeList(i)) .AND. (.NOT. InflowHeadwater(i))) netNode_qTR(iNode, IT) = 0.0_dp
+          if ((tNode == InflowNodeList(g)) .AND. (.NOT. InflowHeadwater(g))) netNode_qTR(iNode, IT) = 0.0_dp
         end do
       end if
 
       ! add routed water to downstream node
       netNode_qTIN(tNode, IT) = netNode_qTIN(tNode, IT) + netNode_qTR(iNode, IT)
     end do
     !!$OMP end do
```

### Comparing `mhm-5.12.1.dev21/src/mRM/mo_mrm_signatures.f90` & `mhm-5.13.0/src/mRM/mo_mrm_signatures.f90`

 * *Files 2% similar despite different names*

```diff
@@ -1,37 +1,38 @@
-!>       \file mo_mrm_signatures.f90
-
-!>       \brief Module with calculations for several hydrological signatures.
-
-!>       \details This module contains calculations for hydrological signatures.
-!>       It contains:
-!>       * Autocorrelation
-!>       * Rising and declining limb densities
-!>       * Flow duration curves
-!>       * Peak distribution
-
-!>       \authors Remko Nijzink,
-
-!>       \date March 2014
-
-! Modifications:
-
+!> \file mo_mrm_signatures.f90
+!> \brief   \copybrief mo_mrm_signatures
+!> \details \copydetails mo_mrm_signatures
+
+!> \brief Module with calculations for several hydrological signatures.
+!> \details This module contains calculations for hydrological signatures.
+!!
+!! It contains:
+!! - Autocorrelation
+!! - Rising and declining limb densities
+!! - Flow duration curves
+!! - Peak distribution
+!> \authors Remko Nijzink,
+!> \date March 2014
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mrm
 MODULE mo_mrm_signatures
 
   USE mo_kind, ONLY : i4, sp, dp
+  use mo_message, only : message, error_message
 
   IMPLICIT NONE
 
   PUBLIC :: Autocorrelation         ! Autocorrelation function
   PUBLIC :: FlowDurationCurve       ! Flow duration curve (i.e. CDF of runoff)
   PUBLIC :: Limb_densities          ! Rising and declining limb densities
   PUBLIC :: Moments                 ! Moments of data and log-transformed data, e.g. mean and standard deviation.
   PUBLIC :: PeakDistribution        ! Peak distribution parameter
   PUBLIC :: RunoffRatio             ! Runoff ratio (accumulated daily discharge [mm/d] / accumulated daily precipitation [mm/d])
-  PUBLIC :: ZeroFlowRatio           ! Ratio of zero flow days to total observation days                             
+  PUBLIC :: ZeroFlowRatio           ! Ratio of zero flow days to total observation days
 
   ! ------------------------------------------------------------------
 
 CONTAINS
 
   !-------------------------------------------------------------------------------
   !    NAME
@@ -187,17 +188,17 @@
 
   !    HISTORY
   !>       \authors Remko Nijzink, Juliane Mai
 
   !>       \date March 2014
 
   ! Modifications:
-  ! Juliane Mai Jun 2015 - mask added 
-  !                      - function instead of subroutine 
-  !                      - use of percentile 
+  ! Juliane Mai Jun 2015 - mask added
+  !                      - function instead of subroutine
+  !                      - use of percentile
   !                      - add concavity_index
   ! Juliane Mai Jun 2015 - add mid_segment_slope, mhigh_segment_volume, high_segment_volume, low_segment_volume
   ! Robert Schweppe Jun 2018 - refactoring and reformatting
 
   FUNCTION FlowDurationCurve(data, quantiles, mask, concavity_index, mid_segment_slope, mhigh_segment_volume, &
                             high_segment_volume, low_segment_volume)
 
@@ -330,22 +331,20 @@
 
   !    HISTORY
   !>       \authors Remko Nijzink
 
   !>       \date March 2014
 
   ! Modifications:
-  ! Juliane Mai Jun 2015 - RLD and DLD as optional 
+  ! Juliane Mai Jun 2015 - RLD and DLD as optional
   !                      - optional mask for data can be given
   ! Robert Schweppe Jun 2018 - refactoring and reformatting
 
   SUBROUTINE Limb_densities(data, mask, RLD, DLD)
 
-    use mo_message, only : message
-
     implicit none
 
     ! data series
     real(dp), dimension(:), intent(in) :: data
 
     ! mask for data series
     logical, dimension(size(data, 1)), optional, intent(in) :: mask
@@ -382,16 +381,15 @@
     if (present(mask)) then
       maske = mask
     else
       maske = .true.
     end if
 
     if ((.not. present(RLD)) .and. (.not. present(DLD))) then
-      call message('mo_signatures: limb_densities: Neither RLD or DLD is specified in calling sequence.')
-      stop
+      call error_message('mo_signatures: limb_densities: Neither RLD or DLD is specified in calling sequence.')
     end if
 
     ! initialize
     n_rise = 0_i4
     n_decline = 0_i4
     n_peak = 0_i4
 
@@ -509,15 +507,14 @@
 
   ! Modifications:
   ! Robert Schweppe Jun 2018 - refactoring and reformatting
 
   FUNCTION MaximumMonthlyFlow(data, mask, yr_start, mo_start, dy_start)
 
     use mo_julian, only : date2dec, dec2date
-    use mo_message, only : message
 
     implicit none
 
     ! array of data
     real(dp), dimension(:), intent(in) :: data
 
     ! mask for data points given
@@ -556,16 +553,15 @@
     if (present(mask)) then
       maske = mask
     else
       maske = .true.
     end if
 
     if (.not. present(yr_start)) then
-      call message('mo_signatures: MaximumMonthlyFlow: Year of of data point has to be given!')
-      stop
+      call error_message('mo_signatures: MaximumMonthlyFlow: Year of of data point has to be given!')
     else
       yr = yr_start
     end if
 
     if (present(mo_start)) then
       mo = mo_start
     else
@@ -589,17 +585,15 @@
         ! add value
         counter(imo) = counter(imo) + 1
         flow_month(imo) = flow_month(imo) + data(ii)
       end if
     end do
 
     if (any(counter == 0_i4)) then
-      call message('mo_signatures: MaximumMonthlyFlow: There are months with no data points!')
-      call message('                                   Aborted!')
-      stop
+      call error_message('mo_signatures: MaximumMonthlyFlow: There are months with no data points!')
     end if
 
     ! average
     MaximumMonthlyFlow = maxval(flow_month / real(counter, dp))
 
   END FUNCTION MaximumMonthlyFlow
 
@@ -656,15 +650,14 @@
 
   ! Modifications:
   ! Robert Schweppe Jun 2018 - refactoring and reformatting
 
   SUBROUTINE Moments(data, mask, mean_data, stddev_data, median_data, max_data, mean_log, stddev_log, median_log, &
                     max_log)
 
-    use mo_message, only : message
     use mo_moment, only : mean, stddev
     use mo_percentile, only : median
 
     implicit none
 
     ! array of data
     real(dp), dimension(:), intent(in) :: data
@@ -707,16 +700,15 @@
       maske = .true.
     end if
 
     if (.not.(present(mean_data)) .and. .not.(present(stddev_data)) .and. &
             .not.(present(median_data)) .and. .not.(present(max_data)) .and. &
                     .not.(present(mean_log))  .and. .not.(present(stddev_log)) .and. &
                             .not.(present(median_log))  .and. .not.(present(max_log))) then
-      call message('mo_signatures: Moments: None of the optional output arguments is specified')
-      stop
+      call error_message('mo_signatures: Moments: None of the optional output arguments is specified')
     end if
 
     if (present(mean_data))   mean_data = mean(data, mask = maske)
     if (present(stddev_data)) stddev_data = stddev(data, mask = maske)
     if (present(median_data)) median_data = median(data, mask = maske)
     if (present(max_data))    max_data = maxval(data, mask = maske)
 
@@ -776,16 +768,16 @@
 
   !    HISTORY
   !>       \authors Remko Nijzink
 
   !>       \date March 2014
 
   ! Modifications:
-  ! Juliane Mai Jun 2015 - mask added 
-  !                      - function instead of subroutine 
+  ! Juliane Mai Jun 2015 - mask added
+  !                      - function instead of subroutine
   !                      - use of percentile
   ! Robert Schweppe Jun 2018 - refactoring and reformatting
 
   FUNCTION PeakDistribution(data, quantiles, mask, slope_peak_distribution)
 
     use mo_percentile, only : percentile
 
@@ -920,16 +912,14 @@
   !>       \date Jun 2015
 
   ! Modifications:
   ! Robert Schweppe Jun 2018 - refactoring and reformatting
 
   FUNCTION RunoffRatio(data, domain_area, mask, precip_series, precip_sum, log_data)
 
-    use mo_message, only : message
-
     implicit none
 
     ! array of data   [m**3/s]
     real(dp), dimension(:), intent(in) :: data
 
     ! area of domain   [km**2]
     real(dp), intent(in) :: domain_area
@@ -971,25 +961,23 @@
       log_dat = log_data
     else
       log_dat = .false.
     end if
 
     if ((present(precip_series) .and. present(precip_sum)) .or. &
             (.not. present(precip_series) .and. .not. present(precip_sum))) then
-      call message('mo_signatures: RunoffRatio: Exactly one precipitation information')
-      call message('                            (precipitation series or sum of precipitation) ')
-      call message('                            has to be specified!')
-      stop
+      call error_message('mo_signatures: RunoffRatio: Exactly one precipitation information', raise=.false.)
+      call error_message('                            (precipitation series or sum of precipitation) ', raise=.false.)
+      call error_message('                            has to be specified!')
     end if
 
     if (present(mask) .and. present(precip_sum)) then
-      call message('mo_signatures: RunoffRatio: Already aggregated precipitation (precip_sum) and')
-      call message('                            mask can not be used together.')
-      call message('                            Precip_series should be used instead!')
-      stop
+      call error_message('mo_signatures: RunoffRatio: Already aggregated precipitation (precip_sum) and', raise=.false.)
+      call error_message('                            mask can not be used together.', raise=.false.)
+      call error_message('                            Precip_series should be used instead!')
     end if
 
     ! mhm output [m**3/s]  --> required [mm/d]
     !    [m**3/s] / [km**2] = [m**3/(s km**2)]
     ! => [m**3/(s km**2) * 60*60*24/1000**2] = [m/d]
     ! => [m**3/(s km**2) * 60*60*24*1000/1000**2] = [mm/d]
     ! => [m**3/(s km**2) * 86.4 ] = [mm/d]
@@ -1040,15 +1028,14 @@
   !>       \date Jun 2015
 
   ! Modifications:
   ! Robert Schweppe Jun 2018 - refactoring and reformatting
 
   FUNCTION ZeroFlowRatio(data, mask)
 
-    use mo_message, only : message
     use mo_utils, only : eq
 
     implicit none
 
     ! array of data
     real(dp), dimension(:), intent(in) :: data
 
@@ -1077,14 +1064,13 @@
 
     nall = count(maske)
     nzero = count(maske .and. (eq(data, 0.0_dp)))
 
     if (nall > 0) then
       ZeroFlowRatio = real(nzero, dp) / real(nall, dp)
     else
-      call message('mo_signatures: ZeroFlowRatio: all data points are masked')
-      stop
+      call error_message('mo_signatures: ZeroFlowRatio: all data points are masked')
     end if
 
   END FUNCTION ZeroFlowRatio
 
 END MODULE mo_mrm_signatures
```

### Comparing `mhm-5.12.1.dev21/src/mRM/mo_mrm_write.f90` & `mhm-5.13.0/src/mRM/mo_mrm_write.f90`

 * *Files 4% similar despite different names*

```diff
@@ -1,37 +1,33 @@
-!>       \file mo_mrm_write.f90
-
-!>       \brief write of discharge and restart files
-
-!>       \details This module contains the subroutines for
-!>       writing the discharge files and optionally the restart
-!>       files.
-
-!>       \authors Stephan Thober
-
-!>       \date Aug 2015
-
-! Modifications:
-
+!> \file mo_mrm_write.f90
+!> \brief   \copybrief mo_mrm_write
+!> \details \copydetails mo_mrm_write
+
+!> \brief write of discharge and restart files
+!> \details This module contains the subroutines for writing the discharge files and optionally the restart files.
+!> \authors Stephan Thober
+!> \date Aug 2015
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_mrm
 module mo_mrm_write
 
   use mo_kind, only : i4, dp
   use mo_mrm_write_fluxes_states, only : OutputDataset
+  use mo_mrm_global_variables, only : output_time_reference_mrm
+  use mo_message, only : message, error_message
 
   implicit none
 
   public :: mrm_write
-  public :: mrm_write_output_fluxes
   public :: mrm_write_optinamelist
   public :: mrm_write_optifile
 
   private
 
-  type(OutputDataset) :: nc ! netcdf Output Dataset
-
 contains
 
   ! ------------------------------------------------------------------
 
   !    NAME
   !        mrm_write
 
@@ -56,15 +52,14 @@
 
     use mo_common_constants, only : nodata_dp
     use mo_common_mhm_mrm_variables, only : evalPer, mrm_coupling_mode, nTstepDay, simPer, warmingDays
     use mo_common_variables, only : mrmFileRestartOut, domainMeta, write_restart
     use mo_mrm_global_variables, only : domain_mrm, &
                                         gauge, mRM_runoff, nGaugesTotal, nMeasPerDay
     use mo_mrm_restart, only : mrm_write_restart
-    use mo_message, only : message
 
     implicit none
 
     integer(i4) :: domainID, iDomain
 
     integer(i4) :: iDay, iSubDay, iS, iE
 
@@ -116,16 +111,15 @@
     TPD_sim = nTstepDay
     TPD_obs = nMeasPerDay
 
     ! check if modelled timestep is an integer multiple of measured timesteps
     if (modulo(TPD_sim, TPD_obs) .eq. 0) then
       factor = TPD_sim / TPD_obs
     else
-      call message(' Error: Number of modelled datapoints is no multiple of measured datapoints per day')
-      stop
+      call error_message(' Error: Number of modelled datapoints is no multiple of measured datapoints per day')
     end if
 
 
     maxDailyTimeSteps = maxval(evalPer(1 : domainMeta%nDomains)%julEnd - evalPer(1 : domainMeta%nDomains)%julStart + 1)
     maxMeasTimeSteps  = maxval(evalPer(1 : domainMeta%nDomains)%julEnd - evalPer(1 : domainMeta%nDomains)%julStart + 1) * TPD_obs
     allocate(d_Qmod     (maxDailyTimeSteps, nGaugesTotal))
     allocate(d_Qobs     (maxDailyTimeSteps, nGaugesTotal))
@@ -259,42 +253,39 @@
     use mo_common_mHM_mRM_variables, only : LCyearId, SimPer, evalPer, mrm_coupling_mode, read_restart, &
                                             resolutionRouting, timeStep, warmPer
     use mo_common_variables, only : LC_year_end, LC_year_start, LCfilename, &
                                     dirConfigOut, dirLCover, dirMorpho, dirOut, mrmFileRestartOut, global_parameters, &
                                     global_parameters_name, level0, level1, domainMeta, nLCoverScene, processMatrix, &
                                     resolutionHydrology, write_restart
     use mo_kind, only : dp, i4
-    use mo_message, only : message
     use mo_mrm_file, only : version
     use mo_mrm_global_variables, only : InflowGauge, L11_L1_Id, L11_fromN, L11_label, &
                                         L11_length, L11_netPerm, L11_rOrder, L11_slope, L11_toN, L1_L11_Id, domain_mrm, &
                                         dirGauges, dirTotalRunoff, gauge, level11, nGaugesTotal, nInflowGaugesTotal
     use mo_string_utils, only : num2str
     use mo_utils, only : ge
-    use mo_os, only : path_isdir
+    use mo_os, only : check_path_isdir
 
     implicit none
 
     character(256) :: fName
 
     integer(i4) :: i, iDomain, domainID, j
 
     integer(i4) :: err
 
 
     fName = trim(adjustl(dirConfigOut)) // trim(adjustl(file_config))
     call message()
     call message('  Log-file written to ', trim(fName))
     !checking whether the directory exists where the file shall be created or opened
-    call path_isdir(trim(adjustl(dirConfigOut)), quiet_=.true., throwError_=.true.)
+    call check_path_isdir(trim(adjustl(dirConfigOut)), raise=.true.)
     open(uconfig, file = fName, status = 'unknown', action = 'write', iostat = err)
     if (err .ne. 0) then
-      call message('  Problems while creating File')
-      call message('  Error-Code', num2str(err))
-      stop
+      call error_message('  Problems while creating File. Error-Code ', num2str(err))
     end if
     write(uconfig, 200)
     write(uconfig, 100) 'mRM-UFZ v-' // trim(version)
     write(uconfig, 100) 'S. Thober, L. Samaniego & R. Kumar, UFZ'
     write(uconfig, 200)
     write(uconfig, 100)
     write(uconfig, 201) '         M A I N  mRM  C O N F I G U R A T I O N  I N F O R M A T I O N         '
@@ -577,15 +568,14 @@
   subroutine write_daily_obs_sim_discharge(Qobs, Qsim)
 
     use mo_common_constants, only : nodata_dp
     use mo_common_mhm_mrm_variables, only : evalPer
     use mo_common_variables, only : dirOut, domainMeta
     use mo_errormeasures, only : kge, nse
     use mo_julian, only : dec2date
-    use mo_message, only : message
     use mo_mrm_file, only : file_daily_discharge, ncfile_discharge, udaily_discharge
     use mo_mrm_global_variables, only : domain_mrm, gauge
     use mo_string_utils, only : num2str
     use mo_utils, only : ge
     use mo_netcdf, only : NcDataset, NcDimension, NcVariable
 
     implicit none
@@ -609,15 +599,15 @@
     ! time axis
     integer(i4), allocatable, dimension(:) :: taxis
 
     real(dp) :: newTime
 
     ! nc related variables
     type(NcDataset) :: nc_out
-    type(NcDimension) :: dim
+    type(NcDimension) :: dim, dim_bnd
     type(NcVariable) :: var
 
     ! initalize igauge_start
     igauge_start = 1
 
     ! domain loop
     do iDomain = 1, domainMeta%nDomains
@@ -627,17 +617,15 @@
       ! estimate igauge_end
       igauge_end = igauge_start + domain_mrm(iDomain)%nGauges - 1
 
       ! check the existance of file
       fName = trim(adjustl(dirOut(iDomain))) // trim(adjustl(file_daily_discharge))
       open(udaily_discharge, file = trim(fName), status = 'unknown', action = 'write', iostat = err)
       if(err .ne. 0) then
-        call message ('  IOError while openening ', trim(fName))
-        call message ('  Error-Code ', num2str(err))
-        stop
+        call error_message('  IOError while openening "', trim(fName), '". Error-Code ', num2str(err))
       end if
 
       ! header
       write(formHeader, *) '( 4a8, ', domain_mrm(iDomain)%nGauges, '(2X, a5, i10.10, 2X, a5, i10.10) )'
       write(udaily_discharge, formHeader) 'No', 'Day', 'Mon', 'Year', &
               ('Qobs_', gauge%gaugeId(gg), &
                       'Qsim_', gauge%gaugeId(gg), gg = igauge_start, igauge_end)
@@ -661,24 +649,42 @@
       ! write netcdf file
       ! ======================================================================
       fName = trim(adjustl(dirOut(iDomain))) // trim(adjustl(ncfile_discharge))
       nc_out = NcDataset(trim(fName), "w")
       tlength = evalPer(iDomain)%julEnd - evalPer(iDomain)%julStart + 1
       ! write time
       allocate(taxis(tlength))
-      forall(tt = 1 : tlength) taxis(tt) = tt * 24 - 1
+
+      ! tt is dependent on the unit of the time axis and is set to hours in mRM
+      select case( output_time_reference_mrm)
+        case(0)
+          forall(tt = 1 : tlength) taxis(tt) = (tt-1) * 24
+        case(1)
+          forall(tt = 1 : tlength) taxis(tt) = tt * 24 - 12
+        case(2)
+          forall(tt = 1 : tlength) taxis(tt) = tt * 24
+      end select
+
       call dec2date(real(evalPer(iDomain)%julStart, dp) - 0.5_dp, yy = year, mm = month, dd = day)
       dim = nc_out%setDimension("time", tlength)
       var = nc_out%setVariable("time", "i32", [dim])
       call var%setData(taxis)
       call var%setAttribute( &
         "units", &
         'hours since '//trim(num2str(year))//'-'//trim(num2str(month, '(i2.2)'))//'-'//trim(num2str(day, '(i2.2)'))//' 00:00:00' &
       )
       call var%setAttribute("long_name", "time in hours")
+      call var%setAttribute("bounds", "time_bnds")
+      call var%setAttribute("axis", "T")
+      dim_bnd = nc_out%setDimension("bnds", 2)
+      var = nc_out%setVariable("time_bnds", "i32", [dim_bnd, dim])
+      do tt = 1, tlength
+        call var%setData((tt - 1) * 24, (/1, tt/))
+        call var%setData(tt * 24, (/2, tt/))
+      end do
       deallocate(taxis)
       ! write gauges
       do gg = igauge_start, igauge_end
         var = nc_out%setVariable('Qsim_' // trim(num2str(gauge%gaugeID(gg), '(i10.10)')), "f64", [dim])
         call var%setFillValue(nodata_dp)
         call var%setData(Qsim(1 : tlength, gg))
         call var%setAttribute("units", "m3 s-1")
@@ -755,15 +761,14 @@
   subroutine write_subdaily_obs_sim_discharge(Qobs, Qsim, factor)
 
     use mo_common_constants, only : nodata_dp
     use mo_common_mhm_mrm_variables, only : evalPer
     use mo_common_variables, only : dirOut, domainMeta
     use mo_errormeasures, only : kge, nse
     use mo_julian, only : dec2date
-    use mo_message, only : message
     use mo_mrm_file, only : ncfile_subdaily_discharge, file_subdaily_discharge, &
                             usubdaily_discharge
     use mo_mrm_global_variables, only : domain_mrm, gauge, nMeasPerDay
     use mo_string_utils, only : num2str
     use mo_utils, only : ge
     use mo_netcdf, only : NcDataset, NcDimension, NcVariable
 
@@ -791,17 +796,20 @@
     ! time axis
     integer(i4), allocatable, dimension(:) :: taxis
 
     real(dp) :: newTime
 
     ! nc related variables
     type(NcDataset) :: nc_out
-    type(NcDimension) :: dim
+    type(NcDimension) :: dim, dim_bnd
     type(NcVariable) :: var
 
+    ! use minutes if needed
+    logical :: use_minutes
+    integer(i4) :: time_unit_factor
 
     ! initalize igauge_start
     igauge_start = 1
 
     ! domain loop
     do iDomain = 1, domainMeta%nDomains
       domainID = domainMeta%indices(iDomain)
@@ -815,17 +823,15 @@
       ! write text file
       ! ======================================================================
 
       ! check the existance of file
       fName = trim(adjustl(dirOut(iDomain))) // trim(adjustl(file_subdaily_discharge))
       open(usubdaily_discharge, file = trim(fName), status = 'unknown', action = 'write', iostat = err)
       if(err .ne. 0) then
-        call message ('  IOError while openening ', trim(fName))
-        call message ('  Error-Code ', num2str(err))
-        stop
+        call error_message('  IOError while openening "', trim(fName), '". Error-Code ', num2str(err))
       end if
 
       ! header
       write(formHeader, *) '( 5a8, ', domain_mrm(iDomain)%nGauges, '(2X, a5, i10.10, 2X, a5, i10.10) )'
       write(usubdaily_discharge, formHeader) 'No', 'Hour', 'Day', 'Mon', 'Year', &
               ('Qobs_', gauge%gaugeId(gg), &
                       'Qsim_', gauge%gaugeId(gg), gg = igauge_start, igauge_end)
@@ -849,25 +855,59 @@
       ! write netcdf file
       ! ======================================================================
       fName = trim(adjustl(dirOut(iDomain))) // trim(adjustl(ncfile_subdaily_discharge))
       nc_out = NcDataset(trim(fName), "w")
       tlength = (evalPer(iDomain)%julEnd - evalPer(iDomain)%julStart + 1) * nMeasPerDay
       ! write time
       allocate(taxis(tlength))
-      forall(tt = 1 : tlength) taxis(tt) = (tt - 1) * factor
+
+      use_minutes = .false.
+      time_unit_factor = 1
+      if ( mod(factor, 2) == 1 ) then
+        use_minutes = .true.
+        time_unit_factor = 60
+      end if
+
+      ! tt is dependent on the unit of the time axis and is set to hours in mRM
+      select case( output_time_reference_mrm)
+        case(0)
+          forall(tt = 1 : tlength) taxis(tt) = (tt-1) * factor * time_unit_factor
+        case(1)
+          forall(tt = 1 : tlength) taxis(tt) = tt * factor - factor * time_unit_factor / 2
+        case(2)
+          forall(tt = 1 : tlength) taxis(tt) = tt * factor * time_unit_factor
+      end select
+
       call dec2date(real(evalPer(iDomain)%julStart, dp) - 0.5_dp, yy = year, mm = month, dd = day, hh = hour)
       dim = nc_out%setDimension("time", tlength)
       var = nc_out%setVariable("time", "i32", [dim])
       call var%setData(taxis)
-      call var%setAttribute( &
-        "units", &
-        'hours since '//trim(num2str(year))//'-'//trim(num2str(month, '(i2.2)'))//'-'//trim(num2str(day, '(i2.2)'))//' '// &
-        trim(num2str(hour, '(i2.2)'))//':00:00' &
-      )
-      call var%setAttribute("long_name", "time in hours")
+      if (use_minutes) then
+        call var%setAttribute( &
+          "units", &
+          'minutes since '//trim(num2str(year))//'-'//trim(num2str(month, '(i2.2)'))//'-'//trim(num2str(day, '(i2.2)'))//' '// &
+          trim(num2str(hour, '(i2.2)'))//':00:00' &
+        )
+        call var%setAttribute("long_name", "time in minutes")
+      else
+        call var%setAttribute( &
+          "units", &
+          'hours since '//trim(num2str(year))//'-'//trim(num2str(month, '(i2.2)'))//'-'//trim(num2str(day, '(i2.2)'))//' '// &
+          trim(num2str(hour, '(i2.2)'))//':00:00' &
+        )
+        call var%setAttribute("long_name", "time in hours")
+      end if
+      call var%setAttribute("bounds", "time_bnds")
+      call var%setAttribute("axis", "T")
+      dim_bnd = nc_out%setDimension("bnds", 2)
+      var = nc_out%setVariable("time_bnds", "i32", [dim_bnd, dim])
+      do tt = 1, tlength
+        call var%setData((tt - 1) * factor * time_unit_factor, (/1, tt/))
+        call var%setData(tt * factor * time_unit_factor, (/2, tt/))
+      end do
       deallocate(taxis)
       ! write gauges
       do gg = igauge_start, igauge_end
         var = nc_out%setVariable('Qsim_' // trim(num2str(gauge%gaugeID(gg), '(i10.10)')), "f64", [dim])
         call var%setFillValue(nodata_dp)
         call var%setData(Qsim(1 : tlength, gg))
         call var%setAttribute("units", "m3 s-1")
@@ -902,109 +942,14 @@
       ! update igauge_start
       igauge_start = igauge_end + 1
       !
     end do
     !
   end subroutine write_subdaily_obs_sim_discharge
 
-
-  ! ------------------------------------------------------------------
-
-  !    NAME
-  !        mrm_write_output_fluxes
-
-  !    PURPOSE
-  !>       \brief write fluxes to netcdf output files
-
-  !>       \details This subroutine creates a netcdf data set
-  !>       for writing L11_QTIN for different time averages.
-
-  !    INTENT(IN)
-  !>       \param[in] "integer(i4) :: iDomain"
-  !>       \param[in] "integer(i4) :: nCells"
-  !>       \param[in] "integer(i4) :: timeStep_model_outputs" timestep of model outputs
-  !>       \param[in] "integer(i4) :: warmingDays"            number of warming days
-  !>       \param[in] "real(dp) :: newTime"                   julian date of next time step
-  !>       \param[in] "integer(i4) :: nTimeSteps"             number of total timesteps
-  !>       \param[in] "integer(i4) :: nTStepDay"              number of timesteps per day
-  !>       \param[in] "integer(i4) :: tt"                     current model timestep
-  !>       \param[in] "integer(i4) :: day"                    current day of the year
-  !>       \param[in] "integer(i4) :: month"                  current month of the year
-  !>       \param[in] "integer(i4) :: year"                   current year
-  !>       \param[in] "integer(i4) :: timestep"               current model time resolution
-  !>       \param[in] "logical, dimension(:, :) :: mask11"    mask at level 11
-  !>       \param[in] "real(dp), dimension(:) :: L11_qMod"    current routed streamflow
-
-  !    HISTORY
-  !>       \authors Stephan Thober
-
-  !>       \date Aug 2015
-
-  ! Modifications:
-  ! Robert Schweppe Jun 2018 - refactoring and reformatting
-  ! Sebastian Mueller Jul 2020 - added output for river-temperature
-
-  subroutine mrm_write_output_fluxes(iDomain, nCells, timeStep_model_outputs, domainDateTime, &
-                                    tt, timestep, mask11, L11_qmod)
-
-    use mo_julian, only : caldat
-    use mo_kind, only : dp, i4
-    use mo_common_datetime_type, only : datetimeinfo
-    use mo_mrm_global_variables, only : riv_temp_pcs
-
-    implicit none
-
-    integer(i4), intent(in) :: iDomain
-
-    integer(i4), intent(in) :: nCells
-
-    ! timestep of model outputs
-    integer(i4), intent(in) :: timeStep_model_outputs
-
-    ! datetimeinfo variable
-    type(datetimeinfo), intent(in) :: domainDateTime
-
-    ! current model timestep
-    integer(i4), intent(in) :: tt
-
-    ! current model time resolution
-    integer(i4), intent(in) :: timestep
-
-    ! mask at level 11
-    logical, intent(in), dimension(:, :), pointer :: mask11
-
-    ! current routed streamflow
-    real(dp), intent(in), dimension(:) :: L11_qMod
-
-    ! update the counters
-
-    if ((domainDateTime%tIndex_out > 0_i4)) then
-
-      ! create output dataset
-      if (domainDateTime%tIndex_out == 1) nc = OutputDataset(iDomain, mask11, nCells)
-
-      ! update Dataset (riv-temp as optional input)
-      if ( riv_temp_pcs%active ) then
-        call nc%updateDataset(1, size(L11_Qmod), L11_Qmod, riv_temp_pcs%river_temp(riv_temp_pcs%s11 : riv_temp_pcs%e11))
-      else
-        call nc%updateDataset(1, size(L11_Qmod), L11_Qmod)
-      end if
-
-      ! write data
-      if (domainDateTime%writeout(timeStep_model_outputs, tt)) then
-        call nc%writeTimestep(domainDateTime%tIndex_out * timestep - 1)
-      end if
-
-      ! close dataset
-      if (tt == domainDateTime%nTimeSteps) call nc%close()
-
-    end if
-
-  end subroutine mrm_write_output_fluxes
-
   ! ------------------------------------------------------------------
 
   !    NAME
   !        mrm_write_optifile
 
   !    PURPOSE
   !>       \brief Write briefly final optimization results.
@@ -1030,15 +975,14 @@
   ! Stephan Thober Oct 2015 - ported to mRM
   ! Robert Schweppe Jun 2018 - refactoring and reformatting
 
   subroutine mrm_write_optifile(best_OF, best_paramSet, param_names)
 
     use mo_common_mhm_mrm_file, only : file_opti, uopti
     use mo_common_variables, only : dirConfigOut
-    use mo_message, only : message
     use mo_string_utils, only : num2str
 
     implicit none
 
     ! best objective function value as returnedby the optimization routine
     real(dp), intent(in) :: best_OF
 
@@ -1055,17 +999,15 @@
     ! number of parameters
     n_params = size(best_paramSet)
 
     ! open file
     fName = trim(adjustl(dirConfigOut)) // trim(adjustl(file_opti))
     open(uopti, file = fName, status = 'unknown', action = 'write', iostat = err, recl = (n_params + 1) * 40)
     if(err .ne. 0) then
-      call message ('  IOError while openening ', trim(fName))
-      call message ('  Error-Code ', num2str(err))
-      stop
+      call error_message('  IOError while openening "', trim(fName), '" Error-Code ', num2str(err))
     end if
 
     ! header
     write(formHeader, *) '(a40,', n_params, 'a40)'
     ! len(param_names(1))=256 but only 39 characters taken here
     ! write(uopti, formHeader) 'OF', (trim(adjustl(param_names(ii))), ii=1, n_params)
     write(uopti, formHeader) 'OF', (trim(adjustl(param_names(ii)(1 : 39))), ii = 1, n_params)
@@ -1109,15 +1051,14 @@
   ! Stephan Thober Nov 2016 - adapt header to routing process
   ! Robert Schweppe Jun 2018 - refactoring and reformatting
 
   subroutine mrm_write_optinamelist(parameters, maskpara, parameters_name)
 
     use mo_common_mhm_mrm_file, only : file_opti_nml, uopti_nml
     use mo_common_variables, only : dirConfigOut, processMatrix
-    use mo_message, only : message
     use mo_string_utils, only : num2str
 
     implicit none
 
     ! (min, max, opti)
     real(dp), dimension(:, :), intent(in) :: parameters
 
@@ -1136,17 +1077,15 @@
     integer(i4) :: iPar
 
 
     ! open file
     fName = trim(adjustl(dirConfigOut)) // trim(adjustl(file_opti_nml))
     open(uopti_nml, file = fName, status = 'unknown', action = 'write', iostat = err)
     if(err .ne. 0) then
-      call message ('  IOError while openening ', trim(fName))
-      call message ('  Error-Code ', num2str(err))
-      stop
+      call message ('  IOError while openening "', trim(fName), '" Error-Code ', num2str(err))
     end if
 
     write(uopti_nml, *) '!global_parameters'
     write(uopti_nml, *) '!PARAMETER                       lower_bound  upper_bound          value   FLAG  SCALING'
 
     write(uopti_nml, *) '! ', trim(adjustl('routing'))
```

### Comparing `mhm-5.12.1.dev21/src/mRM/mo_mrm_write_fluxes_states.f90` & `mhm-5.13.0/src/common/mo_nc_output.f90`

 * *Files 22% similar despite different names*

```diff
@@ -1,663 +1,500 @@
-!>       \file mo_mrm_write_fluxes_states.f90
+!> \file mo_nc_output.f90
+!> \brief \copybrief mo_nc_output
+!> \details \copydetails mo_nc_output
+
+!> \brief Creates NetCDF output for different fluxes and state variables of mHM.
+!> \details NetCDF is first initialized and later on variables are put to the NetCDF.
+!> \changelog
+!! - David Schaefer       Aug 2015
+!!   - major rewrite
+!! - Stephan Thober       Oct 2015
+!!   - adapted to mRM
+!! - O. Rakovec, R. Kumar Nov 2017
+!!   - added project description for the netcdf outputs
+!! - S. Mueller,          Dec 2022
+!!   - unified module for mHM and mRM
+!> \authors Matthias Zink
+!> \date Apr 2013
+!> \copyright Copyright 2005-\today, the mHM Developers, Luis Samaniego, Sabine Attinger: All rights reserved.
+!! mHM is released under the LGPLv3+ license \license_note
+!> \ingroup f_common
+module mo_nc_output
 
-!>       \brief Creates NetCDF output for different fluxes and state variables of mHM.
-
-!>       \details NetCDF is first initialized and later on variables are put to the NetCDF.
-
-!>       \authors Matthias Zink
-
-!>       \date Apr 2013
-
-! Modifications:
-! David Schaefer       Aug 2015 - major rewrite
-! Stephan Thober       Oct 2015 - adapted to mRM
-! O. Rakovec, R. Kumar Nov 2017 - added project description for the netcdf outputs
-
-module mo_mrm_write_fluxes_states
-
-  use mo_kind, only : i4, dp
+  use mo_kind, only : i4, dp, sp
+  use mo_common_types, only: Grid
   use mo_common_variables, only : project_details, setup_description, simulation_type, &
-          Conventions, contact, mHM_details, history
+          Conventions, contact, mHM_details, history, dirOut, iFlag_cordinate_sys
+  use mo_file, only : version
   use mo_common_constants, only : nodata_dp
   use mo_netcdf, only : NcDataset, NcDimension, NcVariable
-  use mo_mrm_global_variables, only : output_deflate_level_mrm, output_double_precision_mrm
+  use mo_common_mHM_mRM_variables, only: timeStep
 
   implicit none
 
+  public :: OutputDataset, OutputVariable, set_attributes, data_dims, data_dtype
+
+  private
+
   type OutputVariable
-    type(NcVariable) :: nc                 !> NcDataset which contains the variable
-    logical :: avg = .false.      !> average data before writing
-    logical, pointer :: mask(:, :)          !> mask to reconstruct data
-    real(dp), allocatable :: data(:)            !> store the data between writes
-    integer(i4) :: counter = 0        !> count the number of updateVariable calls
+    type(NcVariable) :: nc                 !< NcDataset which contains the variable
+    logical :: avg = .false.      !< average data before writing
+    logical, pointer :: mask(:, :)          !< mask to reconstruct data
+    real(dp), allocatable :: data(:)            !< store the data between writes
+    integer(i4) :: counter = 0        !< count the number of updateVariable calls
 
   contains
     procedure, public :: updateVariable
     procedure, public :: writeVariableTimestep
 
   end type OutputVariable
 
   ! constructor interface
   interface OutputVariable
     procedure newOutputVariable
   end interface OutputVariable
 
   type OutputDataset
-    integer(i4) :: iDomain      !> domain id
-    type(NcDataset) :: nc          !> NcDataset to write
-    type(OutputVariable), allocatable :: vars(:)     !> store all created (dynamic) variables
-    integer(i4) :: counter = 0 !> count written time steps
+    integer(i4) :: iDomain      !< domain id
+    type(NcDataset) :: nc          !< NcDataset to write
+    type(OutputVariable), allocatable :: vars(:)     !< store all created (dynamic) variables
+    integer(i4) :: counter !< count written time steps
+    integer(i4) :: previous_time !< previous time steps for bounds
+    integer(i4) :: time_unit_factor !< possible factor to convert hours to minutes when using center as time reference
+    integer(i4) :: outputs_frequence !< write out frequence (-3: yearly, -2: monthly, -1: daily, 0: end of run, >0: after n steps)
+    integer(i4) :: time_reference !< time stamp reference (0: begin, 1: center, 2: end of time interval)
+    logical :: double_precision !< output precision switch for nc files
 
   contains
-    procedure, public :: updateDataset
     procedure, public :: writeTimestep
     procedure, public :: close
 
   end type OutputDataset
 
   ! constructor interface
   interface OutputDataset
     procedure newOutputDataset
   end interface OutputDataset
 
-  private
-
-  public :: OutputDataset
-
 contains
 
-  !------------------------------------------------------------------
-  !    NAME
-  !        newOutputVariable
-
-  !    PURPOSE
-  !>       \brief Initialize OutputVariable
-
-  !>       \details TODO: add description
-
-  !>       \return type(OutputVariable)
-
-  !    INTENT(IN)
-  !>       \param[in] "type(NcDataset) :: nc"               -> NcDataset which contains the variable
-  !>       \param[in] "character(*) :: name"
-  !>       \param[in] "character(*) :: dtype"
-  !>       \param[in] "character(16), dimension(3) :: dims"
-  !>       \param[in] "integer(i4) :: ncells"               -> number of cells in domain
-  !>       \param[in] "logical, dimension(:, :) :: mask"
-
-  !    INTENT(IN), OPTIONAL
-  !>       \param[in] "logical, optional :: avg" -> average the data before writing
-
-  !    HISTORY
-  !>       \authors David Schaefer
-
-  !>       \date June 2015
-
-  ! Modifications:
-  ! David Schaefer Nov 2017 - , added NcVariable initialization
-  ! Robert Schweppe Jun 2018 - refactoring and reformatting
-
-  function newOutputVariable(nc, name, dtype, dims, ncells, mask, avg) result(out)
+  !> \brief Output variable dtype for single or double precision.
+  !> \return "f64" or "f32"
+  character(3) function data_dtype(double_precision)
     implicit none
+    logical, intent(in) :: double_precision !< flag to use double precision
+    if ( double_precision ) then
+      data_dtype = "f64"
+    else
+      data_dtype = "f32"
+    end if
+  end function data_dtype
 
-    ! -> NcDataset which contains the variable
-    type(NcDataset), intent(in) :: nc
-
-    character(*), intent(in) :: name
-
-    character(*), intent(in) :: dtype
-
-    character(16), intent(in), dimension(3) :: dims
-
-    ! -> number of cells in domain
-    integer(i4), intent(in) :: ncells
+  !> \brief Output variable dimension names.
+  !> \return (X, Y, T) names tuple
+  function data_dims()
+    implicit none
+    character(16), dimension(3) :: data_dims
+    if (iFlag_cordinate_sys == 0) then
+      data_dims = (/"easting ", "northing", "time    "/) ! X & Y coordinate system
+    else
+      data_dims = (/"lon ", "lat ", "time"/) ! lat & lon coordinate system
+    endif
+  end function data_dims
 
-    logical, intent(in), target, dimension(:, :) :: mask
+  !> \brief Initialize OutputVariable
+  !> \details Modifications:
+  !! - David Schaefer Nov 2017 - added NcVariable initialization
+  !! - Robert Schweppe Jun 2018 - refactoring and reformatting
+  !> \return type(OutputVariable)
+  !> \authors David Schaefer
+  !> \date June 2015
+  function newOutputVariable(nc, name, dtype, dims, ncells, mask, deflate_level, avg) result(out)
+    implicit none
 
-    ! -> average the data before writing
-    logical, intent(in), optional :: avg
+    type(NcDataset), intent(in) :: nc !< NcDataset which contains the variable
+    character(*), intent(in) :: name !< name of the variable
+    character(*), intent(in) :: dtype !< data type of the variable
+    character(16), intent(in), dimension(3) :: dims !< dimensions of the variable (by name)
+    integer(i4), intent(in) :: ncells !< number of cells in domain
+    logical, intent(in), target, dimension(:, :) :: mask !< mask of the variable
+    integer(i4), intent(in) :: deflate_level !< deflate level for compression
+    logical, intent(in), optional :: avg !< flag to average the data before writing
 
     type(OutputVariable) :: out
 
-
     allocate(out%data(ncells))
-    out%nc = nc%setVariable(name, dtype, dims, deflate_level = output_deflate_level_mrm, shuffle = .true.)
+    out%nc = nc%setVariable(name, dtype, dims, deflate_level = deflate_level, shuffle = .true.)
     out%data = 0
     out%mask => mask
     if (present(avg)) out%avg = avg
   end function newOutputVariable
 
-  !------------------------------------------------------------------
-  !    NAME
-  !        updateVariable
-
-  !    PURPOSE
-  !>       \brief Update OutputVariable
-
-  !>       \details Add the array given as actual argument
-  !>       to the derived type's component 'data'
-
-  !>       \return type(OutputVariable)
-
-  !    INTENT(INOUT)
-  !>       \param[inout] "class(OutputVariable) :: self"
-
-  !    INTENT(IN)
-  !>       \param[in] "real(dp), dimension(:) :: data"
-
-  !    HISTORY
-  !>       \authors David Schaefer
-
-  !>       \date June 2015
-
-  ! Modifications:
-  ! Robert Schweppe Jun 2018 - refactoring and reformatting
-
+  !> \brief Update OutputVariable
+  !> \details Add the array given as actual argument to the derived type's component 'data'
+  !> \changelog
+  !! - Robert Schweppe Jun 2018
+  !!   - refactoring and reformatting
+  !> \return type(OutputVariable)
+  !> \authors David Schaefer
+  !> \date June 2015
   subroutine updateVariable(self, data)
     implicit none
 
     class(OutputVariable), intent(inout) :: self
-
-    real(dp), intent(in), dimension(:) :: data
-
+    real(dp), intent(in), dimension(:) :: data !< data for current time step
 
     self%data = self%data + data
     self%counter = self%counter + 1
 
   end subroutine updateVariable
 
-  !------------------------------------------------------------------
-  !    NAME
-  !        writeVariableTimestep
-
-  !    PURPOSE
-  !>       \brief Write timestep to file
-
-  !>       \details Write the content of the derived types's component
-  !>       'data' to file, average if necessary
-
-  !    INTENT(INOUT)
-  !>       \param[inout] "class(OutputVariable) :: self"
-
-  !    INTENT(IN)
-  !>       \param[in] "integer(i4) :: timestep" -> index along the time dimension of the netcdf variable
-
-  !    HISTORY
-  !>       \authors David Schafer
-
-  !>       \date June 2015
-
-  ! Modifications:
-  ! Robert Schweppe Jun 2018 - refactoring and reformatting
-
-  subroutine writeVariableTimestep(self, timestep)
+  !> \brief Write timestep to file
+  !> \details Write the content of the derived types's component 'data' to file, average if necessary
+  !> \changelog
+  !! - Robert Schweppe Jun 2018
+  !!   - refactoring and reformatting
+  !> \authors David Schafer
+  !> \date June 2015
+  subroutine writeVariableTimestep(self, current_time_step)
     implicit none
 
     class(OutputVariable), intent(inout) :: self
 
-    ! -> index along the time dimension of the netcdf variable
-    integer(i4), intent(in) :: timestep
-
+    !> index along the time dimension of the netcdf variable
+    integer(i4), intent(in) :: current_time_step
 
     if (self%avg) then
       self%data = self%data / real(self%counter, dp)
     end if
 
     call self%nc%setData(unpack(self%data, self%mask, nodata_dp), &
-            (/1, 1, timestep/))
+            (/1, 1, current_time_step/))
     self%data = 0
     self%counter = 0
 
   end subroutine writeVariableTimestep
 
-  !------------------------------------------------------------------
-  !    NAME
-  !        newOutputDataset
-
-  !    PURPOSE
-  !>       \brief Initialize OutputDataset
-
-  !>       \details Create and initialize the output file. If new a new output
-  !>       variable needs to be written, this is the first of two
-  !>       procedures to change (second: updateDataset)
-
-  !>       \return type(OutputDataset)
-
-  !    INTENT(IN)
-  !>       \param[in] "integer(i4) :: iDomain"            -> domain id
-  !>       \param[in] "logical, dimension(:, :) :: mask"
-  !>       \param[in] "integer(i4) :: nCells"
-
-  !    HISTORY
-  !>       \authors Matthias Zink
-
-  !>       \date Apr 2013
-
-  ! Modifications:
-  ! Robert Schweppe Jun 2018 - refactoring and reformatting
-  ! Sebastian Mueller Jul 2020 - added output for river temperature
-
-  function newOutputDataset(iDomain, mask, nCells) result(out)
-
-    use mo_mrm_global_variables, only : outputFlxState_mrm, riv_temp_pcs
-    use mo_common_variables, only : iFlag_cordinate_sys
-
+  !> \brief Initialize OutputDataset
+  !> \details Create and initialize the output file. If new a new output
+  !! variable needs to be written, this is the first of two
+  !! procedures to change (second: updateDataset)
+  !> \changelog
+  !! - Robert Schweppe Jun 2018
+  !!   - refactoring and reformatting
+  !! - Sebastian Mueller Jul 2020
+  !!   - added output for river temperature
+  !> \return type(OutputDataset)
+  !> \authors Matthias Zink
+  !> \date Apr 2013
+  function newOutputDataset( iDomain, level, file_name, double_precision, outputs_frequence, time_reference ) result(out)
     implicit none
 
-    ! -> domain id
-    integer(i4), intent(in) :: iDomain
-
-    logical, intent(in), pointer, dimension(:, :) :: mask
-
-    integer(i4), intent(in) :: nCells
+    integer(i4), intent(in) :: iDomain !< domain id
+    type(Grid), dimension(:), allocatable, target, intent(in) :: level !< level definitions for all domains
+    character(*), intent(in) :: file_name !< long name of the variable
+    logical, intent(in) :: double_precision !< mask on desired level
+    integer(i4), intent(in) :: outputs_frequence !< write out frequence (-3, -2, -1, 0, >0)
+    integer(i4), intent(in) :: time_reference !< time stamp reference (0: begin, 1: center, 2: end of time interval)
 
     type(OutputDataset) :: out
 
-    integer(i4) :: ii
-
-    character(3) :: dtype
-
-    character(16), dimension(3) :: dims1
-
-    type(NcDataset) :: nc
-
-    type(OutputVariable), dimension(size(outputFlxState_mrm)) :: tmpvars
-
-    if ( output_double_precision_mrm ) then
-      dtype = "f64"
-    else
-      dtype = "f32"
-    end if
+    out%nc = createOutputFile(iDomain, level, file_name, double_precision, outputs_frequence, time_reference)
+    out%iDomain = iDomain
 
-    if (iFlag_cordinate_sys == 0) then
-      dims1 = (/"easting ", "northing", "time    "/) ! X & Y coordinate system
+    ! check if we need minutes instead of hours as time unit and set the time unit factor accordingly
+    if ( (outputs_frequence > 0) &
+         .and. (mod(timestep * outputs_frequence, 2) == 1) &
+         .and. (time_reference == 1) &
+    ) then
+      out%time_unit_factor = 60
     else
-      dims1 = (/"lon ", "lat ", "time"/) ! lat & lon coordinate system
-    endif
-
-    nc = createOutputFile(iDomain)
-
-    ii = 0
-
-    if (outputFlxState_mrm(1)) then
-      ii = ii + 1
-      tmpvars(ii) = OutputVariable(nc, "Qrouted", dtype, dims1, nCells, mask, .true.)
-      call writeVariableAttributes(tmpvars(ii), "routed streamflow", "m3 s-1")
+      out%time_unit_factor = 1
     end if
-
-    if (outputFlxState_mrm(2) .AND. riv_temp_pcs%active) then
-      ii = ii + 1
-      tmpvars(ii) = OutputVariable(nc, "RivTemp", dtype, dims1, nCells, mask, .true.)
-      call writeVariableAttributes(tmpvars(ii), "routed river temperature", "degC")
-    end if
-
-    ! out = OutputDataset(iDomain, nc, tmpvars(1 : ii))
-    allocate(out%vars(ii))
-    out%vars = tmpvars(1:ii)
-    out%nc = nc
-    out%iDomain = iDomain
-    ! print*, 'Finished OutputDatasetInit'
+    out%outputs_frequence = outputs_frequence
+    out%time_reference = time_reference
+    out%double_precision = double_precision
+    out%previous_time = 0
+    out%counter = 0
 
   end function newOutputDataset
 
-  !------------------------------------------------------------------
-  !    NAME
-  !        updateDataset
-
-  !    PURPOSE
-  !>       \brief Update all variables.
-
-  !>       \details Call the type bound procedure updateVariable for
-  !>       all output variables. If a new output
-  !>       variable needs to be written, this is the second
-  !>       of two procedures to change (first: newOutputDataset)
-
-  !    INTENT(INOUT)
-  !>       \param[inout] "class(OutputDataset) :: self"
-
-  !    INTENT(IN)
-  !>       \param[in] "integer(i4) :: sidx, eidx"          - start index of the domain related data in L1_* arguments
-  !>       \param[in] "integer(i4) :: sidx, eidx"          - end index of the domain related data in L1_* arguments
-  !>       \param[in] "real(dp), dimension(:) :: L11_Qmod"
-
-  !    INTENT(IN), OPTIONAL
-  !>       \param[in] "real(dp), dimension(:), optional :: L11_riv_temp"
-
-  !    HISTORY
-  !>       \authors Matthias Zink
-
-  !>       \date Apr 2013
-
-  ! Modifications:
-  ! L. Samaniego et al. Dec  2013 - nullify pointer Matthias Zink,        Feb. 2014
-  !                              - added aditional output: pet V. Prykhodk, J. Mai,  Nov. 2014
-  !                              - adding new variable infilSoil
-  !                              - case 16 David Schaefer      , Jun. 2015
-  !                              - major rewrite
-  ! Stephan Thober      Oct  2015 - adapted to mRM
-  ! Robert Schweppe Jun 2018 - refactoring and reformatting
-  ! Sebastian Mueller Jul 2020 - add river temperature output (optional)
-
-  subroutine updateDataset(self, sidx, eidx, L11_Qmod, L11_riv_temp)
-
-    use mo_mrm_global_variables, only : outputFlxState_mrm
-
+  !> \brief Write all accumulated data.
+  !> \details Write all accumulated and potentially averaged data to disk.
+  !> \changelog
+  !! - Robert Schweppe Jun 2018
+  !!   - refactoring and reformatting
+  !> \authors David Schaefer
+  !> \date June 2015
+  subroutine writeTimestep(self, current_time_step)
     implicit none
 
     class(OutputDataset), intent(inout), target :: self
 
-    ! - end index of the domain related data in L1_* arguments
-    integer(i4), intent(in) :: sidx, eidx
-
-    real(dp), intent(in), dimension(:) :: L11_Qmod
-    real(dp), intent(in), dimension(:), optional :: L11_riv_temp
-
-    type(OutputVariable), pointer, dimension(:) :: vars
-
-    integer(i4) :: ii
-
-    ii = 0
-    vars => self%vars
-
-    if (outputFlxState_mrm(1)) then
-      ii = ii + 1
-      call vars(ii)%updateVariable(L11_Qmod(sidx : eidx))
-    end if
-
-    if (outputFlxState_mrm(2) .AND. present(L11_riv_temp)) then
-      ii = ii + 1
-      call vars(ii)%updateVariable(L11_riv_temp(sidx : eidx))
-    end if
-
-  end subroutine updateDataset
-
-  !------------------------------------------------------------------
-  !    NAME
-  !        writeTimestep
-
-  !    PURPOSE
-  !>       \brief Write all accumulated data.
-
-  !>       \details Write all accumulated and potentially averaged
-  !>       data to disk.
-
-  !>       \return type(OutputVariable)
-
-  !    INTENT(INOUT)
-  !>       \param[inout] "class(OutputDataset) :: self"
-
-  !    INTENT(IN)
-  !>       \param[in] "integer(i4) :: timestep" The model timestep to write
-
-  !    HISTORY
-  !>       \authors David Schaefer
-
-  !>       \date June 2015
-
-  ! Modifications:
-  ! Robert Schweppe Jun 2018 - refactoring and reformatting
-
-  subroutine writeTimestep(self, timestep)
-    implicit none
-
-    class(OutputDataset), intent(inout), target :: self
-
-    ! The model timestep to write
-    integer(i4), intent(in) :: timestep
+    !> The model timestep to write
+    integer(i4), intent(in) :: current_time_step
 
     integer(i4) :: ii
 
     type(NcVariable) :: tvar
 
-
     self%counter = self%counter + 1
 
     ! add to time variable
     tvar = self%nc%getVariable("time")
-    call tvar%setData(timestep, (/self%counter/))
+    select case( self%time_reference )
+      case(0)
+        call tvar%setData(self%previous_time * self%time_unit_factor, (/self%counter/))
+      case(1)
+        call tvar%setData((self%previous_time + current_time_step) * self%time_unit_factor / 2, (/self%counter/))
+      case(2)
+        call tvar%setData(current_time_step * self%time_unit_factor, (/self%counter/))
+    end select
+    ! add bounds (with current time at end)
+    tvar = self%nc%getVariable("time_bnds")
+    call tvar%setData(self%previous_time * self%time_unit_factor, (/1, self%counter/))
+    call tvar%setData(current_time_step * self%time_unit_factor, (/2, self%counter/))
+    self%previous_time = current_time_step
 
     do ii = 1, size(self%vars)
       call self%vars(ii)%writeVariableTimestep(self%counter)
     end do
 
   end subroutine writeTimestep
 
-  !------------------------------------------------------------------
-  !    NAME
-  !        close
-
-  !    PURPOSE
-  !>       \brief Close the file
-
-  !>       \details Close the file associated with variable of
-  !>       type(OutputDataset)
-
-  !    HISTORY
-  !>       \authors Rohini Kumar & Stephan Thober
-
-  !>       \date August 2013
-
-  ! Modifications:
-  ! Stephan Thober Oct  2015 - adapted to mRM
-  ! Robert Schweppe Jun 2018 - refactoring and reformatting
-
+  !> \brief Close the file
+  !> \details Close the file associated with variable of type(OutputDataset)
+  !> \changelog
+  !! - Stephan Thober Oct  2015
+  !!   - adapted to mRM
+  !! - Robert Schweppe Jun 2018
+  !!   - refactoring and reformatting
+  !> \authors Rohini Kumar & Stephan Thober
+  !> \date August 2013
   subroutine close(self)
 
     use mo_String_utils, only : num2str
-    use mo_common_variables, only : dirOut
     use mo_message, only : message
 
     implicit none
 
     class(OutputDataset) :: self
 
-
     call self%nc%close()
     call message('  OUTPUT: saved netCDF file for domain', trim(num2str(self%iDomain)))
-    call message('    to ', trim(dirOut(self%iDomain)))
+    call message('    to ', trim(self%nc%fname))
 
   end subroutine close
 
-  !------------------------------------------------------------------
-  !    NAME
-  !        createOutputFile
-
-  !    PURPOSE
-  !>       \brief Create and initialize output file for X & Y coordinate system
-
-  !>       \details Create output file, write all non-dynamic variables
-  !>       and global attributes for the given domain for X & Y coordinate system
-
-  !>       \return type(NcDataset)
-
-  !    INTENT(IN)
-  !>       \param[in] "integer(i4) :: iDomain" -> domain id
-
-  !    HISTORY
-  !>       \authors David Schaefer
-
-  !>       \date June 2015
-
-  ! Modifications:
-  ! Stephan Thober  Oct 2015 - adapted to mRM
-  ! Robert Schweppe Jun 2018 - refactoring and reformatting
-  ! Pallav Shrestha Mar 2020 - output file lat and lon are 1d or 2d based on coordinate system
-
-  function createOutputFile(iDomain) result(nc)
+  !> \brief Create and initialize output file for X & Y coordinate system
+  !> \details Create output file, write all non-dynamic variables
+  !!       and global attributes for the given domain for X & Y coordinate system
+  !> \changelog
+  !! - Stephan Thober  Oct 2015
+  !!   - adapted to mRM
+  !! - Robert Schweppe Jun 2018
+  !!   - refactoring and reformatting
+  !! - Pallav Shrestha Mar 2020
+  !!   - output file lat and lon are 1d or 2d based on coordinate system
+  !> \return type(NcDataset)
+  !> \authors David Schaefer
+  !> \date June 2015
+  function createOutputFile(iDomain, level, file_name, double_precision, outputs_frequence, time_reference) result(nc)
 
     use mo_common_mhm_mrm_variables, only : evalPer
-    use mo_common_variables, only : dirOut, iFlag_cordinate_sys
     use mo_grid, only : geoCoordinates, mapCoordinates
     use mo_julian, only : dec2date
-    use mo_mrm_file, only : file_mrm_output, version
-    use mo_mrm_global_variables, only : level11
 
     implicit none
 
     ! -> domain id
-    integer(i4), intent(in) :: iDomain
+    integer(i4), intent(in) :: iDomain !< selected domain
+    type(Grid), dimension(:), allocatable, intent(in) :: level !< level definitions for all domains
+    character(*), intent(in) :: file_name !< long name of the variable
+    logical, intent(in) :: double_precision !< mask on desired level
+    integer(i4), intent(in) :: outputs_frequence !< write out frequence (-3, -2, -1, 0, >0)
+    integer(i4), intent(in) :: time_reference !< time stamp reference (0: begin, 1: center, 2: end of time interval)
 
     type(NcDataset) :: nc
-
-    type(NcDimension), dimension(3) :: dimids1
-
+    type(NcDimension), dimension(4) :: dimids1
     type(NcVariable) :: var
-
     integer(i4) :: day, month, year
-
     character(1028) :: fname
-
     character(128) :: unit, date, time, datetime
-
     real(dp), allocatable, dimension(:) :: easting, northing
-
+    real(dp), allocatable, dimension(:, :) :: x_bnds, y_bnds
+    real(dp) :: half_step
     real(dp), allocatable, dimension(:) :: lat1d, lon1d    ! 1D lat lon vectors. Used if coordinate system is lat & lon
-
     real(dp), allocatable, dimension(:, :) :: lat2d, lon2d ! temporary storage of mHM's 2D latlon array.
                                                            ! Used as 2d lat lon arrays if coordinate system is X & Y
     character(3) :: dtype
 
-    if ( output_double_precision_mrm ) then
-      dtype = "f64"
-    else
-      dtype = "f32"
-    end if
+    dtype = data_dtype(double_precision)
+
+    ! half cell step to calculate cell bounds from center
+    half_step = level(iDomain)%cellsize / 2.0_dp
 
-    fname = trim(dirOut(iDomain)) // trim(file_mrm_output)
-    call geoCoordinates(level11(iDomain), lat2d, lon2d)
+    fname = trim(dirOut(iDomain)) // trim(file_name)
+    call geoCoordinates(level(iDomain), lat2d, lon2d)
 
     nc = NcDataset(trim(fname), "w")
 
     ! set the horizonal dimensions
     if (iFlag_cordinate_sys == 0) then
 
       ! X & Y coordinate system; 2D lat lon!
       !============================================================
-      call mapCoordinates(level11(iDomain), northing, easting)
+      call mapCoordinates(level(iDomain), northing, easting)
+      allocate(x_bnds(2, size(easting)))
+      allocate(y_bnds(2, size(northing)))
+      x_bnds(1, :) = easting - half_step
+      x_bnds(2, :) = easting + half_step
+      y_bnds(1, :) = northing - half_step
+      y_bnds(2, :) = northing + half_step
 
       dimids1 = (/&
-              nc%setDimension("easting", size(easting)), &
-                      nc%setDimension("northing", size(northing)), &
-                      nc%setDimension("time", 0) &
-              /)
-      ! northing
-      var = nc%setVariable("northing", dtype, (/ dimids1(2) /))
-      call var%setData(northing)
-      call var%setAttribute("units", "m")
-      call var%setAttribute("long_name", "y-coordinate in the given coordinate system")
+        nc%setDimension("easting", size(easting)), &
+        nc%setDimension("northing", size(northing)), &
+        nc%setDimension("time", 0), &
+        nc%setDimension("bnds", 2) &
+      /)
       ! easting
       var = nc%setVariable("easting", dtype, (/ dimids1(1) /))
+      call set_attributes(var, "x-coordinate in the given coordinate system", &
+        unit="m", standard_name="projection_x_coordinate", add_coords=.false., axis="X", bounds="easting_bnds")
       call var%setData(easting)
-      call var%setAttribute("units", "m")
-      call var%setAttribute("long_name", "x-coordinate in the given coordinate system")
+      var = nc%setVariable("easting_bnds", dtype, (/ dimids1(4), dimids1(1) /))
+      call var%setData(x_bnds)
+      ! northing
+      var = nc%setVariable("northing", dtype, (/ dimids1(2) /))
+      call set_attributes(var, "y-coordinate in the given coordinate system", &
+        unit="m", standard_name="projection_y_coordinate", add_coords=.false., axis="Y", bounds="northing_bnds")
+      call var%setData(northing)
+      var = nc%setVariable("northing_bnds", dtype, (/ dimids1(4), dimids1(2) /))
+      call var%setData(y_bnds)
       ! lon
       var = nc%setVariable("lon", dtype, dimids1(1 : 2))
-      call var%setFillValue(nodata_dp)
+      call set_attributes(var, "longitude", unit="degrees_east", &
+       double_precision=double_precision, add_coords=.false., standard_name="longitude")
       call var%setData(lon2d)
-      call var%setAttribute("units", "degrees_east")
-      call var%setAttribute("long_name", "longitude")
-      call var%setAttribute("missing_value", nodata_dp)
       ! lat
       var = nc%setVariable("lat", dtype, dimids1(1 : 2))
-      call var%setFillValue(nodata_dp)
+      call set_attributes(var, "latitude", unit="degrees_north", &
+        double_precision=double_precision, add_coords=.false., standard_name="latitude")
       call var%setData(lat2d)
-      call var%setAttribute("units", "degrees_north")
-      call var%setAttribute("long_name", "latitude")
-      call var%setAttribute("missing_value", nodata_dp)
 
     else
 
       ! lat & lon coordinate system; 1D lat lon!
       !============================================================
-      lat1d = lat2d(1, :) ! first row info is sufficient
       lon1d = lon2d(:, 1) ! first column info is sufficient
+      lat1d = lat2d(1, :) ! first row info is sufficient
+      allocate(x_bnds(2, size(lon1d)))
+      allocate(y_bnds(2, size(lat1d)))
+      ! cellsize is given in degree in case of lat-lon coordinates
+      x_bnds(1, :) = lon1d - half_step
+      x_bnds(2, :) = lon1d + half_step
+      y_bnds(1, :) = lat1d - half_step
+      y_bnds(2, :) = lat1d + half_step
+
       dimids1 = (/&
-              nc%setDimension("lon", size(lon1d)), &
-                      nc%setDimension("lat", size(lat1d)), &
-                      nc%setDimension("time", 0) &
-              /)
+        nc%setDimension("lon", size(lon1d)), &
+        nc%setDimension("lat", size(lat1d)), &
+        nc%setDimension("time", 0), &
+        nc%setDimension("bnds", 2) &
+      /)
       ! lon
       var = nc%setVariable("lon", dtype, (/ dimids1(1) /)) ! sufficient to store lon as vector
-      call var%setFillValue(nodata_dp)
+      call set_attributes(var, "longitude", unit="degrees_east", &
+        add_coords=.false., standard_name="longitude", axis="X", bounds="lon_bnds")
       call var%setData(lon1d)
-      call var%setAttribute("units", "degrees_east")
-      call var%setAttribute("long_name", "longitude")
-      call var%setAttribute("missing_value", nodata_dp)
+      var = nc%setVariable("lon_bnds", dtype, (/ dimids1(4), dimids1(1) /))
+      call var%setData(x_bnds)
       ! lat
       var = nc%setVariable("lat", dtype, (/ dimids1(2) /)) ! sufficient to store lat as vector
-      call var%setFillValue(nodata_dp)
+      call set_attributes(var, "latitude", unit="degrees_north", &
+        add_coords=.false., standard_name="latitude", axis="Y", bounds="lat_bnds")
       call var%setData(lat1d)
-      call var%setAttribute("units", "degrees_north")
-      call var%setAttribute("long_name", "latitude")
-      call var%setAttribute("missing_value", nodata_dp)
+      var = nc%setVariable("lat_bnds", dtype, (/ dimids1(4), dimids1(2) /))
+      call var%setData(y_bnds)
 
     endif
 
     ! set record dimension
     ! time units
     call dec2date(real(evalPer(iDomain)%julStart, dp), dd = day, mm = month, yy = year)
-    write(unit, "('hours since ', i4, '-' ,i2.2, '-', i2.2, 1x, '00:00:00')") year, month, day
+
+    ! check if we need minutes instead of hours as time unit
+    if ( (outputs_frequence > 0) &                           ! only for output after n steps
+         .and. (mod(timestep * outputs_frequence, 2) == 1) & ! only for uneven hours
+         .and. (time_reference == 1) &                       ! only when center of time span is used for time stamp
+    ) then
+      write(unit, "('minutes since ', i4, '-' ,i2.2, '-', i2.2, 1x, '00:00:00')") year, month, day
+    else
+      write(unit, "('hours since ', i4, '-' ,i2.2, '-', i2.2, 1x, '00:00:00')") year, month, day
+    end if
 
     ! time
     var = nc%setVariable("time", "i32", (/ dimids1(3) /))
-    call var%setAttribute("units", unit)
-    call var%setAttribute("long_name", "time")
+    call set_attributes(var, "time", unit=unit, add_coords=.false., standard_name="time", axis="T", bounds="time_bnds")
+    var = nc%setVariable("time_bnds", "i32", (/ dimids1(4), dimids1(3) /))
 
     ! global attributes
     call date_and_time(date = date, time = time)
     write(datetime, "(a4,'-',a2,'-',a2,1x,a2,':',a2,':',a2)") date(1 : 4), &
             date(5 : 6), date(7 : 8), time(1 : 2), time(3 : 4), time(5 : 6)
 
     call nc%setAttribute("project", project_details)
     call nc%setAttribute("setup_description", setup_description)
     call nc%setAttribute("simulation_type", simulation_type)
     call nc%setAttribute("Conventions", Conventions)
     call nc%setAttribute("contact", contact)
-    call nc%setAttribute("mRM_details", trim(mHM_details) // ", release mRMv" // trim(version))
+    call nc%setAttribute("mHM_details", trim(mHM_details) // ", release mHMv" // trim(version))
     call nc%setAttribute("history", trim(datetime) // ", " // history)
-    call nc%setAttribute("title", "mRMv"//trim(version)//" "//trim(simulation_type)//" outputs")
+    call nc%setAttribute("title", "mHMv"//trim(version)//" "//trim(simulation_type)//" outputs")
     call nc%setAttribute("creation_date", datetime)
 
   end function createOutputFile
 
-  !------------------------------------------------------------------
-  !    NAME
-  !        writeVariableAttributes
-
-  !    PURPOSE
-  !>       \brief Write output variable attributes
-
-  !>       \details TODO: add description
-
-  !    INTENT(IN)
-  !>       \param[in] "type(OutputVariable) :: var"
-  !>       \param[in] "character(*) :: long_name, unit" -> variable name
-  !>       \param[in] "character(*) :: long_name, unit" -> physical unit
-
-  !    HISTORY
-  !>       \authors David Schaefer
-
-  !>       \date June 2015
-
-  ! Modifications:
-  ! Robert Schweppe Jun 2018 - refactoring and reformatting
-
-  subroutine writeVariableAttributes(var, long_name, unit)
+  !> \brief Write output variable attributes
+  !> \details Modifications:
+  !! - Robert Schweppe Jun 2018 - refactoring and reformatting
+  !> \authors David Schaefer
+  !> \date June 2015
+  subroutine set_attributes(var, long_name, unit, double_precision, add_coords, standard_name, axis, bounds)
     implicit none
 
-    type(OutputVariable), intent(inout) :: var
-
-    ! -> physical unit
-    character(*), intent(in) :: long_name, unit
-
-
-    call var%nc%setFillValue(nodata_dp)
-    call var%nc%setAttribute("long_name", long_name)
-    call var%nc%setAttribute("units", unit)
-    call var%nc%setAttribute("scale_factor", 1.0_dp)
-    call var%nc%setAttribute("missing_value", nodata_dp)
-    call var%nc%setAttribute("coordinates", "lat lon")
+    type(NcVariable), intent(inout) :: var !< NetCDF variable
+    character(*), intent(in), optional :: long_name !< long name of the variable
+    character(*), intent(in), optional :: unit !< unit of the variable
+    logical, intent(in), optional :: double_precision !< precision flag, if missing, no fill-value and missing-value is written
+    logical, intent(in), optional :: add_coords !< whether to add the "coordiantes" attribute "lat lon", .true. by defult
+    character(*), intent(in), optional :: standard_name !< standard name of the variable
+    character(*), intent(in), optional :: axis !< axis attribute
+    character(*), intent(in), optional :: bounds !< bounds attribute
+
+    logical :: add_coords_
+
+    add_coords_ = .true.
+    if (present(add_coords)) add_coords_ = add_coords
+
+    if (present(double_precision)) then
+      if (double_precision) then
+        call var%setFillValue(nodata_dp)
+        call var%setAttribute("missing_value", nodata_dp)
+        ! call var%setAttribute("scale_factor", 1.0_dp) ! not needed if just 1
+      else
+        call var%setFillValue(real(nodata_dp, kind=sp))
+        call var%setAttribute("missing_value", real(nodata_dp, kind=sp))
+        ! call var%setAttribute("scale_factor", 1.0_sp) ! not needed if just 1
+      end if
+    end if
+    if (present(long_name)) call var%setAttribute("long_name", long_name)
+    if (present(unit)) call var%setAttribute("units", unit)
+    if (add_coords_) call var%setAttribute("coordinates", "lat lon")
+    if (present(standard_name)) call var%setAttribute("standard_name", standard_name)
+    if (present(axis)) call var%setAttribute("axis", axis)
+    if (present(bounds)) call var%setAttribute("bounds", bounds)
 
-  end subroutine writeVariableAttributes
+  end subroutine set_attributes
 
-end module mo_mrm_write_fluxes_states
+end module mo_nc_output
```

